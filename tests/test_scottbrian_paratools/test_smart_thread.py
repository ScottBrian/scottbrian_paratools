"""test_smart_thread.py module."""

########################################################################
# Standard Library
########################################################################
from abc import ABC, abstractmethod
from collections import deque, defaultdict
from collections.abc import Iterable
from contextlib import contextmanager
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum, auto
from itertools import combinations, chain
import queue

import logging

from more_itertools import roundrobin
from pprint import pprint
import random
import re
from sys import _getframe
import time
from typing import (
    Any,
    Callable,
    ClassVar,
    cast,
    Generator,
    NamedTuple,
    Type,
    TypeAlias,
    TypedDict,
    TYPE_CHECKING,
    Optional,
    Union,
)
from typing_extensions import Unpack, NotRequired
import threading

########################################################################
# Third Party
########################################################################
import pytest
from scottbrian_utils.msgs import Msgs
from scottbrian_utils.log_verifier import LogVer
from scottbrian_utils.diag_msg import get_formatted_call_sequence, get_caller_info
from scottbrian_locking import se_lock as sel


########################################################################
# Local
########################################################################
import scottbrian_paratools.smart_thread as st


logger = logging.getLogger(__name__)


########################################################################
# Type alias
########################################################################
IntOrFloat: TypeAlias = Union[int, float]

StrOrList: TypeAlias = Union[str, list[str]]
StrOrSet: TypeAlias = Union[str, set[str]]

SetStateKey: TypeAlias = tuple[str, str, st.ThreadState, st.ThreadState]

AddRegKey: TypeAlias = tuple[str, str]

AddPaKey: TypeAlias = tuple[str, st.PairKey]

AddStatusBlockKey: TypeAlias = tuple[str, st.PairKey, str]

RequestKey: TypeAlias = tuple[str, str]

SubProcessKey: TypeAlias = tuple[str, str, str, str, str]

RemRegKey: TypeAlias = tuple[str, str]

AckKey: TypeAlias = tuple[str, str]

AlreadyUnregKey: TypeAlias = tuple[str, str]

UnregJoinSuccessKey: TypeAlias = tuple[str, str]

JoinProgKey: TypeAlias = tuple[int, int]

InitCompKey: TypeAlias = tuple[
    str, st.ThreadCreate, st.ThreadState, "AutoStartDecision"
]

CallRefKey: TypeAlias = str

PendEvents: TypeAlias = dict["PE", Any]

CheckPendArg: TypeAlias = tuple[str, st.PairKey]

CheckZeroCtArg: TypeAlias = tuple[str, str]

PotentialDefDelKey: TypeAlias = tuple[st.PairKey, str]


class DefDelReasons(NamedTuple):
    """DefDelReasons used to test pending flags."""

    pending_request: bool = False
    pending_msg: bool = False
    pending_wait: bool = False
    pending_sync: bool = False


RemSbKey: TypeAlias = tuple[str, tuple[str, str], DefDelReasons]

RefPendKey: TypeAlias = tuple[str, st.PairKey]

RemPaeKey: TypeAlias = tuple[str, tuple[str, str]]


########################################################################
# text units
########################################################################
class AutoStartDecision(Enum):
    """AutoStartDecision used to specify the expected decision."""

    auto_start_obviated = auto()
    auto_start_yes = auto()
    auto_start_no = auto()


init_complete_text_units: dict[AutoStartDecision, str] = {
    AutoStartDecision.auto_start_obviated: "auto_start obviated",
    AutoStartDecision.auto_start_yes: "auto_start will proceed",
    AutoStartDecision.auto_start_no: "auto_start not requested",
}


########################################################################
# get_ptime
########################################################################
def get_ptime() -> str:
    """Returns a printable UTC time stamp.

    Returns:
        a timestamp as a string
    """
    now_time = datetime.utcnow()
    print_time = now_time.strftime("%H:%M:%S.%f")

    return print_time


@dataclass
class CheckExpectedResponsesArgs:
    """Parameters for received responses with WaitForCondition."""

    requestors: set[str]
    exp_response_targets: set[str]
    request: st.ReqType


########################################################################
# wait_for
########################################################################
def wait_for(condition: Callable[..., bool], timeout_value: IntOrFloat = 15) -> None:
    """Wait for a condition with timeout.

    Args:
        condition: function to call that returns True when the condition
            is satisfied
        timeout_value: the number of seconds to allow the condition to
            be satisfied before raising a timeout error

    Raises:
        CmdTimedOut: wait_for called from line_num took longer than '
            timeout_value seconds waiting for condition.

    """
    start_time = time.time()
    logging.debug(f"wait_for entered with {condition=}")
    while not condition():
        time.sleep(0.2)
        if time.time() - start_time > timeout_value:
            frame = _getframe(1)
            caller_info = get_caller_info(frame)
            line_num = caller_info.line_num
            del frame
            raise CmdTimedOut(
                f"wait_for called from {line_num=} took longer than "
                f"{timeout_value} seconds waiting for {condition=}."
            )


########################################################################
# SendRecvMsgs
########################################################################
class SendType(Enum):
    """SendType used to specify how to send msgs with smart_send."""

    ToRemotes = auto()
    SRMsgs = auto()


class RecvType(Enum):
    """RecvType used for test cases to specify number of senders."""

    PartialSenders = auto()
    MatchSenders = auto()
    ExtraSenders = auto()
    UnmatchSenders = auto()


class SendRecvMsgs:
    """SendRecvMsgs used for testing smart_send and smart_recv."""

    def __init__(
        self,
        sender_names: Iterable[str],
        receiver_names: Iterable[str],
        num_msgs: int,
        text: str = "",
    ) -> None:
        """Initialize the SendRecvMsg object used for test messages.

        Args:
            sender_names: sender who will send messages
            receiver_names: receivers expected to recv the messages
            num_msgs: the number of messages to create
            text: any text to place in the message

        """
        self.sender_names = get_set(sender_names)
        self.receiver_names = get_set(receiver_names)
        self.num_msgs = num_msgs

        self.text = text

        self.broadcast_msgs: list[dict[str, Any]] = []
        self.directed_msgs: list[dict[str, dict[str, Any]]] = []
        self.exp_received_msgs: dict[str, dict[str, list[Any]]] = defaultdict(
            lambda: defaultdict(list)
        )
        self.msg_lock = threading.Lock()
        self.build_msgs()

    def build_msgs(self) -> None:
        """Create the messages that will be sent and received."""
        for msg_idx in range(self.num_msgs):
            self.broadcast_msgs.append({})
            for sender_name in self.sender_names:
                self.broadcast_msgs[msg_idx][sender_name] = (
                    f"{sender_name} broadcast message" f" {self.text} {msg_idx}"
                )

                self.directed_msgs.append(defaultdict(lambda: defaultdict(str)))
                for receiver_name in self.receiver_names:
                    self.directed_msgs[msg_idx][sender_name][receiver_name] = (
                        f"{sender_name} message {self.text} "
                        f"{msg_idx} to {receiver_name}"
                    )

    def get_broadcast_msg(
        self, sender_name: str, exp_receivers: Iterable[str], msg_idx: int
    ) -> Any:
        """Return a single message that is to be sent to receivers.

        Args:
            sender_name: sender who will send the message
            exp_receivers: names of receivers expected to recv the
                message
            msg_idx: the index into the messages array for the message
                to retrieve

        Returns:
            the broadcast messages to be sent

        """
        with self.msg_lock:
            msg = self.broadcast_msgs[msg_idx][sender_name]
            for receiver_name in exp_receivers:
                self.add_exp_msg_received(
                    receiver_name=receiver_name, sender_name=sender_name, msg=msg
                )
        return msg

    def get_send_msgs(
        self,
        sender_name: str,
        receiver_names: Iterable[str],
        exp_receivers: Iterable[str],
        msg_idx: int,
    ) -> dict[str, Any]:
        """Return the messages that are to be sent.

        Args:
            sender_name: sender who will send the message
            receiver_names: names of receivers that the message will be
                sent to (but not necessarily received)
            exp_receivers: names of receivers expected to recv the
                message
            msg_idx: the index into the messages array for the message
                to retrieve

        Returns:
            the set of messages to be sent

        """
        send_msgs: dict[str, Any] = {}
        with self.msg_lock:
            for receiver_name in receiver_names:
                msg = self.directed_msgs[msg_idx][sender_name][receiver_name]
                send_msgs[receiver_name] = msg
                if receiver_name in exp_receivers:
                    self.add_exp_msg_received(
                        receiver_name=receiver_name, sender_name=sender_name, msg=msg
                    )
        return send_msgs

    def add_exp_msg_received(
        self, receiver_name: str, sender_name: str, msg: Any
    ) -> None:
        """Add sent message to the expected received messages list.

        Args:
            receiver_name: name of receiver that message was sent to
            sender_name: sender who send the message
            msg: the message that was sent

        """
        self.exp_received_msgs[receiver_name][sender_name].append(msg)

    def clear_exp_msgs_received(
        self, receiver_name: str, sender_names: Iterable[str], num_msgs: int
    ) -> None:
        """Clear expected messages for a receiver and its senders.

        Args:
            receiver_name: name of receiver whose msgs are to be cleared
            sender_names: senders whose message are to clear for
                the specified receiver
            num_msgs: number of messages to be cleared

        """
        sender_names = get_set(sender_names)
        with self.msg_lock:
            for sender in sender_names:
                for idx in range(num_msgs):
                    if self.exp_received_msgs[receiver_name][sender]:
                        self.exp_received_msgs[receiver_name][sender].pop(0)
                    else:
                        break

    def clear_all_exp_msgs_received(self, receiver_name: str) -> None:
        """Clear the expected messages in the SendRecvMsgs object.

        Args:
            receiver_name: name of receiver whose msgs are to be cleared

        """
        with self.msg_lock:
            senders = list(self.exp_received_msgs[receiver_name].keys())
            for sender in senders:
                self.exp_received_msgs[receiver_name][sender].clear()


########################################################################
# LockMgr
########################################################################
class LockMgr:
    """Class LockMsg manages locking for test cases."""

    def __init__(self, config_ver: "ConfigVerifier", locker_names: list[str]):
        """Initialize the object.

        Args:
            config_ver: the ConfigVerifier object
            locker_names: thread names that do the locking
        """
        self.config_ver = config_ver
        self.locker_avail_q: deque[str] = deque(locker_names)
        self.lock_positions: list[str] = []

    ####################################################################
    # get_lock
    ####################################################################
    def get_lock(self, alt_frame_num: int = 1):
        """Get the lock and verify the lock positions.

        Args:
            alt_frame_num: frame to get line_num

        """
        locker_name = self.locker_avail_q.pop()
        obtain_lock_serial_num = self.config_ver.add_cmd(
            LockObtain(cmd_runners=locker_name), alt_frame_num=alt_frame_num
        )
        self.lock_positions.append(locker_name)

        # we can confirm only this first lock obtain
        if len(self.lock_positions) == 1:
            self.config_ver.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.config_ver.commander_name],
                    confirm_cmd="LockObtain",
                    confirm_serial_num=obtain_lock_serial_num,
                    confirmers=locker_name,
                ),
                alt_frame_num=alt_frame_num,
            )

        self.config_ver.add_cmd(
            LockVerify(
                cmd_runners=self.config_ver.commander_name,
                exp_positions=self.lock_positions.copy(),
            ),
            alt_frame_num=alt_frame_num,
        )

    ####################################################################
    # start_request
    ####################################################################
    def start_request(
        self, requestor_name: str, trailing_lock: bool = True, alt_frame_num: int = 1
    ):
        """Append a requestor and verify lock positions.

        Args:
            requestor_name: thread name of requestor that just obtained
                the lock
            trailing_lock: if True, add a lock at end
            alt_frame_num: frame to get line_num
        """
        self.lock_positions.append(requestor_name)
        self.config_ver.add_cmd(
            LockVerify(
                cmd_runners=self.config_ver.commander_name,
                exp_positions=self.lock_positions.copy(),
            ),
            alt_frame_num=alt_frame_num,
        )
        if trailing_lock:
            self.get_lock(alt_frame_num=alt_frame_num + 1)

    ####################################################################
    # drop_lock
    ####################################################################
    def drop_lock(
        self,
        requestor_complete: bool = False,
        free_all: bool = False,
        alt_frame_num: int = 1,
    ):
        """Drop the lock and verify positions.

        Args:
            requestor_complete: If True, the requestor has completed
                its smart request and can be removed from the positions
                list. If False, request has progressed and should now be
                behind another lock.
            free_all: specifies that all requests will complete
            alt_frame_num: frame to get line_num
        """
        locker_name = self.lock_positions.pop(0)
        self.locker_avail_q.append(locker_name)
        self.config_ver.add_cmd(
            LockRelease(cmd_runners=locker_name), alt_frame_num=alt_frame_num
        )

        requestor_name = self.lock_positions.pop(0)
        if not requestor_complete:
            self.lock_positions.append(requestor_name)
        if free_all:
            self.lock_positions = []

        self.config_ver.add_cmd(
            LockVerify(
                cmd_runners=self.config_ver.commander_name,
                exp_positions=self.lock_positions.copy(),
            ),
            alt_frame_num=alt_frame_num,
        )

    ####################################################################
    # complete_request
    ####################################################################
    def complete_request(self, free_all: bool = False, alt_frame_num: int = 1):
        """Drop the lock and verify positions.

        Args:
            free_all: specifies that all requests will complete
            alt_frame_num: frame to get line_num
        """
        self.drop_lock(
            requestor_complete=True, free_all=free_all, alt_frame_num=alt_frame_num
        )

    ####################################################################
    # advance_request
    ####################################################################
    def advance_request(
        self, num_times: int = 1, trailing_lock: bool = True, alt_frame_num: int = 1
    ):
        """Drop the lock, requeue the requestor, verify positions.

        Args:
            num_times: number of times to do the advance
            trailing_lock: if True, add a lock at end
            alt_frame_num: frame to get line_num
        """
        for _ in range(num_times):
            self.drop_lock(requestor_complete=False, alt_frame_num=alt_frame_num + 1)
            if trailing_lock:
                self.get_lock(alt_frame_num=alt_frame_num + 1)

    ####################################################################
    # advance_request
    ####################################################################
    def swap_requestors(self, alt_frame_num: int = 1):
        """Swap the requests lock positions.

        Args:
            alt_frame_num: frame to get line_num
        """
        lock_pos_1 = self.lock_positions[1]
        self.lock_positions[1] = self.lock_positions[3]
        self.lock_positions[3] = lock_pos_1

        self.config_ver.add_cmd(
            LockSwap(
                cmd_runners=self.config_ver.commander_name,
                new_positions=self.lock_positions.copy(),
            ),
            alt_frame_num=alt_frame_num,
        )
        self.config_ver.add_cmd(
            LockVerify(
                cmd_runners=self.config_ver.commander_name,
                exp_positions=self.lock_positions.copy(),
            ),
            alt_frame_num=alt_frame_num,
        )


########################################################################
# WaitType
########################################################################
class WaitType(Enum):
    """WaitType used to specify the number of resumers."""

    PartialResumers = auto()
    MatchResumers = auto()
    ExtraResumers = auto()
    UnmatchResumers = auto()


########################################################################
# VerifyData items
########################################################################
class VerifyType(Enum):
    """VerifyType used to select the verification to be done."""

    VerifyStructures = auto()
    VerifyAlive = auto()
    VerifyNotAlive = auto()
    VerifyState = auto()
    VerifyInRegistry = auto()
    VerifyNotInRegistry = auto()
    VerifyAliveState = auto()
    VerifyRegisteredState = auto()
    VerifyStoppedState = auto()
    VerifyPaired = auto()
    VerifyNotPaired = auto()
    VerifyHalfPaired = auto()
    VerifyPendingFlags = auto()
    VerifyCounts = auto()


@dataclass
class PendingFlags:
    """PendingFlags used for setting and checking the pending flags."""

    pending_request: bool = False
    pending_msgs: int = 0
    pending_wait: bool = False
    pending_sync: bool = False


@dataclass
class VerifyData:
    """VerifyData used for the verify methods."""

    cmd_runner: str
    verify_type: VerifyType
    names_to_check: set[str]
    aux_names: set[str]
    state_to_check: st.ThreadState
    exp_pending_flags: PendingFlags
    obtain_reg_lock: bool
    num_registered: int = 0
    num_active: int = 0
    num_stopped: int = 0


@dataclass
class RegistrySnapshotItem:
    """RegistrySnapshotItem used to verify registry."""

    is_alive: bool
    state: st.ThreadState


@dataclass
class StatusBlockSnapshotItem:
    """StatusBlockSnapshotItem used for pending flags."""

    del_def_flag: bool = False
    pending_request: bool = False
    pending_msg_count: int = 0
    pending_wait: bool = False
    pending_sync: bool = False


RegistryItems: TypeAlias = dict[str, RegistrySnapshotItem]
StatusBlockItems: TypeAlias = dict[str, StatusBlockSnapshotItem]
PairArrayItems: TypeAlias = dict[st.PairKey, StatusBlockItems]


@dataclass
class SnapShotDataItem:
    """SnapShotData used to collect mock array info."""

    registry_items: RegistryItems
    pair_array_items: PairArrayItems
    verify_data: VerifyData


@contextmanager
def conditional_registry_lock(
    lock: sel.SELock, obtain_tf: bool
) -> Generator[None, None, None]:
    """Obtain the connection_block lock.

    This method is called to conditionally obtain a lock using a with
    statement.

    Args:
        lock: the lock to obtain
        obtain_tf: whether to obtain the lock

    """
    # if request needs the lock
    if obtain_tf:
        lock.obtain_excl()
    try:
        yield
    finally:
        # release the lock if it was obtained
        if obtain_tf:
            lock.release()


########################################################################
# CommanderConfig
########################################################################
class AppConfig(Enum):
    """Commander configuration choices."""

    ScriptStyle = auto()
    CurrentThreadApp = auto()
    RemoteThreadApp = auto()
    RemoteSmartThreadApp = auto()
    RemoteSmartThreadApp2 = auto()


########################################################################
# ResumeStyles
########################################################################
class Actors(Enum):
    """Resume scenario cases."""

    ActiveBeforeActor = auto()
    ActiveAfterActor = auto()
    ActionExitActor = auto()
    ExitActionActor = auto()
    UnregActor = auto()
    RegActor = auto()


########################################################################
# DeadlockScenario
########################################################################
class DeadlockScenario(Enum):
    """Deadlock scenario cases to test."""

    NormalSendRecv = auto()
    NormalResumeWait = auto()
    NormalSync = auto()
    SendSyncRecv = auto()
    ResumeSyncWait = auto()
    RecvDeadlock = auto()
    WaitDeadlock = auto()
    SyncDeadlock = auto()


########################################################################
# DefDelScenario
########################################################################
class DefDelScenario(Enum):
    """Deferred delete scenario cases."""

    NormalRecv = auto()
    NormalWait = auto()
    ResurrectionRecv = auto()
    ResurrectionWait = auto()
    Recv0Recv1 = auto()
    Recv1Recv0 = auto()
    Wait0Wait1 = auto()
    Wait1Wait0 = auto()
    RecvWait = auto()
    WaitRecv = auto()
    RecvDel = auto()
    RecvAdd = auto()
    WaitDel = auto()
    WaitAdd = auto()


########################################################################
# RequestConfirmParms
########################################################################
@dataclass()
class RequestConfirmParms:
    """Request confirm parms."""

    request_name: str
    serial_number: int


########################################################################
# timeout_type used to specify whether to use timeout on various cmds
########################################################################
class TimeoutType(Enum):
    """Timeout type for test."""

    TimeoutNone = auto()
    TimeoutFalse = auto()
    TimeoutTrue = auto()


########################################################################
# SmartThread test exceptions
########################################################################
class ErrorTstSmartThread(Exception):
    """Base class for exception in this module."""

    pass


class IncorrectActionSpecified(ErrorTstSmartThread):
    """IncorrectActionSpecified exception class."""

    pass


class IncorrectDataDetected(ErrorTstSmartThread):
    """IncorrectDataDetected exception class."""

    pass


class UnexpectedEvent(ErrorTstSmartThread):
    """Unexpected action encountered exception class."""

    pass


class UnrecognizedEvent(ErrorTstSmartThread):
    """Unrecognized event ws detected."""

    pass


class UnrecognizedCmd(ErrorTstSmartThread):
    """UnrecognizedCmd exception class."""

    pass


class InvalidConfigurationDetected(ErrorTstSmartThread):
    """UnrecognizedCmd exception class."""

    pass


class InvalidInputDetected(ErrorTstSmartThread):
    """The input is not correct."""

    pass


class CmdTimedOut(ErrorTstSmartThread):
    """The cmd took to long."""

    pass


class CmdFailed(ErrorTstSmartThread):
    """The cmd failed."""

    pass


class FailedLockVerify(ErrorTstSmartThread):
    """An expected lock position was not found."""

    pass


class FailedDefDelVerify(ErrorTstSmartThread):
    """An expected condition was incorrect."""

    pass


class RemainingPendingEvents(ErrorTstSmartThread):
    """There are remaining pending events."""

    pass


########################################################################
# get_names
########################################################################
def get_names(stem: str, count: int) -> set[str]:
    """Create a set of names give stem and count.

    Args:
        stem: base of name to which index will be added
        count: number of names to create

    Returns:
        A set of names

    """
    if count:
        return {stem + str(i) for i in range(count)}
    else:
        return set()


########################################################################
# get_set
########################################################################
def get_set(item: Optional[Iterable[str]] = None) -> set[Any]:
    """Return a set given the iterable input.

    Args:
        item: iterable to be returned as a set

    Returns:
        A set created from the input iterable item. Note that the set
        will be empty if None was passed in.
    """
    return set({item} if isinstance(item, str) else item or "")


########################################################################
# ConfigCmd
########################################################################
class ConfigCmd(ABC):
    """Configuration command base class."""

    def __init__(self, cmd_runners: Iterable[str]) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command

        """
        # The serial number, line_num, and config_ver are filled in
        # by the ConfigVerifier add_cmd method just before queueing
        # the command.
        self.serial_num: int = 0
        self.line_num: int = 0
        self.alt_line_num: int = 0
        self.config_ver: "ConfigVerifier"

        # specified_args are set in each subclass
        self.specified_args: dict[str, Any] = {}

        self.cmd_runners = get_set(cmd_runners)

        self.arg_list: list[str] = ["cmd_runners", "serial_num", "line_num"]

    def __repr__(self) -> str:
        """Method to provide repr."""
        if TYPE_CHECKING:
            __class__: Type[ConfigVerifier]  # noqa: F842
        classname = self.__class__.__name__
        parms = f"serial={self.serial_num}, line={self.line_num}"
        if self.alt_line_num:
            parms += f"({self.alt_line_num})"
        comma = ", "
        for key, item in self.specified_args.items():
            if item:  # if not None
                if key in self.arg_list:
                    if type(item) is str:
                        parms += comma + f"{key}='{item}'"
                    else:
                        parms += comma + f"{key}={item}"
                    # comma = ', '  # after first item, now need comma
            if key == "f1_create_items":
                create_names: list[str] = []
                for create_item in item:
                    create_names.append(create_item.name)
                parms += comma + f"{create_names=}"

        return f"{classname}({parms})"

    @abstractmethod
    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
           cmd_runner: name of thread running the command
        """
        pass


########################################################################
# ConfirmResponse
########################################################################
class ConfirmResponse(ConfigCmd):
    """Confirm that an earlier command has completed."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        confirm_cmd: str,
        confirm_serial_num: int,
        confirmers: Iterable[str],
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            confirm_cmd: command to be confirmed
            confirm_serial_num: serial number of command to confirm
            confirmers: cmd runners of the cmd to be confirmed
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.confirm_cmd = confirm_cmd
        self.confirm_serial_num = confirm_serial_num

        self.confirmers = get_set(confirmers)

        self.arg_list += ["confirm_cmd", "confirm_serial_num", "confirmers"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
           cmd_runner: name of thread running the command
        """
        start_time = time.time()
        work_confirmers = self.confirmers.copy()
        if not work_confirmers:
            raise InvalidInputDetected(
                "ConfirmResponse detected an empty set of confirmers"
            )
        while work_confirmers:
            for name in work_confirmers:
                # If the serial number is in the completed_cmds for
                # this name then the command was completed. Remove the
                # target_rtn name and break to start looking again with
                # one less target_rtn until no targets remain.
                if self.confirm_serial_num in self.config_ver.completed_cmds[name]:
                    work_confirmers.remove(name)
                    break
            time.sleep(0.2)
            timeout_value = 60
            if time.time() - start_time > timeout_value:
                self.config_ver.abort_all_f1_threads()
                raise CmdTimedOut(
                    "ConfirmResponse serial_num "
                    f"{self.serial_num} took longer than "
                    f"{timeout_value} seconds waiting "
                    f"for {work_confirmers} to complete "
                    f"cmd {self.confirm_cmd} with "
                    f"serial_num {self.confirm_serial_num}."
                )


########################################################################
# ConfirmResponseNot
########################################################################
class ConfirmResponseNot(ConfirmResponse):
    """Confirm that an earlier command has not yet completed."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        confirm_cmd: str,
        confirm_serial_num: int,
        confirmers: Iterable[str],
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            confirm_cmd: command to be confirmed as not yet completed
            confirm_serial_num: serial number of command to not confirm
            confirmers: cmd runners of the cmd to be not confirmed
        """
        super().__init__(
            cmd_runners=cmd_runners,
            confirm_cmd=confirm_cmd,
            confirm_serial_num=confirm_serial_num,
            confirmers=confirmers,
        )
        self.specified_args = locals()  # used for __repr__

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
           cmd_runner: name of thread running the command
        """
        for name in self.confirmers:
            # If the serial number is in the completed_cmds for
            # this name then the command was completed. Remove the
            # target_rtn name and break to start looking again with one
            # less target_rtn until no targets remain.
            if self.confirm_serial_num in self.config_ver.completed_cmds[name]:
                raise CmdFailed(
                    "ConfirmResponseNot found that "
                    f"{name} completed {self.confirm_cmd=} "
                    f"with {self.serial_num=}."
                )


########################################################################
# CreateF1AutoStart
########################################################################
class CreateF1AutoStart(ConfigCmd):
    """Create an f1 thread with autostart."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        f1_create_items: list["F1CreateItem"],
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            f1_create_items: list of names and attributes to be used
                when creating the threads
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.f1_create_items = f1_create_items

        self.args_list = ["f1_create_items"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
           cmd_runner: name of thread running the command
        """
        for f1_item in self.f1_create_items:
            self.config_ver.create_f1_thread(
                cmd_runner=cmd_runner,
                name=f1_item.name,
                target=f1_item.target_rtn,
                app_config=f1_item.app_config,
                auto_start=True,
            )


########################################################################
# CreateF1NoStart
########################################################################
class CreateF1NoStart(CreateF1AutoStart):
    """Create an f1 thread with no autostart."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        f1_create_items: list["F1CreateItem"],
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            f1_create_items: list of names and attributes to be used
                when creating the threads
        """
        super().__init__(cmd_runners=cmd_runners, f1_create_items=f1_create_items)
        self.specified_args = locals()  # used for __repr__

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        for f1_item in self.f1_create_items:
            self.config_ver.create_f1_thread(
                cmd_runner=cmd_runner,
                name=f1_item.name,
                target=f1_item.target_rtn,
                app_config=f1_item.app_config,
                auto_start=False,
            )


########################################################################
# ExitThread
########################################################################
class ExitThread(ConfigCmd):
    """Cause thread to exit its command loop."""

    def __init__(self, cmd_runners: Iterable[str], stopped_by: str) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            stopped_by: name of thread that did the stop
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.stopped_by = stopped_by

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.exit_thread(cmd_runner=cmd_runner, stopped_by=self.stopped_by)


########################################################################
# Join
########################################################################
class Join(ConfigCmd):
    """Do smart_join."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        join_names: Iterable[str],
        unreg_names: Optional[Iterable[str]] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            join_names: thread names to join
            unreg_names: thread names that are already unregistered
            log_msg: log message specification for the smart_join
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.join_names = get_set(join_names)
        self.unreg_names = get_set(unreg_names)
        self.log_msg = log_msg
        self.arg_list += ["join_names", "unreg_names"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_join(
            cmd_runner=cmd_runner,
            join_names=self.join_names,
            unreg_names=self.unreg_names,
            timeout_type=TimeoutType.TimeoutNone,
            timeout=0,
            log_msg=self.log_msg,
        )


########################################################################
# JoinTimeoutFalse
########################################################################
class JoinTimeoutFalse(Join):
    """Do smart_join with timeout false."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        join_names: Iterable[str],
        timeout: IntOrFloat,
        unreg_names: Optional[Iterable[str]] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            join_names: thread names to join
            unreg_names: thread names that are already unregistered
            timeout: timeout specification for the smart_join
            log_msg: log message specification for the smart_join
        """
        super().__init__(
            cmd_runners=cmd_runners,
            join_names=join_names,
            unreg_names=unreg_names,
            log_msg=log_msg,
        )
        self.specified_args = locals()  # used for __repr__

        self.timeout = timeout
        self.arg_list += ["timeout"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_join(
            cmd_runner=cmd_runner,
            join_names=self.join_names,
            unreg_names=self.unreg_names,
            timeout_type=TimeoutType.TimeoutFalse,
            timeout=self.timeout,
            log_msg=self.log_msg,
        )


########################################################################
# JoinTimeoutTrue
########################################################################
class JoinTimeoutTrue(JoinTimeoutFalse):
    """Do smart_join with timeout true."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        join_names: Iterable[str],
        timeout: IntOrFloat,
        timeout_names: Iterable[str],
        unreg_names: Optional[Iterable[str]] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            join_names: thread names to join
            unreg_names: thread names that are already unregistered
            timeout: timeout specification for the smart_join
            timeout_names: thread names expected to cause timeout
            log_msg: log message specification for the smart_join
        """
        super().__init__(
            cmd_runners=cmd_runners,
            join_names=join_names,
            unreg_names=unreg_names,
            timeout=timeout,
            log_msg=log_msg,
        )
        self.specified_args = locals()  # used for __repr__

        self.timeout_names = get_set(timeout_names)
        self.arg_list += ["timeout_names"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        if self.timeout_names:
            self.config_ver.handle_join(
                cmd_runner=cmd_runner,
                join_names=self.join_names,
                unreg_names=self.unreg_names,
                timeout_type=TimeoutType.TimeoutTrue,
                timeout=self.timeout,
                timeout_names=self.timeout_names,
                log_msg=self.log_msg,
            )
        else:
            self.config_ver.handle_join(
                cmd_runner=cmd_runner,
                join_names=self.join_names,
                unreg_names=self.unreg_names,
                timeout_type=TimeoutType.TimeoutFalse,
                timeout=self.timeout,
                log_msg=self.log_msg,
            )


########################################################################
# LockObtain
########################################################################
class LockObtain(ConfigCmd):
    """Obtain the registry lock."""

    def __init__(self, cmd_runners: Iterable[str]) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command

        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.lock_obtain()


########################################################################
# LockRelease
########################################################################
class LockRelease(ConfigCmd):
    """Release the registry lock."""

    def __init__(self, cmd_runners: Iterable[str]) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command

        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.lock_release()


########################################################################
# LockSwap
########################################################################
class LockSwap(ConfigCmd):
    """Swap the lock positions."""

    def __init__(self, cmd_runners: Iterable[str], new_positions: list[str]) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            new_positions: list of thread names for new position
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.new_positions = new_positions
        self.arg_list += ["new_positions"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.lock_swap(
            cmd_runner=cmd_runner, new_positions=self.new_positions
        )


########################################################################
# LockVerify
########################################################################
class LockVerify(ConfigCmd):
    """Verify the registry lock has the expected owners and waiters."""

    def __init__(self, cmd_runners: Iterable[str], exp_positions: list[str]) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            exp_positions: thread names for expected positions
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.exp_positions = exp_positions
        self.arg_list += ["exp_positions"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.lock_verify(
            cmd_runner=cmd_runner,
            exp_positions=self.exp_positions,
            line_num=self.line_num,
        )


########################################################################
# Pause
########################################################################
class Pause(ConfigCmd):
    """Pause the commands."""

    def __init__(self, cmd_runners: Iterable[str], pause_seconds: IntOrFloat) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            pause_seconds: number seconds to sleep
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.pause_seconds = pause_seconds

        self.arg_list += ["pause_seconds"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        time.sleep(self.pause_seconds)


########################################################################
# RecvMsg
########################################################################
class RecvMsg(ConfigCmd):
    """Do smart_recv."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        senders: Iterable[str],
        exp_senders: Iterable[str],
        exp_msgs: SendRecvMsgs,
        sender_count: Optional[int] = None,
        stopped_remotes: Optional[Iterable[str]] = None,
        deadlock_remotes: Optional[Iterable[str]] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            senders: thread names that will do smart_send
            exp_senders: names of threads that are expected to send a
                msg depending on the RcvType
            exp_msgs: messages to be sent and verified
            sender_count: specification for smart_recv for how many
                senders are needed to satisfy the smart_recv
            stopped_remotes: thread names that are stopped
            deadlock_remotes: thread names that cause deadlock
            log_msg: log message to specify on the smart_recv
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.senders = get_set(senders)

        self.exp_senders = get_set(exp_senders)

        self.exp_msgs = exp_msgs

        self.sender_count = sender_count

        self.log_msg = log_msg

        self.stopped_remotes = get_set(stopped_remotes)

        self.deadlock_remotes = get_set(deadlock_remotes)

        self.arg_list += [
            "senders",
            "exp_senders",
            "sender_count",
            "stopped_remotes",
            "deadlock_remotes",
        ]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_recv_msg(
            cmd_runner=cmd_runner,
            senders=self.senders,
            exp_senders=self.exp_senders,
            exp_msgs=self.exp_msgs,
            sender_count=self.sender_count,
            stopped_remotes=self.stopped_remotes,
            deadlock_remotes=self.deadlock_remotes,
            deadlock_or_timeout=False,
            timeout_type=TimeoutType.TimeoutNone,
            timeout=0,
            timeout_names=set(),
            log_msg=self.log_msg,
        )


########################################################################
# RecvMsgTimeoutFalse
########################################################################
class RecvMsgTimeoutFalse(RecvMsg):
    """Do smart_recv with timeout false."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        senders: Iterable[str],
        exp_senders: Iterable[str],
        exp_msgs: SendRecvMsgs,
        timeout: IntOrFloat,
        sender_count: Optional[int] = None,
        stopped_remotes: Optional[Iterable[str]] = None,
        deadlock_remotes: Optional[Iterable[str]] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            senders: thread names that will do smart_send
            exp_senders: names of threads that are expected to send a
                msg depending on the RcvType
            exp_msgs: messages to be sent and verified
            timeout: value to specify on the smart_recv
            sender_count: specification for smart_recv for how many
                senders are needed to satisfy the smart_recv
            stopped_remotes: thread names that are stopped
            deadlock_remotes: thread names that cause deadlock
            log_msg: log message to specify on the smart_recv
        """
        super().__init__(
            cmd_runners=cmd_runners,
            senders=senders,
            exp_senders=exp_senders,
            exp_msgs=exp_msgs,
            sender_count=sender_count,
            stopped_remotes=stopped_remotes,
            deadlock_remotes=deadlock_remotes,
            log_msg=log_msg,
        )
        self.specified_args = locals()  # used for __repr__

        self.timeout = timeout

        self.arg_list += ["timeout"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_recv_msg(
            cmd_runner=cmd_runner,
            senders=self.senders,
            exp_senders=self.exp_senders,
            exp_msgs=self.exp_msgs,
            sender_count=self.sender_count,
            stopped_remotes=self.stopped_remotes,
            deadlock_remotes=self.deadlock_remotes,
            deadlock_or_timeout=False,
            timeout_type=TimeoutType.TimeoutFalse,
            timeout=self.timeout,
            timeout_names=set(),
            log_msg=self.log_msg,
        )


########################################################################
# RecvMsgTimeoutTrue
########################################################################
class RecvMsgTimeoutTrue(RecvMsgTimeoutFalse):
    """Do smart_recv with timeout true."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        senders: Iterable[str],
        exp_senders: Iterable[str],
        exp_msgs: SendRecvMsgs,
        timeout: IntOrFloat,
        timeout_names: Iterable[str],
        sender_count: Optional[int] = None,
        stopped_remotes: Optional[Iterable[str]] = None,
        deadlock_remotes: Optional[Iterable[str]] = None,
        deadlock_or_timeout: bool = False,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            senders: thread names that will do smart_send
            exp_senders: names of threads that are expected to send a
                msg depending on the RcvType
            exp_msgs: messages to be sent and verified
            timeout: value to specify on the smart_recv
            timeout_names: thread names that are expected to cause a
                timeout
            sender_count: specification for smart_recv for how many
                senders are needed to satisfy the smart_recv
            stopped_remotes: thread names that are stopped
            deadlock_remotes: thread names that cause deadlock
            deadlock_or_timeout: except deadlock or timeout
            log_msg: log message to specify on the smart_recv
        """
        super().__init__(
            cmd_runners=cmd_runners,
            senders=senders,
            exp_senders=exp_senders,
            exp_msgs=exp_msgs,
            timeout=timeout,
            sender_count=sender_count,
            stopped_remotes=stopped_remotes,
            deadlock_remotes=deadlock_remotes,
            log_msg=log_msg,
        )
        self.specified_args = locals()  # used for __repr__

        self.timeout_names = get_set(timeout_names)

        self.deadlock_or_timeout = deadlock_or_timeout

        self.arg_list += ["timeout_names"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_recv_msg(
            cmd_runner=cmd_runner,
            senders=self.senders,
            exp_senders=self.exp_senders,
            exp_msgs=self.exp_msgs,
            sender_count=self.sender_count,
            stopped_remotes=self.stopped_remotes,
            deadlock_remotes=self.deadlock_remotes,
            deadlock_or_timeout=self.deadlock_or_timeout,
            timeout_type=TimeoutType.TimeoutTrue,
            timeout=self.timeout,
            timeout_names=self.timeout_names,
            log_msg=self.log_msg,
        )


########################################################################
# Resume
########################################################################
class Resume(ConfigCmd):
    """Do smart_resume."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        targets: Iterable[str],
        exp_resumed_targets: Iterable[str],
        stopped_remotes: Optional[Iterable[str]] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            targets: thread names to resume
            exp_resumed_targets: thread names expected to be resumed
            stopped_remotes: thread names that are stopped
            log_msg: log msg for smart_resume
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.targets = get_set(targets)

        self.exp_resumed_targets = get_set(exp_resumed_targets)

        self.stopped_remotes = get_set(stopped_remotes)

        self.log_msg = log_msg

        self.arg_list += ["targets", "exp_resumed_targets", "stopped_remotes"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_resume(
            cmd_runner=cmd_runner,
            targets=self.targets,
            exp_resumed_targets=self.exp_resumed_targets,
            stopped_remotes=self.stopped_remotes,
            timeout=0,
            timeout_names=set(),
            timeout_type=TimeoutType.TimeoutNone,
            log_msg=self.log_msg,
        )


########################################################################
# ResumeTimeoutFalse
########################################################################
class ResumeTimeoutFalse(Resume):
    """Do smart_resume with timeout false."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        targets: Iterable[str],
        exp_resumed_targets: Iterable[str],
        timeout: IntOrFloat,
        stopped_remotes: Optional[Iterable[str]] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            targets: thread names to resume
            exp_resumed_targets: thread names expected to be resumed
            stopped_remotes: thread names that are stopped
            timeout: value for smart_resume
            log_msg: log msg for smart_resume
        """
        super().__init__(
            cmd_runners=cmd_runners,
            targets=targets,
            exp_resumed_targets=exp_resumed_targets,
            stopped_remotes=stopped_remotes,
            log_msg=log_msg,
        )
        self.specified_args = locals()  # used for __repr__

        self.timeout = timeout

        self.arg_list += ["timeout"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_resume(
            cmd_runner=cmd_runner,
            targets=self.targets,
            exp_resumed_targets=self.exp_resumed_targets,
            stopped_remotes=self.stopped_remotes,
            timeout=self.timeout,
            timeout_names=set(),
            timeout_type=TimeoutType.TimeoutFalse,
            log_msg=self.log_msg,
        )


########################################################################
# ResumeTimeoutFalse
########################################################################
class ResumeTimeoutTrue(ResumeTimeoutFalse):
    """Do smart_resume with timeout true."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        targets: Iterable[str],
        exp_resumed_targets: Iterable[str],
        timeout: IntOrFloat,
        timeout_names: Iterable[str],
        stopped_remotes: Optional[Iterable[str]] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            targets: thread names to resume
            exp_resumed_targets: thread names expected to be resumed
            stopped_remotes: thread names that are stopped
            timeout: value for smart_resume
            timeout_names: thread names expected to cause timeout
            log_msg: log msg for smart_resume
        """
        super().__init__(
            cmd_runners=cmd_runners,
            targets=targets,
            exp_resumed_targets=exp_resumed_targets,
            stopped_remotes=stopped_remotes,
            timeout=timeout,
            log_msg=log_msg,
        )
        self.specified_args = locals()  # used for __repr__

        self.timeout_names = get_set(timeout_names)

        self.arg_list += ["timeout_names"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_resume(
            cmd_runner=cmd_runner,
            targets=self.targets,
            exp_resumed_targets=self.exp_resumed_targets,
            stopped_remotes=self.stopped_remotes,
            timeout=self.timeout,
            timeout_names=self.timeout_names,
            timeout_type=TimeoutType.TimeoutTrue,
            log_msg=self.log_msg,
        )


########################################################################
# SendMsg
########################################################################
class SendMsg(ConfigCmd):
    """Do smart_send."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        receivers: Iterable[str],
        exp_receivers: Iterable[str],
        msgs_to_send: SendRecvMsgs,
        msg_idx: int,
        send_type: SendType = SendType.ToRemotes,
        stopped_remotes: Optional[Iterable[str]] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            receivers: thread names that will receive the message
            exp_receivers: thread names expected to receive
            msgs_to_send: messages to send and verify
            msg_idx: index to use with msgs_to_send for this call
            send_type: specifies how to send the messages
            stopped_remotes: thread names that are stopped
            log_msg: log message for smart_send
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.receivers = get_set(receivers)
        self.msgs_to_send = msgs_to_send
        self.msg_idx = msg_idx

        self.send_type = send_type

        self.stopped_remotes = get_set(stopped_remotes)

        self.exp_receivers = get_set(exp_receivers)

        self.log_msg = log_msg

        self.arg_list += ["receivers", "stopped_remotes", "send_type", "msg_idx"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_send_msg(
            cmd_runner=cmd_runner,
            receivers=self.receivers,
            exp_receivers=self.exp_receivers,
            msgs_to_send=self.msgs_to_send,
            msg_idx=self.msg_idx,
            send_type=self.send_type,
            timeout_type=TimeoutType.TimeoutNone,
            timeout=0,
            unreg_timeout_names=None,
            fullq_timeout_names=None,
            stopped_remotes=self.stopped_remotes,
            log_msg=self.log_msg,
        )


########################################################################
# SendMsgTimeoutFalse
########################################################################
class SendMsgTimeoutFalse(SendMsg):
    """Do smart_send with timeout false."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        receivers: Iterable[str],
        exp_receivers: Iterable[str],
        msgs_to_send: SendRecvMsgs,
        msg_idx: int,
        timeout: IntOrFloat,
        send_type: SendType = SendType.ToRemotes,
        stopped_remotes: Optional[StrOrSet] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            receivers: thread names that will receive the message
            exp_receivers: thread names expected to receive
            msgs_to_send: messages to send and verify
            msg_idx: index to use with msgs_to_send for this call
            timeout: value for smart_send
            send_type: specifies how to send the messages
            stopped_remotes: thread names that are stopped
            log_msg: log message for smart_send
        """
        super().__init__(
            cmd_runners=cmd_runners,
            receivers=receivers,
            exp_receivers=exp_receivers,
            msgs_to_send=msgs_to_send,
            msg_idx=msg_idx,
            send_type=send_type,
            stopped_remotes=stopped_remotes,
            log_msg=log_msg,
        )
        self.specified_args = locals()  # used for __repr__

        self.timeout = timeout

        self.arg_list += ["timeout"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_send_msg(
            cmd_runner=cmd_runner,
            receivers=self.receivers,
            exp_receivers=self.exp_receivers,
            msgs_to_send=self.msgs_to_send,
            msg_idx=self.msg_idx,
            send_type=self.send_type,
            timeout_type=TimeoutType.TimeoutFalse,
            timeout=self.timeout,
            unreg_timeout_names=None,
            fullq_timeout_names=None,
            stopped_remotes=self.stopped_remotes,
            log_msg=self.log_msg,
        )


########################################################################
# SendMsgTimeoutTrue
########################################################################
class SendMsgTimeoutTrue(SendMsgTimeoutFalse):
    """Do smart_send with timeout true."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        receivers: Iterable[str],
        exp_receivers: Iterable[str],
        msgs_to_send: SendRecvMsgs,
        msg_idx: int,
        timeout: IntOrFloat,
        unreg_timeout_names: Iterable[str],
        fullq_timeout_names: Iterable[str],
        send_type: SendType = SendType.ToRemotes,
        stopped_remotes: Optional[StrOrSet] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            receivers: thread names that will receive the message
            exp_receivers: thread names expected to receive
            msgs_to_send: messages to send and verify
            msg_idx: index to use with msgs_to_send for this call
            timeout: value for smart_send
            unreg_timeout_names: thread names that are not registered
            fullq_timeout_names: thread names whose msg_q is full
            send_type: specifies how to send the messages
            stopped_remotes: thread names that are stopped
            log_msg: log message for smart_send
        """
        super().__init__(
            cmd_runners=cmd_runners,
            receivers=receivers,
            exp_receivers=exp_receivers,
            msgs_to_send=msgs_to_send,
            msg_idx=msg_idx,
            timeout=timeout,
            send_type=send_type,
            stopped_remotes=stopped_remotes,
            log_msg=log_msg,
        )
        self.specified_args = locals()  # used for __repr__

        self.arg_list += ["unreg_timeout_names", "fullq_timeout_names"]

        self.unreg_timeout_names = get_set(unreg_timeout_names)

        self.fullq_timeout_names = get_set(fullq_timeout_names)

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_send_msg(
            cmd_runner=cmd_runner,
            receivers=self.receivers,
            exp_receivers=self.exp_receivers,
            msgs_to_send=self.msgs_to_send,
            msg_idx=self.msg_idx,
            send_type=self.send_type,
            timeout_type=TimeoutType.TimeoutTrue,
            timeout=self.timeout,
            unreg_timeout_names=set(self.unreg_timeout_names),
            fullq_timeout_names=set(self.fullq_timeout_names),
            stopped_remotes=self.stopped_remotes,
            log_msg=self.log_msg,
        )


########################################################################
# StartThread
########################################################################
class StartThread(ConfigCmd):
    """Start a thread with smart_start."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        start_names: Iterable[str],
        unreg_remotes: Optional[Iterable[str]] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            start_names: thread names to start
            unreg_remotes: thread names that are not registered state
            log_msg: log message for smart_start
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.start_names = get_set(start_names)

        self.unreg_remotes = get_set(unreg_remotes)

        self.log_msg = log_msg

        self.arg_list += ["start_names", "unreg_remotes"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_start(
            cmd_runner=cmd_runner,
            start_names=self.start_names,
            unreg_remotes=self.unreg_remotes,
            log_msg=self.log_msg,
        )


########################################################################
# StopThread
########################################################################
class StopThread(ConfigCmd):
    """Stop a thread."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        stop_names: Iterable[str],
        reset_ops_count: bool = False,
        send_recv_msgs: Optional[SendRecvMsgs] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            stop_names: thread names to stop
            reset_ops_count: specifies whether to reset ops count for
                the stop names
            send_recv_msgs: messages to be reset
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.stop_names = get_set(stop_names)

        self.reset_ops_count = reset_ops_count

        self.send_recv_msgs = send_recv_msgs

        self.arg_list += ["stop_names", "reset_ops_count"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.stop_thread(
            cmd_runner=cmd_runner,
            stop_names=self.stop_names,
            reset_ops_count=self.reset_ops_count,
            send_recv_msgs=self.send_recv_msgs,
        )


########################################################################
# Sync
########################################################################
class Sync(ConfigCmd):
    """Do smart_sync."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        targets: Iterable[str],
        timeout: IntOrFloat = 0,
        timeout_remotes: Optional[Iterable[str]] = None,
        stopped_remotes: Optional[Iterable[str]] = None,
        deadlock_remotes: Optional[Iterable[str]] = None,
        sync_set_ack_remotes: Optional[Iterable[str]] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            targets: thread names who will sync with each other
            timeout: value for smart_sync
            timeout_remotes: thread names that cause timeout
            stopped_remotes: thread names that are stopped
            deadlock_remotes: thread names that cause deadlock
            sync_set_ack_remotes: thread names that will get the first
                sync set ack message (but may or may not get the
                achieved sync ack if they fail to respond for timeout or
                stopped scenarios)
            log_msg: log message for smart_sync
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.targets = get_set(targets)

        self.timeout = timeout

        self.timeout_remotes = get_set(timeout_remotes)

        self.stopped_remotes = get_set(stopped_remotes)

        self.deadlock_remotes = get_set(deadlock_remotes)

        self.sync_set_ack_remotes = get_set(sync_set_ack_remotes)

        self.log_msg = log_msg

        self.arg_list += [
            "targets",
            "timeout",
            "stopped_remotes",
            "timeout_remotes",
            "deadlock_remotes",
            "sync_set_ack_remotes",
        ]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        targets = self.targets - {cmd_runner}
        self.config_ver.handle_sync(
            cmd_runner=cmd_runner,
            targets=targets,
            timeout=self.timeout,
            timeout_remotes=self.timeout_remotes,
            stopped_remotes=self.stopped_remotes,
            deadlock_remotes=self.deadlock_remotes,
            sync_set_ack_remotes=self.sync_set_ack_remotes,
            timeout_type=TimeoutType.TimeoutNone,
            log_msg=self.log_msg,
        )


########################################################################
# SyncTimeoutFalse
########################################################################
class SyncTimeoutFalse(Sync):
    """Do smart_sync with timeout of false."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        targets: Iterable[str],
        timeout: IntOrFloat,
        stopped_remotes: Optional[Iterable[str]] = None,
        timeout_remotes: Optional[Iterable[str]] = None,
        deadlock_remotes: Optional[Iterable[str]] = None,
        sync_set_ack_remotes: Optional[Iterable[str]] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            targets: thread names who will sync with each other
            timeout: value for smart_sync
            timeout_remotes: thread names that cause timeout
            stopped_remotes: thread names that are stopped
            deadlock_remotes: thread names that cause deadlock
            sync_set_ack_remotes: thread names that will get the first
                sync set ack message (but may or may not get the
                achieved sync ack if they fail to respond for timeout or
                stopped scenarios)
            log_msg: log message for smart_sync
        """
        super().__init__(
            cmd_runners=cmd_runners,
            targets=targets,
            timeout=timeout,
            timeout_remotes=timeout_remotes,
            stopped_remotes=stopped_remotes,
            deadlock_remotes=deadlock_remotes,
            sync_set_ack_remotes=sync_set_ack_remotes,
            log_msg=log_msg,
        )
        self.specified_args = locals()  # used for __repr__

        self.arg_list += ["timeout"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        targets = self.targets - {cmd_runner}
        self.config_ver.handle_sync(
            cmd_runner=cmd_runner,
            targets=targets,
            timeout=self.timeout,
            timeout_remotes=self.timeout_remotes,
            stopped_remotes=self.stopped_remotes,
            deadlock_remotes=self.deadlock_remotes,
            sync_set_ack_remotes=self.sync_set_ack_remotes,
            timeout_type=TimeoutType.TimeoutFalse,
            log_msg=self.log_msg,
        )


########################################################################
# SyncTimeoutFalse
########################################################################
class SyncTimeoutTrue(SyncTimeoutFalse):
    """Do smart_sync with timeout of true."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        targets: Iterable[str],
        timeout: IntOrFloat,
        timeout_remotes: Iterable[str],
        stopped_remotes: Optional[Iterable[str]] = None,
        deadlock_remotes: Optional[Iterable[str]] = None,
        sync_set_ack_remotes: Optional[Iterable[str]] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            targets: thread names who will sync with each other
            timeout: value for smart_sync
            timeout_remotes: thread names that cause timeout
            stopped_remotes: thread names that are stopped
            deadlock_remotes: thread names that cause deadlock
            sync_set_ack_remotes: thread names that will get the first
                sync set ack message (but may or may not get the
                achieved sync ack if they fail to respond for timeout or
                stopped scenarios)
            log_msg: log message for smart_sync
        """
        super().__init__(
            cmd_runners=cmd_runners,
            targets=targets,
            timeout=timeout,
            timeout_remotes=timeout_remotes,
            stopped_remotes=stopped_remotes,
            deadlock_remotes=deadlock_remotes,
            sync_set_ack_remotes=sync_set_ack_remotes,
            log_msg=log_msg,
        )
        self.specified_args = locals()  # used for __repr__

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        targets = self.targets - {cmd_runner}
        self.config_ver.handle_sync(
            cmd_runner=cmd_runner,
            targets=targets,
            timeout=self.timeout,
            timeout_remotes=self.timeout_remotes,
            stopped_remotes=self.stopped_remotes,
            deadlock_remotes=self.deadlock_remotes,
            sync_set_ack_remotes=self.sync_set_ack_remotes,
            timeout_type=TimeoutType.TimeoutTrue,
            log_msg=self.log_msg,
        )


########################################################################
# Unregister
########################################################################
class Unregister(ConfigCmd):
    """Do the smart_unreg."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        unregister_targets: Iterable[str],
        not_registered_remotes: Optional[Iterable[str]] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            unregister_targets: thread names to be unregistered
            not_registered_remotes: remotes not registered that should
                result in error
            log_msg: log message for smart_unreg
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.unregister_targets = get_set(unregister_targets)

        self.not_registered_remotes = get_set(not_registered_remotes)

        self.log_msg = log_msg

        self.arg_list += ["unregister_targets", "not_registered_remotes"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_unregister(
            cmd_runner=cmd_runner,
            unregister_targets=self.unregister_targets,
            not_registered_remotes=self.not_registered_remotes,
            log_msg=self.log_msg,
        )


########################################################################
# ValidateConfig
########################################################################
class VerifyConfig(ConfigCmd):
    """Validate the configuration."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        verify_type: VerifyType,
        names_to_check: Optional[Iterable[str]] = None,
        aux_names: Optional[Iterable[str]] = None,
        state_to_check: st.ThreadState = st.ThreadState.Unregistered,
        exp_pending_flags: PendingFlags = PendingFlags(),
        obtain_reg_lock: bool = True,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            verify_type: type of verification to do
            names_to_check: thread names to verify
            aux_names: thread names associated with names_to_check
            state_to_check: expected ThreadState
            exp_pending_flags: expected pending flags
            obtain_reg_lock: if True, obtain the smart_thread lock

        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.verify_type = verify_type
        self.names_to_check = get_set(names_to_check)
        self.aux_names = get_set(aux_names)
        self.state_to_check = state_to_check
        self.exp_pending_flags = exp_pending_flags
        self.obtain_reg_lock = obtain_reg_lock

        self.arg_list += [
            "verify_type",
            "names_to_check",
            "aux_names",
            "state_to_check",
            "exp_pending_flags",
        ]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        verify_data: VerifyData = VerifyData(
            cmd_runner=cmd_runner,
            verify_type=self.verify_type,
            names_to_check=self.names_to_check,
            aux_names=self.aux_names,
            state_to_check=self.state_to_check,
            exp_pending_flags=self.exp_pending_flags,
            obtain_reg_lock=self.obtain_reg_lock,
        )

        self.config_ver.create_snapshot_data(
            verify_name="verify_config",
            verify_idx=self.serial_num,
            verify_data=verify_data,
        )

        self.config_ver.verify_config_complete_event.wait()
        self.config_ver.verify_config_complete_event.clear()


########################################################################
# VerifyCounts
########################################################################
class VerifyCounts(ConfigCmd):
    """Verify the number of threads at various states in the config."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        exp_num_registered: int,
        exp_num_active: int,
        exp_num_stopped: int,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            exp_num_registered: number thread expected to be registered
                state
            exp_num_active: number thread expected to be alive state
            exp_num_stopped: number thread expected to be stopped state
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.exp_num_registered = exp_num_registered
        self.exp_num_active = exp_num_active
        self.exp_num_stopped = exp_num_stopped

        self.arg_list += ["exp_num_registered", "exp_num_active", "exp_num_stopped"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        verify_data: VerifyData = VerifyData(
            cmd_runner=cmd_runner,
            verify_type=VerifyType.VerifyCounts,
            names_to_check=set(),
            aux_names=set(),
            state_to_check=st.ThreadState.Alive,
            exp_pending_flags=PendingFlags(),
            obtain_reg_lock=True,
            num_registered=self.exp_num_registered,
            num_active=self.exp_num_active,
            num_stopped=self.exp_num_stopped,
        )
        self.config_ver.create_snapshot_data(
            verify_name="verify_counts",
            verify_idx=self.serial_num,
            verify_data=verify_data,
        )


########################################################################
# VerifyDefDel
########################################################################
class VerifyDefDel(ConfigCmd):
    """Verify deferred deletes."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        def_del_scenario: DefDelScenario,
        receiver_names: list[str],
        sender_names: list[str],
        waiter_names: list[str],
        resumer_names: list[str],
        del_names: list[str],
        add_names: list[str],
        deleter_names: list[str],
        adder_names: list[str],
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            def_del_scenario: scenario to run
            receiver_names: thread names
            sender_names: thread names
            waiter_names: thread names
            resumer_names: thread names
            del_names: thread names
            add_names: thread names
            deleter_names: thread names
            adder_names: thread names
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.def_del_scenario = def_del_scenario
        self.receiver_names = receiver_names
        self.sender_names = sender_names
        self.waiter_names = waiter_names
        self.resumer_names = resumer_names
        self.del_names = del_names
        self.add_names = add_names
        self.deleter_names = deleter_names
        self.adder_names = adder_names

        self.arg_list += ["def_del_scenario"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.verify_def_del(
            cmd_runner=cmd_runner,
            def_del_scenario=self.def_del_scenario,
            receiver_names=self.receiver_names,
            sender_names=self.sender_names,
            waiter_names=self.waiter_names,
            resumer_names=self.resumer_names,
            del_names=self.del_names,
            add_names=self.add_names,
            deleter_names=self.deleter_names,
            adder_names=self.adder_names,
        )


########################################################################
# Wait
########################################################################
class Wait(ConfigCmd):
    """Do smart_wait."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        resumers: Iterable[str],
        exp_resumers: Iterable[str],
        resumer_count: Optional[int] = None,
        stopped_remotes: Optional[Iterable[str]] = None,
        deadlock_remotes: Optional[Iterable[str]] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            resumers: thread names that will resume
            exp_resumers: thread names that the wait is expected to be
                resumed by
            resumer_count: specification for smart_wait for how many
                resumes are needed to satisfy the smart_wait
            stopped_remotes: thread names that are stopped
            deadlock_remotes: thread names that cause deadlock
            log_msg: log message for the smart_resume
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.resumers = get_set(resumers)
        self.exp_resumers = get_set(exp_resumers)

        self.stopped_remotes = get_set(stopped_remotes)

        self.deadlock_remotes = get_set(deadlock_remotes)

        self.resumer_count = resumer_count

        self.log_msg = log_msg

        self.arg_list += [
            "resumers",
            "exp_resumers",
            "resumer_count",
            "stopped_remotes",
            "deadlock_remotes",
        ]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_wait(
            cmd_runner=cmd_runner,
            resumers=self.resumers,
            exp_resumers=self.exp_resumers,
            timeout=0,
            timeout_remotes=set(),
            stopped_remotes=self.stopped_remotes,
            deadlock_remotes=self.deadlock_remotes,
            deadlock_or_timeout=False,
            timeout_type=TimeoutType.TimeoutNone,
            resumer_count=self.resumer_count,
            log_msg=self.log_msg,
        )


########################################################################
# WaitTimeoutFalse
########################################################################
class WaitTimeoutFalse(Wait):
    """Do smart_wait with timeout false."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        resumers: Iterable[str],
        exp_resumers: Iterable[str],
        timeout: IntOrFloat,
        resumer_count: Optional[int] = None,
        stopped_remotes: Optional[Iterable[str]] = None,
        deadlock_remotes: Optional[Iterable[str]] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            resumers: thread names that will do the smart_resume
            exp_resumers: thread names that the wait is expected to be
                resumed by
            timeout: value for smart_wait
            resumer_count: specification for smart_wait for how many
                resumes are needed to satisfy the smart_wait
            stopped_remotes: thread names that are stopped
            deadlock_remotes: thread names that are deadlocked
            log_msg: log message for smart_wait
        """
        super().__init__(
            cmd_runners=cmd_runners,
            resumers=resumers,
            exp_resumers=exp_resumers,
            stopped_remotes=stopped_remotes,
            resumer_count=resumer_count,
            deadlock_remotes=deadlock_remotes,
            log_msg=log_msg,
        )
        self.specified_args = locals()  # used for __repr__

        self.timeout = timeout

        self.arg_list += ["timeout"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_wait(
            cmd_runner=cmd_runner,
            resumers=self.resumers,
            exp_resumers=self.exp_resumers,
            timeout=self.timeout,
            timeout_remotes=set(),
            stopped_remotes=self.stopped_remotes,
            deadlock_remotes=self.deadlock_remotes,
            deadlock_or_timeout=False,
            timeout_type=TimeoutType.TimeoutFalse,
            resumer_count=self.resumer_count,
            log_msg=self.log_msg,
        )


########################################################################
# WaitTimeoutTrue
########################################################################
class WaitTimeoutTrue(WaitTimeoutFalse):
    """Do smart_wait with timeout true."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        resumers: Iterable[str],
        exp_resumers: Iterable[str],
        timeout: IntOrFloat,
        timeout_remotes: Iterable[str],
        resumer_count: Optional[int] = None,
        stopped_remotes: Optional[Iterable[str]] = None,
        deadlock_remotes: Optional[Iterable[str]] = None,
        deadlock_or_timeout: bool = False,
        log_msg: Optional[str] = None,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            resumers: thread names that will do the smart_resume
            exp_resumers: thread names that the wait is expected to be
                resumed by
            timeout: value for smart_wait
            timeout_remotes: thread names that cause a timeout
            resumer_count: specification for smart_wait for how many
                resumes are needed to satisfy the smart_wait
            stopped_remotes: thread names that are stopped
            deadlock_remotes: thread names that are deadlocked
            deadlock_or_timeout: expect either deadlock or timeout
            log_msg: log message for smart_wait
        """
        super().__init__(
            cmd_runners=cmd_runners,
            resumers=resumers,
            exp_resumers=exp_resumers,
            stopped_remotes=stopped_remotes,
            resumer_count=resumer_count,
            deadlock_remotes=deadlock_remotes,
            timeout=timeout,
            log_msg=log_msg,
        )
        self.specified_args = locals()  # used for __repr__

        self.timeout_remotes = get_set(timeout_remotes)

        self.deadlock_or_timeout = deadlock_or_timeout

        self.arg_list += ["timeout_remotes"]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_wait(
            cmd_runner=cmd_runner,
            resumers=self.resumers,
            exp_resumers=self.exp_resumers,
            timeout=self.timeout,
            timeout_remotes=self.timeout_remotes,
            stopped_remotes=self.stopped_remotes,
            deadlock_remotes=self.deadlock_remotes,
            deadlock_or_timeout=self.deadlock_or_timeout,
            timeout_type=TimeoutType.TimeoutTrue,
            resumer_count=self.resumer_count,
            log_msg=self.log_msg,
        )


########################################################################
# WaitForCondition
########################################################################
class WaitForCondition(ConfigCmd):
    """Wait for receive message timeouts."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        check_rtn: Callable[..., bool],
        check_args: Any,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            check_rtn: routine that will do the check
            check_args: the arguments for the check_rtn

        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__
        self.check_rtn = check_rtn
        self.check_args = check_args

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        start_time = time.time()
        while not self.check_rtn(cmd_runner=cmd_runner, check_args=self.check_args):
            time.sleep(0.1)
            if start_time + 30 < time.time():
                raise CmdTimedOut("WaitForCondition timed out")


########################################################################
# WaitForRecvTimeouts
########################################################################
class WaitForRecvTimeouts(ConfigCmd):
    """Wait for receive message timeouts."""

    def __init__(self, cmd_runners: Iterable[str]) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command

        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.wait_for_recv_msg_timeouts(cmd_runner=cmd_runner)


########################################################################
# WaitForRequestTimeouts
########################################################################
class WaitForRequestTimeouts(ConfigCmd):
    """Wait for request timeouts command."""

    def __init__(
        self,
        cmd_runners: Iterable[str],
        actor_names: Iterable[str],
        timeout_names: Iterable[str],
        use_work_remotes: bool = False,
        as_subset: bool = False,
    ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            actor_names: thread names that are cmd runners waiting for a
                timeout or timeout condition
            timeout_names: thread names that are expected to cause
                timeout by not responding or by not being alive
            use_work_remotes: if True, compare against work_remotes,
                else pk_remotes
            as_subset: if True, the wait is satisfied when the
                timeout_names are a subset of the pk_remotes
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.actor_names = get_set(actor_names)

        self.timeout_names = get_set(timeout_names)

        self.use_work_remotes = use_work_remotes

        self.as_subset = as_subset

        self.arg_list += [
            "actor_names",
            "timeout_names",
            "use_work_remotes",
            "as_subset",
        ]

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.wait_for_request_timeouts(
            cmd_runner=cmd_runner,
            actor_names=self.actor_names,
            timeout_names=self.timeout_names,
            use_work_remotes=self.use_work_remotes,
            as_subset=self.as_subset,
        )


########################################################################
# F1CreateItem
########################################################################
@dataclass
class F1CreateItem:
    """Class that has infor for f1 create."""

    name: str
    auto_start: bool
    target_rtn: Callable[..., Any]
    app_config: AppConfig = AppConfig.ScriptStyle


########################################################################
# TestSmartThreadLogMsgs class
########################################################################
@dataclass
class ThreadTracker:
    """Class that tracks each thread."""

    thread: st.SmartThread
    is_alive: bool
    exiting: bool
    is_auto_started: bool
    is_TargetThread: bool
    exp_init_is_alive: bool
    thread_create: st.ThreadCreate
    exp_init_thread_state: st.ThreadState
    auto_start_decision: AutoStartDecision
    st_state: st.ThreadState
    found_del_pairs: dict[tuple[str, str, str], int]
    stopped_by: str = ""
    reg_to_unreg: bool = False
    stopped_to_unreg: bool = False


@dataclass
class ThreadPairStatus:
    """Class that keeps pair status."""

    reset_ops_count: bool
    pending_request: bool = False
    pending_msg_count: int = 0
    pending_wait: bool = False
    pending_wait_count: int = 0
    pending_sync: bool = False


@dataclass
class MonitorAddItem:
    """Class keeps track of threads to add, start, delete, unreg."""

    cmd_runner: str
    thread_alive: bool
    auto_start: bool
    is_ThreadTarget: bool
    expected_state: st.ThreadState


@dataclass
class UpaItem:
    """Update pair_array item."""

    upa_cmd_runner: str
    upa_type: str
    upa_target: str
    upa_def_del_name: str
    upa_process: str


@dataclass
class MonitorEventItem:
    """Class keeps track of threads to add, start, delete, unreg."""

    client_event: threading.Event
    targets: set[str]
    deferred_post_needed: bool = False


hour_match = "([01][0-9]|20|21|22|23)"
min_sec_match = "[0-5][0-9]"
micro_sec_match = "[0-9]{6,6}"
time_match = rf"{hour_match}:{min_sec_match}:{min_sec_match}\." f"{micro_sec_match}"

list_of_thread_states = (
    "(ThreadState.Unregistered"
    "|ThreadState.Initialized"
    "|ThreadState.Registered"
    "|ThreadState.Alive"
    "|ThreadState.Stopped)"
)

list_of_smart_requests = (
    "(smart_init"
    "|smart_start"
    "|smart_unreg"
    "|smart_join"
    "|smart_send"
    "|smart_recv"
    "|smart_wait"
    "|smart_resume"
    "|smart_sync)"
)

list_of_sub_processes = (
    "(_register" "|_clean_registry" "|_clean_pair_array" "|_add_to_pair_array)"
)

smart_reqs = ("smart_send", "smart_recv", "smart_wait", "smart_resume", "smart_sync")


########################################################################
# LogSearchItem
########################################################################
class LogSearchItem(ABC):
    """Input to search log msgs."""

    def __init__(
        self,
        search_str: str,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            search_str: regex style search string
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        self.search_pattern = re.compile(search_str)
        self.config_ver: "ConfigVerifier" = config_ver
        self.found_log_msg = found_log_msg
        self.found_log_idx = found_log_idx

    @abstractmethod
    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "LogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            LogFoundItem containing found message and index
        """
        pass

    @abstractmethod
    def run_process(self) -> None:
        """Run the process to handle the log message."""
        pass


########################################################################
# RequestEntryExitLogSearchItem
########################################################################
class RequestEntryExitLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(
                f"{list_of_smart_requests} (entry|exit): "
                r"requestor: [a-z0-9_]+ \([a-z0-9_]+\), "
                r"targets: \[([a-z0-9_]*|,|'| )*\]"
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "RequestEntryExitLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return RequestEntryExitLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        request_name = split_msg[0]
        entry_exit = split_msg[1][0:-1]  # remove colon
        cmd_runner = split_msg[3]
        target_msg = self.found_log_msg.split("[")[1].split("]")[0].split(", ")

        targets: list[str] = []
        for item in target_msg:
            targets.append(item[1:-1])

        if not targets:
            targets = [""]

        self.config_ver.handle_request_entry_exit_log_msg(
            cmd_runner=cmd_runner,
            request_name=request_name,
            entry_exit=entry_exit,
            targets=targets,
            log_msg=self.found_log_msg,
        )


########################################################################
# SetupCompleteLogSearchItem
########################################################################
class SetupCompleteLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(
                rf"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) {list_of_smart_requests} "
                "setup complete for targets: "
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "SetupCompleteLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return SetupCompleteLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[1]
        request_name = split_msg[3]
        target_msg = self.found_log_msg.split("[")[1].split("]")[0].split(", ")

        targets: list[str] = []
        for item in target_msg:
            if item.startswith("remote="):
                target = item[8:-1]
                targets.append(target)

        if request_name in (
            "smart_send",
            "smart_recv",
            "smart_wait",
            "smart_resume",
            "smart_sync",
        ):
            self.config_ver.set_request_pending_flag(
                cmd_runner=cmd_runner, targets=set(targets), pending_request_flag=True
            )

        self.config_ver.add_log_msg(re.escape(self.found_log_msg))


########################################################################
# SubProcessEntryExitLogSearchItem
########################################################################
class SubProcessEntryExitLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(
                f"{list_of_smart_requests} {list_of_sub_processes} "
                "(entry|exit): "
                r"[a-z0-9_]+ \([a-z0-9_]+\)(, target: [a-z0-9_]+)*"
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "SubProcessEntryExitLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return SubProcessEntryExitLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        request_name = split_msg[0]
        subprocess_name = split_msg[1]
        entry_exit = split_msg[2][0:-1]  # remove trailing colon
        cmd_runner = split_msg[3]
        # if split_msg[-2] == "target:":
        #     cmd_runner = cmd_runner[0:-1]  # remove trailing comma
        if split_msg[-2] == "target:":
            target = split_msg[-1]
        else:
            target = split_msg[-2]

        if subprocess_name == "_clean_registry":
            self.config_ver.last_clean_reg_msg_idx = self.found_log_idx

        self.config_ver.handle_subprocess_entry_exit_log_msg(
            cmd_runner=cmd_runner,
            request_name=request_name,
            subprocess_name=subprocess_name,
            entry_exit=entry_exit,
            target=target,
            log_msg=self.found_log_msg,
        )


########################################################################
# SetStateLogSearchItem
########################################################################
class SetStateLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(
                r"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) set state for thread "
                "[a-z0-9_]+ from "
                f"{list_of_thread_states} to {list_of_thread_states}"
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "SetStateLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SetStateLogSearchItem containing found message and index
        """
        return SetStateLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[1]
        target_name = split_msg[7]
        from_state_str = split_msg[9]
        to_state_str = split_msg[11]

        from_state = eval("st." + from_state_str)
        to_state = eval("st." + to_state_str)

        self.config_ver.handle_set_state_log_msg(
            cmd_runner=cmd_runner,
            target=target_name,
            from_state=from_state,
            to_state=to_state,
            log_msg=self.found_log_msg,
        )


########################################################################
# InitCompleteLogSearchItem
########################################################################
class InitCompleteLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        list_of_thread_creates = (
            "(ThreadCreate.Current" "|ThreadCreate.Target" "|ThreadCreate.Thread)"
        )

        list_of_auto_start_texts = (
            "(auto_start obviated"
            "|auto_start will proceed"
            "|auto_start not requested)"
        )
        super().__init__(
            search_str=(
                r"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) completed initialization "
                "of [a-z0-9_]+: "
                f"{list_of_thread_creates}, "
                f"{list_of_thread_states}, "
                f"{list_of_auto_start_texts}."
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "InitCompleteLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            InitCompleteLogSearchItem containing found message and index
        """
        return InitCompleteLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[1]
        target_name = split_msg[6][0:-1]
        create_text = split_msg[7][0:-1]
        state_text = split_msg[8][0:-1]

        thread_create = eval("st." + create_text)
        thread_state = eval("st." + state_text)

        if (
            init_complete_text_units[AutoStartDecision.auto_start_obviated]
            in self.found_log_msg
        ):
            auto_start = AutoStartDecision.auto_start_obviated
        elif (
            init_complete_text_units[AutoStartDecision.auto_start_yes]
            in self.found_log_msg
        ):
            auto_start = AutoStartDecision.auto_start_yes
        elif (
            init_complete_text_units[AutoStartDecision.auto_start_no]
            in self.found_log_msg
        ):
            auto_start = AutoStartDecision.auto_start_no
        else:
            raise InvalidInputDetected(
                "InitCompleteLogSearchItem encountered log msg with "
                f"unknown auto_start text: {self.found_log_msg}"
            )

        pe = self.config_ver.pending_events[cmd_runner]

        comp_key: InitCompKey = (target_name, thread_create, thread_state, auto_start)

        if pe[PE.init_comp_msg][comp_key] <= 0:
            raise UnexpectedEvent(
                f"InitCompleteLogSearchItem using {comp_key=} encountered "
                f"unexpected log message: {self.found_log_msg}"
            )

        pe[PE.init_comp_msg][comp_key] -= 1

        self.config_ver.add_log_msg(
            re.escape(self.found_log_msg), log_level=logging.INFO
        )


########################################################################
# F1AppExitLogSearchItem
########################################################################
class F1AppExitLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        list_of_thread_apps = r"(OuterF1ThreadApp.run\(\)" "|outer_f1)"
        super().__init__(
            # search_str=r'OuterF1ThreadApp.run\(\) exit: [a-z0-9_]+',
            search_str=f"{list_of_thread_apps} exit: [a-z0-9_]+",
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "F1AppExitLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            F1AppExitLogSearchItem containing found message and index
        """
        return F1AppExitLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        target = split_msg[2]

        self.config_ver.expected_registered[target].is_alive = False

        self.config_ver.last_thread_stop_msg_idx[target] = self.found_log_idx


########################################################################
# AlreadyUnregLogSearchItem
########################################################################
class AlreadyUnregLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(
                r"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) determined that thread "
                "[a-z0-9_]+ is already in state ThreadState.Unregistered"
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "AlreadyUnregLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            AlreadyUnregLogSearchItem containing found message and index
        """
        return AlreadyUnregLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[1]
        target = split_msg[6]

        pe = self.config_ver.pending_events[cmd_runner]
        unreg_key: AlreadyUnregKey = (cmd_runner, target)
        if pe[PE.already_unreg_msg][unreg_key] <= 0:
            raise UnexpectedEvent(
                f"AlreadyUnregLogSearchItem using {unreg_key=} encountered "
                f"unexpected log message: {self.found_log_msg}"
            )

        pe[PE.already_unreg_msg][unreg_key] -= 1

        self.config_ver.add_log_msg(re.escape(self.found_log_msg))


########################################################################
# AddRegEntryLogSearchItem
########################################################################
class AddRegEntryLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(
                r"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) added [a-z0-9_]+ to "
                f"SmartThread registry at UTC {time_match}"
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "AddRegEntryLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            AddRegEntryLogSearchItem containing found message and index
        """
        return AddRegEntryLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        self.config_ver.handle_add_reg_log_msg(
            cmd_runner=split_msg[1], target=split_msg[4], log_msg=self.found_log_msg
        )


########################################################################
# AddPairArrayEntryLogSearchItem
########################################################################
class AddPairArrayEntryLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(
                r"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) added "
                r"PairKey\(name0='[a-z0-9_]+', name1='[a-z0-9_]+'\) "
                "to the pair_array"
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "AddPairArrayEntryLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            AddPairArrayEntryLogSearchItem containing found message and
                index
        """
        return AddPairArrayEntryLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[1]
        name_0 = split_msg[4][15:-2]  # lose left paren, comma, quotes
        name_1 = split_msg[5][7:-2]  # lose right paren, quotes
        pair_key: st.PairKey = st.PairKey(name_0, name_1)
        self.config_ver.handle_add_pair_array_log_msg(
            cmd_runner=cmd_runner, pair_key=pair_key, log_msg=self.found_log_msg
        )


########################################################################
# AddStatusBlockEntryLogSearchItem
########################################################################
class AddStatusBlockEntryLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(
                r"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) added status_blocks entry for "
                r"PairKey\(name0='[a-z0-9_]+', name1='[a-z0-9_]+'\), "
                "name = [a-z0-9_]+"
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "AddStatusBlockEntryLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            AddStatusBlockEntryLogSearchItem containing found message
                and index
        """
        return AddStatusBlockEntryLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[1]
        name_0 = split_msg[7][15:-2]  # lose left paren, comma, quotes
        name_1 = split_msg[8][7:-3]  # lose right paren, quotes
        target = split_msg[11]
        pair_key: st.PairKey = st.PairKey(name_0, name_1)
        self.config_ver.handle_add_status_block_log_msg(
            cmd_runner=cmd_runner,
            pair_key=pair_key,
            target=target,
            log_msg=self.found_log_msg,
        )


########################################################################
# UpdatePairArrayUtcLogSearchItem
########################################################################
class UpdatePairArrayUtcLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=r"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) updated _pair_array at "
            f"UTC {time_match}",
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "UpdatePairArrayUtcLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            UpdatePairArrayUtcLogSearchItem containing found message
                and index
        """
        return UpdatePairArrayUtcLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        cmd_runner = self.found_log_msg.split()[1]

        pe = self.config_ver.pending_events[cmd_runner]
        if pe[PE.update_pair_array_utc_msg] <= 0:
            raise UnexpectedEvent(
                "UpdatePairArrayUtcLogSearchItem encountered unexpected "
                f"log message: {self.found_log_msg}"
            )

        pe[PE.update_pair_array_utc_msg] -= 1
        self.config_ver.log_test_msg(
            f"UpdatePairArrayUtcLogSearchItem for {cmd_runner=} "
            f"decremented {pe[PE.update_pair_array_utc_msg]=}"
        )

        self.config_ver.add_log_msg(re.escape(self.found_log_msg))


########################################################################
# RegistryStatusLogSearchItem
########################################################################
class RegistryStatusLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(
                "name=[a-z0-9_]+, is_alive=(True|False), "
                f"state={list_of_thread_states}, smart_thread="
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "RegistryStatusLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            RegistryStatusLogSearchItem containing found message and
                index
        """
        return RegistryStatusLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        target = split_msg[0][5:-1]
        is_alive = eval(split_msg[1][9:-1])
        state = eval("st." + split_msg[2][6:-1])

        if (
            self.config_ver.pending_events[target][PE.status_msg][(is_alive, state)]
            <= 0
        ):
            if not is_alive and (
                self.config_ver.last_clean_reg_msg_idx
                < self.config_ver.last_thread_stop_msg_idx[target]
            ):
                if (
                    self.config_ver.pending_events[target][PE.status_msg][
                        (True, st.ThreadState.Alive)
                    ]
                    <= 0
                ):
                    raise UnexpectedEvent(
                        f"RegistryStatusLogSearchItem 1 using "
                        f"{(True, st.ThreadState.Alive)} encountered "
                        f"unexpected log message: {self.found_log_msg}"
                    )
                else:
                    self.config_ver.pending_events[target][PE.status_msg][
                        (True, st.ThreadState.Alive)
                    ] -= 1
            else:
                raise UnexpectedEvent(
                    f"RegistryStatusLogSearchItem 2 using {(is_alive, state)} "
                    f"encountered unexpected log message: "
                    f"{self.found_log_msg}"
                )

        else:
            self.config_ver.pending_events[target][PE.status_msg][
                (is_alive, state)
            ] -= 1

        self.config_ver.add_log_msg(re.escape(self.found_log_msg))


########################################################################
# RemRegEntryLogSearchItem
########################################################################
class RemRegEntryLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(
                r"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) removed [a-z0-9_]+ from "
                f"registry for request: {list_of_smart_requests}"
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "RemRegEntryLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            RemRegEntryLogSearchItem containing found message and index
        """
        return RemRegEntryLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[1]
        rem_name = split_msg[4]
        process = split_msg[9]

        self.config_ver.handle_rem_reg_log_msg(
            cmd_runner=cmd_runner,
            rem_name=rem_name,
            process=process,
            log_msg=self.found_log_msg,
        )


########################################################################
# DidCleanRegLogSearchItem
########################################################################
class DidCleanRegLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(
                r"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) did cleanup of registry at "
                rf"UTC {time_match}, deleted \[('[a-z0-9_]+'|, )+\]"
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "DidCleanRegLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            DidCleanRegLogSearchItem containing found message and index
        """
        return DidCleanRegLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[1]
        target_msg = self.found_log_msg.split("[")[1].split("]")[0].split(", ")

        targets: list[str] = []
        for item in target_msg:
            targets.append(item[1:-1])

        self.config_ver.handle_did_clean_reg_log_msg(
            cmd_runner=cmd_runner, targets=targets, log_msg=self.found_log_msg
        )


########################################################################
# RemStatusBlockEntryLogSearchItem
########################################################################
class RemStatusBlockEntryLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        list_of_extras = (
            "(, with non-empty msg_q"
            "|, with wait event set"
            "|, with sync event set)*"
        )
        super().__init__(
            search_str=(
                r"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) removed status_blocks entry "
                r"for PairKey\(name0='[a-z0-9_]+', name1='[a-z0-9_]+'\), "
                f"name = [a-z0-9_]+{list_of_extras}"
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "RemStatusBlockEntryLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return RemStatusBlockEntryLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[1]
        name_0 = split_msg[7][15:-2]  # lose left paren, comma, quotes
        name_1 = split_msg[8][7:-3]  # lose right paren, quotes
        rem_name = split_msg[11]

        pair_key: st.PairKey = st.PairKey(name_0, name_1)

        pending_msg = pending_wait = pending_sync = False
        if ", with non-empty msg_q" in self.found_log_msg:
            pending_msg = True
        if ", with wait event set" in self.found_log_msg:
            pending_wait = True
        if ", with sync event set" in self.found_log_msg:
            pending_sync = True

        if pending_msg or pending_wait or pending_sync:
            rem_name = rem_name[0:-1]

        pe = self.config_ver.pending_events[cmd_runner]

        def_del_reasons: DefDelReasons = DefDelReasons(
            pending_request=False,
            pending_msg=pending_msg,
            pending_wait=pending_wait,
            pending_sync=pending_sync,
        )

        rem_sb_key: RemSbKey = (rem_name, pair_key, def_del_reasons)
        # self.config_ver.log_test_msg(
        #     'RemStatusBlockEntryLogSearchItem about to check '
        #     f'{pe[PE.rem_status_block_msg][rem_sb_key]=} for '
        #     f'{cmd_runner=}, {rem_sb_key=}'
        # )
        if pe[PE.rem_status_block_msg][rem_sb_key] <= 0:
            self.config_ver.log_test_msg(
                f"RemStatusBlockEntryLogSearchItem using {rem_sb_key=} "
                "encountered unexpected "
                f"log msg: {self.found_log_msg}, {pe[PE.rem_status_block_msg]=}"
            )
            raise UnexpectedEvent(
                f"RemStatusBlockEntryLogSearchItem using {rem_sb_key=} "
                f"encountered unexpected log msg: {self.found_log_msg}"
            )

        pe[PE.rem_status_block_msg][rem_sb_key] -= 1

        if pe[PE.notify_rem_status_block_msg][rem_sb_key] > 0:
            pe[PE.notify_rem_status_block_msg][rem_sb_key] -= 1

        self.config_ver.add_log_msg(
            re.escape(self.found_log_msg), log_level=logging.DEBUG
        )


########################################################################
# RemStatusBlockEntryDefLogSearchItem
########################################################################
class RemStatusBlockEntryDefLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(
                r"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) removal deferred for "
                r"status_blocks entry for PairKey\(name0='[a-z0-9_]+', "
                r"name1='[a-z0-9_]+'\), name = [a-z0-9_]+, reasons: "
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "RemStatusBlockEntryDefLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return RemStatusBlockEntryDefLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[1]
        name_0 = split_msg[9][15:-2]  # lose left paren, comma, quotes
        name_1 = split_msg[10][7:-3]  # lose right paren, quotes
        rem_name = split_msg[13][0:-1]

        pair_key: st.PairKey = st.PairKey(name_0, name_1)

        pending_request = pending_msg = pending_wait = pending_sync = False
        idx = -1
        while split_msg[idx] != "reasons:":
            if split_msg[idx] in ("set", "set,"):
                if split_msg[idx - 2] == "sync":
                    pending_sync = True
                    idx -= 3
                elif split_msg[idx - 2] == "wait":
                    pending_wait = True
                    idx -= 3
            elif split_msg[idx] in ("msg_q", "msg_q,"):
                pending_msg = True
                idx -= 2
            elif split_msg[idx] in ("request", "request,"):
                pending_request = True
                idx -= 2

        pe = self.config_ver.pending_events[cmd_runner]
        def_del_reasons: DefDelReasons = DefDelReasons(
            pending_request=pending_request,
            pending_msg=pending_msg,
            pending_wait=pending_wait,
            pending_sync=pending_sync,
        )

        rem_sb_key: RemSbKey = (rem_name, pair_key, def_del_reasons)

        if pe[PE.rem_status_block_def_msg][rem_sb_key] <= 0:
            raise UnexpectedEvent(
                f"RemStatusBlockEntryDefLogSearchItem using {rem_sb_key=} "
                f"encountered unexpected log msg: {self.found_log_msg}"
            )

        pe[PE.rem_status_block_def_msg][rem_sb_key] -= 1

        if pe[PE.notify_rem_status_block_def_msg][rem_sb_key] > 0:
            pe[PE.notify_rem_status_block_def_msg][rem_sb_key] -= 1

        self.config_ver.add_log_msg(
            re.escape(self.found_log_msg), log_level=logging.DEBUG
        )


########################################################################
# RemPairArrayEntryLogSearchItem
########################################################################
class RemPairArrayEntryLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(
                r"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) removed _pair_array entry "
                r"for PairKey\(name0='[a-z0-9_]+', name1='[a-z0-9_]+'\)"
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "RemPairArrayEntryLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            RemPairArrayEntryLogSearchItem containing found message
                and index
        """
        return RemPairArrayEntryLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[1]
        name_0 = split_msg[7][15:-2]  # lose left paren, comma, quotes
        name_1 = split_msg[8][7:-2]  # lose right paren, quotes
        pair_key: st.PairKey = st.PairKey(name_0, name_1)

        pe = self.config_ver.pending_events[cmd_runner]
        rem_pae_key: RemPaeKey = (cmd_runner, pair_key)

        if pe[PE.rem_pair_array_entry_msg][rem_pae_key] <= 0:
            raise UnexpectedEvent(
                f"RemPairArrayEntryLogSearchItem using {rem_pae_key=}"
                "encountered unexpected "
                f"log message: {self.found_log_msg}"
            )

        pe[PE.rem_pair_array_entry_msg][rem_pae_key] -= 1

        self.config_ver.add_log_msg(re.escape(self.found_log_msg))


########################################################################
# DidCleanPairArrayUtcLogSearchItem
########################################################################
class DidCleanPairArrayUtcLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(
                r"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) did cleanup of _pair_array at "
                f"UTC {time_match}"
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "DidCleanPairArrayUtcLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            DidCleanPairArrayUtcLogSearchItem containing found message
                and index
        """
        return DidCleanPairArrayUtcLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        cmd_runner = self.found_log_msg.split()[1]

        pe = self.config_ver.pending_events[cmd_runner]
        if pe[PE.did_cleanup_pair_array_utc_msg] <= 0:
            raise UnexpectedEvent(
                "DidCleanPairArrayUtcLogSearchItem encountered unexpected "
                f"log message: {self.found_log_msg}"
            )

        pe[PE.did_cleanup_pair_array_utc_msg] -= 1

        self.config_ver.add_log_msg(re.escape(self.found_log_msg))


########################################################################
# RequestAckLogSearchItem
########################################################################
class RequestAckLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        list_of_acks = (
            "(smart_send sent message to"
            "|smart_recv received [0-9]+ msg[s]* from"
            "|smart_wait resumed by"
            "|smart_resume resumed"
            "|smart_sync set flag for"
            "|smart_sync backout reset local sync_flag for"
            "|smart_sync backout reset remote sync_flag for"
            "|smart_sync achieved with)"
        )
        super().__init__(
            search_str=(
                rf"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) {list_of_acks} [a-z0-9_]+"
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "RequestAckLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return RequestAckLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[1]
        request = split_msg[3]
        action = split_msg[4]
        remote = split_msg[-1]

        pe = self.config_ver.pending_events[cmd_runner]

        ack_key: AckKey = (remote, request)

        if request == "smart_send":
            self.config_ver.set_msg_pending_count(
                receiver=remote, sender=cmd_runner, pending_msg_adj=1
            )
        elif request == "smart_recv":
            self.config_ver.set_msg_pending_count(
                receiver=cmd_runner, sender=remote, pending_msg_adj=0
            )
        elif request == "smart_wait":
            self.config_ver.set_wait_pending_flag(
                waiter=cmd_runner, resumer=remote, pending_wait_flag=False
            )
        elif request == "smart_resume":
            self.config_ver.set_wait_pending_flag(
                waiter=remote, resumer=cmd_runner, pending_wait_flag=True
            )
        elif request == "smart_sync":
            if action == "set":
                ack_key = (remote, "smart_sync_set")
                self.config_ver.set_sync_pending_flag(
                    waiter=remote, resumer=cmd_runner, pending_sync_flag=True
                )
            elif action == "achieved":
                if self.config_ver.auto_sync_ach_or_back_msg:
                    ack_key = (remote, "smart_sync_ach_or_back")
                else:
                    ack_key = (remote, "smart_sync_achieved")
                self.config_ver.set_sync_pending_flag(
                    waiter=cmd_runner, resumer=remote, pending_sync_flag=False
                )
            elif action == "backout":
                if split_msg[6] == "local":
                    if self.config_ver.auto_sync_ach_or_back_msg:
                        ack_key = (remote, "smart_sync_ach_or_back")
                    else:
                        ack_key = (remote, "smart_sync_backout_local")
                    self.config_ver.set_sync_pending_flag(
                        waiter=cmd_runner, resumer=remote, pending_sync_flag=False
                    )
                else:
                    if self.config_ver.auto_sync_ach_or_back_msg:
                        ack_key = (remote, "smart_sync_ach_or_back")
                    else:
                        ack_key = (remote, "smart_sync_backout_remote")
                    self.config_ver.set_sync_pending_flag(
                        waiter=remote, resumer=cmd_runner, pending_sync_flag=False
                    )

        if not (request == "smart_sync" and action == "set"):
            self.config_ver.set_request_pending_flag(
                cmd_runner=cmd_runner, targets={remote}, pending_request_flag=False
            )

        if pe[PE.ack_msg][ack_key] <= 0:
            raise UnexpectedEvent(
                f"RequestAckLogSearchItem using {ack_key=} detected "
                f"unexpected log msg: {self.found_log_msg}"
            )

        pe[PE.ack_msg][ack_key] -= 1

        self.config_ver.add_log_msg(
            re.escape(self.found_log_msg), log_level=logging.INFO
        )


########################################################################
# DetectedStoppedRemoteLogSearchItem
########################################################################
class DetectedStoppedRemoteLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(
                rf"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) {list_of_smart_requests} "
                "detected remote [a-z0-9_]+ is stopped"
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "DetectedStoppedRemoteLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return DetectedStoppedRemoteLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[1]
        remote = split_msg[6]

        self.config_ver.set_request_pending_flag(
            cmd_runner=cmd_runner, targets={remote}, pending_request_flag=False
        )

        self.config_ver.add_log_msg(
            re.escape(self.found_log_msg), log_level=logging.DEBUG
        )


########################################################################
# RequestRefreshLogSearchItem
########################################################################
class RequestRefreshLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(
                rf"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) {list_of_smart_requests} "
                r"calling refresh, remaining remotes: \["
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "RequestRefreshLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return RequestRefreshLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[1]
        request = split_msg[3]
        target_msg = self.found_log_msg.split("[")[1].split("]")[0]

        targets: set[str] = set()
        if target_msg:
            split_targets = target_msg.split()
            for idx in range(0, len(split_targets), 4):
                remote = split_targets[idx + 2][8:-2]
                targets |= {remote}

        self.config_ver.handle_request_refresh_log_msg(
            cmd_runner=cmd_runner,
            request=request,
            targets=targets,
            log_msg=self.found_log_msg,
        )

        self.config_ver.add_log_msg(
            re.escape(self.found_log_msg), log_level=logging.DEBUG
        )


########################################################################
# UnregJoinSuccessLogSearchItem
########################################################################
class UnregJoinSuccessLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(
                r"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) did successful "
                r"(smart_unreg|smart_join) of \[([a-z0-9_]*|,|'| )*\]"
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "UnregJoinSuccessLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return UnregJoinSuccessLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[1]
        request = split_msg[5]
        target_msg = self.found_log_msg.split("[")[1].split("]")[0].split(", ")

        targets: list[str] = []
        for item in target_msg:
            targets.append(item[1:-1])

        pe = self.config_ver.pending_events[cmd_runner]

        uj_key: UnregJoinSuccessKey = (request, targets[0])

        if pe[PE.unreg_join_success_msg][uj_key] <= 0:
            raise UnexpectedEvent(
                f"UnregJoinSuccessLogSearchItem using {uj_key=} detected "
                f"unexpected log msg: {self.found_log_msg}"
            )

        pe[PE.unreg_join_success_msg][uj_key] -= 1

        self.config_ver.add_log_msg(
            re.escape(self.found_log_msg), log_level=logging.INFO
        )


########################################################################
# JoinWaitingLogSearchItem
########################################################################
class JoinWaitingLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(
                r"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) smart_join "
                r"completed targets: \[('[a-z0-9_]+'|, )*\], "
                r"pending targets: \[('[a-z0-9_]+'|, )*\]"
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "JoinWaitingLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return JoinWaitingLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[1]
        left_bracket_split_msg = self.found_log_msg.split("[")
        comp_targ_msg = left_bracket_split_msg[1].split("]")[0].split(", ")

        comp_targets: list[str] = []
        for item in comp_targ_msg:
            comp_targets.append(item[1:-1])

        pend_targets: list[str] = []
        if left_bracket_split_msg[2] != "]":
            pend_targ_msg = left_bracket_split_msg[2].split("]")[0].split(", ")
            for item in pend_targ_msg:
                pend_targets.append(item[1:-1])

        pe = self.config_ver.pending_events[cmd_runner]

        prog_key: JoinProgKey = (len(comp_targets), len(pend_targets))

        if pe[PE.join_progress_msg][prog_key] <= 0:
            raise UnexpectedEvent(
                f"JoinWaitingLogSearchItem using {prog_key=} detected "
                f"unexpected log msg: {self.found_log_msg}"
            )

        pe[PE.join_progress_msg][prog_key] -= 1

        self.config_ver.add_log_msg(
            re.escape(self.found_log_msg), log_level=logging.INFO
        )


########################################################################
# StoppedLogSearchItem
########################################################################
class StoppedLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str="[a-z0-9_]+ has been stopped by [a-z0-9_]+",
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "StoppedLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            StoppedLogSearchItem containing found message and index
        """
        return StoppedLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()

        self.config_ver.handle_stopped_log_msg(
            cmd_runner=split_msg[5],
            stopped_name=split_msg[0],
            log_idx=self.found_log_idx,
        )


########################################################################
# CmdWaitingLogSearchItem
########################################################################
class CmdWaitingLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        list_of_waiting_methods = (
            "(create_commander_thread"
            "|create_f1_thread"
            "|handle_join"
            "|handle_recv"
            "|handle_recv_tof"
            "|handle_recv_tot"
            "|handle_resume"
            "|handle_start"
            "|handle_sync"
            "|handle_wait"
            "|handle_unregister)"
        )
        super().__init__(
            search_str=(
                f"cmd_runner='[a-z0-9_]+' {list_of_waiting_methods} "
                "waiting for monitor"
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "CmdWaitingLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            CmdWaitingLogSearchItem containing found message and index
        """
        return CmdWaitingLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[0].split(sep="=")[1]
        cmd_runner = cmd_runner[1:-1]

        self.config_ver.handle_cmd_waiting_log_msg(cmd_runner=cmd_runner)


########################################################################
# DebugLogSearchItem
########################################################################
class DebugLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str="TestDebug [a-z0-9_]+ ",
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "DebugLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return DebugLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        self.config_ver.add_log_msg(
            re.escape(self.found_log_msg), log_level=logging.DEBUG
        )


########################################################################
# CRunnerRaisesLogSearchItem
########################################################################
class CRunnerRaisesLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        list_of_errors = (
            "(SmartThreadRemoteThreadNotAlive"
            "|SmartThreadDeadlockDetected"
            "|SmartThreadRequestTimedOut"
            "|SmartThreadRemoteThreadNotRegistered)"
        )
        super().__init__(
            search_str=(
                rf"SmartThread [a-z0-9_]+ \([a-z0-9_]+\) raising {list_of_errors} "
                f"while processing a {list_of_smart_requests} request with "
                r"targets \[([a-z0-9_]*|,|'| )*\]"
            ),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "CRunnerRaisesLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return CRunnerRaisesLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[1]
        target_msg = self.found_log_msg.split("[")[1].split("]")[0].split(", ")

        targets: set[str] = set()
        for item in target_msg:
            targets |= {item[1:-1]}

        self.config_ver.set_request_pending_flag(
            cmd_runner=cmd_runner, targets=targets, pending_request_flag=False
        )

        pe = self.config_ver.pending_events[cmd_runner]
        pe[PE.current_request] = StartRequest(req_type=st.ReqType.NoReq)

        # self.config_ver.add_log_msg(re.escape(self.found_log_msg),
        #                             log_level=logging.ERROR)


########################################################################
# MonitorCheckpointLogSearchItem
########################################################################
class MonitorCheckpointLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(
        self,
        config_ver: "ConfigVerifier",
        found_log_msg: str = "",
        found_log_idx: int = 0,
    ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str="Monitor Checkpoint: [a-z_]+ [0-9]+",
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
        )

    def get_found_log_item(
        self, found_log_msg: str, found_log_idx: int
    ) -> "MonitorCheckpointLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return MonitorCheckpointLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver,
        )

    def run_process(self) -> None:
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        verify_name = split_msg[2]
        verify_idx = split_msg[3]

        call_stm = f"self.config_ver.{verify_name}(verify_idx={verify_idx})"

        eval(call_stm)

        if verify_name == "verify_config":
            self.config_ver.verify_config_complete_event.set()
        elif verify_name == "check_pending_events":
            self.config_ver.check_pending_events_complete_event.set()


LogSearchItems: TypeAlias = Union[
    RequestEntryExitLogSearchItem,
    SetupCompleteLogSearchItem,
    SubProcessEntryExitLogSearchItem,
    RegistryStatusLogSearchItem,
    AddPairArrayEntryLogSearchItem,
    AddStatusBlockEntryLogSearchItem,
    DidCleanPairArrayUtcLogSearchItem,
    UpdatePairArrayUtcLogSearchItem,
    AddRegEntryLogSearchItem,
    RemRegEntryLogSearchItem,
    RemPairArrayEntryLogSearchItem,
    DidCleanRegLogSearchItem,
    SetStateLogSearchItem,
    InitCompleteLogSearchItem,
    F1AppExitLogSearchItem,
    AlreadyUnregLogSearchItem,
    RequestAckLogSearchItem,
    DetectedStoppedRemoteLogSearchItem,
    RequestRefreshLogSearchItem,
    UnregJoinSuccessLogSearchItem,
    JoinWaitingLogSearchItem,
    StoppedLogSearchItem,
    CmdWaitingLogSearchItem,
    DebugLogSearchItem,
    RemStatusBlockEntryLogSearchItem,
    RemStatusBlockEntryDefLogSearchItem,
    CRunnerRaisesLogSearchItem,
    MonitorCheckpointLogSearchItem,
]


########################################################################
# MockGetTargetState
########################################################################
TargetsDict: TypeAlias = dict[str, dict[str, tuple[st.ThreadState, st.ThreadState]]]


class MockGetTargetState:
    """Tracks targets whose state is to be reported differently."""

    targets: ClassVar[TargetsDict] = {}
    config_ver: ClassVar["ConfigVerifier"]

    def __init__(self, targets: TargetsDict, config_ver: "ConfigVerifier") -> None:
        """Initialize the mock target_rtn state.

        Args:
            targets: dictionary of targets
            config_ver: instance of ConfigurationVerifier
        """
        MockGetTargetState.targets = targets
        MockGetTargetState.config_ver = config_ver

    ####################################################################
    # mock_get_target_state
    ####################################################################
    def mock_get_target_state(self, pk_remote: st.PairKeyRemote) -> st.ThreadState:
        """Get the status of thread that is the target_rtn of a request.

        Args:
            pk_remote: contains target_rtn thread info

        Returns:
            The thread status

        Notes:
            Must be called holding the registry lock either shared or
            exclusive
        """
        group_name: str = self.group_name  # type: ignore
        if pk_remote.remote not in self.registry:
            if pk_remote.create_time != 0.0:
                ret_state = st.ThreadState.Stopped
            else:
                ret_state = st.ThreadState.Unregistered

        else:
            if (
                not self.registry[pk_remote.remote].thread.is_alive()
                and self.registry[pk_remote.remote].st_state == st.ThreadState.Alive
            ):
                ret_state = st.ThreadState.Stopped

            elif (
                pk_remote.pair_key in self.pair_array
                and pk_remote.remote
                in self.pair_array[pk_remote.pair_key].status_blocks
                and self.pair_array[pk_remote.pair_key]
                .status_blocks[pk_remote.remote]
                .create_time
                != pk_remote.create_time
            ):
                ret_state = st.ThreadState.Stopped

            elif (
                not self.registry[pk_remote.remote].thread.is_alive()
                and self.registry[pk_remote.remote].st_state == st.ThreadState.Alive
            ):
                ret_state = st.ThreadState.Stopped

            else:
                ret_state = self.registry[pk_remote.remote].st_state

        name = self.name  # type: ignore
        if name in MockGetTargetState.targets:
            if pk_remote.remote in MockGetTargetState.targets[name]:
                if ret_state == MockGetTargetState.targets[name][pk_remote.remote][0]:
                    old_ret_state = ret_state
                    ret_state = MockGetTargetState.targets[name][pk_remote.remote][1]
                    MockGetTargetState.config_ver.log_test_msg(
                        f"mock {name} changed state for "
                        f"{pk_remote.remote=} "
                        f"from {old_ret_state=} to {ret_state=}"
                    )

        return ret_state


class MockCleanPairArray:
    """Tracks targets whose state is to be reported differently."""

    # targets: ClassVar[TargetsDict] = {}
    # config_ver: ClassVar["ConfigVerifier"]

    def __init__(self) -> None:
        """Initialize the mock target_rtn state."""
        pass

    ####################################################################
    # mock_clean_pair_arraye
    ####################################################################
    def mock_clean_pair_array(self) -> None:
        """Get status of a thread that is the target_rtn of a request.

        Notes:
            Must be called holding the registry lock either shared or
            exclusive
        """
        pass


@dataclass
class PaLogMsgsFound:
    """Pair array log message info."""

    entered_rpa: bool
    removed_sb_entry: list[st.PairKey]
    removed_pa_entry: list[st.PairKey]
    updated_pa: bool


@dataclass
class StartRequest:
    """StartRequest class used to track command progress."""

    targets: set[str] = field(default_factory=set)
    unreg_remotes: set[str] = field(default_factory=set)
    not_registered_remotes: set[str] = field(default_factory=set)
    timeout_remotes: set[str] = field(default_factory=set)
    stopped_remotes: set[str] = field(default_factory=set)
    deadlock_remotes: set[str] = field(default_factory=set)
    eligible_targets: set[str] = field(default_factory=set)
    completed_targets: set[str] = field(default_factory=set)
    first_round_completed: set[str] = field(default_factory=set)
    stopped_target_threads: set[str] = field(default_factory=set)
    sync_set_ack_remotes: set[str] = field(default_factory=set)
    exp_senders: set[str] = field(default_factory=set)
    exp_resumers: set[str] = field(default_factory=set)
    exp_receivers: set[str] = field(default_factory=set)
    exp_resumed_targets: set[str] = field(default_factory=set)
    timeout_type: TimeoutType = TimeoutType.TimeoutNone
    req_type: st.ReqType = st.ReqType.NoReq


@dataclass
class PendingEvent:
    """Pending event class."""

    start_request: deque[StartRequest]
    current_request: StartRequest
    num_targets_remaining: int
    request_msg: dict[RequestKey, int]
    subprocess_msg: dict[SubProcessKey, int]
    set_state_msg: dict[SetStateKey, int]
    status_msg: dict[tuple[bool, st.ThreadState], int]
    rem_reg_msg: dict[RemRegKey, int]
    did_clean_reg_msg: int
    update_pair_array_utc_msg: int
    did_cleanup_pair_array_utc_msg: int
    rem_reg_targets: deque[list[str]]
    add_reg_msg: dict[AddRegKey, int]
    add_pair_array_msg: dict[AddPaKey, int]
    add_status_block_msg: dict[AddStatusBlockKey, int]
    rem_status_block_msg: dict[RemSbKey, int]
    rem_status_block_def_msg: dict[RemSbKey, int]
    rem_pair_array_entry_msg: dict[RemPaeKey, int]
    notify_rem_status_block_msg: dict[RemSbKey, int]
    notify_rem_status_block_def_msg: dict[RemSbKey, int]
    ack_msg: dict[AckKey, int]


class PE(Enum):
    """PE class used for index into PendingEvent array."""

    start_request = auto()
    current_request = auto()
    save_current_request = auto()
    num_targets_remaining = auto()
    request_msg = auto()
    subprocess_msg = auto()
    set_state_msg = auto()
    status_msg = auto()
    rem_reg_msg = auto()
    did_clean_reg_msg = auto()
    update_pair_array_utc_msg = auto()
    did_cleanup_pair_array_utc_msg = auto()
    rem_reg_targets = auto()
    add_reg_msg = auto()
    add_pair_array_msg = auto()
    add_status_block_msg = auto()
    rem_status_block_msg = auto()
    rem_status_block_def_msg = auto()
    rem_pair_array_entry_msg = auto()
    notify_rem_status_block_msg = auto()
    notify_rem_status_block_def_msg = auto()
    ack_msg = auto()
    confirm_stop_msg = auto()
    already_unreg_msg = auto()
    unreg_join_success_msg = auto()
    join_progress_msg = auto()
    init_comp_msg = auto()
    calling_refresh_msg = auto()
    refresh_pending_needed = auto()


class ConfigVerifier:
    """Class that tracks and verifies the SmartThread configuration."""

    def __init__(
        self,
        group_name: str,
        commander_name: str,
        log_ver: LogVer,
        caplog_to_use: pytest.LogCaptureFixture,
        msgs: Msgs,
        max_msgs: int = 10,
    ) -> None:
        """Initialize the ConfigVerifier.

        Args:
            group_name: name of group for this ConfigVerifier
            commander_name: name of the thread running the commands
            log_ver: the log verifier to track and verify log msgs
            caplog_to_use: pytest fixture to capture log messages
            msgs: Msgs class instance used to communicate with threads
            max_msgs: max message for the SmartThread msg_q

        """
        self.specified_args = locals()  # used for __repr__, see below
        self.group_name = group_name
        self.commander_name = commander_name
        self.commander_thread_config_built = False

        self.monitor_thread = threading.Thread(target=self.monitor)
        self.monitor_exit = False
        self.monitor_bail = False

        self.cmd_suite: deque[ConfigCmd] = deque()
        self.cmd_serial_num: int = 0
        self.completed_cmds: dict[str, list[int]] = defaultdict(list)
        self.f1_process_cmds: dict[str, bool] = {}
        self.thread_names: list[str] = [
            "alpha",
            "beta",
            "charlie",
            "delta",
            "echo",
            "fox",
            "george",
            "henry",
            "ida",
            "jack",
            "king",
            "love",
            "mary",
            "nancy",
            "oscar",
            "peter",
            "queen",
            "roger",
            "sam",
            "tom",
            "uncle",
            "victor",
            "wanda",
            "xander",
        ]
        self.unregistered_names: set[str] = set(self.thread_names)
        self.registered_names: set[str] = set()
        self.active_names: set[str] = set()
        self.thread_target_names: set[str] = set()
        self.stopped_remotes: set[str] = set()
        self.expected_registered: dict[str, ThreadTracker] = {}
        # self.expected_pairs: dict[tuple[str, str],
        #                           dict[str, ThreadPairStatus]] = {}
        self.expected_pairs: dict[st.PairKey, dict[str, ThreadPairStatus]] = {}
        self.log_ver = log_ver
        self.caplog_to_use = caplog_to_use
        self.msgs = msgs
        self.ops_lock = threading.RLock()

        self.all_threads: dict[str, st.SmartThread] = {}

        self.max_msgs = max_msgs

        self.expected_num_recv_timeouts: int = 0

        self.stopped_event_items: dict[str, MonitorEventItem] = {}
        self.cmd_waiting_event_items: dict[str, threading.Event] = {}

        self.stopping_names: list[str] = []

        self.recently_stopped: dict[str, int] = defaultdict(int)

        self.log_start_idx: int = 0
        self.log_search_items: tuple[LogSearchItems, ...] = (
            RequestEntryExitLogSearchItem(config_ver=self),
            SetupCompleteLogSearchItem(config_ver=self),
            SubProcessEntryExitLogSearchItem(config_ver=self),
            RegistryStatusLogSearchItem(config_ver=self),
            AddPairArrayEntryLogSearchItem(config_ver=self),
            AddStatusBlockEntryLogSearchItem(config_ver=self),
            DidCleanPairArrayUtcLogSearchItem(config_ver=self),
            UpdatePairArrayUtcLogSearchItem(config_ver=self),
            AddRegEntryLogSearchItem(config_ver=self),
            RemRegEntryLogSearchItem(config_ver=self),
            RemPairArrayEntryLogSearchItem(config_ver=self),
            DidCleanRegLogSearchItem(config_ver=self),
            SetStateLogSearchItem(config_ver=self),
            InitCompleteLogSearchItem(config_ver=self),
            F1AppExitLogSearchItem(config_ver=self),
            AlreadyUnregLogSearchItem(config_ver=self),
            RequestAckLogSearchItem(config_ver=self),
            DetectedStoppedRemoteLogSearchItem(config_ver=self),
            RequestRefreshLogSearchItem(config_ver=self),
            UnregJoinSuccessLogSearchItem(config_ver=self),
            JoinWaitingLogSearchItem(config_ver=self),
            StoppedLogSearchItem(config_ver=self),
            CmdWaitingLogSearchItem(config_ver=self),
            DebugLogSearchItem(config_ver=self),
            RemStatusBlockEntryLogSearchItem(config_ver=self),
            RemStatusBlockEntryDefLogSearchItem(config_ver=self),
            CRunnerRaisesLogSearchItem(config_ver=self),
            MonitorCheckpointLogSearchItem(config_ver=self),
        )

        self.log_found_items: deque[LogSearchItem] = deque()

        self.pending_events: dict[str, PendEvents] = {}
        self.auto_calling_refresh_msg = True
        self.auto_sync_ach_or_back_msg = True
        self.potential_def_del_pairs: dict[PotentialDefDelKey, int] = defaultdict(int)
        self.setup_pending_events()

        self.snap_shot_data: dict[int, SnapShotDataItem] = {}

        self.allow_log_test_msg = True

        self.last_clean_reg_msg_idx: int = 0
        self.last_thread_stop_msg_idx: dict[str, int] = defaultdict(int)

        self.monitor_event: threading.Event = threading.Event()
        self.monitor_condition: threading.Condition = threading.Condition()
        self.monitor_pause: int = 0
        self.check_pending_events_complete_event: threading.Event = threading.Event()
        self.verify_config_complete_event: threading.Event = threading.Event()
        self.monitor_thread.start()

    ####################################################################
    # __repr__
    ####################################################################
    def __repr__(self) -> str:
        """Return a representation of the class.

        Returns:
            The representation as how the class is instantiated

        """
        if TYPE_CHECKING:
            __class__: Type[ConfigVerifier]  # noqa: F842
        classname = self.__class__.__name__
        parms = ""
        comma = ""

        for key, item in self.specified_args.items():
            if item:  # if not None
                if key in ("log_ver",):
                    if type(item) is str:
                        parms += comma + f"{key}='{item}'"
                    else:
                        parms += comma + f"{key}={item}"
                    comma = ", "  # after first item, now need comma

        return f"{classname}({parms})"

    ####################################################################
    # setup_pending_events
    ####################################################################
    def setup_pending_events(self) -> None:
        """Setup the pending events for all threads."""
        self.pending_events = {}
        for name in self.thread_names:
            self.pending_events[name] = {}
        for name in self.thread_names:
            self.pending_events[name][PE.start_request] = deque()
            self.pending_events[name][PE.current_request] = StartRequest(
                req_type=st.ReqType.NoReq,
                targets=set(),
                unreg_remotes=set(),
                not_registered_remotes=set(),
                timeout_remotes=set(),
                stopped_remotes=set(),
                deadlock_remotes=set(),
                eligible_targets=set(),
                completed_targets=set(),
                first_round_completed=set(),
                stopped_target_threads=set(),
                exp_senders=set(),
                exp_resumers=set(),
            )
            self.pending_events[name][PE.save_current_request] = StartRequest(
                req_type=st.ReqType.NoReq,
                targets=set(),
                unreg_remotes=set(),
                not_registered_remotes=set(),
                timeout_remotes=set(),
                stopped_remotes=set(),
                deadlock_remotes=set(),
                eligible_targets=set(),
                completed_targets=set(),
                first_round_completed=set(),
                stopped_target_threads=set(),
                exp_senders=set(),
                exp_resumers=set(),
            )
            self.pending_events[name][PE.num_targets_remaining] = 0
            self.pending_events[name][PE.request_msg] = defaultdict(int)
            self.pending_events[name][PE.subprocess_msg] = defaultdict(int)
            self.pending_events[name][PE.set_state_msg] = defaultdict(int)
            self.pending_events[name][PE.status_msg] = defaultdict(int)
            self.pending_events[name][PE.rem_reg_msg] = defaultdict(int)
            self.pending_events[name][PE.did_clean_reg_msg] = 0
            self.pending_events[name][PE.update_pair_array_utc_msg] = 0
            self.pending_events[name][PE.did_cleanup_pair_array_utc_msg] = 0
            self.pending_events[name][PE.rem_reg_targets] = deque()
            self.pending_events[name][PE.add_reg_msg] = defaultdict(int)
            self.pending_events[name][PE.add_pair_array_msg] = defaultdict(int)
            self.pending_events[name][PE.add_status_block_msg] = defaultdict(int)
            self.pending_events[name][PE.rem_status_block_msg] = defaultdict(int)
            self.pending_events[name][PE.rem_status_block_def_msg] = defaultdict(int)
            self.pending_events[name][PE.rem_pair_array_entry_msg] = defaultdict(int)
            self.pending_events[name][PE.notify_rem_status_block_msg] = defaultdict(int)
            self.pending_events[name][PE.notify_rem_status_block_def_msg] = defaultdict(
                int
            )
            self.pending_events[name][PE.ack_msg] = defaultdict(int)
            self.pending_events[name][PE.confirm_stop_msg] = defaultdict(int)
            self.pending_events[name][PE.already_unreg_msg] = defaultdict(int)
            self.pending_events[name][PE.unreg_join_success_msg] = defaultdict(int)
            self.pending_events[name][PE.join_progress_msg] = defaultdict(int)
            self.pending_events[name][PE.init_comp_msg] = defaultdict(int)
            self.pending_events[name][PE.calling_refresh_msg] = defaultdict(int)
            self.pending_events[name][PE.refresh_pending_needed] = defaultdict(int)

    ####################################################################
    # monitor
    ####################################################################
    def monitor(self) -> None:
        """Gather log messages and call handlers."""
        self.log_test_msg("monitor entered")

        while not self.monitor_exit:
            self.monitor_event.wait(timeout=0.25)
            self.monitor_event.clear()

            if self.monitor_pause > 0:
                with self.monitor_condition:
                    self.monitor_condition.notify_all()
                continue

            if self.monitor_bail:
                break

            while self.get_log_msgs():
                while self.log_found_items:
                    found_log_item = self.log_found_items.popleft()

                    # log the log msg being processed but mangle it a
                    # little so we don't find it again and get into a
                    # loop here
                    found_msg = found_log_item.found_log_msg
                    if "TestDebug" not in found_msg:
                        semi_msg = found_msg.replace(" ", ";", 3)
                        self.log_test_msg(f"monitor processing msg: {semi_msg}")

                    found_log_item.run_process()

        self.log_test_msg(
            f"monitor exiting: {self.monitor_bail=}," f"{self.monitor_exit=}"
        )

    ####################################################################
    # set_request_pending_flag
    ####################################################################
    def set_request_pending_flag(
        self, cmd_runner: str, targets: set[str], pending_request_flag: bool
    ) -> None:
        """Set or reset request pending flags.

        Args:
            cmd_runner: thread name doing the set or reset
            targets: thread names that are targets of request
            pending_request_flag: specifies value to set for request

        """
        for target in targets:
            pair_key = st.SmartThread._get_pair_key(cmd_runner, target)
            if pair_key not in self.expected_pairs:
                continue

            pae = self.expected_pairs[pair_key]

            cb = pae[cmd_runner]
            pot_key: PotentialDefDelKey = (pair_key, cmd_runner)

            if (
                self.auto_calling_refresh_msg
                and cb.pending_request
                and not pending_request_flag
                and cb.pending_msg_count == 0
                and not cb.pending_wait
                and not cb.pending_sync
                and self.potential_def_del_pairs[pot_key] > 0
            ):
                pe = self.pending_events[cmd_runner]
                req_type = pe[PE.current_request].req_type
                pe[PE.calling_refresh_msg][req_type.value] = 1
                self.potential_def_del_pairs[pot_key] = 0

            self.log_test_msg(
                f"set_request_pending_flag {cmd_runner=}, "
                f"{pair_key=}, {target=}, updating from "
                f"{cb.pending_request=} to "
                f"{pending_request_flag=}"
            )
            cb.pending_request = pending_request_flag

    ####################################################################
    # set_msg_pending_count
    ####################################################################
    def set_msg_pending_count(
        self, receiver: str, sender: str, pending_msg_adj: int
    ) -> None:
        """Set or reset one or more pending flags.

        Args:
            receiver: thread name whose msg count is to be adj
            sender: thread name that sent the msg
            pending_msg_adj: specifies value to add or subtract for msg
                count

        """
        pair_key = st.SmartThread._get_pair_key(receiver, sender)
        if pair_key not in self.expected_pairs:
            raise InvalidConfigurationDetected(
                f"set_msg_pending_count detected that for {receiver=}, "
                f"{sender=}: {pair_key=} is not in the "
                f"{self.expected_pairs=}"
            )

        pae = self.expected_pairs[pair_key]

        if receiver not in pae:
            raise InvalidConfigurationDetected(
                f"set_msg_pending_count detected that for {sender=}, "
                f"{pair_key=}: {receiver=} is not in the {pae=}"
            )

        cb = pae[receiver]
        if pending_msg_adj == 0:
            new_msg_count = 0
        else:
            new_msg_count = cb.pending_msg_count + pending_msg_adj
        self.log_test_msg(
            f"set_msg_pending_count {receiver=}, "
            f"{pair_key=}, {sender=}, updating from "
            f"{cb.pending_msg_count=} to "
            f"{new_msg_count=}"
        )
        cb.pending_msg_count = new_msg_count

    ####################################################################
    # set_wait_pending_flag
    ####################################################################
    def set_wait_pending_flag(
        self, waiter: str, resumer: str, pending_wait_flag: bool
    ) -> None:
        """Set or reset one or more pending flags.

        Args:
            waiter: thread name whose wait flag is to be set
            resumer: thread name that set the wait event
            pending_wait_flag: specifies True or False to set the flag

        """
        pair_key = st.SmartThread._get_pair_key(waiter, resumer)
        if pair_key not in self.expected_pairs:
            raise InvalidConfigurationDetected(
                f"set_wait_pending_flag detected that for {waiter=}, "
                f"{resumer=}: {pair_key=} is not in the "
                f"{self.expected_pairs=}"
            )

        pae = self.expected_pairs[pair_key]

        if waiter not in pae:
            raise InvalidConfigurationDetected(
                f"set_wait_pending_flag detected that for {resumer=}, "
                f"{pair_key=}: {waiter=} is not in the {pae=}"
            )

        cb = pae[waiter]

        before_pending_wait_count = cb.pending_wait_count
        if pending_wait_flag:
            cb.pending_wait_count += 1
        else:
            cb.pending_wait_count -= 1

        after_pending_wait_count = cb.pending_wait_count

        if cb.pending_wait_count == 1:
            new_pending_wait_flag = True
        else:
            new_pending_wait_flag = False

        self.log_test_msg(
            f"set_wait_pending_flag {waiter=}, "
            f"{pair_key=}, {resumer=}, {pending_wait_flag=} "
            f"{before_pending_wait_count=} updating from "
            f"{cb.pending_wait=} to "
            f"{new_pending_wait_flag=}, "
            f"{after_pending_wait_count=}"
        )

        cb.pending_wait = new_pending_wait_flag

    ####################################################################
    # set_sync_pending_flag
    ####################################################################
    def set_sync_pending_flag(
        self, waiter: str, resumer: str, pending_sync_flag: bool
    ) -> None:
        """Set or reset one or more pending flags.

        Args:
            waiter: thread name whose wait flag is to be set
            resumer: thread name that set the wait event
            pending_sync_flag: specifies True or False to set the flag

        """
        pair_key = st.SmartThread._get_pair_key(waiter, resumer)
        if pair_key not in self.expected_pairs:
            raise InvalidConfigurationDetected(
                f"set_sync_pending_flag detected that for {waiter=}, "
                f"{resumer=}: {pair_key=} is not in the "
                f"{self.expected_pairs=}"
            )

        pae = self.expected_pairs[pair_key]

        if waiter not in pae:
            raise InvalidConfigurationDetected(
                f"set_sync_pending_flag detected that for {resumer=}, "
                f"{pair_key=}: {waiter=} is not in the {pae=}"
            )

        cb = pae[waiter]

        self.log_test_msg(
            f"set_sync_pending_flag {waiter=}, "
            f"{pair_key=}, {resumer=}, updating from "
            f"{cb.pending_sync=} to "
            f"{pending_sync_flag=}"
        )
        cb.pending_sync = pending_sync_flag

    ####################################################################
    # abort_all_f1_threads
    ####################################################################
    def abort_all_f1_threads(self) -> None:
        """Abort all threads before raising an error."""
        self.log_test_msg("abort_all_f1_threads entry")
        self.log_test_msg(f"{len(self.all_threads.keys())=}")
        for name, thread in self.all_threads.items():
            if name == self.commander_name:
                continue
            self.log_test_msg(
                f"aborting f1_thread {name}, "
                f"thread.is_alive(): {thread.thread.is_alive()}."
            )
            if thread.thread.is_alive():
                exit_cmd = ExitThread(cmd_runners=name, stopped_by=self.commander_name)
                self.add_cmd_info(exit_cmd)
                self.msgs.queue_msg(name, exit_cmd)
        self.monitor_bail = True
        self.monitor_exit = True
        self.monitor_event.set()

        if threading.current_thread() is not self.monitor_thread:
            self.monitor_thread.join()

        self.log_test_msg("abort_all_f1_threads exit")

    ####################################################################
    # add_cmd
    ####################################################################
    def add_cmd(self, cmd: ConfigCmd, alt_frame_num: Optional[int] = None) -> int:
        """Add a command to the deque.

        Args:
            cmd: command to add
            alt_frame_num: non-zero indicates to add the line number for
                the specified frame to the cmd object so that it will be
                included with in the log just after the line_num in
                parentheses

        Returns:
            the serial number for the command

        """
        if alt_frame_num is not None:
            alt_frame_num += 2
        serial_num = self.add_cmd_info(
            cmd=cmd, frame_num=2, alt_frame_num=alt_frame_num
        )
        self.cmd_suite.append(cmd)
        return serial_num

    ####################################################################
    # add_cmd_info
    ####################################################################
    def add_cmd_info(
        self,
        cmd: ConfigCmd,
        frame_num: int = 1,
        alt_frame_num: Optional[int] = None,
    ) -> int:
        """Add a command to the deque.

        Args:
            cmd: command to add
            frame_num: how many frames back to go for line number
            alt_frame_num: non-zero indicates to add the line number for
                the specified frame to the cmd object so that it will be
                included with in the log just after the line_num in
                parentheses

        Returns:
            the serial number for the command
        """
        self.cmd_serial_num += 1
        cmd.serial_num = self.cmd_serial_num

        frame = _getframe(frame_num)
        caller_info = get_caller_info(frame)
        cmd.line_num = caller_info.line_num
        del frame
        if alt_frame_num is not None and alt_frame_num > 0:
            frame = _getframe(alt_frame_num)
            caller_info = get_caller_info(frame)
            cmd.alt_line_num = caller_info.line_num
            del frame

        cmd.config_ver = self

        return self.cmd_serial_num

    ####################################################################
    # add_log_msg
    ####################################################################
    def add_log_msg(
        self, new_log_msg: str, log_level: int = logging.DEBUG, fullmatch: bool = True
    ) -> None:
        """Add log message to log_ver for SmartThread logger.

        Args:
            new_log_msg: msg to add to log_ver
            log_level: the logging severity level to use
            fullmatch: specify whether fullmatch should be done instead
                of match
        """
        self.log_ver.add_msg(
            log_name="scottbrian_paratools.smart_thread",
            log_level=log_level,
            log_msg=new_log_msg,
            fullmatch=fullmatch,
        )

    ####################################################################
    # build_normal_send_recv_scenario
    ####################################################################
    def build_normal_send_recv_scenario(self, actor_names: list[str]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            actor_names: names of threads that will do the sync

        """
        mid_point = len(actor_names) // 2
        senders = actor_names[0:mid_point]
        receivers = actor_names[mid_point:]

        msgs_to_send = SendRecvMsgs(
            sender_names=senders,
            receiver_names=receivers,
            num_msgs=1,
            text="build_normal_send_recv_scenario",
        )

        send_serial_num = self.add_cmd(
            SendMsg(
                cmd_runners=senders,
                receivers=receivers,
                exp_receivers=receivers,
                msgs_to_send=msgs_to_send,
                msg_idx=0,
                log_msg="normal send recv test",
            )
        )
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd="Send",
                confirm_serial_num=send_serial_num,
                confirmers=senders,
            )
        )
        recv_serial_num = self.add_cmd(
            RecvMsg(
                cmd_runners=receivers,
                senders=senders,
                exp_senders=senders,
                exp_msgs=msgs_to_send,
                log_msg="normal send recv test",
            )
        )
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd="RecvMsg",
                confirm_serial_num=recv_serial_num,
                confirmers=receivers,
            )
        )

    ####################################################################
    # build_normal_resume_wait_scenario
    ####################################################################
    def build_normal_resume_wait_scenario(self, actor_names: list[str]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            actor_names: names of threads that will do the sync

        """
        mid_point = len(actor_names) // 2
        resumers = actor_names[0:mid_point]
        waiters = actor_names[mid_point:]
        resume_serial_num = self.add_cmd(
            Resume(
                cmd_runners=resumers,
                targets=waiters,
                exp_resumed_targets=waiters,
                stopped_remotes=[],
                log_msg="normal resume wait test",
            )
        )
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd="Resume",
                confirm_serial_num=resume_serial_num,
                confirmers=resumers,
            )
        )
        wait_serial_num = self.add_cmd(
            Wait(
                cmd_runners=waiters,
                resumers=resumers,
                exp_resumers=resumers,
                log_msg="normal resume wait test",
            )
        )
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd="Wait",
                confirm_serial_num=wait_serial_num,
                confirmers=waiters,
            )
        )

    ####################################################################
    # build_normal_sync_scenario
    ####################################################################
    def build_normal_sync_scenario(self, actor_names: list[str]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            actor_names: names of threads that will do the sync

        """
        sync_serial_num = self.add_cmd(
            Sync(
                cmd_runners=actor_names,
                targets=actor_names,
                sync_set_ack_remotes=actor_names,
                log_msg="normal sync test",
            )
        )
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd="Sync",
                confirm_serial_num=sync_serial_num,
                confirmers=list(actor_names),
            )
        )

    ####################################################################
    # build_send_sync_recv_scenario
    ####################################################################
    def build_send_sync_recv_scenario(self, actor_names: list[str]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            actor_names: names of threads that will do the sync

        """
        mid_point = len(actor_names) // 2
        senders = actor_names[0:mid_point]
        receivers = actor_names[mid_point:]

        msgs_to_send = SendRecvMsgs(
            sender_names=senders,
            receiver_names=receivers,
            num_msgs=1,
            text="build_send_sync_recv_scenario",
        )

        send_serial_num = self.add_cmd(
            SendMsg(
                cmd_runners=senders,
                receivers=receivers,
                exp_receivers=receivers,
                msgs_to_send=msgs_to_send,
                msg_idx=0,
                log_msg="send sync recv test",
            )
        )
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd="SendMsg",
                confirm_serial_num=send_serial_num,
                confirmers=senders,
            )
        )
        sync_serial_num = self.add_cmd(
            Sync(
                cmd_runners=actor_names,
                targets=actor_names,
                sync_set_ack_remotes=actor_names,
                log_msg="send sync recv test",
            )
        )
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd="Sync",
                confirm_serial_num=sync_serial_num,
                confirmers=actor_names,
            )
        )
        recv_serial_num = self.add_cmd(
            RecvMsg(
                cmd_runners=receivers,
                senders=senders,
                exp_senders=senders,
                exp_msgs=msgs_to_send,
                log_msg="send sync recv test",
            )
        )
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd="RecvMsg",
                confirm_serial_num=recv_serial_num,
                confirmers=receivers,
            )
        )

    ####################################################################
    # build_resume_sync_wait_scenario
    ####################################################################
    def build_resume_sync_wait_scenario(self, actor_names: list[str]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            actor_names: names of threads that will do the sync

        """
        mid_point = len(actor_names) // 2
        resumers = actor_names[0:mid_point]
        waiters = actor_names[mid_point:]
        resume_serial_num = self.add_cmd(
            Resume(
                cmd_runners=resumers,
                targets=waiters,
                exp_resumed_targets=waiters,
                stopped_remotes=[],
                log_msg="resume sync sync wait test",
            )
        )
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd="Resume",
                confirm_serial_num=resume_serial_num,
                confirmers=resumers,
            )
        )
        sync_serial_num = self.add_cmd(
            Sync(
                cmd_runners=actor_names,
                targets=actor_names,
                sync_set_ack_remotes=actor_names,
                log_msg="resume sync sync wait test",
            )
        )
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd="Sync",
                confirm_serial_num=sync_serial_num,
                confirmers=actor_names,
            )
        )
        wait_serial_num = self.add_cmd(
            Wait(
                cmd_runners=waiters,
                resumers=resumers,
                exp_resumers=resumers,
                log_msg="resume sync sync wait test",
            )
        )
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd="Wait",
                confirm_serial_num=wait_serial_num,
                confirmers=waiters,
            )
        )

    ####################################################################
    # build_recv_deadlock_scenario
    ####################################################################
    def build_recv_deadlock_scenario(self, actor_names: list[str]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            actor_names: names of threads that will do the sync

        """
        mid_point = len(actor_names) // 2
        receivers1 = actor_names[0:mid_point]
        receivers2 = actor_names[mid_point:]

        msgs_to_send = SendRecvMsgs(
            sender_names=receivers1 + receivers2,
            receiver_names=receivers1 + receivers2,
            num_msgs=1,
            text="build_recv_deadlock_scenario",
        )

        recv_serial_num_1 = self.add_cmd(
            RecvMsg(
                cmd_runners=receivers1,
                senders=receivers2,
                exp_senders=set(),
                exp_msgs=msgs_to_send,
                deadlock_remotes=set(receivers2),
                log_msg="receive deadlock test",
            )
        )

        self.add_cmd(
            WaitForRequestTimeouts(
                cmd_runners=self.commander_name,
                actor_names=receivers1,
                timeout_names=receivers2,
            )
        )

        recv_serial_num_2 = self.add_cmd(
            RecvMsgTimeoutTrue(
                cmd_runners=receivers2,
                senders=receivers1,
                exp_senders=set(),
                exp_msgs=msgs_to_send,
                deadlock_remotes=set(receivers1),
                deadlock_or_timeout=True,
                timeout_names=set(receivers1),
                timeout=5,
                log_msg="receive deadlock test",
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd="RecvMsg",
                confirm_serial_num=recv_serial_num_1,
                confirmers=receivers1,
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd="RecvMsg",
                confirm_serial_num=recv_serial_num_2,
                confirmers=receivers2,
            )
        )

    ####################################################################
    # build_wait_deadlock_scenario
    ####################################################################
    def build_wait_deadlock_scenario(self, actor_names: list[str]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            actor_names: names of threads that will do the sync

        """
        mid_point = len(actor_names) // 2
        waiters1 = actor_names[0:mid_point]
        waiters2 = actor_names[mid_point:]

        wait_serial_num_1 = self.add_cmd(
            Wait(
                cmd_runners=waiters1,
                resumers=waiters2,
                exp_resumers=set(),
                deadlock_remotes=set(waiters2),
                log_msg="wait deadlock test",
            )
        )

        self.add_cmd(
            WaitForRequestTimeouts(
                cmd_runners=self.commander_name,
                actor_names=waiters1,
                timeout_names=waiters2,
            )
        )

        wait_serial_num_2 = self.add_cmd(
            WaitTimeoutTrue(
                cmd_runners=waiters2,
                resumers=waiters1,
                exp_resumers=set(),
                deadlock_remotes=set(waiters1),
                deadlock_or_timeout=True,
                timeout_remotes=set(waiters1),
                timeout=5,
                log_msg="wait deadlock test",
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd="Wait",
                confirm_serial_num=wait_serial_num_1,
                confirmers=waiters1,
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd="Wait",
                confirm_serial_num=wait_serial_num_2,
                confirmers=waiters2,
            )
        )

    ####################################################################
    # build_sync_deadlock_scenario
    ####################################################################
    def build_sync_deadlock_scenario(self, actor_names: list[str]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            actor_names: names of threads that will do the sync

        """
        mid_point_1 = len(actor_names) // 3
        mid_point_2 = 2 * mid_point_1
        syncers = actor_names[0:mid_point_1]
        receivers = actor_names[mid_point_1:mid_point_2]
        waiters = actor_names[mid_point_2:]

        msgs_to_send = SendRecvMsgs(
            sender_names=syncers + waiters,
            receiver_names=receivers,
            num_msgs=1,
            text="build_sync_deadlock_scenario",
        )

        sync_serial_num = self.add_cmd(
            Sync(
                cmd_runners=syncers,
                targets=actor_names,
                sync_set_ack_remotes=actor_names,
                deadlock_remotes=receivers + waiters,
                log_msg="sync deadlock test",
            )
        )

        self.add_cmd(
            WaitForRequestTimeouts(
                cmd_runners=self.commander_name,
                actor_names=syncers,
                timeout_names=receivers + waiters,
            )
        )

        recv_serial_num = self.add_cmd(
            RecvMsg(
                cmd_runners=receivers,
                senders=syncers + waiters,
                exp_senders=set(),
                exp_msgs=msgs_to_send,
                deadlock_remotes=syncers + waiters,
                log_msg="sync deadlock test",
            )
        )

        wait_serial_num = self.add_cmd(
            Wait(
                cmd_runners=waiters,
                resumers=syncers,
                exp_resumers=set(),
                deadlock_remotes=syncers + receivers,
                log_msg="sync deadlock test",
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd="Sync",
                confirm_serial_num=sync_serial_num,
                confirmers=syncers,
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd="RecvMsg",
                confirm_serial_num=recv_serial_num,
                confirmers=receivers,
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd="Wait",
                confirm_serial_num=wait_serial_num,
                confirmers=waiters,
            )
        )

    ####################################################################
    # build_deadlock_scenario
    ####################################################################
    def build_deadlock_scenario(
        self, scenario_list: list[DeadlockScenario], num_cd_actors: int
    ) -> None:
        """Build ConfigCmd items for sync scenarios.

        Args:
            scenario_list: scenario 1, 2, and 3
            num_cd_actors: number of syncers, resumers, and waiters

        """
        actions: dict[DeadlockScenario, Callable[..., None]] = {
            DeadlockScenario.NormalSendRecv: self.build_normal_send_recv_scenario,
            DeadlockScenario.NormalResumeWait: self.build_normal_resume_wait_scenario,
            DeadlockScenario.NormalSync: self.build_normal_sync_scenario,
            DeadlockScenario.SendSyncRecv: self.build_send_sync_recv_scenario,
            DeadlockScenario.ResumeSyncWait: self.build_resume_sync_wait_scenario,
            DeadlockScenario.RecvDeadlock: self.build_recv_deadlock_scenario,
            DeadlockScenario.WaitDeadlock: self.build_wait_deadlock_scenario,
            DeadlockScenario.SyncDeadlock: self.build_sync_deadlock_scenario,
        }
        # Make sure we have enough threads
        assert num_cd_actors <= len(self.unregistered_names)

        self.build_config(cmd_runner=self.commander_name, num_active=num_cd_actors + 1)

        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose actor_names
        ################################################################
        actor_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_cd_actors,
            update_collection=True,
            var_name_for_log="actor_names",
        )

        for scenario in scenario_list:
            actions[scenario](actor_names=actor_names)

    ####################################################################
    # build_config
    ####################################################################
    def build_config(
        self,
        cmd_runner: str,
        num_registered: int = 0,
        num_active: int = 1,
        num_stopped: int = 0,
    ) -> None:
        """Add ConfigCmd items to the queue.

        Args:
            cmd_runner: thread running the command
            num_registered: number of threads that need to be
                registered but not yet started (meaning state is
                Registered)
            num_active: number of threads that need to be active
                (meaning state is Active)
            num_stopped: number of threads that need to have exited but
                not yet joined (meaning state is Stopped)

        Note: the number of registered, active, and stopped must not
            exceed the number of thread_names

        """
        assert (num_registered + num_active + num_stopped) <= len(self.thread_names)
        assert num_active >= 1  # always need at least 1 for commander

        num_adjust_registered = len(self.registered_names) - num_registered
        num_adjust_active = len(self.active_names) - num_active
        num_adjust_stopped = len(self.stopped_remotes) - num_stopped

        num_create_auto_start = 0
        num_create_no_start = 0
        num_reg_to_unreg = 0
        num_reg_to_start = 0
        num_active_to_exit = 0
        num_stopped_to_join = 0
        num_active_to_join = 0

        # determine how many to start for active and stopped
        if num_adjust_registered > 0:  # if surplus of registered
            num_adjust_act_stop = num_adjust_active + num_adjust_stopped
            if num_adjust_act_stop < 0:  # if shortage
                num_reg_to_start = min(num_adjust_registered, -num_adjust_act_stop)
                num_adjust_registered -= num_reg_to_start
                num_adjust_active += num_reg_to_start

            if num_adjust_registered > 0:  # if still surplus
                num_reg_to_unreg = num_adjust_registered
                num_adjust_registered = 0
        elif num_adjust_registered < 0:
            num_create_no_start = -num_adjust_registered
            num_adjust_registered = 0

        if num_adjust_active > 0:  # if surplus
            if num_adjust_stopped < 0:  # need more
                num_active_to_exit = min(num_adjust_active, -num_adjust_stopped)
                num_adjust_active -= num_active_to_exit
                num_adjust_stopped += num_active_to_exit

            if num_adjust_active > 0:  # if still surplus
                num_active_to_exit += num_adjust_active
                num_active_to_join = num_adjust_active
                num_adjust_active = 0
        elif num_adjust_active < 0:  # if need more
            num_create_auto_start += -num_adjust_active
            num_adjust_active = 0

        if num_adjust_stopped > 0:  # if surplus
            num_stopped_to_join += num_adjust_stopped
            num_adjust_stopped = 0
        elif num_adjust_stopped < 0:  # if we need more
            num_create_auto_start += -num_adjust_stopped
            num_active_to_exit += -num_adjust_stopped
            num_adjust_stopped = 0

        # start by reducing surpluses
        if num_reg_to_unreg > 0:
            self.build_unreg_suite_num(num_to_unreg=num_reg_to_unreg)

        if num_stopped_to_join > 0:
            self.build_join_suite_num(
                cmd_runners=cmd_runner, num_to_join=num_stopped_to_join
            )

        # create threads with no_start
        if num_create_no_start > 0:
            self.build_f1_create_suite_num(
                num_to_create=num_create_no_start, auto_start=False
            )

        # start registered so we have actives to exit if need be
        if num_reg_to_start > 0:
            self.build_start_suite_num(num_to_start=num_reg_to_start)

        # create threads with auto_start
        if num_create_auto_start > 0:
            self.build_f1_create_suite_num(
                num_to_create=num_create_auto_start, auto_start=True
            )

        # Now that we have actives, do any needed exits
        if num_active_to_exit > 0:
            self.build_exit_suite_num(num_to_exit=num_active_to_exit)

        # Finally, join the stopped threads as needed
        if num_active_to_join > 0:
            self.build_join_suite_num(
                cmd_runners=cmd_runner, num_to_join=num_active_to_join
            )

        self.log_name_groups()

        # verify the counts
        self.add_cmd(
            VerifyCounts(
                cmd_runners=cmd_runner,
                exp_num_registered=num_registered,
                exp_num_active=num_active,
                exp_num_stopped=num_stopped,
            )
        )

    ####################################################################
    # create_config
    ####################################################################
    def create_config(
        self,
        unreg_names: Optional[Iterable[str]] = None,
        reg_names: Optional[Iterable[str]] = None,
        active_names: Optional[Iterable[str]] = None,
        stopped_names: Optional[Iterable[str]] = None,
    ) -> None:
        """Add ConfigCmd items to the queue to create a config.

        Args:
            unreg_names: thread names to be in the unreg pool
            reg_names: thread names to be in the registered pool
            active_names: thread names to be in the active pool
            stopped_names: thread names to be in the stopped pool

        """
        self.thread_names = [self.commander_name]
        if unreg_names:
            self.thread_names.extend(unreg_names)

        if reg_names:
            self.thread_names.extend(reg_names)
        if active_names:
            self.thread_names.extend(active_names)
        if stopped_names:
            self.thread_names.extend(stopped_names)

        self.unregistered_names = set(self.thread_names)
        self.setup_pending_events()
        self.unregistered_names -= {self.commander_name}

        if reg_names:
            names: list[str] = sorted(reg_names)
            f1_create_items: list[F1CreateItem] = []
            for idx, name in enumerate(names):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(
                    F1CreateItem(
                        name=name,
                        auto_start=False,
                        target_rtn=outer_f1,
                        app_config=app_config,
                    )
                )

            self.build_create_suite(
                f1_create_items=f1_create_items, validate_config=True
            )

        if active_names:
            names = sorted(active_names)
            f1_create_items = []
            for idx, name in enumerate(names):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(
                    F1CreateItem(
                        name=name,
                        auto_start=True,
                        target_rtn=outer_f1,
                        app_config=app_config,
                    )
                )

            self.build_create_suite(
                f1_create_items=f1_create_items, validate_config=True
            )

        if stopped_names:
            names = sorted(stopped_names)
            f1_create_items = []
            for idx, name in enumerate(names):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(
                    F1CreateItem(
                        name=name,
                        auto_start=True,
                        target_rtn=outer_f1,
                        app_config=app_config,
                    )
                )

            self.build_create_suite(
                f1_create_items=f1_create_items, validate_config=True
            )

            self.build_exit_suite(cmd_runner=self.commander_name, names=names)

        self.log_name_groups()

    ####################################################################
    # build_config_build_suite
    ####################################################################
    def build_config_build_suite(
        self,
        num_registered_1: int,
        num_active_1: int,
        num_stopped_1: int,
        num_registered_2: int,
        num_active_2: int,
        num_stopped_2: int,
    ) -> None:
        """Return a list of ConfigCmd items for config build.

        Args:
            num_registered_1: number of threads to initially build as
                registered
            num_active_1: number of threads to initially build as
                active
            num_stopped_1: number of threads to initially build as
                stopped
            num_registered_2: number of threads to reconfigure as
                registered
            num_active_2: number of threads to reconfigure as active
            num_stopped_2: number of threads to reconfigure as stopped

        """
        self.build_config(
            cmd_runner=self.commander_name,
            num_registered=num_registered_1,
            num_active=num_active_1,
            num_stopped=num_stopped_1,
        )
        self.build_config(
            cmd_runner=self.commander_name,
            num_registered=num_registered_2,
            num_active=num_active_2,
            num_stopped=num_stopped_2,
        )

    ####################################################################
    # build_create_suite
    ####################################################################
    def build_create_suite(
        self,
        cmd_runner: Optional[str] = None,
        f1_create_items: Optional[list[F1CreateItem]] = None,
        validate_config: Optional[bool] = True,
    ) -> None:
        """Return a list of ConfigCmd items for a create.

        Args:
            cmd_runner: name of thread to do the creates
            f1_create_items: contain f1_names to create
            validate_config: indicates whether to do config validation

        """
        if cmd_runner:
            cmd_runner_to_use = cmd_runner
        else:
            cmd_runner_to_use = self.commander_name

        if f1_create_items:
            f1_names: list[str] = []
            f1_auto_start_names: list[str] = []
            f1_auto_items: list[F1CreateItem] = []
            f1_no_start_names: list[str] = []
            f1_no_start_items: list[F1CreateItem] = []
            for f1_create_item in f1_create_items:
                f1_names.append(f1_create_item.name)
                if f1_create_item.auto_start:
                    f1_auto_start_names.append(f1_create_item.name)
                    f1_auto_items.append(f1_create_item)
                else:
                    f1_no_start_names.append(f1_create_item.name)
                    f1_no_start_items.append(f1_create_item)
                if f1_create_item.app_config == AppConfig.ScriptStyle:
                    self.thread_target_names |= {f1_create_item.name}
            if not set(f1_names).issubset(self.unregistered_names):
                self.abort_all_f1_threads()
                raise InvalidInputDetected(
                    f"Input names {f1_names} not a "
                    f"subset of unregistered names "
                    f"{self.unregistered_names}"
                )
            self.unregistered_names -= set(f1_names)
            if f1_auto_items:
                self.add_cmd(
                    CreateF1AutoStart(
                        cmd_runners=cmd_runner_to_use, f1_create_items=f1_auto_items
                    )
                )

                self.active_names |= set(f1_auto_start_names)
            elif f1_no_start_items:
                self.add_cmd(
                    CreateF1NoStart(
                        cmd_runners=cmd_runner_to_use, f1_create_items=f1_no_start_items
                    )
                )
                self.registered_names |= set(f1_no_start_names)

        if self.registered_names:
            self.add_cmd(
                VerifyConfig(
                    cmd_runners=cmd_runner_to_use,
                    verify_type=VerifyType.VerifyRegisteredState,
                    names_to_check=self.registered_names.copy(),
                )
            )

        if self.active_names:
            # self.add_cmd(VerifyActive(
            #     cmd_runners=cmd_runner_to_use,
            #     exp_active_names=list(self.active_names)))
            self.add_cmd(
                VerifyConfig(
                    cmd_runners=cmd_runner_to_use,
                    verify_type=VerifyType.VerifyAliveState,
                    names_to_check=self.active_names.copy(),
                )
            )

        if validate_config:
            self.add_cmd(
                VerifyConfig(
                    cmd_runners=cmd_runner_to_use,
                    verify_type=VerifyType.VerifyStructures,
                )
            )

    ####################################################################
    # build_exit_suite
    ####################################################################
    def build_exit_suite(
        self,
        cmd_runner: str,
        names: Iterable[str],
        validate_config: bool = True,
        reset_ops_count: bool = False,
        send_recv_msgs: Optional[SendRecvMsgs] = None,
    ) -> None:
        """Add ConfigCmd items for an exit.

        Args:
            cmd_runner: name of thread that will do the cmd
            names: names of threads to exit
            validate_config: specifies whether to validate the
                configuration
            reset_ops_count: specifies that the pending_ops_count is to
                be set to zero
            send_recv_msgs: contains messages sent to the names

        """
        names = get_set(names)
        if not names.issubset(self.active_names):
            self.abort_all_f1_threads()
            raise InvalidInputDetected(
                f"Input names {names} not a subset "
                f"of active names {self.active_names}"
            )
        active_names = list(self.active_names - names)

        if names:
            self.add_cmd(
                StopThread(
                    cmd_runners=cmd_runner,
                    stop_names=names,
                    reset_ops_count=reset_ops_count,
                    send_recv_msgs=send_recv_msgs,
                )
            )
            if validate_config:
                self.add_cmd(Pause(cmd_runners=cmd_runner, pause_seconds=0.2))
                self.add_cmd(
                    VerifyConfig(
                        cmd_runners=cmd_runner,
                        verify_type=VerifyType.VerifyNotAlive,
                        names_to_check=names,
                    )
                )

                # if alive_state_names:
                self.add_cmd(
                    VerifyConfig(
                        cmd_runners=cmd_runner,
                        verify_type=VerifyType.VerifyState,
                        names_to_check=names,
                        state_to_check=st.ThreadState.Alive,
                    )
                )
        if active_names and validate_config:
            self.add_cmd(
                VerifyConfig(
                    cmd_runners=cmd_runner,
                    verify_type=VerifyType.VerifyAlive,
                    names_to_check=active_names,
                )
            )
            self.add_cmd(
                VerifyConfig(
                    cmd_runners=cmd_runner,
                    verify_type=VerifyType.VerifyState,
                    names_to_check=active_names,
                    state_to_check=st.ThreadState.Alive,
                )
            )

        if validate_config:
            self.add_cmd(
                VerifyConfig(
                    cmd_runners=cmd_runner, verify_type=VerifyType.VerifyStructures
                )
            )

        self.active_names -= names
        self.stopped_remotes |= names

    ####################################################################
    # build_exit_suite_num
    ####################################################################
    def build_exit_suite_num(self, num_to_exit: int) -> None:
        """Return a list of ConfigCmd items for smart_unreg.

        Args:
            num_to_exit: number of threads to exit

        """
        assert num_to_exit > 0
        if (len(self.active_names) - 1) < num_to_exit:
            self.abort_all_f1_threads()
            raise InvalidInputDetected(
                f"Input num_to_exit {num_to_exit} "
                f"is greater than the number of "
                f"registered threads "
                f"{len(self.active_names)}"
            )

        names: list[str] = list(
            random.sample(
                sorted(self.active_names - {self.commander_name}), num_to_exit
            )
        )

        return self.build_exit_suite(cmd_runner=self.commander_name, names=names)

    ####################################################################
    # build_f1_create_suite_num
    ####################################################################
    def build_f1_create_suite_num(
        self, num_to_create: int, auto_start: bool = True, validate_config: bool = True
    ) -> None:
        """Return a list of ConfigCmd items for a create.

        Args:
            num_to_create: number of f1 threads to create
            auto_start: indicates whether to use auto_start
            validate_config: indicates whether to do config validation

        """
        assert num_to_create > 0
        if len(self.unregistered_names) < num_to_create:
            self.abort_all_f1_threads()
            raise InvalidInputDetected(
                f"Input num_to_create {num_to_create} "
                f"is greater than the number of "
                f"unregistered threads "
                f"{len(self.unregistered_names)}"
            )

        names: list[str] = list(
            random.sample(sorted(self.unregistered_names), num_to_create)
        )
        f1_create_items: list[F1CreateItem] = []
        for idx, name in enumerate(names):
            if idx % 2:
                app_config = AppConfig.ScriptStyle
            else:
                app_config = AppConfig.RemoteThreadApp

            f1_create_items.append(
                F1CreateItem(
                    name=name,
                    auto_start=auto_start,
                    target_rtn=outer_f1,
                    app_config=app_config,
                )
            )

        self.build_create_suite(
            f1_create_items=f1_create_items, validate_config=validate_config
        )

    ####################################################################
    # build_join_suite
    ####################################################################
    def build_join_suite(
        self,
        cmd_runners: Iterable[str],
        join_target_names: Iterable[str],
        validate_config: Optional[bool] = True,
    ) -> None:
        """Return a list of ConfigCmd items for join.

        Args:
            cmd_runners: list of names to do the join
            join_target_names: the threads that are to be joined
            validate_config: specifies whether to validate the config
                after the join is done

        """
        cmd_runners = get_set(cmd_runners)
        join_target_names = get_set(join_target_names)

        if not join_target_names.issubset(self.stopped_remotes):
            self.abort_all_f1_threads()
            raise InvalidInputDetected(
                f"Input {join_target_names} is not a "
                "subset of inactive names "
                f"{self.stopped_remotes}"
            )

        if join_target_names:
            self.add_cmd(Join(cmd_runners=cmd_runners, join_names=join_target_names))

            self.add_cmd(
                VerifyConfig(
                    cmd_runners=cmd_runners,
                    verify_type=VerifyType.VerifyNotInRegistry,
                    names_to_check=join_target_names,
                )
            )

            self.add_cmd(
                VerifyConfig(
                    cmd_runners=cmd_runners,
                    verify_type=VerifyType.VerifyNotPaired,
                    names_to_check=join_target_names,
                )
            )

        if validate_config:
            self.add_cmd(
                VerifyConfig(
                    cmd_runners=cmd_runners, verify_type=VerifyType.VerifyStructures
                )
            )

        self.unregistered_names |= join_target_names
        self.stopped_remotes -= join_target_names

    ####################################################################
    # build_join_suite
    ####################################################################
    def build_join_suite_num(
        self, cmd_runners: Iterable[str], num_to_join: int
    ) -> None:
        """Return a list of ConfigCmd items for join.

        Args:
            cmd_runners: threads running the command
            num_to_join: number of threads to join

        """
        assert num_to_join > 0
        if len(self.stopped_remotes) < num_to_join:
            self.abort_all_f1_threads()
            raise InvalidInputDetected(
                f"Input num_to_join {num_to_join} "
                f"is greater than the number of "
                f"stopped threads "
                f"{len(self.stopped_remotes)}"
            )

        names: list[str] = list(
            random.sample(sorted(self.stopped_remotes), num_to_join)
        )

        self.build_join_suite(cmd_runners=cmd_runners, join_target_names=names)

    ####################################################################
    # build_join_timeout_scenario
    ####################################################################
    def build_join_timeout_scenario(
        self,
        timeout_type: TimeoutType,
        num_active_no_target: int,
        num_no_delay_exit: int,
        num_delay_exit: int,
        num_delay_unreg: int,
        num_no_delay_reg: int,
        num_delay_reg: int,
    ) -> None:
        """Return a list of ConfigCmd items for a create.

        Args:
            timeout_type: specifies TimeoutNone, TimeoutFalse,
                or TimeoutTrue
            num_active_no_target: number of threads that should be
                active and stay active during the join as non-targets
            num_no_delay_exit: number of threads that should be active
                and targeted for join, and then exited immediately to
                allow the join to succeed
            num_delay_exit: number of threads that should be active and
                targeted for join, and then be exited after a short
                delay to allow a TimeoutFalse join to succeed, and a
                long delay to cause a TimeoutTrue join to
                timeout and a TimeoutNone to eventually succeed
            num_delay_unreg: number of threads that should be
                unregistered and targeted for join. These will cause the
                already unregistered log message and will be considered
                as successfully joined in the smart_join completion
                message. They will be eventually started to show that
                they are unaffected by the smart_join once they are
                recognized as already unregistered.
            num_no_delay_reg: number of threads that should be
                registered and targeted for join, and then be
                be immediately started and exited to allow the
                join to succeed
            num_delay_reg: number of threads that should be registered
                and targeted for join, and then be started and exited
                after a short delay to allow a TimeoutFalse join to
                succeed, and a long delay to cause a TimeoutTrue join to
                timeout and a TimeoutNone to eventually succeed

        """
        # Make sure we have enough threads
        assert (
            1
            < (
                num_active_no_target
                + num_no_delay_exit
                + num_delay_exit
                + num_delay_unreg
                + num_no_delay_reg
                + num_delay_reg
            )
            <= len(self.unregistered_names)
        )

        if (
            timeout_type == TimeoutType.TimeoutFalse
            or timeout_type == TimeoutType.TimeoutTrue
        ):
            assert (num_delay_exit + num_delay_reg) > 0

        assert num_active_no_target > 0

        num_registered_needed = num_no_delay_reg + num_delay_reg

        num_active_needed = (
            num_active_no_target + num_no_delay_exit + num_delay_exit + 1
        )

        timeout_time = ((num_no_delay_exit + num_no_delay_reg) * 0.3) + (
            (num_delay_exit + num_delay_reg) * 1.5
        )

        if timeout_type == TimeoutType.TimeoutNone:
            pause_time = 0.5
        elif timeout_type == TimeoutType.TimeoutFalse:
            pause_time = 0.5
            timeout_time += pause_time * 4  # prevent timeout
        else:  # timeout True
            pause_time = timeout_time + 1  # force timeout

        self.build_config(
            cmd_runner=self.commander_name,
            num_registered=num_registered_needed,
            num_active=num_active_needed,
        )

        unregistered_names_copy = self.unregistered_names.copy()
        registered_names_copy = self.registered_names.copy()
        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose receiver_names
        ################################################################
        active_no_target_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_active_no_target,
            update_collection=True,
            var_name_for_log="active_no_target_names",
        )

        ################################################################
        # choose active_no_delay_sender_names
        ################################################################
        no_delay_exit_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_no_delay_exit,
            update_collection=True,
            var_name_for_log="no_delay_exit_names",
        )

        ################################################################
        # choose active_delay_sender_names
        ################################################################
        delay_exit_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_delay_exit,
            update_collection=True,
            var_name_for_log="delay_exit_names",
        )

        ################################################################
        # choose delay_unreg_names
        ################################################################
        delay_unreg_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_delay_unreg,
            update_collection=True,
            var_name_for_log="delay_unreg_names",
        )

        ################################################################
        # choose unreg_sender_names
        ################################################################
        no_delay_reg_names = self.choose_names(
            name_collection=registered_names_copy,
            num_names_needed=num_no_delay_reg,
            update_collection=True,
            var_name_for_log="no_delay_reg_names",
        )

        ################################################################
        # choose reg_sender_names
        ################################################################
        delay_reg_names = self.choose_names(
            name_collection=registered_names_copy,
            num_names_needed=num_delay_reg,
            update_collection=True,
            var_name_for_log="delay_reg_names",
        )

        ################################################################
        # start by doing the recv_msgs, one for each sender
        ################################################################
        all_target_names: list[str] = (
            no_delay_exit_names
            + delay_exit_names
            + delay_unreg_names
            + no_delay_reg_names
            + delay_reg_names
        )

        all_timeout_names: list[str] = delay_exit_names + delay_reg_names

        if len(all_target_names) % 2 == 0:
            log_msg = f"join log test: {get_ptime()}"
        else:
            log_msg = None

        ################################################################
        # start the join
        ################################################################
        if timeout_type == TimeoutType.TimeoutNone:
            confirm_cmd_to_use = "Join"
            join_serial_num = self.add_cmd(
                Join(
                    cmd_runners=active_no_target_names[0],
                    join_names=all_target_names,
                    unreg_names=delay_unreg_names,
                    log_msg=log_msg,
                )
            )
        elif timeout_type == TimeoutType.TimeoutFalse:
            confirm_cmd_to_use = "JoinTimeoutFalse"
            join_serial_num = self.add_cmd(
                JoinTimeoutFalse(
                    cmd_runners=active_no_target_names[0],
                    join_names=all_target_names,
                    unreg_names=delay_unreg_names,
                    timeout=timeout_time,
                    log_msg=log_msg,
                )
            )
        else:  # TimeoutType.TimeoutTrue
            confirm_cmd_to_use = "JoinTimeoutTrue"
            join_serial_num = self.add_cmd(
                JoinTimeoutTrue(
                    cmd_runners=active_no_target_names[0],
                    join_names=all_target_names,
                    unreg_names=delay_unreg_names,
                    timeout=timeout_time,
                    timeout_names=all_timeout_names,
                    log_msg=log_msg,
                )
            )

        ################################################################
        # handle no_delay_exit_names
        ################################################################
        if no_delay_exit_names:
            self.build_exit_suite(
                cmd_runner=self.commander_name,
                names=no_delay_exit_names,
                validate_config=False,
            )

        ################################################################
        # handle no_delay_reg_names
        ################################################################
        if no_delay_reg_names:
            self.build_start_suite(
                start_names=no_delay_reg_names, validate_config=False
            )
            self.build_exit_suite(
                cmd_runner=self.commander_name,
                names=no_delay_reg_names,
                validate_config=False,
            )

        ################################################################
        # make sure smart_join is in loop waiting for timeout names
        ################################################################
        if timeout_type != TimeoutType.TimeoutNone and all_timeout_names:
            self.add_cmd(
                WaitForRequestTimeouts(
                    cmd_runners=self.commander_name,
                    actor_names=active_no_target_names[0],
                    timeout_names=all_timeout_names,
                    use_work_remotes=True,
                    as_subset=True,
                )
            )

        ################################################################
        # pause for short or long delay
        ################################################################
        self.add_cmd(Pause(cmd_runners=self.commander_name, pause_seconds=pause_time))

        ################################################################
        # handle delay_exit_names
        ################################################################
        if delay_exit_names:
            self.build_exit_suite(
                cmd_runner=self.commander_name,
                names=delay_exit_names,
                validate_config=False,
            )

        ################################################################
        # handle delay_reg_names
        ################################################################
        if delay_reg_names:
            self.build_start_suite(start_names=delay_reg_names, validate_config=False)
            self.add_cmd(
                VerifyConfig(
                    cmd_runners=self.commander_name,
                    verify_type=VerifyType.VerifyAliveState,
                    names_to_check=delay_reg_names,
                )
            )

            self.build_exit_suite(
                cmd_runner=self.commander_name,
                names=delay_reg_names,
                validate_config=False,
            )

        ################################################################
        # handle delay_unreg_names
        ################################################################
        if delay_unreg_names:
            f1_create_items: list[F1CreateItem] = []
            for idx, name in enumerate(delay_unreg_names):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(
                    F1CreateItem(
                        name=name,
                        auto_start=True,
                        target_rtn=outer_f1,
                        app_config=app_config,
                    )
                )

            self.build_create_suite(
                f1_create_items=f1_create_items, validate_config=False
            )
            self.build_exit_suite(
                cmd_runner=self.commander_name,
                names=delay_unreg_names,
                validate_config=False,
            )

        ################################################################
        # finally, confirm the smart_recv is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd=confirm_cmd_to_use,
                confirm_serial_num=join_serial_num,
                confirmers=active_no_target_names[0],
            )
        )

        if delay_unreg_names:
            self.add_cmd(
                VerifyConfig(
                    cmd_runners=self.commander_name,
                    verify_type=VerifyType.VerifyStoppedState,
                    names_to_check=delay_unreg_names,
                )
            )

    ####################################################################
    # build_msg_suite
    ####################################################################
    def build_msg_suite(self, from_names: list[str], to_names: list[str]) -> None:
        """Return a list of ConfigCmd items for msgs.

        Args:
            from_names: names of threads that send
            to_names: names of threads that receive

        """
        msgs_to_send = SendRecvMsgs(
            sender_names=from_names,
            receiver_names=to_names,
            num_msgs=1,
            text="build_msg_suite",
        )

        self.add_cmd(
            SendMsg(
                cmd_runners=from_names,
                receivers=to_names,
                exp_receivers=to_names,
                msgs_to_send=msgs_to_send,
                msg_idx=0,
            )
        )

        self.add_cmd(
            RecvMsg(
                cmd_runners=to_names,
                senders=from_names,
                exp_senders=from_names,
                exp_msgs=msgs_to_send,
            )
        )

    ####################################################################
    # build_pending_sans_sync_scenario
    ####################################################################
    def build_pending_sans_sync_scenario(
        self,
        request_type: st.ReqType,
        pending_request_tf: bool,
        pending_msg_count: int,
        pending_wait_tf: bool,
    ) -> None:
        """Return a list of ConfigCmd items for a create.

        Args:
            request_type: request type that is to get the pending
                flags set on it
            pending_request_tf: if True, pending_request flag is to be
                set
            pending_msg_count: number of msgs to be placed on the
                pending thread
            pending_wait_tf: if True, pending_wait flag is to be set

        Notes:
            There are two test cases dealing with the pending flags:
            test_pending_sans_sync_scenario:
                this will test combinations for:
                    pending_request: True, False
                    pending_msg: count of 0, 1, 2
                    pending_wait: True, False
                using requests:
                    smart_send
                    smart_recv
                    smart_wait
                    smart_resume

            test_pending_sync_only_scenario:
                this will test combinations for:
                    pending_request: True
                    pending_msg: count of 0, 1, 2
                    pending_wait: True, False
                    pending_sync: True, False
                using requests:
                    smart_sync

            The reason for having two different test cases is that
            pending_sync can only be set with smart_sync, and
            only with pending_request also set.
        """
        self.auto_calling_refresh_msg = False
        pending_names = ["pending_0"]
        remote_names = ["remote_0"]

        locker_names = ["locker_0", "locker_1", "locker_2"]
        lm = LockMgr(config_ver=self, locker_names=locker_names)

        joiner_names = ["joiner_0"]

        active_names: list[str] = (
            pending_names + remote_names + locker_names + joiner_names
        )

        self.create_config(active_names=active_names)

        pend_req_serial_num: int = 0
        join_serial_num: int = 0

        stopped_remotes: Union[str, set[str]] = set()
        exp_senders: Union[str, set[str]] = set()
        exp_resumers: Union[str, set[str]] = set()
        ################################################################
        # verify all flags off
        ################################################################
        exp_pending_flags = PendingFlags()
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyPendingFlags,
                names_to_check=pending_names,
                aux_names=remote_names,
                exp_pending_flags=exp_pending_flags,
                obtain_reg_lock=False,
            )
        )

        ################################################################
        # handle pending_msg_count
        ################################################################
        msgs_remote_to_pending = SendRecvMsgs(
            sender_names=remote_names,
            receiver_names=pending_names,
            num_msgs=max(1, pending_msg_count),
            text="build_pending_sans_sync_scenario",
        )

        for idx in range(pending_msg_count):
            send_msg_serial_num = self.add_cmd(
                SendMsg(
                    cmd_runners=remote_names,
                    receivers=pending_names,
                    exp_receivers=pending_names,
                    msgs_to_send=msgs_remote_to_pending,
                    msg_idx=idx,
                    send_type=SendType.ToRemotes,
                )
            )
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd="SendMsg",
                    confirm_serial_num=send_msg_serial_num,
                    confirmers=remote_names,
                )
            )

        exp_pending_flags = PendingFlags(pending_msgs=pending_msg_count)
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyPendingFlags,
                names_to_check=pending_names,
                aux_names=remote_names,
                exp_pending_flags=exp_pending_flags,
                obtain_reg_lock=False,
            )
        )

        ################################################################
        # handle pending_wait
        ################################################################
        if pending_wait_tf:
            resume_serial_num = self.add_cmd(
                Resume(
                    cmd_runners=remote_names,
                    targets=pending_names,
                    exp_resumed_targets=pending_names,
                )
            )
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd="Resume",
                    confirm_serial_num=resume_serial_num,
                    confirmers=remote_names,
                )
            )

        exp_pending_flags = PendingFlags(
            pending_msgs=pending_msg_count, pending_wait=pending_wait_tf
        )
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyPendingFlags,
                names_to_check=pending_names,
                aux_names=remote_names,
                exp_pending_flags=exp_pending_flags,
                obtain_reg_lock=False,
            )
        )

        if pending_request_tf:
            ############################################################
            # start of by getting lock
            # locks held:
            # before: none
            # after : lock
            ############################################################
            lm.get_lock()

            ############################################################
            # smart_req will get behind lock in
            # _verify_thread_is_current
            # locks held:
            # before: lock
            # after : lock|smart_req
            ############################################################
            if request_type == st.ReqType.Smart_send:
                stopped_remotes = remote_names[0]
                msgs_pending_to_remote = SendRecvMsgs(
                    sender_names=pending_names,
                    receiver_names=remote_names,
                    num_msgs=1,
                    text="build_pending_sans_sync_scenario",
                )
                pend_req_serial_num = self.add_cmd(
                    SendMsg(
                        cmd_runners=pending_names[0],
                        receivers=remote_names[0],
                        exp_receivers=set(),
                        msgs_to_send=msgs_pending_to_remote,
                        msg_idx=0,
                        stopped_remotes=stopped_remotes,
                    )
                )
            elif request_type == st.ReqType.Smart_recv:
                if pending_msg_count == 0:
                    stopped_remotes = remote_names[0]
                else:
                    exp_senders = remote_names[0]
                pend_req_serial_num = self.add_cmd(
                    RecvMsg(
                        cmd_runners=pending_names[0],
                        senders=remote_names[0],
                        exp_msgs=msgs_remote_to_pending,
                        exp_senders=exp_senders,
                        stopped_remotes=stopped_remotes,
                    )
                )
            elif request_type == st.ReqType.Smart_wait:
                if not pending_wait_tf:
                    stopped_remotes = remote_names[0]
                else:
                    exp_resumers = remote_names[0]
                pend_req_serial_num = self.add_cmd(
                    Wait(
                        cmd_runners=pending_names[0],
                        resumers=remote_names[0],
                        exp_resumers=exp_resumers,
                        stopped_remotes=stopped_remotes,
                    )
                )
            elif request_type == st.ReqType.Smart_resume:
                stopped_remotes = remote_names[0]
                pend_req_serial_num = self.add_cmd(
                    Resume(
                        cmd_runners=pending_names[0],
                        targets=remote_names[0],
                        exp_resumed_targets=set(),
                        stopped_remotes=stopped_remotes,
                    )
                )
            else:
                raise InvalidInputDetected(
                    "build_pending_sans_sync_scenario detected invalid "
                    f"input with {request_type=}"
                )

            lm.start_request(pending_names[0])

            pe = self.pending_events[pending_names[0]]
            if request_type == st.ReqType.Smart_recv:
                if not pending_wait_tf:
                    ref_key: CallRefKey = "smart_recv"
                    pe[PE.calling_refresh_msg][ref_key] += 1
            elif request_type == st.ReqType.Smart_wait:
                if pending_msg_count == 0:
                    ref_key = "smart_wait"
                    pe[PE.calling_refresh_msg][ref_key] += 1
            else:
                if pending_msg_count == 0 and not pending_wait_tf:
                    ref_key = request_type.value
                    pe[PE.calling_refresh_msg][ref_key] += 1

            ############################################################
            # release lock to allow smart_req to progress to
            # request_set_up where it waits on the lock
            # locks held:
            # before: lock|smart_req|lock
            # after : lock|smart_req|lock
            ############################################################
            lm.advance_request()

            ############################################################
            # smart_join gets behind lock
            # locks held:
            # before: lock|smart_req|lock
            # after : lock|smart_req|lock|smart_join|lock
            ############################################################
            join_serial_num = self.add_cmd(
                Join(cmd_runners=joiner_names[0], join_names=remote_names[0])
            )
            lm.start_request(joiner_names[0])

            ############################################################
            # release lock to allow smart_req to do request_set_up
            # to get pending_request set, and then wait behind lock_0
            # before going into request loop
            # locks held:
            # before: lock|smart_req|lock|smart_join|lock
            # after : lock|smart_join|lock|smart_req|lock
            ############################################################
            lm.advance_request()

        ################################################################
        # verify results
        ################################################################
        exp_pending_flags = PendingFlags(
            pending_request=pending_request_tf,
            pending_msgs=pending_msg_count,
            pending_wait=pending_wait_tf,
            pending_sync=False,
        )
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyPendingFlags,
                names_to_check=pending_names,
                aux_names=remote_names,
                exp_pending_flags=exp_pending_flags,
                obtain_reg_lock=False,
            )
        )

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures,
                obtain_reg_lock=False,
            )
        )

        self.build_exit_suite(
            cmd_runner=self.commander_name, names=remote_names, validate_config=False
        )

        if pending_request_tf:
            ############################################################
            # release lock to allow smart_join to progress to wait for
            # the lock in its process loop
            # locks held:
            # before: lock|smart_join|lock|smart_req|lock
            # after : lock|smart_req|lock|smart_join
            ############################################################
            lm.advance_request(trailing_lock=False)

            ############################################################
            # swap smart_req and joiner to allow joiner to go first
            # locks held:
            # before: lock|smart_req|lock|smart_join
            # after : lock|smart_join|lock|smart_req
            ############################################################
            lm.swap_requestors()

            ############################################################
            # release lock to allow smart_join to remove remotes
            # locks held:
            # before: lock|smart_join|lock|smart_req
            # after : lock|smart_req
            ############################################################
            lm.complete_request()

        else:
            ############################################################
            # do smart_join, no locks to deal with
            ############################################################
            join_serial_num = self.add_cmd(
                Join(cmd_runners=joiner_names[0], join_names=remote_names[0])
            )

        ################################################################
        # verify results
        ################################################################
        exp_pending_flags = PendingFlags(
            pending_request=pending_request_tf,
            pending_msgs=pending_msg_count,
            pending_wait=pending_wait_tf,
            pending_sync=False,
        )

        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyPendingFlags,
                names_to_check=pending_names,
                aux_names=remote_names,
                exp_pending_flags=exp_pending_flags,
                obtain_reg_lock=False,
            )
        )

        pe = self.pending_events[joiner_names[0]]

        pair_key = st.SmartThread._get_pair_key(pending_names[0], remote_names[0])

        pending_msg_tf: bool = False
        if pending_msg_count > 0:
            pending_msg_tf = True
        if pending_request_tf or pending_msg_tf or pending_wait_tf:
            def_del_reasons: DefDelReasons = DefDelReasons(
                pending_request=pending_request_tf,
                pending_msg=pending_msg_tf,
                pending_wait=pending_wait_tf,
                pending_sync=False,
            )

            rem_sb_key: RemSbKey = (pending_names[0], pair_key, def_del_reasons)

            pe[PE.notify_rem_status_block_def_msg][rem_sb_key] += 1

        if lm.lock_positions:  # if we still hold lock and smart_req
            ############################################################
            # release lock to allow smart_req to complete
            # locks held:
            # before: lock|smart_req
            # after:  None
            ############################################################
            lm.complete_request()

        ################################################################
        # confirm the wait is done
        ################################################################
        if pend_req_serial_num:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd="Wait",
                    confirm_serial_num=pend_req_serial_num,
                    confirmers=pending_names,
                )
            )

        ################################################################
        # confirm the join is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Unregister",
                confirm_serial_num=join_serial_num,
                confirmers=joiner_names,
            )
        )
        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures,
                obtain_reg_lock=False,
            )
        )

    ####################################################################
    # build_pending_sync_only_scenarios
    ####################################################################
    def build_pending_sync_only_scenarios(
        self, pending_msg_count: int, pending_wait_tf: bool, pending_sync_tf: bool
    ) -> None:
        """Return a list of ConfigCmd items for a create.

        Args:
            pending_msg_count: number of msgs to be placed on the
                pending thread
            pending_wait_tf: if True, pending_wait flag is to be set
            pending_sync_tf: if True, pending_sync flag is to be set

        Notes:
            There are two test cases dealing with the pending flags:
            test_pending_sans_sync_scenario:
                this will test combinations for:
                    pending_request: True, False
                    pending_msg: count of 0, 1, 2
                    pending_wait: True, False
                using requests:
                    smart_send
                    smart_recv
                    smart_wait
                    smart_resume

            test_pending_sync_only_scenario:
                this will test combinations for:
                    pending_request: True
                    pending_msg: count of 0, 1, 2
                    pending_wait: True, False
                    pending_sync: True, False
                using requests:
                    smart_sync

            The reason for having two different test cases is that
            pending_sync can only be set with smart_sync, and
            only with pending_request also set.
        """
        self.auto_calling_refresh_msg = False
        pending_names = ["pending_0"]
        remote_names = ["remote_0"]

        locker_names = ["locker_0", "locker_1", "locker_2", "locker_3", "locker_4"]
        lm = LockMgr(config_ver=self, locker_names=locker_names)

        joiner_names = ["joiner_0"]

        active_names: list[str] = (
            pending_names + remote_names + locker_names + joiner_names
        )

        self.create_config(active_names=active_names)

        ################################################################
        # verify all flags off
        ################################################################
        exp_pending_flags = PendingFlags()
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyPendingFlags,
                names_to_check=pending_names,
                aux_names=remote_names,
                exp_pending_flags=exp_pending_flags,
                obtain_reg_lock=False,
            )
        )

        ################################################################
        # handle pending_msg_count
        ################################################################
        msgs_remote_to_pending = SendRecvMsgs(
            sender_names=remote_names,
            receiver_names=pending_names,
            num_msgs=max(1, pending_msg_count),
            text="build_pending_sync_only_scenarios",
        )

        for idx in range(pending_msg_count):
            send_msg_serial_num = self.add_cmd(
                SendMsg(
                    cmd_runners=remote_names,
                    receivers=pending_names,
                    exp_receivers=pending_names,
                    msgs_to_send=msgs_remote_to_pending,
                    msg_idx=idx,
                    send_type=SendType.ToRemotes,
                )
            )
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd="SendMsg",
                    confirm_serial_num=send_msg_serial_num,
                    confirmers=remote_names,
                )
            )

        exp_pending_flags = PendingFlags(pending_msgs=pending_msg_count)
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyPendingFlags,
                names_to_check=pending_names,
                aux_names=remote_names,
                exp_pending_flags=exp_pending_flags,
                obtain_reg_lock=False,
            )
        )

        ################################################################
        # handle pending_wait
        ################################################################
        if pending_wait_tf:
            resume_serial_num = self.add_cmd(
                Resume(
                    cmd_runners=remote_names,
                    targets=pending_names,
                    exp_resumed_targets=pending_names,
                )
            )
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd="Resume",
                    confirm_serial_num=resume_serial_num,
                    confirmers=remote_names,
                )
            )

        exp_pending_flags = PendingFlags(
            pending_msgs=pending_msg_count, pending_wait=pending_wait_tf
        )
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyPendingFlags,
                names_to_check=pending_names,
                aux_names=remote_names,
                exp_pending_flags=exp_pending_flags,
                obtain_reg_lock=False,
            )
        )

        ################################################################
        # start of by getting lock
        # locks held:
        # before: none
        # after : lock
        ################################################################
        lm.get_lock()

        ################################################################
        # pend_sync will get behind lock in _verify_thread_is_current
        # locks held:
        # before: lock
        # after : lock|pend_sync|lovk
        ################################################################
        if pending_sync_tf:
            stopped_remotes: Union[str, set[str]] = set()
            sync_set_ack_remotes: Union[str, set[str]] = remote_names[0]
        else:
            stopped_remotes = remote_names[0]
            sync_set_ack_remotes = set()
        pend_req_serial_num = self.add_cmd(
            Sync(
                cmd_runners=pending_names[0],
                targets=remote_names[0],
                sync_set_ack_remotes=sync_set_ack_remotes,
                stopped_remotes=stopped_remotes,
            )
        )

        lm.start_request(requestor_name=pending_names[0])

        if pending_msg_count == 0 and not pending_wait_tf:
            pe = self.pending_events[pending_names[0]]
            ref_key: CallRefKey = "smart_sync"

            pe[PE.calling_refresh_msg][ref_key] += 1

        ############################################################
        # handle sync case part 1
        ############################################################
        if pending_sync_tf:
            ############################################################
            # remote_sync gets behind lock_1
            # locks held:
            # before: lock|pend_sync|lock
            # after : lock|pend_sync|lock|remote_sync|lock
            ############################################################
            self.add_cmd(
                Sync(
                    cmd_runners=remote_names[0],
                    targets=pending_names[0],
                    sync_set_ack_remotes=pending_names[0],
                    stopped_remotes=set(),
                )
            )
            lm.start_request(requestor_name=remote_names[0])

            ############################################################
            # release lock to get pend_sync to progress to setup
            # behind lock
            # locks held:
            # before: lock|pend_sync|lock|remote_sync|lock
            # after : lock|remote_sync|lock|pend_sync|lock
            ############################################################
            lm.advance_request()

            ############################################################
            # release lock to get remote_sync to progress to setup
            # behind lock
            # locks held:
            # before: lock|remote_sync|lock|pend_sync|lock
            # after : lock|pend_sync|lock|remote_sync|lock
            ############################################################
            lm.advance_request()

            ############################################################
            # release lock to get pend_sync to set its pending_request
            # and then get behind lock just before starting request
            # loop
            # locks held:
            # before: lock|pend_sync|lock|remote_sync|lock
            # after : lock|remote_sync|lock|pend_sync|lock
            ############################################################
            lm.advance_request()

            ############################################################
            # release lock to get remote_sync to set its pending_request
            # and then get behind lock just before starting request loop
            # locks held:
            # before: lock|remote_sync|lock|pend_sync|lock
            # after : lock|pend_sync|lock|remote_sync|lock
            ############################################################
            lm.advance_request()

            ############################################################
            # smart_join gets behind lock
            # locks held:
            # before: lock|pend_sync|lock|remote_sync|lock
            # after : lock|pend_sync|lock|remote_sync|lock|smart_join
            #         |lock
            ############################################################
            join_serial_num = self.add_cmd(
                Join(cmd_runners=joiner_names[0], join_names=remote_names[0])
            )
            lm.start_request(requestor_name=joiner_names[0])

            ############################################################
            # release lock to get pend_sync to set sync flag for
            # remote_sync and then get behind lock (because its sync
            # flag is not yet set by remote_sync)
            # locks held:
            # before: lock|pend_sync|lock|remote_sync|lock|smart_join
            #         |lock
            # after : lock|remote_sync|lock|smart_join|lock|pend_sync
            #         |lock
            ############################################################
            lm.advance_request()

            ############################################################
            # release lock to allow remote_sync to set sync flag for
            # pend_sync and complete the request
            # locks held:
            # before: lock|remote_sync|lock|smart_join|lock|pend_sync
            #         |lock
            # after : lock|smart_join|lock|pend_sync|lock
            ############################################################
            lm.complete_request()

        else:
            ############################################################
            # release lock to allow pend_sync to progress to start of
            # request_set_up behind lock
            # before: lock|pend_sync|lock
            # after : lock|pend_sync|lock
            ############################################################
            lm.advance_request()

            ############################################################
            # smart_join gets behind lock
            # locks held:
            # before: lock|pend_sync|lock
            # after : lock|pend_sync|lock|smart_join|lock
            ############################################################
            join_serial_num = self.add_cmd(
                Join(cmd_runners=joiner_names[0], join_names=remote_names[0])
            )
            lm.start_request(joiner_names[0])

            ############################################################
            # release lock to allow pend_sync to do request_set_up
            # to get pending_request set, and then wait behind lock
            # before going into request loop
            # before: lock|pend_sync|lock|smart_join|lock
            # after : lock|smart_join|lock|pend_sync|lock
            ############################################################
            lm.advance_request()

        ################################################################
        # verify results
        ################################################################
        exp_pending_flags = PendingFlags(
            pending_request=True,
            pending_msgs=pending_msg_count,
            pending_wait=pending_wait_tf,
            pending_sync=pending_sync_tf,
        )
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyPendingFlags,
                names_to_check=pending_names,
                aux_names=remote_names,
                exp_pending_flags=exp_pending_flags,
                obtain_reg_lock=False,
            )
        )

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures,
                obtain_reg_lock=False,
            )
        )

        self.build_exit_suite(
            cmd_runner=self.commander_name, names=remote_names, validate_config=False
        )

        ################################################################
        # release lock to allow smart_join to progress to start of loop
        # behind lock
        # before: lock|smart_join|lock|pend_sync|lock
        # after : lock|pend_sync|lock|smart_join
        ################################################################
        lm.advance_request(trailing_lock=False)

        ################################################################
        # before: lock|pend_sync|lock|smart_join
        # action: swap pend_sync and smart_join
        # after : lock|smart_join|lock|pend_sync
        ################################################################
        lm.swap_requestors()

        ############################################################
        # release lock to allow smart_join to remove remote_sync
        # before: lock|smart_join|lock|pend_sync
        # after : lock|pend_sync
        ############################################################
        lm.complete_request()

        ################################################################
        # verify results
        ################################################################
        exp_pending_flags = PendingFlags(
            pending_request=True,
            pending_msgs=pending_msg_count,
            pending_wait=pending_wait_tf,
            pending_sync=pending_sync_tf,
        )
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyPendingFlags,
                names_to_check=pending_names,
                aux_names=remote_names,
                exp_pending_flags=exp_pending_flags,
                obtain_reg_lock=False,
            )
        )

        pe = self.pending_events[joiner_names[0]]

        pair_key = st.SmartThread._get_pair_key(pending_names[0], remote_names[0])

        pending_msg_tf: bool = False
        if pending_msg_count > 0:
            pending_msg_tf = True
        def_del_reasons: DefDelReasons = DefDelReasons(
            pending_request=True,
            pending_msg=pending_msg_tf,
            pending_wait=pending_wait_tf,
            pending_sync=pending_sync_tf,
        )

        rem_sb_key: RemSbKey = (pending_names[0], pair_key, def_del_reasons)

        pe[PE.notify_rem_status_block_def_msg][rem_sb_key] += 1

        if lm.lock_positions:  # if we still hold lock_2
            ############################################################
            # release lock to allow pend_sync to complete
            # before: lock|pend_sync
            # after :
            ############################################################
            lm.complete_request()

        ################################################################
        # confirm the pend_sync is done
        ################################################################
        if pend_req_serial_num:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd="Wait",
                    confirm_serial_num=pend_req_serial_num,
                    confirmers=pending_names,
                )
            )

        ################################################################
        # confirm the join is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Join",
                confirm_serial_num=join_serial_num,
                confirmers=joiner_names,
            )
        )

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures,
                obtain_reg_lock=True,
            )
        )

    ####################################################################
    # build_remove_reasons_scenarios
    ####################################################################
    def build_remove_reasons_scenarios(
        self, pending_msg_count: int, pending_wait_tf: bool, pending_sync_tf: bool
    ) -> None:
        """Return a list of ConfigCmd items for a create.

        Args:
            pending_msg_count: number of msgs to be placed on the
                pending thread
            pending_wait_tf: if True, pending_wait flag is to be set
            pending_sync_tf: if True, pending_sync flag is to be set

        """
        self.auto_calling_refresh_msg = False
        pending_names = ["pending_0"]
        remote_names = ["remote_0"]

        locker_names = ["locker_0", "locker_1", "locker_2", "locker_3", "locker_4"]
        lm = LockMgr(config_ver=self, locker_names=locker_names)

        joiner_names = ["joiner_0"]

        active_names: list[str] = (
            pending_names + remote_names + locker_names + joiner_names
        )

        self.create_config(active_names=active_names)

        pending_name = pending_names[0]
        remote_name = remote_names[0]
        joiner_name = joiner_names[0]

        join_serial_num: int = 0

        ################################################################
        # verify all flags off
        ################################################################
        exp_pending_flags = PendingFlags()
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyPendingFlags,
                names_to_check=pending_name,
                aux_names=remote_name,
                exp_pending_flags=exp_pending_flags,
                obtain_reg_lock=False,
            )
        )

        ################################################################
        # handle pending_msg_count
        ################################################################
        msgs_remote_to_pending = SendRecvMsgs(
            sender_names=remote_name,
            receiver_names=pending_name,
            num_msgs=max(1, pending_msg_count),
            text="build_remove_reasons_scenarios",
        )

        for idx in range(pending_msg_count):
            send_msg_serial_num = self.add_cmd(
                SendMsg(
                    cmd_runners=remote_name,
                    receivers=pending_name,
                    exp_receivers=pending_name,
                    msgs_to_send=msgs_remote_to_pending,
                    msg_idx=idx,
                    send_type=SendType.ToRemotes,
                )
            )
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd="SendMsg",
                    confirm_serial_num=send_msg_serial_num,
                    confirmers=remote_name,
                )
            )

        exp_pending_flags = PendingFlags(pending_msgs=pending_msg_count)
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyPendingFlags,
                names_to_check=pending_name,
                aux_names=remote_name,
                exp_pending_flags=exp_pending_flags,
                obtain_reg_lock=False,
            )
        )

        ################################################################
        # handle pending_wait
        ################################################################
        if pending_wait_tf:
            resume_serial_num = self.add_cmd(
                Resume(
                    cmd_runners=remote_name,
                    exp_resumed_targets=pending_name,
                    targets=pending_name,
                )
            )
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd="Resume",
                    confirm_serial_num=resume_serial_num,
                    confirmers=remote_name,
                )
            )

        exp_pending_flags = PendingFlags(
            pending_msgs=pending_msg_count, pending_wait=pending_wait_tf
        )
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyPendingFlags,
                names_to_check=pending_name,
                aux_names=remote_name,
                exp_pending_flags=exp_pending_flags,
                obtain_reg_lock=False,
            )
        )

        ################################################################
        # handle pending_sync
        ################################################################
        sync_serial_num = 0
        if pending_sync_tf:
            ############################################################
            # start of by getting lock
            # locks held:
            # before: none
            # after : lock
            ############################################################
            lm.get_lock()

            ############################################################
            # remote smart_sync will get behind lock in
            # _verify_thread_is_current
            # locks held:
            # before: lock
            # after : lock|smart_sync|lock
            ############################################################
            sync_serial_num = self.add_cmd(
                Sync(
                    cmd_runners=remote_name,
                    targets=pending_name,
                    sync_set_ack_remotes=set(),
                    stopped_remotes=pending_name,
                )
            )

            lm.start_request(remote_name)

            # Normally, handle_request_smart_sync_entry will set up the
            # ack msg when the target_rtn is not included in the set of
            # stopped_remotes. In this case, we know the sync flag will
            # be set for the pending_name, but we include it in the set
            # of stopped_remotes. So, we need to set up the ack msg
            # here.
            pe = self.pending_events[remote_name]

            ack_key: AckKey = (pending_name, "smart_sync_set")

            pe[PE.ack_msg][ack_key] += 1

            # smart_sync will eventually see that it was delete deferred
            # while it was behind the lock when pending_name was joined.
            # So, we need to indicate that the smart_sync will do a
            # refresh.

            pe = self.pending_events[remote_name]
            ref_key: CallRefKey = "smart_sync"
            pe[PE.calling_refresh_msg][ref_key] += 1

            ############################################################
            # release lock to allow smart_sync to do progress to
            # lock in request_set_up
            # locks held:
            # before: lock|smart_sync|lock
            # after : lock|smart_sync|lock
            ############################################################
            lm.advance_request()

            ############################################################
            # smart_join gets behind lock in _verify_thread_is_current
            # locks held:
            # before: lock|smart_sync|lock
            # after : lock|smart_sync|lock|smart_join|lock
            ############################################################
            join_serial_num = self.add_cmd(
                Join(cmd_runners=joiner_name, join_names=pending_name)
            )
            lm.start_request(joiner_name)

            ############################################################
            # release lock to allow smart_sync to do request_set_up
            # to get pending_request set, and then wait behind lock
            # before going into request loop
            # locks held:
            # before: lock|smart_sync|lock|smart_join|lock
            # after : lock|smart_join|lock|smart_sync|lock
            ############################################################
            lm.advance_request()

            ############################################################
            # release lock to allow smart_join to progress to loop
            # locks held:
            # before: lock|smart_join|lock|smart_sync|lock
            # after : lock|smart_sync|lock|smart_join|lock
            ############################################################
            lm.advance_request()

            ############################################################
            # release lock to allow smart_sync to set the sync flag in
            # pending_name and then get behind lock
            # locks held:
            # before: lock|smart_sync|lock|smart_join|lock
            # after : lock|smart_join|lock|smart_sync
            ############################################################
            lm.advance_request(trailing_lock=False)

            pair_key = st.SmartThread._get_pair_key(remote_name, pending_name)
            check_pend_arg: CheckPendArg = (pending_name, pair_key)
            self.add_cmd(
                WaitForCondition(
                    cmd_runners=self.commander_name,
                    check_rtn=self.check_sync_event_set,
                    check_args=check_pend_arg,
                )
            )

        ################################################################
        # verify the pending flags are as expected before we do the join
        ################################################################
        exp_pending_flags = PendingFlags(
            pending_msgs=pending_msg_count,
            pending_wait=pending_wait_tf,
            pending_sync=pending_sync_tf,
        )
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyPendingFlags,
                names_to_check=pending_name,
                aux_names=remote_name,
                exp_pending_flags=exp_pending_flags,
                obtain_reg_lock=False,
            )
        )

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures,
                obtain_reg_lock=False,
            )
        )

        ################################################################
        # remove the pending thread
        ################################################################
        self.build_exit_suite(
            cmd_runner=self.commander_name, names=pending_name, validate_config=False
        )

        if pending_sync_tf:
            ############################################################
            # release lock to allow smart_join to remove remotes
            # locks held:
            # before: lock|smart_join|lock|smart_sync
            # after : lock|smart_sync
            ############################################################
            lm.complete_request()

            ############################################################
            # release lock to allow smart_sync to complete
            # locks held:
            # before: lock|smart_sync
            # after : none
            ############################################################
            lm.complete_request()

            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd="Sync",
                    confirm_serial_num=sync_serial_num,
                    confirmers=remote_name,
                )
            )
        else:
            ############################################################
            # do smart_join, no locks to deal with
            ############################################################
            join_serial_num = self.add_cmd(
                Join(cmd_runners=joiner_name, join_names=pending_name)
            )

        pe = self.pending_events[joiner_name]

        pair_key = st.SmartThread._get_pair_key(pending_name, remote_name)

        pending_msg_tf: bool = False
        if pending_msg_count > 0:
            pending_msg_tf = True

        def_del_reasons: DefDelReasons = DefDelReasons(
            pending_request=False,
            pending_msg=pending_msg_tf,
            pending_wait=pending_wait_tf,
            pending_sync=pending_sync_tf,
        )

        rem_sb_key: RemSbKey = (pending_name, pair_key, def_del_reasons)

        pe[PE.notify_rem_status_block_msg][rem_sb_key] += 1

        ################################################################
        # confirm the join is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Join",
                confirm_serial_num=join_serial_num,
                confirmers=joiner_names,
            )
        )

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures,
                obtain_reg_lock=True,
            )
        )

    ####################################################################
    # build_backout_sync_remote_scenario
    ####################################################################
    def build_backout_sync_remote_scenario(self, num_pending: int) -> None:
        """Return a list of ConfigCmd items for sync backout scenario.

        Args:
            num_pending: number of threads that will be backed out

        Notes:
            1) The first pending thread will be stopped to cause the
               backout to happen in the _process_sync method, and any
               additional pending threads will not be stopped and will
               be backed out in the _sync_wait_error_cleanup method

        """
        self.auto_sync_ach_or_back_msg = False

        pending_names = get_names("pending_", num_pending)
        remote_names = ["remote_0"]
        joiner_names = ["joiner_0"]

        active_names: list[str] = list(pending_names) + remote_names + joiner_names

        self.create_config(active_names=active_names)

        pending_name = "pending_0"
        remote_name = remote_names[0]
        joiner_name = joiner_names[0]

        timeout_remotes = pending_names - {pending_name}

        ################################################################
        # verify all flags off
        ################################################################
        exp_pending_flags = PendingFlags()
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyPendingFlags,
                names_to_check=pending_names,
                aux_names=remote_name,
                exp_pending_flags=exp_pending_flags,
                obtain_reg_lock=False,
            )
        )

        ################################################################
        # issue the sync to set sync_flag for pending_name
        ################################################################
        sync_serial_num = self.add_cmd(
            Sync(
                cmd_runners=remote_name,
                targets=pending_names,
                timeout_remotes=timeout_remotes,
                sync_set_ack_remotes=pending_names,
                stopped_remotes=pending_name,
            )
        )

        ################################################################
        # wait for the pending_sync flag to be set in mock structures
        ################################################################
        for pending in pending_names:
            pair_key = st.SmartThread._get_pair_key(remote_name, pending)
            check_pend_arg: CheckPendArg = (pending, pair_key)
            self.add_cmd(
                WaitForCondition(
                    cmd_runners=self.commander_name,
                    check_rtn=self.check_sync_event_set,
                    check_args=check_pend_arg,
                )
            )

        ################################################################
        # verify the pending flags are as expected before we do the join
        ################################################################
        exp_pending_flags = PendingFlags(pending_sync=True)
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyPendingFlags,
                names_to_check=pending_names,
                aux_names=remote_name,
                exp_pending_flags=exp_pending_flags,
                obtain_reg_lock=False,
            )
        )

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures,
                obtain_reg_lock=False,
            )
        )

        ################################################################
        # remove the pending thread to cause the backout
        ################################################################
        self.build_exit_suite(
            cmd_runner=self.commander_name, names=pending_name, validate_config=False
        )

        pe = self.pending_events[remote_name]

        for pending in pending_names:
            ack_key: AckKey = (pending, "smart_sync_backout_remote")

            pe[PE.ack_msg][ack_key] += 1

        ################################################################
        # confirm the sync is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Sync",
                confirm_serial_num=sync_serial_num,
                confirmers=remote_name,
            )
        )

        ################################################################
        # do smart_join
        ################################################################
        join_serial_num = self.add_cmd(
            Join(cmd_runners=joiner_name, join_names=pending_name)
        )

        pe = self.pending_events[joiner_name]
        # pe = self.pending_events[pending_name]

        pair_key = st.SmartThread._get_pair_key(pending_name, remote_name)

        # we expect no reasons
        def_del_reasons: DefDelReasons = DefDelReasons()

        rem_sb_key: RemSbKey = (pending_name, pair_key, def_del_reasons)

        pe[PE.notify_rem_status_block_msg][rem_sb_key] += 1

        ################################################################
        # confirm the join is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Join",
                confirm_serial_num=join_serial_num,
                confirmers=joiner_names,
            )
        )

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures,
                obtain_reg_lock=True,
            )
        )

    ####################################################################
    # build_backout_sync_local_scenario
    ####################################################################
    def build_backout_sync_local_scenario(self) -> None:
        """Return a list of ConfigCmd items for a create."""
        self.auto_sync_ach_or_back_msg = False

        pending_names = ["pending_0"]
        remote_names = ["remote_0"]

        locker_names = ["locker_0", "locker_1", "locker_2", "locker_3", "locker_4"]
        lm = LockMgr(config_ver=self, locker_names=locker_names)

        active_names: list[str] = pending_names + remote_names + locker_names

        self.create_config(active_names=active_names)

        pending_name = pending_names[0]
        remote_name = remote_names[0]

        timeout_time: IntOrFloat = 2
        pause_time: IntOrFloat = timeout_time * 1.5

        ################################################################
        # verify all flags off
        ################################################################
        exp_pending_flags = PendingFlags()
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyPendingFlags,
                names_to_check=pending_name,
                aux_names=remote_name,
                exp_pending_flags=exp_pending_flags,
                obtain_reg_lock=False,
            )
        )

        ################################################################
        # start off by getting lock_0
        # locks held:
        # before: none
        # after : lock_0
        ################################################################
        lm.get_lock()

        ################################################################
        # before: lock
        # remote_sync will get behind lock in _verify_thread_is_current
        # after : lock|remote_sync_vt|lock
        ################################################################
        remote_sync_serial_num = self.add_cmd(
            SyncTimeoutTrue(
                cmd_runners=remote_name,
                targets=pending_name,
                sync_set_ack_remotes=pending_name,
                timeout=timeout_time,
                timeout_remotes=pending_name,
            )
        )

        lm.start_request(remote_name)

        ################################################################
        # before: lock|remote_sync_vt|lock
        # remote_sync will get behind lock in request_setup
        # after : lock|remote_sync_rs|lock
        # should see smart_sync entry for remote_0
        ################################################################
        lm.advance_request()

        ################################################################
        # pend_sync will get behind lock in _verify_thread_is_current
        # locks held:
        # before: lock|remote_sync_rs|lock
        # after : lock|remote_sync_rs|lock|pend_sync_vt|lock
        ################################################################
        pend_sync_serial_num = self.add_cmd(
            Sync(
                cmd_runners=pending_name,
                targets=remote_name,
                sync_set_ack_remotes=remote_name,
            )
        )

        lm.start_request(pending_name)

        ################################################################
        # remote_sync will do setup and progress to start of request
        # loop
        # locks held:
        # before: lock|remote_sync_rs|lock|pend_sync_vt|lock
        # after : lock|pend_sync_vt|lock|remote_sync_rl|lock
        # should see remote_0 smart_sync setup complete
        ################################################################
        lm.advance_request()

        ################################################################
        # pend_sync will progress to setup
        # locks held:
        # before: lock|pend_sync_vt|lock|remote_sync_rl|lock
        # after : lock|remote_sync_rl|lock|pend_sync_rs|lock
        # should see smart_sync entry for pending_0
        ################################################################
        lm.advance_request()

        ################################################################
        # release lock to allow remote_sync to enter the request loop
        # and set the pending_name sync flag, and then get behind lock
        # before doing a second loop lap
        # locks held:
        # before: lock|remote_sync_rl|lock|pend_sync_rs|lock
        # after : lock|pend_sync_rs|lock|remote_sync_rl2|lock
        # should see remote_0 (test1) smart_sync set flag for pending_0
        ################################################################
        lm.advance_request()

        ################################################################
        # release lock to allow pend_sync to do setup and then wait
        # behind lock just before entering request loop
        # locks held:
        # before: lock|pend_sync_rs|lock|remote_sync_rl2|lock
        # after : lock|remote_sync_rl2|lock|pend_sync_rl|lock
        # should see pending_0 (test1) smart_sync setup complete
        ################################################################
        lm.advance_request()

        ################################################################
        # pause to cause remote_sync to timeout
        ################################################################
        self.add_cmd(Pause(cmd_runners=self.commander_name, pause_seconds=pause_time))

        ################################################################
        # release lock to allow remote_sync to enter the request loop
        # and see no progress from the pending_name, and then
        # timeout and get behind lock just before sync backout
        # locks held:
        # before: lock|remote_sync_rl2|lock|pend_sync_rl|lock
        # after : lock|pend_sync_rl|lock|remote_sync_sb
        ################################################################
        lm.advance_request(trailing_lock=False)

        ################################################################
        # release lock to allow pend_sync to enter the request loop
        # and set sync event for remote_sync and see that its sync event
        # is set and complete the sync request
        # locks held:
        # before: lock|pend_sync_rl|lock|remote_sync_sb
        # after : lock|remote_sync_sb
        # should see pending_0 (test1) smart_sync set flag for remote_0
        # and pending_0 (test1) smart_sync achieved with remote_0
        # and smart_sync exit: requestor: pending_0
        ################################################################
        lm.complete_request()

        ################################################################
        # Set the ack message for the completed sync by pend_sync.
        ################################################################
        pe = self.pending_events[pending_name]
        ack_key: AckKey = (remote_name, "smart_sync_achieved")

        pe[PE.ack_msg][ack_key] += 1

        ################################################################
        # release lock to allow remote_sync to enter the backout
        # routine to reset its sync event flag
        # locks held:
        # before: lock|remote_sync_sb
        # after : none
        # should see remote_0 (test1) smart_sync backout reset local
        # sync_flag for pending_0
        # and remote_0 (test1) raising SmartThreadRequestTimedOut
        ################################################################
        lm.complete_request()

        ################################################################
        # We also need to set the ack message for the backout.
        ################################################################
        pe = self.pending_events[remote_name]
        ack_key = (pending_name, "smart_sync_backout_local")

        pe[PE.ack_msg][ack_key] += 1

        ################################################################
        # verify the pending flags are as expected
        ################################################################
        exp_pending_flags = PendingFlags()
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyPendingFlags,
                names_to_check=pending_name,
                aux_names=remote_name,
                exp_pending_flags=exp_pending_flags,
                obtain_reg_lock=False,
            )
        )

        exp_pending_flags = PendingFlags()
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyPendingFlags,
                names_to_check=remote_name,
                aux_names=pending_name,
                exp_pending_flags=exp_pending_flags,
                obtain_reg_lock=False,
            )
        )

        ################################################################
        # confirm the remote_sync is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="SyncTimeoutTrue",
                confirm_serial_num=remote_sync_serial_num,
                confirmers=remote_name,
            )
        )

        ################################################################
        # confirm the pend_sync is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Sync",
                confirm_serial_num=pend_sync_serial_num,
                confirmers=pending_name,
            )
        )

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures,
                obtain_reg_lock=True,
            )
        )

    ####################################################################
    # build_send_unreg_receiver_scenario
    ####################################################################
    def build_send_unreg_receiver_scenario(self) -> None:
        """Return a list of ConfigCmd items for test scenario."""
        sender_names = get_names("sender_", 1)
        receiver_names = get_names("receiver_", 1)

        self.create_config(active_names=sender_names | receiver_names)

        ################################################################
        # setup the messages to send
        ################################################################
        sender_msgs = SendRecvMsgs(
            sender_names=sender_names,
            receiver_names=receiver_names,
            num_msgs=1,
            text="build_send_unreg_receiver_scenario",
        )

        ################################################################
        # receiver issues resume of sender to get sender del def
        ################################################################
        resume_serial_num = self.add_cmd(
            Resume(
                cmd_runners=receiver_names,
                targets=sender_names,
                exp_resumed_targets=sender_names,
            )
        )

        ################################################################
        # confirm the resume is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Resume",
                confirm_serial_num=resume_serial_num,
                confirmers=receiver_names,
            )
        )

        ################################################################
        # remove the receiver
        ################################################################
        self.build_exit_suite(
            cmd_runner=self.commander_name, names=receiver_names, validate_config=False
        )

        self.add_cmd(Join(cmd_runners=self.commander_name, join_names=receiver_names))

        ################################################################
        # issue the send to drive the path in _get_target_state that
        # sees receiver is not in the registry and it's pk_remote
        # create_time is zero, so it returns ThreadState.Unregistered
        ################################################################
        send_serial_num = self.add_cmd(
            SendMsgTimeoutTrue(
                cmd_runners=sender_names,
                receivers=receiver_names,
                exp_receivers=set(),
                timeout=1,
                unreg_timeout_names=receiver_names,
                fullq_timeout_names=set(),
                msgs_to_send=sender_msgs,
                msg_idx=0,
            )
        )

        ################################################################
        # confirm the send is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="SendMsgTimeoutTrue",
                confirm_serial_num=send_serial_num,
                confirmers=sender_names,
            )
        )

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures,
                obtain_reg_lock=True,
            )
        )

    ####################################################################
    # build_join_simple_timeout_scenario
    ####################################################################
    def build_join_simple_timeout_scenario(self) -> None:
        """Return a list of ConfigCmd items for test scenario."""
        target_names = get_names("target_", 1)
        joiner_names = get_names("joiner_", 1)

        self.create_config(reg_names=target_names, active_names=joiner_names)

        timeout_time = 0.5
        ################################################################
        # join
        ################################################################
        join_serial_num = self.add_cmd(
            JoinTimeoutTrue(
                cmd_runners=joiner_names,
                join_names=target_names,
                timeout=timeout_time,
                timeout_names=target_names,
            )
        )

        ################################################################
        # confirm the join is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="JoinTimeoutTrue",
                confirm_serial_num=join_serial_num,
                confirmers=joiner_names,
            )
        )

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures,
                obtain_reg_lock=True,
            )
        )

    ####################################################################
    # build_wait_simple_deadlock_scenario
    ####################################################################
    def build_wait_simple_deadlock_scenario(self) -> None:
        """Return a list of ConfigCmd items for test scenario."""
        waiter_names = get_names("waiter_", 2)

        self.create_config(active_names=waiter_names)

        ################################################################
        # waiter_0
        ################################################################
        wait_0_serial_num = self.add_cmd(
            Wait(
                cmd_runners="waiter_0",
                resumers="waiter_1",
                exp_resumers=set(),
                deadlock_remotes="waiter_1",
            )
        )

        ################################################################
        # waiter_1
        ################################################################
        wait_1_serial_num = self.add_cmd(
            Wait(
                cmd_runners="waiter_1",
                resumers="waiter_0",
                exp_resumers=set(),
                deadlock_remotes="waiter_0",
            )
        )

        ################################################################
        # confirm the wait_0 is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Wait",
                confirm_serial_num=wait_0_serial_num,
                confirmers="waiter_0",
            )
        )

        ################################################################
        # confirm the wait_1 is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Wait",
                confirm_serial_num=wait_1_serial_num,
                confirmers="waiter_1",
            )
        )

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures,
                obtain_reg_lock=True,
            )
        )

    ####################################################################
    # build_sync_unreg_simple_scenario
    ####################################################################
    def build_sync_unreg_simple_scenario(self) -> None:
        """Return a list of ConfigCmd items for test scenario."""
        self.create_config(reg_names={"sync_0"}, active_names={"sync_1"})

        timeout_time = 0.5
        ################################################################
        # waiter_0
        ################################################################
        sync_1_serial_num = self.add_cmd(
            SyncTimeoutTrue(
                cmd_runners="sync_1",
                targets="sync_0",
                timeout=timeout_time,
                timeout_remotes="sync_0",
                sync_set_ack_remotes=set(),
            )
        )

        ################################################################
        # confirm the wait_1 is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="SyncTimeoutTrue",
                confirm_serial_num=sync_1_serial_num,
                confirmers="sync_1",
            )
        )

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures,
                obtain_reg_lock=True,
            )
        )

    ####################################################################
    # build_sync_init_delay_scenario
    ####################################################################
    def build_sync_init_delay_scenario(self) -> None:
        """Return a list of ConfigCmd items for test scenario.

        This test will drive the check of the create time for zero:

            1) create sync_0
            2) get lock
            3) sync_0 does smart_sync with sync_1
            4) get lock
            5) create sync_1 (swap sync_0 and sync_1 to keep sync_0
               from advancing, so it maintains a zero create time for
               sync_1 in its pk_remote)
            6) sync_1 does smart_sync - sees sync_0 has zero create
               time for sync_1, and therefore succeeds in doing the sync

        """
        # self.auto_calling_refresh_msg = False
        sync_names = ["sync_0", "sync_1"]

        locker_names = ["locker_0", "locker_1", "locker_2", "locker_3", "locker_4"]
        lm = LockMgr(config_ver=self, locker_names=locker_names)

        aux_names = ["aux_0"]

        self.create_config(
            unreg_names=[sync_names[1]],
            active_names=([sync_names[0]] + locker_names + aux_names),
        )

        ################################################################
        # The following are appended to the requestor names:
        #     _v means request is behind lock in
        #        _verify_thread_is_current
        #     _s means request is behind lock just before request setup
        #     _r means request is behind lock just before request loop
        #     _e means request is behind lock in error path
        #     -reg means register for smart_init
        ################################################################

        ################################################################
        # before: none
        # action: get lock
        # after : lock
        ################################################################
        lm.get_lock()

        ################################################################
        # before: lock
        # action: sync_0a
        # after : lock|sync_0a_v|lock
        ################################################################
        sync_0a_serial_num = self.add_cmd(
            Sync(
                cmd_runners=sync_names[0],
                targets=sync_names[1],
                sync_set_ack_remotes=sync_names[1],
            )
        )
        lm.start_request(sync_names[0])

        ################################################################
        # before: lock|sync_0a_v|lock
        # action: drop lock, sync_0 does verify and wait at setup
        # after : lock_0|sync_0a_s|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_0a_s|lock
        # action: drop lock, sync_0 does setup, waits at req loop
        # after : lock_0|sync_0a_r|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_0a_r|lock
        # action: create and start sync_1
        # after : lock|sync_0a_r|lock|aux_0_reg|lock
        ################################################################
        self.unregistered_names -= {sync_names[1]}
        self.add_cmd(
            CreateF1AutoStart(
                cmd_runners=aux_names[0],
                f1_create_items=[
                    F1CreateItem(
                        name=sync_names[1],
                        auto_start=True,
                        target_rtn=outer_f1,
                        app_config=AppConfig.ScriptStyle,
                    )
                ],
            )
        )

        self.active_names |= {sync_names[1]}

        lm.start_request(aux_names[0])

        ################################################################
        # before: lock|sync_0a_r|lock|aux_0_reg|lock
        # action: swap sync_0 and aux_0_reg
        # after : lock|aux_0_reg|lock|sync_0a_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|aux_0_reg|lock|sync_0a_r|lock
        # action: drop lock, aux_0 does register, then goes to
        #             smart_start setup
        # after : lock|sync_0a_r|lock|aux_0_s|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_0a_r|lock|aux_0_s|lock
        # action: swap sync_0 and aux_0_s
        # after : lock|aux_0_s|lock|sync_0a_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|aux_0_s|lock|sync_0a_r|lock
        # action: drop lock, aux_0 completes smart_start
        # after : lock|sync_0a_r|lock
        ################################################################
        lm.complete_request()

        ################################################################
        # before: lock|sync_0a_r|lock
        # action: sync_1a_s
        # after : lock|sync_0a_r|lock|sync_1a_v|lock
        ################################################################
        sync_1a_serial_num = self.add_cmd(
            Sync(
                cmd_runners=sync_names[1],
                targets=sync_names[0],
                sync_set_ack_remotes=sync_names[0],
            )
        )
        lm.start_request(sync_names[1])

        ################################################################
        # before: lock|sync_0a_r|lock|sync_1a_v|lock
        # action: swap sync_0 and sync_1a_v
        # after : lock|sync_1a_v|lock|sync_0a_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|sync_1a_v|lock|sync_0a_r|lock
        # action: swap sync_0 and sync_1a_v
        # after : lock|sync_0a_r|lock||sync_1a_s|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_0a_r|lock|sync_1a_s|lock
        # action: swap sync_0 and sync_1a_s
        # after : lock|sync_1a_s|lock|sync_0a_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|sync_1a_s|lock|sync_0a_r|lock
        # action: drop lock, sync_1a_s completes setup and gets
        #             behind lock in req loop
        # after : lock|sync_0a_r|lock|sync_1a_r|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_0a_r|lock|sync_1a_r|lock
        # action: swap sync_0a and sync_1a_s
        # after : lock|sync_1a_r|lock|sync_0a_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # verify sync_0 has zero create time for sync_1
        ################################################################
        check_pend_arg: CheckZeroCtArg = (sync_names[0], sync_names[1])
        self.add_cmd(
            WaitForCondition(
                cmd_runners=self.commander_name,
                check_rtn=self.check_sync_zero_create_time,
                check_args=check_pend_arg,
            )
        )

        ################################################################
        # before: lock|sync_1a_r|lock|sync_0a_r|lock
        # action: drop lock, sync_1a_r sees sync_0 has zero create
        #             time for sync_1, so sync_1 sets sync_0 sync_flag
        #             and loops back to top of req loop to let sync_0
        #             sync up
        # after : lock|sync_0a_r|lock|sync_1a_r
        ################################################################
        lm.advance_request(trailing_lock=False)

        ################################################################
        # before: lock|sync_0a_r|lock|sync_1a_r
        # action: drop lock, sync_0 sees that sync_1 is alive and
        #             sets sync_1 sync_flag, sees its sync_flag is
        #             set and completes the sync request
        # after : lock|sync_1a_r
        ################################################################
        lm.complete_request()

        ################################################################
        # before: lock|sync_1a_r
        # action: drop lock, sync_1 sees sync_0 has set sync_1
        #             sync and completes
        # after : none
        ################################################################
        lm.complete_request()

        ################################################################
        # confirm the sync requests
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Sync",
                confirm_serial_num=sync_0a_serial_num,
                confirmers=sync_names[0],
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Sync",
                confirm_serial_num=sync_1a_serial_num,
                confirmers=sync_names[1],
            )
        )

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures,
                obtain_reg_lock=True,
            )
        )

    ####################################################################
    # build_sync_partial_scenario
    ####################################################################
    def build_sync_partial_scenario(
        self,
        sync_0_targets: int,
        sync_1_targets: int,
        sync_2_targets: int,
        sync_3_targets: int,
    ) -> None:
        """Return a list of ConfigCmd items for test scenario."""
        sync_names = ["sync_0", "sync_1", "sync_2", "sync_3"]

        self.create_config(active_names=sync_names)

        targets: dict[int, set[str]] = {
            1: {"sync_0"},
            2: {"sync_1"},
            3: {"sync_1", "sync_0"},
            4: {"sync_2"},
            5: {"sync_2", "sync_0"},
            6: {"sync_2", "sync_1"},
            7: {"sync_2", "sync_1", "sync_0"},
            8: {"sync_3"},
            9: {"sync_3", "sync_0"},
            10: {"sync_3", "sync_1"},
            11: {"sync_3", "sync_1", "sync_0"},
            12: {"sync_3", "sync_2"},
            13: {"sync_3", "sync_2", "sync_0"},
            14: {"sync_3", "sync_2", "sync_1"},
            15: {"sync_3", "sync_2", "sync_1", "sync_0"},
        }

        sync_0_target_set = targets[sync_0_targets].copy()
        sync_1_target_set = targets[sync_1_targets].copy()
        sync_2_target_set = targets[sync_2_targets].copy()
        sync_3_target_set = targets[sync_3_targets].copy()

        if "sync_0" in sync_1_target_set:
            sync_0_target_set |= {"sync_1"}
        if "sync_0" in sync_2_target_set:
            sync_0_target_set |= {"sync_2"}
        if "sync_0" in sync_3_target_set:
            sync_0_target_set |= {"sync_3"}

        if "sync_1" in sync_0_target_set:
            sync_1_target_set |= {"sync_0"}
        if "sync_1" in sync_2_target_set:
            sync_1_target_set |= {"sync_2"}
        if "sync_1" in sync_3_target_set:
            sync_1_target_set |= {"sync_3"}

        if "sync_2" in sync_0_target_set:
            sync_2_target_set |= {"sync_0"}
        if "sync_2" in sync_1_target_set:
            sync_2_target_set |= {"sync_1"}
        if "sync_2" in sync_3_target_set:
            sync_2_target_set |= {"sync_3"}

        if "sync_3" in sync_0_target_set:
            sync_3_target_set |= {"sync_0"}
        if "sync_3" in sync_1_target_set:
            sync_3_target_set |= {"sync_1"}
        if "sync_3" in sync_2_target_set:
            sync_3_target_set |= {"sync_2"}

        ################################################################
        # sync_0
        ################################################################
        sync_0_serial_num = self.add_cmd(
            Sync(
                cmd_runners="sync_0",
                targets=sync_0_target_set,
                sync_set_ack_remotes=sync_0_target_set,
            )
        )

        ################################################################
        # sync_1
        ################################################################
        sync_1_serial_num = self.add_cmd(
            Sync(
                cmd_runners="sync_1",
                targets=sync_1_target_set,
                sync_set_ack_remotes=sync_1_target_set,
            )
        )

        ################################################################
        # sync_2
        ################################################################
        sync_2_serial_num = self.add_cmd(
            Sync(
                cmd_runners="sync_2",
                targets=sync_2_target_set,
                sync_set_ack_remotes=sync_2_target_set,
            )
        )

        ################################################################
        # sync_3
        ################################################################
        sync_3_serial_num = self.add_cmd(
            Sync(
                cmd_runners="sync_3",
                targets=sync_3_target_set,
                sync_set_ack_remotes=sync_3_target_set,
            )
        )

        ################################################################
        # confirm sync_0
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Sync",
                confirm_serial_num=sync_0_serial_num,
                confirmers="sync_0",
            )
        )

        ################################################################
        # confirm sync_1
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Sync",
                confirm_serial_num=sync_1_serial_num,
                confirmers="sync_1",
            )
        )

        ################################################################
        # confirm sync_2
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Sync",
                confirm_serial_num=sync_2_serial_num,
                confirmers="sync_2",
            )
        )

        ################################################################
        # confirm sync_3
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Sync",
                confirm_serial_num=sync_3_serial_num,
                confirmers="sync_3",
            )
        )

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures,
                obtain_reg_lock=True,
            )
        )

    ####################################################################
    # check_pending_events
    ####################################################################
    def check_expected_responses(
        self, cmd_runner: str, check_args: CheckExpectedResponsesArgs
    ) -> bool:
        """Check that the sync event is set in the target_rtn.

        Args:
            cmd_runner: thread name doing the check
            check_args: requestors, targets, and request type
        """
        for requestor in check_args.requestors:
            if requestor not in self.expected_registered:
                raise InvalidConfigurationDetected(
                    f"check_expected_responses {cmd_runner=} detected "
                    f"that {requestor=} is not in expected_registered."
                )
            if check_args.request == st.ReqType.Smart_recv:
                if check_args.exp_response_targets != set(
                    self.expected_registered[requestor].thread.recvd_msgs.keys()
                ):
                    return False
            else:
                raise InvalidInputDetected(
                    f"check_expected_responses {cmd_runner=} detected "
                    f"unknown {check_args.request=}."
                )

        return True

    ####################################################################
    # check_sync_event_set
    ####################################################################
    def check_sync_event_set(self, cmd_runner: str, check_args: CheckPendArg) -> bool:
        """Check that the sync event is set in the target_rtn.

        Args:
            cmd_runner: thread name doing the check
            check_args: target_rtn name and pair_key to be checked
        """
        target = check_args[0]
        pair_key = check_args[1]
        if target not in self.expected_registered:
            raise InvalidConfigurationDetected(
                f"check_sync_event_set {target=} not in expected_registered"
            )

        if pair_key not in self.expected_pairs:
            raise InvalidConfigurationDetected(
                f"check_sync_event_set {pair_key=} not in expected_pairs"
            )

        if target not in self.expected_pairs[pair_key]:
            raise InvalidConfigurationDetected(
                f"check_sync_event_set {target=} not in expected_pairs"
                f"with {pair_key=}"
            )

        if self.expected_pairs[pair_key][target].pending_sync:
            return True

        return False

    ####################################################################
    # check_sync_zero_create_time
    ####################################################################
    def check_sync_zero_create_time(
        self, cmd_runner: str, check_args: CheckZeroCtArg
    ) -> bool:
        """Check that the sync event is set in the target_rtn.

        Args:
            cmd_runner: thread name doing the check
            check_args: target_rtn name and pair_key to be checked
        """
        sync_0 = check_args[0]
        sync_1 = check_args[1]

        pair_key = st.SmartThread._get_pair_key(sync_0, sync_1)
        pk_remote: st.PairKeyRemote = st.PairKeyRemote(
            pair_key=pair_key, remote=sync_1, create_time=0.0
        )
        if sync_0 not in self.expected_registered:
            raise InvalidConfigurationDetected(
                f"check_sync_zero_create_time {sync_0=} not in " "expected_registered"
            )
        if sync_1 not in self.expected_registered:
            raise InvalidConfigurationDetected(
                f"check_sync_zero_create_time {sync_1=} not in " "expected_registered"
            )

        if pk_remote in self.expected_registered[sync_0].thread.work_pk_remotes:
            return True

        return False

    ####################################################################
    # check_pending_events
    ####################################################################
    def check_pending_events(self, verify_idx: int) -> None:
        """Check pending events are clear.

        Args:
            verify_idx: contains verify index to snapshot data
        """
        incomplete_items: dict[str, dict[PE, Any]] = {}
        for cmd_runner, pend_events in self.pending_events.items():
            for event_name, item in pend_events.items():
                if isinstance(item, defaultdict):
                    for key, item2 in item.items():
                        if item2 != 0:
                            if cmd_runner not in incomplete_items:
                                incomplete_items[cmd_runner] = {}
                            if event_name not in incomplete_items[cmd_runner]:
                                incomplete_items[cmd_runner][event_name] = {}
                            incomplete_items[cmd_runner][event_name][key] = item2
                elif isinstance(item, int):
                    if item != 0:
                        if cmd_runner not in incomplete_items:
                            incomplete_items[cmd_runner] = {}
                        incomplete_items[cmd_runner][event_name] = item
                elif isinstance(item, deque):
                    if len(item) != 0:
                        if cmd_runner not in incomplete_items:
                            incomplete_items[cmd_runner] = {}
                        incomplete_items[cmd_runner][event_name] = item
                elif isinstance(item, StartRequest):
                    if item.req_type != st.ReqType.NoReq:
                        if cmd_runner not in incomplete_items:
                            incomplete_items[cmd_runner] = {}
                        incomplete_items[cmd_runner][event_name] = item
                else:
                    self.abort_all_f1_threads()
                    raise UnrecognizedEvent(
                        "check_pending_events does not recognize"
                        f"event {event_name=}, {item=}"
                    )

        if incomplete_items:
            for cmd_runner, item in incomplete_items.items():
                self.log_test_msg(f"incomplete_item: {cmd_runner=}, {item=}")
            self.abort_all_f1_threads()
            raise RemainingPendingEvents(
                "check_pending_events detected that there are remaining "
                f"pending items:\n {incomplete_items=}"
            )

    ####################################################################
    # build_def_del_scenario
    ####################################################################
    def build_def_del_scenario(self, def_del_scenario: DefDelScenario) -> None:
        """Return a list of ConfigCmd items for a deferred delete.

        Args:
            def_del_scenario: specifies type of test to do

        """
        self.auto_calling_refresh_msg = False
        num_receivers = 2
        num_senders = 1

        num_waiters = 2
        num_resumers = 1

        num_syncers = 2

        num_dels = 1
        num_adds = 1

        num_deleters = 1
        num_adders = 1

        num_lockers = 5

        num_active_needed = (
            num_receivers
            + num_senders
            + num_waiters
            + num_resumers
            + num_syncers
            + num_dels
            + num_deleters
            + num_adders
            + num_lockers
            + 1
        )  # plus 1 for the commander
        self.build_config(cmd_runner=self.commander_name, num_active=num_active_needed)

        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose receiver_names
        ################################################################
        receiver_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_receivers,
            update_collection=True,
            var_name_for_log="receiver_names",
        )

        ################################################################
        # choose sender_names
        ################################################################
        sender_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_senders,
            update_collection=True,
            var_name_for_log="sender_names",
        )

        ################################################################
        # choose waiter_names
        ################################################################
        waiter_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_waiters,
            update_collection=True,
            var_name_for_log="waiter_names",
        )

        ################################################################
        # choose resumer_names
        ################################################################
        resumer_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_resumers,
            update_collection=True,
            var_name_for_log="resumer_names",
        )

        ################################################################
        # choose del_names
        ################################################################
        del_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_dels,
            update_collection=True,
            var_name_for_log="del_names",
        )

        ################################################################
        # choose add_names
        ################################################################
        unregistered_names_copy = self.unregistered_names.copy()
        add_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_adds,
            update_collection=True,
            var_name_for_log="add_names",
        )

        ################################################################
        # choose deleter_names
        ################################################################
        deleter_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_deleters,
            update_collection=True,
            var_name_for_log="deleter_names",
        )

        ################################################################
        # choose adder_names
        ################################################################
        adder_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_adders,
            update_collection=True,
            var_name_for_log="adder_names",
        )

        ################################################################
        # choose locker_names
        ################################################################
        locker_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_lockers,
            update_collection=True,
            var_name_for_log="locker_names",
        )
        lm = LockMgr(config_ver=self, locker_names=locker_names)

        ################################################################
        # Categorize the request types
        ################################################################
        single_request = False
        double_request = False
        del_add_request = False

        cmd_0_name: str = ""
        cmd_0_smart_name = ""
        cmd_0_confirmer: str = ""
        recv_0_name: str = ""
        wait_0_name: str = ""

        cmd_1_name: str = ""
        cmd_1_smart_name = ""
        cmd_1_confirmer: str = ""
        cmd_1_serial_num: int = 0
        recv_1_name: str = ""
        wait_1_name: str = ""

        receivers: list[str] = []
        waiters: list[str] = []

        if (
            def_del_scenario == DefDelScenario.NormalRecv
            or def_del_scenario == DefDelScenario.ResurrectionRecv
            or def_del_scenario == DefDelScenario.NormalWait
            or def_del_scenario == DefDelScenario.ResurrectionWait
        ):
            single_request = True

        elif (
            def_del_scenario == DefDelScenario.Recv0Recv1
            or def_del_scenario == DefDelScenario.Recv1Recv0
            or def_del_scenario == DefDelScenario.WaitRecv
            or def_del_scenario == DefDelScenario.Wait0Wait1
            or def_del_scenario == DefDelScenario.Wait1Wait0
            or def_del_scenario == DefDelScenario.RecvWait
        ):
            double_request = True

        elif (
            def_del_scenario == DefDelScenario.RecvDel
            or def_del_scenario == DefDelScenario.WaitDel
            or def_del_scenario == DefDelScenario.RecvAdd
            or def_del_scenario == DefDelScenario.WaitAdd
        ):
            del_add_request = True

        ################################################################
        # Determine whether first request is smart_recv or wait
        ################################################################
        if (
            def_del_scenario == DefDelScenario.NormalRecv
            or def_del_scenario == DefDelScenario.ResurrectionRecv
            or def_del_scenario == DefDelScenario.Recv0Recv1
            or def_del_scenario == DefDelScenario.Recv1Recv0
            or def_del_scenario == DefDelScenario.RecvWait
            # or def_del_scenario == DefDelScenario.WaitRecv
            or def_del_scenario == DefDelScenario.RecvDel
            or def_del_scenario == DefDelScenario.RecvAdd
        ):
            cmd_0_name = "RecvMsg"
            cmd_0_smart_name = "smart_recv"
            recv_0_name = receiver_names[0]
            cmd_0_confirmer = recv_0_name
            receivers.append(recv_0_name)

        elif (
            def_del_scenario == DefDelScenario.NormalWait
            or def_del_scenario == DefDelScenario.ResurrectionWait
            or def_del_scenario == DefDelScenario.Wait0Wait1
            or def_del_scenario == DefDelScenario.Wait1Wait0
            # or def_del_scenario == DefDelScenario.RecvWait
            or def_del_scenario == DefDelScenario.WaitRecv
            or def_del_scenario == DefDelScenario.WaitDel
            or def_del_scenario == DefDelScenario.WaitAdd
        ):
            cmd_0_name = "Wait"
            cmd_0_smart_name = "smart_wait"
            wait_0_name = waiter_names[0]
            cmd_0_confirmer = wait_0_name
            waiters.append(wait_0_name)

        ################################################################
        # Determine whether second request (if one) is smart_recv or
        # wait
        ################################################################
        if (
            def_del_scenario == DefDelScenario.Recv0Recv1
            or def_del_scenario == DefDelScenario.Recv1Recv0
            or def_del_scenario == DefDelScenario.WaitRecv
        ):
            if def_del_scenario == DefDelScenario.WaitRecv:
                recv_1_name = receiver_names[0]
            else:
                recv_1_name = receiver_names[1]
            cmd_1_name = "RecvMsg"
            cmd_1_smart_name = "smart_recv"
            receivers.append(recv_1_name)

        elif (
            def_del_scenario == DefDelScenario.Wait0Wait1
            or def_del_scenario == DefDelScenario.Wait1Wait0
            or def_del_scenario == DefDelScenario.RecvWait
        ):
            if def_del_scenario == DefDelScenario.RecvWait:
                wait_1_name = waiter_names[0]
            else:
                wait_1_name = waiter_names[1]
            cmd_1_name = "Wait"
            cmd_1_smart_name = "smart_wait"
            waiters.append(wait_1_name)

        exiters: list[str] = []
        if (
            def_del_scenario == DefDelScenario.RecvDel
            or def_del_scenario == DefDelScenario.WaitDel
        ):
            exiters.append(del_names[0])

        adders: list[str] = []
        if (
            def_del_scenario == DefDelScenario.RecvAdd
            or def_del_scenario == DefDelScenario.WaitAdd
        ):
            adders.append(add_names[0])

        exit_names: list[str] = []
        if receivers:
            ############################################################
            # send a msg that will sit on the smart_recv msg_q (1 or 2)
            ############################################################
            exit_names.append(sender_names[0])

            sender_msgs = SendRecvMsgs(
                sender_names=sender_names,
                receiver_names=receivers,
                num_msgs=1,
                text="build_def_del_scenario",
            )
            send_msg_serial_num_0 = self.add_cmd(
                SendMsg(
                    cmd_runners=sender_names[0],
                    receivers=receivers,
                    exp_receivers=receivers,
                    msgs_to_send=sender_msgs,
                    msg_idx=0,
                )
            )
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd="SendMsg",
                    confirm_serial_num=send_msg_serial_num_0,
                    confirmers=sender_names[0],
                )
            )
        if waiters:
            ############################################################
            # resume that will set wait bit
            ############################################################
            exit_names.append(resumer_names[0])
            resume_serial_num_0 = self.add_cmd(
                Resume(
                    cmd_runners=resumer_names[0],
                    targets=waiters,
                    exp_resumed_targets=waiters,
                    stopped_remotes=[],
                )
            )
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd="Resume",
                    confirm_serial_num=resume_serial_num_0,
                    confirmers=resumer_names[0],
                )
            )

        if (
            def_del_scenario != DefDelScenario.NormalRecv
            and def_del_scenario != DefDelScenario.NormalWait
        ):
            ############################################################
            # exit the sender to create a half paired case
            ############################################################
            self.build_exit_suite(
                cmd_runner=self.commander_name, names=exit_names, validate_config=False
            )
            self.build_join_suite(
                cmd_runners=self.commander_name,
                join_target_names=exit_names,
                validate_config=False,
            )

            if (
                def_del_scenario == DefDelScenario.ResurrectionRecv
                or def_del_scenario == DefDelScenario.ResurrectionWait
            ):
                ########################################################
                # resurrect the sender
                ########################################################
                f1_create_items: list[F1CreateItem] = []
                for idx, name in enumerate(exit_names):
                    if idx % 2:
                        app_config = AppConfig.ScriptStyle
                    else:
                        app_config = AppConfig.RemoteThreadApp

                    f1_create_items.append(
                        F1CreateItem(
                            name=name,
                            auto_start=True,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    )
                self.build_create_suite(
                    f1_create_items=f1_create_items, validate_config=False
                )

        ################################################################
        # For scenarios that have a second request, get lock 0 to keep
        # the first smart_recv/wait progressing beyond the lock obtain
        # in _request_setup where the pk_remotes list is built.
        ################################################################
        if not single_request:
            ############################################################
            # before: none
            # action: get lock
            # after: lock
            ############################################################
            lm.get_lock()

        ################################################################
        # do the first recv or wait
        ################################################################
        if cmd_0_name == "RecvMsg":
            cmd_0_serial_num = self.add_cmd(
                RecvMsg(
                    cmd_runners=recv_0_name,
                    senders=sender_names[0],
                    exp_msgs=sender_msgs,
                    exp_senders=sender_names[0],
                    log_msg="def_del_recv_test_0",
                )
            )
            if not single_request:
                ############################################################
                # before: lock
                # action: RecvMsg
                # after: lock|recv_0_v|lock
                ############################################################
                lm.start_request(recv_0_name)

        else:  # must be wait
            cmd_0_serial_num = self.add_cmd(
                Wait(
                    cmd_runners=wait_0_name,
                    resumers=resumer_names[0],
                    exp_resumers=resumer_names[0],
                    stopped_remotes=set(),
                    log_msg="def_del_wait_test_0",
                )
            )
            if not single_request:
                ############################################################
                # before: lock
                # action: Wait
                # after: lock|wait_0_v|lock
                ############################################################
                lm.start_request(wait_0_name)

        ################################################################
        # Note: in the lock verify comments, the 'a', 'b', 'c', or 'd'
        # chars appended to request_0 and request_1 indicate where the
        # request is positioned along the path:
        # 'v' means behind the lock in _verify_thread_is_current
        # 's' means behind the lock in _request_setup
        # 'r' means behind the lock in _request_loop
        # 'f' means behind the lock before doing a refresh pair_array
        # 'i' means the lock in register for add
        ################################################################

        ################################################################
        # From this point on we will split the scenarios into separate
        # build paths to simplify the lock manipulations
        ################################################################
        if double_request:
            if cmd_1_name == "RecvMsg":
                cmd_1_confirmer = recv_1_name
                cmd_1_serial_num = self.add_cmd(
                    RecvMsg(
                        cmd_runners=recv_1_name,
                        senders=sender_names[0],
                        exp_senders=sender_names[0],
                        exp_msgs=sender_msgs,
                        log_msg="def_del_recv_test_1",
                    )
                )
                ########################################################
                # before: lock|recv_0_v|lock
                # or:     lock|wait_0_v|lock
                # action: Wait
                # after: lock|recv_0_v|lock|recv_1_v|lock
                # or:    lock|wait_0_v|lock|recv_1_v|lock
                ########################################################
                lm.start_request(recv_1_name)

            else:  # must be wait
                cmd_1_confirmer = wait_1_name
                cmd_1_serial_num = self.add_cmd(
                    Wait(
                        cmd_runners=wait_1_name,
                        resumers=resumer_names[0],
                        exp_resumers=resumer_names[0],
                        stopped_remotes=set(),
                        log_msg="def_del_wait_test_1",
                    )
                )
                ########################################################
                # before: lock|recv_0_v|lock
                # or:     lock|wait_0_v|lock
                # action: Wait
                # after: lock|recv_0_v|lock|wait_1_1_v|lock
                # or:    lock|wait_0_v|lock|wait_1_1_v|lock
                ########################################################
                lm.start_request(wait_1_name)

            ############################################################
            # before: lock|req_0_v|lock|req_1_v|lock
            # action: drop lock to allow first req to advance to setup
            # after: lock|req_1_v|lock|req_0_s|lock
            ############################################################
            lm.advance_request()

            ############################################################
            # before: lock|req_1_v|lock|req_0_s|lock
            # action: drop lock to allow first req to advance to setup
            # after: lock|req_0_s|lock|req_1_s|lock
            ############################################################
            lm.advance_request()

            ############################################################
            # complete the build in part a
            ############################################################
            self.build_def_del_scenario_part_a(
                def_del_scenario=def_del_scenario,
                lm=lm,
            )
        elif del_add_request:
            ############################################################
            # for del and add, we need to progress request_0 from v to r
            ############################################################
            ############################################################
            # release lock_0
            ############################################################
            ############################################################
            # before: lock|req_0_v|lock
            # action: drop lock to allow first req to advance to setup
            # after:  lock|req_0_s|lock
            ############################################################
            lm.advance_request()

            ############################################################
            # do the del or add request
            ############################################################
            if (
                def_del_scenario == DefDelScenario.RecvDel
                or def_del_scenario == DefDelScenario.WaitDel
            ):
                self.build_exit_suite(
                    cmd_runner=deleter_names[0],
                    names=[del_names[0]],
                    validate_config=False,
                )
                self.build_join_suite(
                    cmd_runners=deleter_names[0],
                    join_target_names=[del_names[0]],
                    validate_config=False,
                )
                ########################################################
                # before: lock|req_0_s|lock
                # action: smart_join
                # after:  lock|req_0_s|lock|smart_join_v|lock
                ########################################################
                lm.start_request(deleter_names[0])

                ########################################################
                # before: lock|req_0_s|lock|smart_join_v|lock
                # action: drop lock
                # after:  lock|smart_join_v|lock|req_0_r
                ########################################################
                lm.advance_request(trailing_lock=False)

                ########################################################
                # before: lock|smart_join_v|lock|req_0_r
                # action: drop lock
                # after:  lock|req_0_r|smart_join_r
                ########################################################
                lm.advance_request(trailing_lock=False)
            else:  # must be add
                ########################################################
                # before: lock|req_0_s|lock
                # action: drop lock to allow first req to advance to
                #         request loop
                # after:  lock|req_0_r
                ########################################################
                lm.advance_request(trailing_lock=False)

                ########################################################
                # smart_init
                ########################################################
                f1_create_items = [
                    F1CreateItem(
                        name=add_names[0],
                        auto_start=True,
                        target_rtn=outer_f1,
                        app_config=AppConfig.ScriptStyle,
                    )
                ]
                self.build_create_suite(
                    cmd_runner=adder_names[0],
                    f1_create_items=f1_create_items,
                    validate_config=False,
                )
                ########################################################
                # before: lock|req_0_r
                # action: smart_init
                # after:  lock|req_0_r|smart_init_i
                ########################################################
                lm.start_request(adder_names[0], trailing_lock=False)

            ############################################################
            # complete the build in part b
            ############################################################
            self.build_def_del_scenario_part_b(
                lm=lm,
            )

        ################################################################
        # handle expected refresh call
        ################################################################
        if (
            def_del_scenario != DefDelScenario.NormalRecv
            and def_del_scenario != DefDelScenario.NormalWait
            and def_del_scenario != DefDelScenario.ResurrectionRecv
            and def_del_scenario != DefDelScenario.ResurrectionWait
        ):
            pe = self.pending_events[cmd_0_confirmer]
            ref_key: CallRefKey = cmd_0_smart_name

            pe[PE.calling_refresh_msg][ref_key] += 1

            if double_request:
                pe = self.pending_events[cmd_1_confirmer]
                ref_key = cmd_1_smart_name

                pe[PE.calling_refresh_msg][ref_key] += 1

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd=cmd_0_name,
                confirm_serial_num=cmd_0_serial_num,
                confirmers=cmd_0_confirmer,
            )
        )

        if cmd_1_name:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd=cmd_1_name,
                    confirm_serial_num=cmd_1_serial_num,
                    confirmers=cmd_1_confirmer,
                )
            )

        ################################################################
        # check results
        ################################################################
        self.add_cmd(
            VerifyDefDel(
                cmd_runners=self.commander_name,
                def_del_scenario=def_del_scenario,
                receiver_names=receiver_names,
                sender_names=sender_names,
                waiter_names=waiter_names,
                resumer_names=resumer_names,
                del_names=del_names,
                add_names=add_names,
                deleter_names=deleter_names,
                adder_names=adder_names,
            )
        )

    ####################################################################
    # build_def_del_scenario_part_a
    ####################################################################
    @staticmethod
    def build_def_del_scenario_part_a(
        def_del_scenario: DefDelScenario,
        lm: LockMgr,
    ) -> None:
        """Add ConfigCmd items for a deferred delete.

        Args:
            def_del_scenario: specifies type of test to do
            lm: lock manager class

        """
        ################################################################
        # Upon entry, both requests have been made and are both sitting
        # behind the first lock in _request_setup
        ################################################################

        ################################################################
        # before: lock|request_0a|lock|request_1a|lock
        # action: release lock to allow first smart_recv/wait to
        #         progress to the lock obtain in _request_loop
        # after:  lock|request_1a_s|lock|request_0a_r|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|request_1a_s|lock|request_0a_r|lock
        # action: release lock to allow second smart_recv/wait to
        #         progress to the lock obtain in _request_loop.
        # after:  lock|request_0a_r|lock|request_1a_r|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|request_0a_r|lock|request_1a_r|lock
        # action: release lock to allow first smart_recv/wait to
        #         progress to the lock obtain before refresh.
        # after:  lock|request_1a_r|lock|request_0a_f|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|request_1a_r|lock|request_0a_f|lock
        # action: release lock to allow second smart_recv/wait to
        #         progress to the lock obtain before refresh.
        # after:  lock|request_0a_f|lock|request_1a_f
        ################################################################
        lm.advance_request(trailing_lock=False)

        ################################################################
        # At this point we will have the first cmd behind lock_4 and
        # the second cmd behind the first cmd. We now need to swap the
        # lock positions for some scenarios.
        ################################################################
        if (
            def_del_scenario == DefDelScenario.Recv1Recv0
            or def_del_scenario == DefDelScenario.Wait1Wait0
        ):
            ############################################################
            # before: lock|request_0a_f|lock|request_1a_f
            # action: swap request positions
            # after:  lock|request_1a_f|lock|request_0a_f
            ############################################################
            lm.swap_requestors()

        ################################################################
        # before: lock|request_0a_f|lock|request_1a_f
        # or:     lock|request_1a_f|lock|request_0a_f
        # action: release lock to allow smart_recv/wait to refresh
        # after:  lock|request_1a_f
        # or:     lock|request_0a_f
        ################################################################
        lm.complete_request()

        ################################################################
        # before:  lock|request_1a_f
        # or:      lock|request_0a_f
        # action: release lock to allow final smart_recv/wait to refresh
        # after:  none
        ################################################################
        lm.complete_request()

    ####################################################################
    # build_def_del_scenario_part_b
    ####################################################################
    @staticmethod
    def build_def_del_scenario_part_b(
        lm: LockMgr,
    ) -> None:
        """Add ConfigCmd items for a deferred delete.

        Args:
            lm: lock manager

        """
        ################################################################
        # Upon entry, both requests have been made with request_0
        # sitting behind the lock in _request_loop and request_1, the
        # add or del, sitting respectively behind the lock in register
        # or smart_join
        ################################################################

        ################################################################
        # before:  lock|req_0_r|smart_cmd_c
        # action: release lock to allow request_0 to complete the
        #         request nad then advance to the lock for refresh, and
        #         the add or del will do the refresh ahead of the recv
        #         or wait and complete. The recv or wait will then enter
        #         refresh but find nothing to do (will not produce the
        #         update at UTC message).
        # after:  none
        ################################################################
        lm.complete_request(free_all=True)

    ####################################################################
    # build_recv_msg_timeout_suite
    ####################################################################
    def build_recv_msg_timeout_suite(
        self,
        timeout_type: TimeoutType,
        num_receivers: int,
        num_active_no_delay_senders: int,
        num_active_delay_senders: int,
        num_send_exit_senders: int,
        num_nosend_exit_senders: int,
        num_unreg_senders: int,
        num_reg_senders: int,
    ) -> None:
        """Return a list of ConfigCmd items for a msg timeout.

        Args:
            timeout_type: specifies whether the smart_recv should
                be coded with timeout and whether the smart_recv should
                succeed or fail with a timeout
            num_receivers: number of threads that will do the
                smart_recv
            num_active_no_delay_senders: number of threads that are
                active and will do the smart_send immediately
            num_active_delay_senders: number of threads that are active
                and will do the smart_send after a delay
            num_send_exit_senders: number of threads that are active
                and will do the smart_send and then exit
            num_nosend_exit_senders: number of threads that are
                active and will not do the smart_send and then exit
            num_unreg_senders: number of threads that are
                unregistered and will be created and started and then
                do the smart_send
            num_reg_senders: number of threads that are registered
                and will be started and then do the smart_send

        """
        # Make sure we have enough threads
        assert (
            num_receivers
            + num_active_no_delay_senders
            + num_active_delay_senders
            + num_send_exit_senders
            + num_nosend_exit_senders
            + num_unreg_senders
            + num_reg_senders
        ) <= len(self.unregistered_names)

        assert num_receivers > 0

        assert (
            num_active_no_delay_senders
            + num_active_delay_senders
            + num_send_exit_senders
            + num_nosend_exit_senders
            + num_unreg_senders
            + num_reg_senders
        ) > 0

        if (
            timeout_type == TimeoutType.TimeoutFalse
            or timeout_type == TimeoutType.TimeoutTrue
        ):
            assert (
                num_active_delay_senders
                + num_nosend_exit_senders
                + num_unreg_senders
                + num_reg_senders
            ) > 0

        num_active_needed = (
            num_receivers
            + num_active_no_delay_senders
            + num_active_delay_senders
            + num_send_exit_senders
            + num_nosend_exit_senders
            + 1
        )

        timeout_time = (
            (num_active_no_delay_senders * 0.1)
            + (num_active_delay_senders * 0.1)
            + (num_send_exit_senders * 0.1)
            + (num_nosend_exit_senders * 0.5)
            + (num_unreg_senders * 0.5)
            + (num_reg_senders * 0.5)
        )

        if timeout_type == TimeoutType.TimeoutNone:
            pause_time = 0.5
        elif timeout_type == TimeoutType.TimeoutFalse:
            pause_time = 0.5
            timeout_time = pause_time * 8  # prevent timeout
        else:  # timeout True
            pause_time = timeout_time + 1  # force timeout

        self.build_config(
            cmd_runner=self.commander_name,
            num_registered=num_reg_senders,
            num_active=num_active_needed,
        )

        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose receiver_names
        ################################################################
        receiver_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_receivers,
            update_collection=True,
            var_name_for_log="receiver_names",
        )

        ################################################################
        # choose active_no_delay_sender_names
        ################################################################
        active_no_delay_sender_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_active_no_delay_senders,
            update_collection=True,
            var_name_for_log="active_no_delay_sender_names",
        )

        ################################################################
        # choose active_delay_sender_names
        ################################################################
        active_delay_sender_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_active_delay_senders,
            update_collection=True,
            var_name_for_log="active_delay_sender_names",
        )

        ################################################################
        # choose send_exit_sender_names
        ################################################################
        send_exit_sender_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_send_exit_senders,
            update_collection=True,
            var_name_for_log="send_exit_sender_names",
        )

        ################################################################
        # choose nosend_exit_sender_names
        ################################################################
        nosend_exit_sender_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_nosend_exit_senders,
            update_collection=True,
            var_name_for_log="nosend_exit_sender_names",
        )

        ################################################################
        # choose unreg_sender_names
        ################################################################
        unreg_sender_names = self.choose_names(
            name_collection=self.unregistered_names,
            num_names_needed=num_unreg_senders,
            update_collection=False,
            var_name_for_log="unreg_sender_names",
        )

        ################################################################
        # choose reg_sender_names
        ################################################################
        reg_sender_names = self.choose_names(
            name_collection=self.registered_names,
            num_names_needed=num_reg_senders,
            update_collection=False,
            var_name_for_log="reg_sender_names",
        )

        ################################################################
        # start by doing the recv_msgs, one for each sender
        ################################################################
        all_sender_names: list[str] = (
            active_no_delay_sender_names
            + active_delay_sender_names
            + send_exit_sender_names
            + nosend_exit_sender_names
            + unreg_sender_names
            + reg_sender_names
        )

        all_timeout_names: list[str] = (
            active_delay_sender_names
            + send_exit_sender_names
            + nosend_exit_sender_names
            + unreg_sender_names
            + reg_sender_names
        )

        if timeout_type == TimeoutType.TimeoutTrue:
            exp_senders = set(all_sender_names) - set(all_timeout_names)
        else:
            exp_senders = set(all_sender_names) - set(nosend_exit_sender_names)

        if nosend_exit_sender_names:
            exp_senders -= set(unreg_sender_names)
            exp_senders -= set(reg_sender_names)

        self.set_recv_timeout(num_timeouts=len(all_timeout_names) * num_receivers)

        if len(all_sender_names) % 2 == 0:
            log_msg = f"smart_recv log test: {get_ptime()}"
        else:
            log_msg = None

        ################################################################
        # setup the messages to send
        ################################################################
        sender_msgs = SendRecvMsgs(
            sender_names=all_sender_names,
            receiver_names=receiver_names,
            num_msgs=1,
            text="build_recv_msg_timeout_suite",
        )

        if timeout_type == TimeoutType.TimeoutNone:
            confirm_cmd_to_use = "RecvMsg"
            recv_msg_serial_num = self.add_cmd(
                RecvMsg(
                    cmd_runners=receiver_names,
                    senders=all_sender_names,
                    exp_senders=exp_senders,
                    stopped_remotes=nosend_exit_sender_names,
                    exp_msgs=sender_msgs,
                    log_msg=log_msg,
                )
            )
        elif timeout_type == TimeoutType.TimeoutFalse:
            confirm_cmd_to_use = "RecvMsgTimeoutFalse"
            recv_msg_serial_num = self.add_cmd(
                RecvMsgTimeoutFalse(
                    cmd_runners=receiver_names,
                    senders=all_sender_names,
                    exp_senders=exp_senders,
                    stopped_remotes=nosend_exit_sender_names,
                    exp_msgs=sender_msgs,
                    timeout=timeout_time,
                    log_msg=log_msg,
                )
            )

        else:  # TimeoutType.TimeoutTrue
            confirm_cmd_to_use = "RecvMsgTimeoutTrue"
            recv_msg_serial_num = self.add_cmd(
                RecvMsgTimeoutTrue(
                    cmd_runners=receiver_names,
                    senders=all_sender_names,
                    exp_senders=exp_senders,
                    exp_msgs=sender_msgs,
                    timeout=2,
                    timeout_names=all_timeout_names,
                    log_msg=log_msg,
                )
            )

        ################################################################
        # do smart_send from active_no_delay_senders
        ################################################################
        if active_no_delay_sender_names:
            self.add_cmd(
                SendMsg(
                    cmd_runners=active_no_delay_sender_names,
                    receivers=receiver_names,
                    exp_receivers=receiver_names,
                    msgs_to_send=sender_msgs,
                    msg_idx=0,
                )
            )

        self.add_cmd(Pause(cmd_runners=self.commander_name, pause_seconds=pause_time))
        if timeout_type == TimeoutType.TimeoutTrue:
            self.add_cmd(WaitForRecvTimeouts(cmd_runners=self.commander_name))

        ################################################################
        # do smart_send from active_delay_senders
        ################################################################
        if active_delay_sender_names:
            send_serial_num = self.add_cmd(
                SendMsg(
                    cmd_runners=active_delay_sender_names,
                    receivers=receiver_names,
                    exp_receivers=receiver_names,
                    msgs_to_send=sender_msgs,
                    msg_idx=0,
                )
            )
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd="SendMsg",
                    confirm_serial_num=send_serial_num,
                    confirmers=active_delay_sender_names,
                )
            )

        ################################################################
        # do smart_send from send_exit_senders and then exit
        ################################################################
        if send_exit_sender_names:
            self.add_cmd(
                SendMsg(
                    cmd_runners=send_exit_sender_names,
                    receivers=receiver_names,
                    exp_receivers=receiver_names,
                    msgs_to_send=sender_msgs,
                    msg_idx=0,
                )
            )

            self.build_exit_suite(
                cmd_runner=self.commander_name,
                names=send_exit_sender_names,
                validate_config=False,
            )
            self.build_join_suite(
                cmd_runners=self.commander_name,
                join_target_names=send_exit_sender_names,
                validate_config=False,
            )

        ################################################################
        # exit the nosend_exit_senders, then resurrect and do smart_send
        ################################################################
        if nosend_exit_sender_names:
            # make sure the senders have a chance to complete their
            # sends before we cause the stop from being recognized
            self.add_cmd(
                WaitForCondition(
                    cmd_runners=self.commander_name,
                    check_rtn=self.check_expected_responses,
                    check_args=CheckExpectedResponsesArgs(
                        requestors=set(receiver_names),
                        exp_response_targets=exp_senders,
                        request=st.ReqType.Smart_recv,
                    ),
                )
            )

            self.build_exit_suite(
                cmd_runner=self.commander_name,
                names=nosend_exit_sender_names,
                validate_config=False,
            )
            self.build_join_suite(
                cmd_runners=self.commander_name,
                join_target_names=nosend_exit_sender_names,
                validate_config=False,
            )

            f1_create_items: list[F1CreateItem] = []
            for idx, name in enumerate(nosend_exit_sender_names):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(
                    F1CreateItem(
                        name=name,
                        auto_start=True,
                        target_rtn=outer_f1,
                        app_config=app_config,
                    )
                )
            self.build_create_suite(
                f1_create_items=f1_create_items, validate_config=False
            )
            self.add_cmd(
                SendMsg(
                    cmd_runners=nosend_exit_sender_names,
                    receivers=receiver_names,
                    exp_receivers=receiver_names,
                    msgs_to_send=sender_msgs,
                    msg_idx=0,
                )
            )

        ################################################################
        # create and start the unreg_senders, then do smart_send
        ################################################################
        if unreg_sender_names:
            f1_create_items = []
            for idx, name in enumerate(unreg_sender_names):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(
                    F1CreateItem(
                        name=name,
                        auto_start=True,
                        target_rtn=outer_f1,
                        app_config=app_config,
                    )
                )
            self.build_create_suite(
                f1_create_items=f1_create_items, validate_config=False
            )
            self.add_cmd(
                SendMsg(
                    cmd_runners=unreg_sender_names,
                    receivers=receiver_names,
                    exp_receivers=receiver_names,
                    msgs_to_send=sender_msgs,
                    msg_idx=0,
                )
            )

        ################################################################
        # start the reg_senders, then do smart_send
        ################################################################
        if reg_sender_names:
            self.build_start_suite(start_names=reg_sender_names, validate_config=False)
            self.add_cmd(
                SendMsg(
                    cmd_runners=reg_sender_names,
                    receivers=receiver_names,
                    exp_receivers=receiver_names,
                    msgs_to_send=sender_msgs,
                    msg_idx=0,
                )
            )

        ################################################################
        # finally, confirm the smart_recv is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd=confirm_cmd_to_use,
                confirm_serial_num=recv_msg_serial_num,
                confirmers=receiver_names,
            )
        )

    ####################################################################
    # build_wait_scenario_suite
    ####################################################################
    def build_wait_scenario_suite(
        self, num_waiters: int, num_actors: int, actor_list: list[Actors]
    ) -> None:
        """Adds cmds to the cmd queue.

        Args:
            num_waiters: number of threads that will do the wait
            num_actors: number of threads that will do the resume
            actor_list: contains the actors

        """
        actions: dict[Actors, Callable[..., None]] = {
            Actors.ActiveBeforeActor: self.build_resume_before_wait_timeout_suite,
            Actors.ActiveAfterActor: self.build_resume_after_wait_timeout_suite,
            Actors.ActionExitActor: self.build_resume_exit_wait_timeout_suite,
            Actors.ExitActionActor: self.build_exit_resume_wait_timeout_suite,
            Actors.UnregActor: self.build_unreg_resume_wait_timeout_suite,
            Actors.RegActor: self.build_reg_resume_wait_timeout_suite,
        }
        # Make sure we have enough threads
        assert num_waiters > 0
        assert num_actors > 0
        assert (num_waiters + num_actors) <= len(self.unregistered_names)

        # number needed for waiters, actors, and commander
        num_active_threads_needed = num_waiters + num_actors + 1

        self.build_config(
            cmd_runner=self.commander_name, num_active=num_active_threads_needed
        )

        active_names_copy = self.active_names - {self.commander_name}

        waiter_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_waiters,
            update_collection=True,
            var_name_for_log="waiter_names",
        )

        actor_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_actors,
            update_collection=True,
            var_name_for_log="actor_names",
        )

        for actor in actor_list:
            actions[actor](waiter_names=waiter_names, actor_names=actor_names)

    ####################################################################
    # powerset
    ####################################################################
    @staticmethod
    def powerset(names: list[str]) -> chain[tuple[str, ...]]:
        """Returns a generator powerset of the input list of names.

        Args:
            names: names to use to make a powerset

        """
        # powerset([1,2,3]) -->
        # () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)
        return chain.from_iterable(
            combinations(names, r) for r in range(len(names) + 1)
        )

    ####################################################################
    # build_wait_active_suite
    ####################################################################
    def build_resume_before_wait_timeout_suite(
        self, waiter_names: list[str], actor_names: list[str]
    ) -> None:
        """Adds cmds to the cmd queue.

        Args:
            waiter_names: names of threads that will do the wait
            actor_names: names of threads that will do the resume

        """
        ################################################################
        # Loop to do combinations of resume names, the waiter names that
        # will be resumed - the remaining waiter names will timeout
        ################################################################
        for target_names in self.powerset(waiter_names.copy()):
            timeout_names = waiter_names
            if target_names:
                # target_names = list(target_names)
                ########################################################
                # resume the waiters that are expected to succeed
                ########################################################
                resume_cmd_serial_num = self.add_cmd(
                    Resume(
                        cmd_runners=actor_names,
                        targets=target_names,
                        exp_resumed_targets=target_names,
                        stopped_remotes=[],
                    )
                )
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="Resume",
                        confirm_serial_num=resume_cmd_serial_num,
                        confirmers=actor_names,
                    )
                )

                timeout_time = 1.5
                wait_serial_num = self.add_cmd(
                    WaitTimeoutFalse(
                        cmd_runners=target_names,
                        resumers=actor_names,
                        exp_resumers=actor_names,
                        stopped_remotes=set(),
                        timeout=timeout_time,
                    )
                )

                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="WaitTimeoutFalse",
                        confirm_serial_num=wait_serial_num,
                        confirmers=target_names,
                    )
                )

                timeout_names = list(set(waiter_names) - set(target_names))

            if timeout_names:
                ########################################################
                # the timeout_names are expected to timeout since they
                # were not resumed
                ########################################################
                timeout_time = 0.5
                wait_serial_num = self.add_cmd(
                    WaitTimeoutTrue(
                        cmd_runners=timeout_names,
                        resumers=actor_names,
                        exp_resumers=set(),
                        stopped_remotes=set(),
                        timeout=timeout_time,
                        timeout_remotes=set(actor_names),
                    )
                )

                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="WaitTimeoutTrue",
                        confirm_serial_num=wait_serial_num,
                        confirmers=timeout_names,
                    )
                )

    ####################################################################
    # build_wait_active_suite
    ####################################################################
    def build_resume_after_wait_timeout_suite(
        self, waiter_names: list[str], actor_names: list[str]
    ) -> None:
        """Adds cmds to the cmd queue.

        Args:
            waiter_names: names of threads that will do the wait
            actor_names: names of threads that will do the resume

        """
        ################################################################
        # Loop to do combinations of resume names, the waiter names that
        # will be resumed - the remaining waiter names will timeout
        ################################################################
        for target_names in self.powerset(waiter_names.copy()):
            timeout_names = waiter_names
            if target_names:
                ########################################################
                # resume the waiters that are expected to succeed
                ########################################################
                timeout_time = 1.5
                wait_serial_num = self.add_cmd(
                    WaitTimeoutFalse(
                        cmd_runners=list(target_names),
                        resumers=actor_names,
                        exp_resumers=actor_names,
                        stopped_remotes=set(),
                        timeout=timeout_time,
                    )
                )

                resume_cmd_serial_num = self.add_cmd(
                    Resume(
                        cmd_runners=actor_names,
                        targets=list(target_names),
                        exp_resumed_targets=list(target_names),
                        stopped_remotes=[],
                    )
                )
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="Resume",
                        confirm_serial_num=resume_cmd_serial_num,
                        confirmers=actor_names,
                    )
                )

                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="WaitTimeoutFalse",
                        confirm_serial_num=wait_serial_num,
                        confirmers=list(target_names),
                    )
                )

                timeout_names = list(set(waiter_names) - set(target_names))

            if timeout_names:
                ########################################################
                # the timeout_names are expected to timeout since they
                # were not resumed
                ########################################################
                timeout_time = 0.5
                wait_serial_num = self.add_cmd(
                    WaitTimeoutTrue(
                        cmd_runners=timeout_names,
                        resumers=actor_names,
                        exp_resumers=set(),
                        stopped_remotes=set(),
                        timeout=timeout_time,
                        timeout_remotes=set(actor_names),
                    )
                )
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="WaitTimeoutTrue",
                        confirm_serial_num=wait_serial_num,
                        confirmers=timeout_names,
                    )
                )

    ####################################################################
    # build_wait_active_suite
    ####################################################################
    def build_resume_exit_wait_timeout_suite(
        self, waiter_names: list[str], actor_names: list[str]
    ) -> None:
        """Adds cmds to the cmd queue.

        Args:
            waiter_names: names of threads that will do the wait
            actor_names: names of threads that will do the resume

        """
        ################################################################
        # Loop to do combinations of resume names, the waiter names that
        # will be resumed - the remaining waiter names will timeout
        ################################################################
        for target_names in self.powerset(waiter_names.copy()):
            timeout_names = waiter_names
            if target_names:
                # target_names = list(target_names)
                ########################################################
                # resume the waiters that are expected to succeed
                ########################################################
                resume_cmd_serial_num = self.add_cmd(
                    Resume(
                        cmd_runners=actor_names,
                        targets=target_names,
                        exp_resumed_targets=target_names,
                        stopped_remotes=[],
                    )
                )

                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="Resume",
                        confirm_serial_num=resume_cmd_serial_num,
                        confirmers=actor_names,
                    )
                )

                self.build_exit_suite(cmd_runner=self.commander_name, names=actor_names)
                self.build_join_suite(
                    cmd_runners=self.commander_name, join_target_names=actor_names
                )

                for resumer_name in actor_names:
                    self.add_cmd(
                        VerifyConfig(
                            cmd_runners=self.commander_name,
                            verify_type=VerifyType.VerifyHalfPaired,
                            names_to_check=target_names,
                            aux_names=resumer_name,
                        )
                    )

                timeout_time = 1.5
                wait_serial_num = self.add_cmd(
                    WaitTimeoutFalse(
                        cmd_runners=target_names,
                        resumers=actor_names,
                        exp_resumers=actor_names,
                        stopped_remotes=set(),
                        timeout=timeout_time,
                    )
                )
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="WaitTimeoutFalse",
                        confirm_serial_num=wait_serial_num,
                        confirmers=target_names,
                    )
                )

                f1_create_items: list[F1CreateItem] = []
                for idx, name in enumerate(actor_names):
                    if idx % 2:
                        app_config = AppConfig.ScriptStyle
                    else:
                        app_config = AppConfig.RemoteThreadApp

                    f1_create_items.append(
                        F1CreateItem(
                            name=name,
                            auto_start=True,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    )
                self.build_create_suite(
                    f1_create_items=f1_create_items, validate_config=False
                )

                timeout_names = list(set(waiter_names) - set(target_names))

            if timeout_names:
                ########################################################
                # the timeout_names are expected to timeout since they
                # were not resumed
                ########################################################
                timeout_time = 0.5
                wait_serial_num = self.add_cmd(
                    WaitTimeoutTrue(
                        cmd_runners=timeout_names,
                        resumers=actor_names,
                        exp_resumers=set(),
                        stopped_remotes=set(),
                        timeout=timeout_time,
                        timeout_remotes=set(actor_names),
                    )
                )
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="WaitTimeoutTrue",
                        confirm_serial_num=wait_serial_num,
                        confirmers=timeout_names,
                    )
                )

    ####################################################################
    # build_exit_resume_wait_timeout_suite
    ####################################################################
    def build_exit_resume_wait_timeout_suite(
        self, waiter_names: list[str], actor_names: list[str]
    ) -> None:
        """Adds cmds to the cmd queue.

        Args:
            waiter_names: names of threads that will do the wait
            actor_names: names of threads that will do the resume

        """
        ################################################################
        # Loop to do combinations of resume names, the waiter names that
        # will be resumed - the remaining waiter names will timeout
        ################################################################
        for target_names in self.powerset(waiter_names.copy()):
            timeout_names = waiter_names

            if len(target_names) % 2:
                stopped_remotes = set(actor_names.copy())
                exp_resumers = set()
            else:
                stopped_remotes = set()
                exp_resumers = set(actor_names.copy())

            if target_names:
                # target_names = list(target_names)

                timeout_time = 3.0
                wait_serial_num = self.add_cmd(
                    WaitTimeoutFalse(
                        cmd_runners=target_names,
                        resumers=actor_names,
                        exp_resumers=exp_resumers,
                        stopped_remotes=stopped_remotes,
                        timeout=timeout_time,
                    )
                )

                if stopped_remotes:
                    self.build_exit_suite(
                        cmd_runner=self.commander_name, names=actor_names
                    )

                    self.add_cmd(
                        ConfirmResponse(
                            cmd_runners=[self.commander_name],
                            confirm_cmd="WaitTimeoutFalse",
                            confirm_serial_num=wait_serial_num,
                            confirmers=target_names,
                        )
                    )

                    self.build_join_suite(
                        cmd_runners=self.commander_name, join_target_names=actor_names
                    )

                    f1_create_items: list[F1CreateItem] = []
                    for idx, name in enumerate(actor_names):
                        if idx % 2:
                            app_config = AppConfig.ScriptStyle
                        else:
                            app_config = AppConfig.RemoteThreadApp

                        f1_create_items.append(
                            F1CreateItem(
                                name=name,
                                auto_start=True,
                                target_rtn=outer_f1,
                                app_config=app_config,
                            )
                        )
                    self.build_create_suite(
                        f1_create_items=f1_create_items, validate_config=False
                    )

                if not stopped_remotes:
                    ####################################################
                    # resume the waiters that are expected to succeed
                    ####################################################
                    resume_cmd_serial_num = self.add_cmd(
                        Resume(
                            cmd_runners=actor_names,
                            targets=target_names,
                            exp_resumed_targets=target_names,
                            stopped_remotes=[],
                        )
                    )

                    self.add_cmd(
                        ConfirmResponse(
                            cmd_runners=[self.commander_name],
                            confirm_cmd="Resume",
                            confirm_serial_num=resume_cmd_serial_num,
                            confirmers=actor_names,
                        )
                    )

                    self.add_cmd(
                        ConfirmResponse(
                            cmd_runners=[self.commander_name],
                            confirm_cmd="WaitTimeoutFalse",
                            confirm_serial_num=wait_serial_num,
                            confirmers=target_names,
                        )
                    )

                timeout_names = list(set(waiter_names) - set(target_names))

            if timeout_names:
                ########################################################
                # the timeout_names are expected to timeout since they
                # were not resumed
                ########################################################
                if len(timeout_names) % 2:
                    stopped_remotes = set(actor_names.copy())
                    self.build_exit_suite(
                        cmd_runner=self.commander_name, names=actor_names
                    )
                else:
                    stopped_remotes = set()

                timeout_time = 0.5
                wait_serial_num = self.add_cmd(
                    WaitTimeoutTrue(
                        cmd_runners=timeout_names,
                        resumers=actor_names,
                        exp_resumers=set(),
                        stopped_remotes=stopped_remotes,
                        timeout=timeout_time,
                        timeout_remotes=set(actor_names),
                    )
                )
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="WaitTimeoutTrue",
                        confirm_serial_num=wait_serial_num,
                        confirmers=timeout_names,
                    )
                )
                if stopped_remotes:
                    self.build_join_suite(
                        cmd_runners=self.commander_name, join_target_names=actor_names
                    )

                    f1_create_items = []
                    for idx, name in enumerate(actor_names):
                        if idx % 2:
                            app_config = AppConfig.ScriptStyle
                        else:
                            app_config = AppConfig.RemoteThreadApp

                        f1_create_items.append(
                            F1CreateItem(
                                name=name,
                                auto_start=True,
                                target_rtn=outer_f1,
                                app_config=app_config,
                            )
                        )
                    self.build_create_suite(
                        f1_create_items=f1_create_items, validate_config=False
                    )

    ####################################################################
    # build_wait_active_suite
    ####################################################################
    def build_unreg_resume_wait_timeout_suite(
        self, waiter_names: list[str], actor_names: list[str]
    ) -> None:
        """Adds cmds to the cmd queue.

        Args:
            waiter_names: names of threads that will do the wait
            actor_names: names of threads that will do the resume

        """
        ################################################################
        # Loop to do combinations of resume names, the waiter names that
        # will be resumed - the remaining waiter names will timeout
        ################################################################
        for target_names in self.powerset(waiter_names.copy()):
            if target_names:
                # target_names = list(target_names)

                ########################################################
                # get actors into unreg state
                ########################################################
                self.build_exit_suite(cmd_runner=self.commander_name, names=actor_names)
                self.build_join_suite(
                    cmd_runners=self.commander_name, join_target_names=actor_names
                )

                ########################################################
                # do the wait
                ########################################################
                wait_serial_num = self.add_cmd(
                    Wait(
                        cmd_runners=target_names,
                        resumers=actor_names,
                        exp_resumers=actor_names,
                        stopped_remotes=set(),
                    )
                )

                ########################################################
                # get actors into active state
                ########################################################
                f1_create_items: list[F1CreateItem] = []
                for idx, name in enumerate(actor_names):
                    if idx % 2:
                        app_config = AppConfig.ScriptStyle
                    else:
                        app_config = AppConfig.RemoteThreadApp

                    f1_create_items.append(
                        F1CreateItem(
                            name=name,
                            auto_start=True,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    )
                self.build_create_suite(
                    f1_create_items=f1_create_items, validate_config=False
                )

                ########################################################
                # resume the waiters
                ########################################################
                resume_cmd_serial_num = self.add_cmd(
                    Resume(
                        cmd_runners=actor_names,
                        targets=target_names,
                        exp_resumed_targets=target_names,
                        stopped_remotes=[],
                    )
                )

                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="Resume",
                        confirm_serial_num=resume_cmd_serial_num,
                        confirmers=actor_names,
                    )
                )

                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="Wait",
                        confirm_serial_num=wait_serial_num,
                        confirmers=target_names,
                    )
                )

    ####################################################################
    # build_wait_active_suite
    ####################################################################
    def build_reg_resume_wait_timeout_suite(
        self, waiter_names: list[str], actor_names: list[str]
    ) -> None:
        """Adds cmds to the cmd queue.

        Args:
            waiter_names: names of threads that will do the wait
            actor_names: names of threads that will do the resume

        """
        ################################################################
        # Loop to do combinations of resume names, the waiter names that
        # will be resumed - the remaining waiter names will timeout
        ################################################################
        for target_names in self.powerset(waiter_names.copy()):
            if target_names:
                ########################################################
                # get actors into reg state
                ########################################################
                self.build_exit_suite(cmd_runner=self.commander_name, names=actor_names)
                self.build_join_suite(
                    cmd_runners=self.commander_name, join_target_names=actor_names
                )

                f1_create_items: list[F1CreateItem] = []
                for idx, name in enumerate(actor_names):
                    if idx % 2:
                        app_config = AppConfig.ScriptStyle
                    else:
                        app_config = AppConfig.RemoteThreadApp

                    f1_create_items.append(
                        F1CreateItem(
                            name=name,
                            auto_start=False,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    )
                self.build_create_suite(
                    f1_create_items=f1_create_items, validate_config=False
                )

                ########################################################
                # do the wait
                ########################################################
                wait_serial_num = self.add_cmd(
                    Wait(
                        cmd_runners=target_names,
                        resumers=actor_names,
                        exp_resumers=actor_names,
                        stopped_remotes=set(),
                    )
                )

                ########################################################
                # get actors into active state
                ########################################################
                self.build_start_suite(start_names=actor_names)

                ########################################################
                # resume the waiters
                ########################################################
                resume_cmd_serial_num = self.add_cmd(
                    Resume(
                        cmd_runners=actor_names,
                        targets=target_names,
                        exp_resumed_targets=target_names,
                        stopped_remotes=[],
                    )
                )

                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="Resume",
                        confirm_serial_num=resume_cmd_serial_num,
                        confirmers=actor_names,
                    )
                )

                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="Wait",
                        confirm_serial_num=wait_serial_num,
                        confirmers=target_names,
                    )
                )

    ####################################################################
    # build_resume_scenario
    ####################################################################
    def build_resume_scenarios(
        self,
        num_resumers: int,
        num_start_before: int,
        num_unreg_before: int,
        num_stop_before: int,
        num_unreg_after: int,
        num_stop_after_ok: int,
        num_stop_after_err: int,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_resumers: number of threads doing resumes
            num_start_before: number of target_rtn threads that will
                be started and issue a wait before the resume is done,
                and should succeed
            num_unreg_before: number of target_rtn threads that will be
                registered and then unregistered before the resume, and
                then started after the resume, and should succeed
            num_stop_before: number of target_rtn threads that will
                be started and then stopped (but not joined) before the
                resume, and should result in a not alive error
            num_unreg_after: number of target_rtn threads that will be
                unregistered after the resume, and should cause an error
            num_stop_after_ok: number of target_rtn threads that will
                be started after the resume is issued, and will stay
                alive long enough for the resume to set the wait_flag,
                and will then be stopped and joined, and should result
                in success
            num_stop_after_err: number of target_rtn threads that will
                be started after the resume is issued, and will quickly
                be stopped and joined before the resume has a chance to
                see that is is alive to set the wait_flag, and should
                result in a not alive error

        """
        # Make sure we have enough threads
        total_arg_counts = (
            num_resumers
            + num_start_before
            + num_unreg_before
            + num_stop_before
            + num_unreg_after
            + num_stop_after_ok
            + num_stop_after_err
        )
        assert total_arg_counts <= len(self.unregistered_names)

        assert num_resumers > 0

        num_active_needed = num_resumers + 1  # plus 1 for commander

        self.build_config(
            cmd_runner=self.commander_name,
            num_active=num_active_needed,
        )

        # remove commander
        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose resumer_names
        ################################################################
        resumer_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_resumers,
            update_collection=True,
            var_name_for_log="resumer_names",
        )

        ################################################################
        # choose start_before_names
        ################################################################
        unregistered_names_copy = self.unregistered_names.copy()
        start_before_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_start_before,
            update_collection=True,
            var_name_for_log="start_before_names",
        )

        ################################################################
        # choose unreg_before_names
        ################################################################
        unreg_before_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_unreg_before,
            update_collection=True,
            var_name_for_log="unreg_before_names",
        )

        ################################################################
        # choose stop_before_names
        ################################################################
        stop_before_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_stop_before,
            update_collection=True,
            var_name_for_log="stop_before_names",
        )

        ################################################################
        # choose unreg_after_names
        ################################################################
        unreg_after_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_unreg_after,
            update_collection=True,
            var_name_for_log="unreg_after_names",
        )

        ################################################################
        # choose stop_after_ok_names
        ################################################################
        stop_after_ok_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_stop_after_ok,
            update_collection=True,
            var_name_for_log="stop_after_ok_names",
        )

        ################################################################
        # choose stop_after_ok_names
        ################################################################
        stop_after_err_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_stop_after_err,
            update_collection=True,
            var_name_for_log="stop_after_err_names",
        )

        all_targets: list[str] = (
            start_before_names
            + unreg_before_names
            + stop_before_names
            + unreg_after_names
            + stop_after_ok_names
            + stop_after_err_names
        )

        after_targets: list[str] = (
            unreg_before_names
            + unreg_after_names
            + stop_after_ok_names
            + stop_after_err_names
        )

        ################################################################
        # monkeypatch for SmartThread._get_target_state
        ################################################################
        a_target_mock_dict = {}
        if stop_after_err_names:
            for resumer_name in resumer_names:
                a_sub_dict = {}
                for stop_name in stop_after_err_names:
                    a_sub_dict[stop_name] = (
                        st.ThreadState.Alive,
                        st.ThreadState.Registered,
                    )
                a_target_mock_dict[resumer_name] = a_sub_dict

        MockGetTargetState(targets=a_target_mock_dict, config_ver=self)

        resume_serial_num_2 = 0

        wait_confirms: list[ConfirmResponse] = []
        for idx, waiter in enumerate(
            roundrobin(start_before_names, unreg_before_names, stop_before_names)
        ):
            if idx % 2:
                app_config = AppConfig.ScriptStyle
            else:
                app_config = AppConfig.RemoteThreadApp

            if waiter in start_before_names:
                self.build_create_suite(
                    f1_create_items=[
                        F1CreateItem(
                            name=waiter,
                            auto_start=True,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    ],
                    validate_config=False,
                )
                wait_serial_num = self.add_cmd(
                    Wait(
                        cmd_runners=waiter,
                        resumers=resumer_names,
                        exp_resumers=resumer_names,
                    )
                )
                wait_confirms.append(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="Wait",
                        confirm_serial_num=wait_serial_num,
                        confirmers=waiter,
                    )
                )
            elif waiter in unreg_before_names:
                self.build_create_suite(
                    f1_create_items=[
                        F1CreateItem(
                            name=waiter,
                            auto_start=False,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    ],
                    validate_config=False,
                )
                self.build_unreg_suite(names=waiter)
            elif waiter in stop_before_names:
                self.build_create_suite(
                    f1_create_items=[
                        F1CreateItem(
                            name=waiter,
                            auto_start=True,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    ],
                    validate_config=False,
                )
                # stop now, join later
                self.build_exit_suite(
                    cmd_runner=self.commander_name, names=waiter, validate_config=False
                )
            else:
                raise IncorrectDataDetected(
                    "build_resume_scenarios "
                    f"{waiter=} not found in "
                    f"{start_before_names=} nor "
                    f"{unreg_before_names=} nor "
                    f"{stop_before_names=}"
                )

        ################################################################
        # wait for wait to be running and waiting to be resumed
        ################################################################
        if start_before_names:
            self.add_cmd(
                WaitForRequestTimeouts(
                    cmd_runners=self.commander_name,
                    actor_names=start_before_names,
                    timeout_names=resumer_names,
                )
            )
        ################################################################
        # issue smart_resume
        ################################################################
        if stop_before_names:
            stopped_remotes = stop_before_names
            exp_resumed_targets = set(start_before_names)
        else:
            exp_resumed_targets = (
                set(start_before_names)
                | set(unreg_before_names)
                | set(stop_after_ok_names)
            )
            stopped_remotes = unreg_after_names + stop_after_err_names

        resume_serial_num_1 = self.add_cmd(
            Resume(
                cmd_runners=resumer_names,
                targets=all_targets,
                exp_resumed_targets=exp_resumed_targets,
                stopped_remotes=stopped_remotes,
            )
        )

        ################################################################
        # confirm response now if we should have raised error for
        # stopped remotes
        ################################################################
        if stop_before_names:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd="Resume",
                    confirm_serial_num=resume_serial_num_1,
                    confirmers=resumer_names,
                )
            )
            ############################################################
            # we need this resume for the after resume waits when the
            # first resume ends early because of stopped remotes
            ############################################################
            if after_targets:
                stopped_remotes = unreg_after_names + stop_after_err_names
                exp_resumed_targets = set(unreg_before_names) | set(stop_after_ok_names)
                resume_serial_num_2 = self.add_cmd(
                    Resume(
                        cmd_runners=resumer_names,
                        targets=after_targets,
                        exp_resumed_targets=exp_resumed_targets,
                        stopped_remotes=stopped_remotes,
                    )
                )

        ################################################################
        # Create and start unreg_before and stop_after_ok and issue the
        # wait. Note unreg_before is used both before and after the
        # resume
        ################################################################
        for idx, waiter in enumerate(
            roundrobin(unreg_before_names, stop_after_ok_names)
        ):
            if idx % 2:
                app_config = AppConfig.ScriptStyle
            else:
                app_config = AppConfig.RemoteThreadApp

            self.build_create_suite(
                f1_create_items=[
                    F1CreateItem(
                        name=waiter,
                        auto_start=True,
                        target_rtn=outer_f1,
                        app_config=app_config,
                    )
                ],
                validate_config=False,
            )
            wait_serial_num = self.add_cmd(
                Wait(
                    cmd_runners=waiter,
                    resumers=resumer_names,
                    exp_resumers=resumer_names,
                )
            )
            wait_confirms.append(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd="Wait",
                    confirm_serial_num=wait_serial_num,
                    confirmers=waiter,
                )
            )

        ################################################################
        # build unreg_after and stop_after_err
        ################################################################
        for idx, waiter in enumerate(
            roundrobin(unreg_after_names, stop_after_err_names)
        ):
            if idx % 2:
                app_config = AppConfig.ScriptStyle
            else:
                app_config = AppConfig.RemoteThreadApp

            if waiter in unreg_after_names:
                self.build_create_suite(
                    f1_create_items=[
                        F1CreateItem(
                            name=waiter,
                            auto_start=False,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    ],
                    validate_config=False,
                )
                self.build_unreg_suite(names=waiter)
            elif waiter in stop_after_err_names:
                self.build_create_suite(
                    f1_create_items=[
                        F1CreateItem(
                            name=waiter,
                            auto_start=True,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    ],
                    validate_config=False,
                )
                self.build_exit_suite(
                    cmd_runner=self.commander_name, names=waiter, validate_config=False
                )
                self.build_join_suite(
                    cmd_runners=self.commander_name,
                    join_target_names=waiter,
                    validate_config=False,
                )
            else:
                raise IncorrectDataDetected(
                    "build_resume_scenarios "
                    f"{waiter=} not found in "
                    f"{unreg_after_names=} nor "
                    f"{stop_after_err_names=}"
                )

        ####################################################
        # confirm the resumes
        ####################################################
        if not stop_before_names:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd="Resume",
                    confirm_serial_num=resume_serial_num_1,
                    confirmers=resumer_names,
                )
            )
        elif after_targets:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd="Resume",
                    confirm_serial_num=resume_serial_num_2,
                    confirmers=resumer_names,
                )
            )

        for confirm in wait_confirms:
            self.add_cmd(confirm)

    ####################################################################
    # build_srrw_scenario
    ####################################################################
    def build_srrw_scenario(
        self,
        req_type: st.ReqType,
        num_requestors: int,
        num_start_before: int,
        num_unreg_before: int,
        num_stop_before: int,
        num_unreg_after: int,
        num_stop_after_ok: int,
        num_stop_after_err: int,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            req_type: specifies whether to issue resume or wait
            num_requestors: number of threads doing resume/wait
            num_start_before: number of target_rtn threads that will
                be started and issue a wait/resume before the resume is
                done, and should succeed
            num_unreg_before: number of target_rtn threads that will be
                registered and then unregistered before the resume/wait,
                and then started after the resume/wait, and should
                succeed
            num_stop_before: number of target_rtn threads that will
                be started and then stopped (but not joined) before the
                resume, and should result in a not alive error
            num_unreg_after: number of target_rtn threads that will be
                unregistered after the resume, and should cause an error
            num_stop_after_ok: number of target_rtn threads that will
                be started after the resume is issued, and will stay
                alive long enough for the resume to set the wait_flag,
                and will then be stopped and joined, and should result
                in success
            num_stop_after_err: number of target_rtn threads that will
                be started after the resume is issued, and will quickly
                be stopped and joined before the resume has a chance to
                see that is is alive to set the wait_flag, and should
                result in a not alive error

        """
        # Make sure we have enough threads
        total_arg_counts = (
            num_requestors
            + num_start_before
            + num_unreg_before
            + num_stop_before
            + num_unreg_after
            + num_stop_after_ok
            + num_stop_after_err
        )
        assert total_arg_counts <= len(self.unregistered_names)

        assert num_requestors > 0

        requestors = get_names("requestor_", num_requestors)
        start_before_names = get_names("start_before_", num_start_before)
        unreg_before_names = get_names("unreg_before_", num_unreg_before)
        stop_before_names = get_names("stop_before_", num_stop_before)
        unreg_after_names = get_names("unreg_after_", num_unreg_after)
        stop_after_ok_names = get_names("stop_after_ok_", num_stop_after_ok)
        stop_after_err_names = get_names("stop_after_err_", num_stop_after_err)

        all_targets: set[str] = (
            start_before_names
            | unreg_before_names
            | stop_before_names
            | unreg_after_names
            | stop_after_ok_names
            | stop_after_err_names
        )

        after_targets: set[str] = (
            unreg_before_names
            | unreg_after_names
            | stop_after_ok_names
            | stop_after_err_names
        )

        self.create_config(unreg_names=all_targets, active_names=requestors)

        ################################################################
        # monkeypatch for SmartThread._get_target_state
        ################################################################
        a_target_mock_dict = {}
        if stop_after_err_names:
            for requestor_name in requestors:
                a_sub_dict = {}
                for stop_name in stop_after_err_names:
                    a_sub_dict[stop_name] = (
                        st.ThreadState.Alive,
                        st.ThreadState.Registered,
                    )
                a_target_mock_dict[requestor_name] = a_sub_dict

        MockGetTargetState(targets=a_target_mock_dict, config_ver=self)

        ################################################################
        # msgs_to_send
        ################################################################
        msgs_to_send = SendRecvMsgs(
            sender_names=requestors | all_targets,
            receiver_names=requestors | all_targets,
            num_msgs=1,
            text="build_srrw_scenario",
        )

        ################################################################
        # build_send_request
        ################################################################
        def build_send_request(
            cmd_runners: Iterable[str],
            targets: Iterable[str],
            exp_targets: Iterable[str],
            stopped_targets: Optional[Iterable[str]] = None,
        ) -> tuple[str, int]:
            """Add send request to run scenario."""
            request_to_confirm = "SendMsg"
            request_serial_num = self.add_cmd(
                SendMsg(
                    cmd_runners=cmd_runners,
                    receivers=targets,
                    exp_receivers=exp_targets,
                    stopped_remotes=stopped_targets,
                    msgs_to_send=msgs_to_send,
                    msg_idx=0,
                )
            )

            return request_to_confirm, request_serial_num

        ################################################################
        # build_receive_request
        ################################################################
        def build_recv_request(
            cmd_runners: Iterable[str],
            targets: Iterable[str],
            exp_targets: Iterable[str],
            stopped_targets: Optional[Iterable[str]] = None,
        ) -> tuple[str, int]:
            """Add receive request to run scenario."""
            request_to_confirm = "RecvMsg"
            request_serial_num = self.add_cmd(
                RecvMsg(
                    cmd_runners=cmd_runners,
                    senders=targets,
                    exp_senders=exp_targets,
                    stopped_remotes=stopped_targets,
                    exp_msgs=msgs_to_send,
                )
            )
            return request_to_confirm, request_serial_num

        ################################################################
        # build_resume_request
        ################################################################
        def build_resume_request(
            cmd_runners: Iterable[str],
            targets: Iterable[str],
            exp_targets: Iterable[str],
            stopped_targets: Optional[Iterable[str]] = None,
        ) -> tuple[str, int]:
            """Add send request to run scenario."""
            request_to_confirm = "Resume"
            request_serial_num = self.add_cmd(
                Resume(
                    cmd_runners=cmd_runners,
                    targets=targets,
                    exp_resumed_targets=exp_targets,
                    stopped_remotes=stopped_targets,
                )
            )
            return request_to_confirm, request_serial_num

        ################################################################
        # build_wait_request
        ################################################################
        def build_wait_request(
            cmd_runners: Iterable[str],
            targets: Iterable[str],
            exp_targets: Iterable[str],
            stopped_targets: Optional[Iterable[str]] = None,
        ) -> tuple[str, int]:
            """Add wait request to run scenario."""
            request_to_confirm = "Wait"
            request_serial_num = self.add_cmd(
                Wait(
                    cmd_runners=cmd_runners,
                    resumers=targets,
                    exp_resumers=exp_targets,
                    stopped_remotes=stopped_targets,
                )
            )
            return request_to_confirm, request_serial_num

        ################################################################
        # request_builds table
        ################################################################
        request_builds: dict[st.ReqType, Callable[..., tuple[str, int]]] = {
            st.ReqType.Smart_send: build_send_request,
            st.ReqType.Smart_recv: build_recv_request,
            st.ReqType.Smart_resume: build_resume_request,
            st.ReqType.Smart_wait: build_wait_request,
        }

        ################################################################
        # target_builds table
        ################################################################
        target_builds: dict[st.ReqType, Callable[..., tuple[str, int]]] = {
            st.ReqType.Smart_send: build_recv_request,
            st.ReqType.Smart_recv: build_send_request,
            st.ReqType.Smart_resume: build_wait_request,
            st.ReqType.Smart_wait: build_resume_request,
        }

        confirm_req_1 = ""
        confirm_serial_1 = 0
        target_confirms_before: list[ConfirmResponse] = []
        target_confirms_after: list[ConfirmResponse] = []

        ################################################################
        # First batch of targets for start, unreg, and stop before
        ################################################################
        for idx, target in enumerate(
            roundrobin(start_before_names, unreg_before_names, stop_before_names)
        ):
            if idx % 2:
                app_config = AppConfig.ScriptStyle
            else:
                app_config = AppConfig.RemoteThreadApp

            if target in start_before_names:
                self.build_create_suite(
                    f1_create_items=[
                        F1CreateItem(
                            name=target,
                            auto_start=True,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    ],
                    validate_config=False,
                )
                confirm_req, confirm_serial = target_builds[req_type](
                    cmd_runners=target, targets=requestors, exp_targets=requestors
                )
                target_confirms_before.append(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd=confirm_req,
                        confirm_serial_num=confirm_serial,
                        confirmers=target,
                    )
                )
            elif target in unreg_before_names:
                self.build_create_suite(
                    f1_create_items=[
                        F1CreateItem(
                            name=target,
                            auto_start=False,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    ],
                    validate_config=False,
                )
                self.build_unreg_suite(names=target)
            elif target in stop_before_names:
                self.build_create_suite(
                    f1_create_items=[
                        F1CreateItem(
                            name=target,
                            auto_start=True,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    ],
                    validate_config=False,
                )
                # stop now, join later
                self.build_exit_suite(
                    cmd_runner=self.commander_name, names=target, validate_config=False
                )
            else:
                raise IncorrectDataDetected(
                    "build_srrw_scenario "
                    f"{target=} not found in "
                    f"{start_before_names=} nor "
                    f"{unreg_before_names=} nor "
                    f"{stop_before_names=}"
                )

        ################################################################
        # for recv/wait, make sure running before send/resume
        ################################################################
        if req_type in (st.ReqType.Smart_send, st.ReqType.Smart_resume):
            if start_before_names:
                self.add_cmd(
                    WaitForRequestTimeouts(
                        cmd_runners=self.commander_name,
                        actor_names=start_before_names,
                        timeout_names=requestors,
                    )
                )
        else:
            for confirm in target_confirms_before:
                self.add_cmd(confirm)

        ################################################################
        # issue request
        ################################################################
        if stop_before_names:
            stopped_remotes = stop_before_names
            exp_targets = start_before_names
        else:
            stopped_remotes = unreg_after_names | stop_after_err_names
            exp_targets = start_before_names | unreg_before_names | stop_after_ok_names

        confirm_req_0, confirm_serial_0 = request_builds[req_type](
            cmd_runners=requestors,
            targets=all_targets,
            exp_targets=exp_targets,
            stopped_targets=stopped_remotes,
        )

        ################################################################
        # confirm response now if we should have raised error for
        # stopped remotes
        ################################################################
        if stop_before_names:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd=confirm_req_0,
                    confirm_serial_num=confirm_serial_0,
                    confirmers=requestors,
                )
            )
            ############################################################
            # we need this request for the after targets when the first
            # request ends early because of stopped remotes
            ############################################################
            if after_targets:
                stopped_remotes = unreg_after_names | stop_after_err_names
                exp_targets = unreg_before_names | stop_after_ok_names

                confirm_req_1, confirm_serial_1 = request_builds[req_type](
                    cmd_runners=requestors,
                    targets=after_targets,
                    exp_targets=exp_targets,
                    stopped_targets=stopped_remotes,
                )

        ################################################################
        # Create and start unreg_before and stop_after_ok and issue the
        # target_rtn request. Note unreg_before is used both before and
        # after the request
        ################################################################
        for idx, target in enumerate(
            roundrobin(unreg_before_names, stop_after_ok_names)
        ):
            if idx % 2:
                app_config = AppConfig.ScriptStyle
            else:
                app_config = AppConfig.RemoteThreadApp

            self.build_create_suite(
                f1_create_items=[
                    F1CreateItem(
                        name=target,
                        auto_start=True,
                        target_rtn=outer_f1,
                        app_config=app_config,
                    )
                ],
                validate_config=False,
            )

            confirm_req, confirm_serial = target_builds[req_type](
                cmd_runners=target, targets=requestors, exp_targets=requestors
            )
            target_confirms_after.append(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd=confirm_req,
                    confirm_serial_num=confirm_serial,
                    confirmers=target,
                )
            )

        ################################################################
        # build unreg_after and stop_after_err
        ################################################################
        for idx, target in enumerate(
            roundrobin(unreg_after_names, stop_after_err_names)
        ):
            if idx % 2:
                app_config = AppConfig.ScriptStyle
            else:
                app_config = AppConfig.RemoteThreadApp

            if target in unreg_after_names:
                self.build_create_suite(
                    f1_create_items=[
                        F1CreateItem(
                            name=target,
                            auto_start=False,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    ],
                    validate_config=False,
                )
                self.build_unreg_suite(names=target)
            elif target in stop_after_err_names:
                self.build_create_suite(
                    f1_create_items=[
                        F1CreateItem(
                            name=target,
                            auto_start=True,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    ],
                    validate_config=False,
                )
                self.build_exit_suite(
                    cmd_runner=self.commander_name, names=target, validate_config=False
                )
                self.build_join_suite(
                    cmd_runners=self.commander_name,
                    join_target_names=target,
                    validate_config=False,
                )
            else:
                raise IncorrectDataDetected(
                    "build_srrw_scenario "
                    f"{target=} not found in "
                    f"{unreg_after_names=} nor "
                    f"{stop_after_err_names=}"
                )

        ####################################################
        # confirm the resumes
        ####################################################
        if not stop_before_names:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd=confirm_req_0,
                    confirm_serial_num=confirm_serial_0,
                    confirmers=requestors,
                )
            )
        elif after_targets:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd=confirm_req_1,
                    confirm_serial_num=confirm_serial_1,
                    confirmers=requestors,
                )
            )

        for confirm in target_confirms_after:
            self.add_cmd(confirm)

    ####################################################################
    # build_wait_scenario
    ####################################################################
    def build_wait_scenario(
        self,
        num_waiters: int,
        num_start_before: int,
        num_unreg_before: int,
        num_stop_before: int,
        num_unreg_after: int,
        num_stop_after_ok: int,
        num_stop_after_err: int,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_waiters: number of threads doing resumes
            num_start_before: number of target_rtn threads that will
                be started and issue a wait before the resume is done,
                and should succeed
            num_unreg_before: number of target_rtn threads that will be
                registered and then unregistered before the resume, and
                then started after the resume, and should succeed
            num_stop_before: number of target_rtn threads that will
                be started and then stopped (but not joined) before the
                resume, and should result in a not alive error
            num_unreg_after: number of target_rtn threads that will be
                unregistered after the resume, and should cause an error
            num_stop_after_ok: number of target_rtn threads that will
                be started after the resume is issued, and will stay
                alive long enough for the resume to set the wait_flag,
                and will then be stopped and joined, and should result
                in success
            num_stop_after_err: number of target_rtn threads that will
                be started after the resume is issued, and will quickly
                be stopped and joined before the resume has a chance to
                see that is is alive to sety the wait_flag, and should
                result in a not alive error

        """
        # Make sure we have enough threads
        total_arg_counts = (
            num_waiters
            + num_start_before
            + num_unreg_before
            + num_stop_before
            + num_unreg_after
            + num_stop_after_ok
            + num_stop_after_err
        )
        assert total_arg_counts <= len(self.unregistered_names)

        assert num_waiters > 0

        num_active_needed = num_waiters + 1  # plus 1 for commander

        self.build_config(
            cmd_runner=self.commander_name,
            num_active=num_active_needed,
        )

        # remove commander
        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose waiter_names
        ################################################################
        waiter_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_waiters,
            update_collection=True,
            var_name_for_log="waiter_names",
        )

        ################################################################
        # choose start_before_names
        ################################################################
        unregistered_names_copy = self.unregistered_names.copy()
        start_before_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_start_before,
            update_collection=True,
            var_name_for_log="start_before_names",
        )

        ################################################################
        # choose unreg_before_names
        ################################################################
        unreg_before_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_unreg_before,
            update_collection=True,
            var_name_for_log="unreg_before_names",
        )

        ################################################################
        # choose stop_before_names
        ################################################################
        stop_before_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_stop_before,
            update_collection=True,
            var_name_for_log="stop_before_names",
        )

        ################################################################
        # choose unreg_after_names
        ################################################################
        unreg_after_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_unreg_after,
            update_collection=True,
            var_name_for_log="unreg_after_names",
        )

        ################################################################
        # choose stop_after_ok_names
        ################################################################
        stop_after_ok_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_stop_after_ok,
            update_collection=True,
            var_name_for_log="stop_after_ok_names",
        )

        ################################################################
        # choose stop_after_ok_names
        ################################################################
        stop_after_err_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_stop_after_err,
            update_collection=True,
            var_name_for_log="stop_after_err_names",
        )

        all_targets: list[str] = (
            start_before_names
            + unreg_before_names
            + stop_before_names
            + unreg_after_names
            + stop_after_ok_names
            + stop_after_err_names
        )

        after_targets: list[str] = (
            unreg_before_names
            + unreg_after_names
            + stop_after_ok_names
            + stop_after_err_names
        )

        ################################################################
        # monkeypatch for SmartThread._get_target_state
        ################################################################
        a_target_mock_dict = {}
        if stop_after_err_names:
            for waiter_name in waiter_names:
                a_sub_dict = {}
                for stop_name in stop_after_err_names:
                    a_sub_dict[stop_name] = (
                        st.ThreadState.Alive,
                        st.ThreadState.Registered,
                    )
                a_target_mock_dict[waiter_name] = a_sub_dict

        MockGetTargetState(targets=a_target_mock_dict, config_ver=self)

        wait_serial_num_2 = 0

        resume_confirms_before: list[ConfirmResponse] = []
        resume_confirms_after: list[ConfirmResponse] = []

        for idx, resumer in enumerate(
            roundrobin(start_before_names, unreg_before_names, stop_before_names)
        ):
            if idx % 2:
                app_config = AppConfig.ScriptStyle
            else:
                app_config = AppConfig.RemoteThreadApp

            if resumer in start_before_names:
                self.build_create_suite(
                    f1_create_items=[
                        F1CreateItem(
                            name=resumer,
                            auto_start=True,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    ],
                    validate_config=False,
                )
                resume_serial_num = self.add_cmd(
                    Resume(
                        cmd_runners=resumer,
                        targets=waiter_names,
                        exp_resumed_targets=waiter_names,
                        stopped_remotes=set(),
                    )
                )
                resume_confirms_before.append(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="Resume",
                        confirm_serial_num=resume_serial_num,
                        confirmers=resumer,
                    )
                )
            elif resumer in unreg_before_names:
                self.build_create_suite(
                    f1_create_items=[
                        F1CreateItem(
                            name=resumer,
                            auto_start=False,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    ],
                    validate_config=False,
                )
                self.build_unreg_suite(names=resumer, validate_config=False)
            elif resumer in stop_before_names:
                self.build_create_suite(
                    f1_create_items=[
                        F1CreateItem(
                            name=resumer,
                            auto_start=True,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    ],
                    validate_config=False,
                )
                # stop now, join later
                self.build_exit_suite(
                    cmd_runner=self.commander_name, names=resumer, validate_config=False
                )
            else:
                raise IncorrectDataDetected(
                    "build_resume_scenarios "
                    f"{resumer=} not found in "
                    f"{start_before_names=} nor "
                    f"{unreg_before_names=} nor "
                    f"{stop_before_names=}"
                )

        ################################################################
        # confirm the before resumes
        ################################################################
        for confirm in resume_confirms_before:
            self.add_cmd(confirm)
        ################################################################
        # issue smart_wait
        ################################################################
        if stop_before_names:
            stopped_remotes = stop_before_names
            exp_resumers = set(start_before_names)
        else:
            stopped_remotes = unreg_after_names + stop_after_err_names
            exp_resumers = (
                set(start_before_names)
                | set(unreg_before_names)
                | set(stop_after_ok_names)
            )

        wait_serial_num_1 = self.add_cmd(
            Wait(
                cmd_runners=waiter_names,
                resumers=all_targets,
                exp_resumers=exp_resumers,
                stopped_remotes=stopped_remotes,
            )
        )

        ################################################################
        # confirm response now if we should have raised error for
        # stopped remotes
        ################################################################
        if stop_before_names:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd="Wait",
                    confirm_serial_num=wait_serial_num_1,
                    confirmers=waiter_names,
                )
            )
            ############################################################
            # we need this wait for the after wait resumes when the
            # first wait ends early because of stopped remotes
            ############################################################
            if after_targets:
                stopped_remotes = unreg_after_names + stop_after_err_names
                exp_resumers = set(unreg_before_names) | set(stop_after_ok_names)
                wait_serial_num_2 = self.add_cmd(
                    Wait(
                        cmd_runners=waiter_names,
                        resumers=after_targets,
                        exp_resumers=exp_resumers,
                        stopped_remotes=stopped_remotes,
                    )
                )

        ################################################################
        # Create and start unreg_before and stop_after_ok and issue the
        # resume. Note unreg_before is used both before and after the
        # wait
        ################################################################
        for idx, resumer in enumerate(
            roundrobin(unreg_before_names, stop_after_ok_names)
        ):
            if idx % 2:
                app_config = AppConfig.ScriptStyle
            else:
                app_config = AppConfig.RemoteThreadApp

            self.build_create_suite(
                f1_create_items=[
                    F1CreateItem(
                        name=resumer,
                        auto_start=True,
                        target_rtn=outer_f1,
                        app_config=app_config,
                    )
                ],
                validate_config=False,
            )
            resume_serial_num = self.add_cmd(
                Resume(
                    cmd_runners=resumer,
                    targets=waiter_names,
                    exp_resumed_targets=waiter_names,
                    stopped_remotes=set(),
                )
            )
            resume_confirms_after.append(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd="Resume",
                    confirm_serial_num=resume_serial_num,
                    confirmers=resumer,
                )
            )

        ################################################################
        # build unreg_after and stop_after_err
        ################################################################
        for idx, resumer in enumerate(
            roundrobin(unreg_after_names, stop_after_err_names)
        ):
            if idx % 2:
                app_config = AppConfig.ScriptStyle
            else:
                app_config = AppConfig.RemoteThreadApp

            if resumer in unreg_after_names:
                self.build_create_suite(
                    f1_create_items=[
                        F1CreateItem(
                            name=resumer,
                            auto_start=False,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    ],
                    validate_config=False,
                )
                self.build_unreg_suite(names=resumer, validate_config=False)
            elif resumer in stop_after_err_names:
                self.build_create_suite(
                    f1_create_items=[
                        F1CreateItem(
                            name=resumer,
                            auto_start=True,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    ],
                    validate_config=False,
                )
                self.build_exit_suite(
                    cmd_runner=self.commander_name, names=resumer, validate_config=False
                )
                self.build_join_suite(
                    cmd_runners=self.commander_name,
                    join_target_names=resumer,
                    validate_config=False,
                )
            else:
                raise IncorrectDataDetected(
                    "build_resume_scenarios "
                    f"{resumer=} not found in "
                    f"{unreg_after_names=} nor "
                    f"{stop_after_err_names=}"
                )

        ####################################################
        # confirm the waits
        ####################################################
        if not stop_before_names:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd="Wait",
                    confirm_serial_num=wait_serial_num_1,
                    confirmers=waiter_names,
                )
            )
        elif after_targets:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd="Wait",
                    confirm_serial_num=wait_serial_num_2,
                    confirmers=waiter_names,
                )
            )

        for confirm in resume_confirms_after:
            self.add_cmd(confirm)

    ####################################################################
    # build_resume_timeout_suite
    ####################################################################
    def build_resume_timeout_suite(
        self,
        timeout_type: TimeoutType,
        num_resumers: int,
        num_active: int,
        num_registered_before: int,
        num_registered_after: int,
        num_unreg_no_delay: int,
        num_unreg_delay: int,
        num_stopped: int,
    ) -> None:
        """Add ConfigCmd items for smart_resume timeout scenarios.

        Args:
            timeout_type: specifies whether to issue the send_cmd with
                timeout, and if so whether the send_cmd should timeout
                or, by starting exited threads in time, not timeout
            num_resumers: number of threads doing resumes
            num_active: number threads active that will wait before the
                resume is done. This is the most expected use case. No
                resume timeout should occur for active targets.
            num_registered_before: number threads registered that will
                be started and then wait before the resume is issued.
                This case provides a variation by having a configuration
                change occur while the active targets are waiting. No
                resume timeout should occur for registered_before
                targets.
            num_registered_after: number threads registered that are
                started and wait after the resume is issued. This case
                provides a variation of a resume target_rtn being not
                alive when the resume is issued, and then a
                configuration change while the resume is running and the
                resume sees that the target_rtn is now alive. There is
                no significant delay between the resume and the start to
                expect the registered_after targets to cause a timeout.
            num_unreg_no_delay: number threads unregistered before the
                resume is done, and are then created and started within
                the allowed timeout
            num_unreg_delay: number threads unregistered before the
                resume is done, and are then created and started after
                the allowed timeout
            num_stopped: number of threads stopped before the
                resume and are resurrected after the resume. This should
                cause the resume to fail with a NotAlive error, and the
                stopped threads will wait and will need a new resume.

        """
        # Make sure we have enough threads
        assert (
            num_resumers
            + num_active
            + num_registered_before
            + num_registered_after
            + num_unreg_no_delay
            + num_unreg_delay
            + num_stopped
        ) <= len(self.unregistered_names)

        assert num_resumers > 0

        timeout_time = (
            (num_active * 0.16)
            + (num_registered_before * 0.16)
            + (num_registered_after * 0.16)
            + (num_unreg_no_delay * 0.32)
            + (num_unreg_delay * 0.16)
            + (num_stopped * 0.32)
        )

        pause_time = 0.5
        if timeout_type == TimeoutType.TimeoutFalse:
            timeout_time *= 4  # prevent timeout
            pause_time = timeout_time * 0.10
        elif timeout_type == TimeoutType.TimeoutTrue:
            # timeout_time *= 0.5  # force timeout
            pause_time = timeout_time * 2

        resumers = get_names("resumer_", num_resumers)

        active_waiters = get_names("active_waiter_", num_active)

        reg_waiters = get_names("reg_waiter_", num_registered_before)

        reg_delay_waiters = get_names("reg_delay_waiter_", num_registered_after)

        unreg_waiters = get_names("unreg_waiter_", num_unreg_no_delay)

        unreg_delay_waiters = get_names("unreg_delay_waiter_", num_unreg_delay)

        stopped_waiters = get_names("stopped_waiter_", num_stopped)

        self.create_config(
            unreg_names=unreg_waiters | unreg_delay_waiters,
            reg_names=reg_waiters | reg_delay_waiters,
            active_names=resumers | active_waiters,
            stopped_names=stopped_waiters,
        )

        all_targets: set[str] = (
            active_waiters
            | reg_waiters
            | reg_delay_waiters
            | unreg_waiters
            | unreg_delay_waiters
            | stopped_waiters
        )

        timeout_names = unreg_delay_waiters | reg_delay_waiters

        if stopped_waiters:
            exp_resumed_targets = active_waiters | reg_waiters
        else:
            if timeout_type != TimeoutType.TimeoutTrue:
                exp_resumed_targets = all_targets
            else:
                exp_resumed_targets = active_waiters | reg_waiters | unreg_waiters

        ################################################################
        # issue smart_wait for active_waiters
        ################################################################
        if active_waiters:
            wait_active_target_serial_num = self.add_cmd(
                Wait(
                    cmd_runners=active_waiters, resumers=resumers, exp_resumers=resumers
                )
            )

        ################################################################
        # start reg_waiters issue smart_wait
        # This provides a variation where a configuration change (start)
        # is done while the above wait for active targets is in progress
        ################################################################
        if reg_waiters:
            self.build_start_suite(start_names=reg_waiters)
            wait_reg_before_target_serial_num = self.add_cmd(
                Wait(cmd_runners=reg_waiters, resumers=resumers, exp_resumers=resumers)
            )

        ################################################################
        # issue smart_resume
        ################################################################
        if timeout_type == TimeoutType.TimeoutNone:
            resume_to_confirm = "Resume"
            resume_serial_num = self.add_cmd(
                Resume(
                    cmd_runners=resumers,
                    targets=all_targets,
                    exp_resumed_targets=exp_resumed_targets,
                    stopped_remotes=stopped_waiters,
                )
            )
        elif timeout_type == TimeoutType.TimeoutFalse:
            resume_to_confirm = "ResumeTimeoutFalse"
            resume_serial_num = self.add_cmd(
                ResumeTimeoutFalse(
                    cmd_runners=resumers,
                    targets=all_targets,
                    exp_resumed_targets=exp_resumed_targets,
                    stopped_remotes=stopped_waiters,
                    timeout=timeout_time,
                )
            )
        else:
            resume_to_confirm = "ResumeTimeoutTrue"
            resume_serial_num = self.add_cmd(
                ResumeTimeoutTrue(
                    cmd_runners=resumers,
                    targets=all_targets,
                    exp_resumed_targets=exp_resumed_targets,
                    stopped_remotes=stopped_waiters,
                    timeout=timeout_time,
                    timeout_names=timeout_names,
                )
            )

        ################################################################
        # prevent stopped_waiters from getting started too soon
        ################################################################
        if stopped_waiters:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd=resume_to_confirm,
                    confirm_serial_num=resume_serial_num,
                    confirmers=resumers,
                )
            )
        ################################################################
        # create and start unreg_waiters and build smart_wait
        ################################################################
        if unreg_waiters:
            f1_create_items: list[F1CreateItem] = []
            for idx, name in enumerate(unreg_waiters):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(
                    F1CreateItem(
                        name=name,
                        auto_start=True,
                        target_rtn=outer_f1,
                        app_config=app_config,
                    )
                )
            self.build_create_suite(
                f1_create_items=f1_create_items, validate_config=False
            )

            wait_unreg_no_delay_serial_num = self.add_cmd(
                Wait(
                    cmd_runners=unreg_waiters, resumers=resumers, exp_resumers=resumers
                )
            )

        ################################################################
        # build stopped_waiters smart_wait
        ################################################################
        if stopped_waiters:
            self.build_join_suite(
                cmd_runners=self.commander_name, join_target_names=stopped_waiters
            )

            for stopped_no_delay_name in stopped_waiters:
                self.add_cmd(
                    VerifyConfig(
                        cmd_runners=self.commander_name,
                        verify_type=VerifyType.VerifyNotPaired,
                        names_to_check=stopped_no_delay_name,
                    )
                )

            f1_create_items = []
            for idx, name in enumerate(stopped_waiters):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(
                    F1CreateItem(
                        name=name,
                        auto_start=True,
                        target_rtn=outer_f1,
                        app_config=app_config,
                    )
                )
            self.build_create_suite(
                f1_create_items=f1_create_items, validate_config=False
            )

            wait_stopped_no_delay_serial_num = self.add_cmd(
                Wait(
                    cmd_runners=stopped_waiters,
                    resumers=resumers,
                    exp_resumers=resumers,
                )
            )

        ################################################################
        # wait for resume timeouts to be known
        ################################################################
        self.add_cmd(Pause(cmd_runners=self.commander_name, pause_seconds=pause_time))

        ################################################################
        # start reg_delay_waiters and issue smart_wait
        ################################################################
        if reg_delay_waiters:
            self.build_start_suite(start_names=reg_delay_waiters)
            wait_reg_after_target_serial_num = self.add_cmd(
                Wait(
                    cmd_runners=reg_delay_waiters,
                    resumers=resumers,
                    exp_resumers=resumers,
                )
            )

        ################################################################
        # build unreg_delay_waiters smart_wait
        ################################################################
        if unreg_delay_waiters:
            f1_create_items = []
            for idx, name in enumerate(unreg_delay_waiters):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(
                    F1CreateItem(
                        name=name,
                        auto_start=True,
                        target_rtn=outer_f1,
                        app_config=app_config,
                    )
                )
            self.build_create_suite(
                f1_create_items=f1_create_items, validate_config=False
            )

            wait_unreg_delay_serial_num = self.add_cmd(
                Wait(
                    cmd_runners=unreg_delay_waiters,
                    resumers=resumers,
                    exp_resumers=resumers,
                )
            )

        ####################################################
        # confirm the active target_rtn waits
        ####################################################
        if active_waiters:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd="Wait",
                    confirm_serial_num=wait_active_target_serial_num,
                    confirmers=active_waiters,
                )
            )

        ####################################################
        # confirm the registered target_rtn waits
        ####################################################
        if reg_waiters:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd="Wait",
                    confirm_serial_num=wait_reg_before_target_serial_num,
                    confirmers=reg_waiters,
                )
            )

        ####################################################
        # confirm the registered target_rtn waits
        ####################################################
        if reg_delay_waiters:
            if timeout_type == TimeoutType.TimeoutTrue or stopped_waiters:
                self.add_cmd(
                    ConfirmResponseNot(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="Wait",
                        confirm_serial_num=wait_reg_after_target_serial_num,
                        confirmers=reg_delay_waiters,
                    )
                )

                resume_serial_num2 = self.add_cmd(
                    ResumeTimeoutFalse(
                        cmd_runners=resumers,
                        targets=reg_delay_waiters,
                        exp_resumed_targets=reg_delay_waiters,
                        timeout=0.5,
                    )
                )
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="ResumeTimeoutFalse",
                        confirm_serial_num=resume_serial_num2,
                        confirmers=resumers,
                    )
                )
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd="Wait",
                    confirm_serial_num=wait_reg_after_target_serial_num,
                    confirmers=reg_delay_waiters,
                )
            )

        ####################################################
        # confirm the unreg_waiters
        ####################################################
        if unreg_waiters:
            # if error_stopped_target and stopped_waiters:
            if stopped_waiters:
                self.add_cmd(
                    ConfirmResponseNot(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="Wait",
                        confirm_serial_num=wait_unreg_no_delay_serial_num,
                        confirmers=unreg_waiters,
                    )
                )

                resume_serial_num2 = self.add_cmd(
                    ResumeTimeoutFalse(
                        cmd_runners=resumers,
                        targets=unreg_waiters,
                        exp_resumed_targets=unreg_waiters,
                        timeout=0.5,
                    )
                )
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="ResumeTimeoutFalse",
                        confirm_serial_num=resume_serial_num2,
                        confirmers=resumers,
                    )
                )
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd="Wait",
                    confirm_serial_num=wait_unreg_no_delay_serial_num,
                    confirmers=unreg_waiters,
                )
            )
        ####################################################
        # confirm the unreg_delay_waiters
        ####################################################
        if unreg_delay_waiters:
            if timeout_type == TimeoutType.TimeoutTrue or stopped_waiters:
                self.add_cmd(
                    ConfirmResponseNot(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="Wait",
                        confirm_serial_num=wait_unreg_delay_serial_num,
                        confirmers=unreg_delay_waiters,
                    )
                )

                resume_serial_num2 = self.add_cmd(
                    ResumeTimeoutFalse(
                        cmd_runners=resumers,
                        targets=unreg_delay_waiters,
                        exp_resumed_targets=unreg_delay_waiters,
                        timeout=0.5,
                    )
                )
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="ResumeTimeoutFalse",
                        confirm_serial_num=resume_serial_num2,
                        confirmers=resumers,
                    )
                )
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd="Wait",
                    confirm_serial_num=wait_unreg_delay_serial_num,
                    confirmers=unreg_delay_waiters,
                )
            )
        ####################################################
        # confirm the stopped_waiters
        ####################################################
        if stopped_waiters:
            # if error_stopped_target and stopped_waiters:
            if stopped_waiters:
                self.add_cmd(
                    ConfirmResponseNot(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="Wait",
                        confirm_serial_num=wait_stopped_no_delay_serial_num,
                        confirmers=stopped_waiters,
                    )
                )

                resume_serial_num2 = self.add_cmd(
                    ResumeTimeoutFalse(
                        cmd_runners=resumers,
                        targets=stopped_waiters,
                        exp_resumed_targets=stopped_waiters,
                        timeout=0.5,
                    )
                )
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="ResumeTimeoutFalse",
                        confirm_serial_num=resume_serial_num2,
                        confirmers=resumers,
                    )
                )
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd="Wait",
                    confirm_serial_num=wait_stopped_no_delay_serial_num,
                    confirmers=stopped_waiters,
                )
            )

        ####################################################
        # confirm the resumers
        ####################################################
        if not stopped_waiters:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd=resume_to_confirm,
                    confirm_serial_num=resume_serial_num,
                    confirmers=resumers,
                )
            )

    ####################################################################
    # build_rotate_state_scenario
    ####################################################################
    def build_rotate_state_scenario(
        self,
        timeout_type: TimeoutType,
        req0: st.ReqType,
        req1: st.ReqType,
        req0_when_req1_state: tuple[st.ThreadState, int],
        req0_when_req1_lap: int,
        req1_lap: int,
    ) -> None:
        """Add cmds to run scenario.

        Args:
            timeout_type: specifies whether the SmartRequest should
                be coded with timeout, and whether it be False or True
            req0: the SmartRequest that req0 will make
            req1: the SmartRequest that req1 will make
            req0_when_req1_state: req0 will issue SmartRequest when
                req1 transitions to this state
            req0_when_req1_lap: req0 will issue SmartRequest when
                req1 transitions during this lap
            req1_lap: lap 0 or 1 when req1 SmartRequest is to be
                issued

        """
        # Make sure we have enough threads. Each of the scenarios will
        # require one thread for the commander, one thread for req0,
        # and one thread for req1, for a total of three.
        assert 3 <= len(self.unregistered_names)

        self.auto_calling_refresh_msg = False
        self.build_config(
            cmd_runner=self.commander_name, num_active=2
        )  # one for commander and one for req0

        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose receiver_names
        ################################################################
        req0_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=1,
            update_collection=True,
            var_name_for_log="req0_names",
        )

        ################################################################
        # choose receiver_names
        ################################################################
        req1_names = self.choose_names(
            name_collection=self.unregistered_names,
            num_names_needed=1,
            update_collection=False,
            var_name_for_log="req1_names",
        )

        ################################################################
        # setup the messages to send
        ################################################################
        req0_name = req0_names[0]
        req1_name = req1_names[0]

        sender_msgs = SendRecvMsgs(
            sender_names=[req0_name, req1_name],
            receiver_names=[req0_name, req1_name],
            num_msgs=1,
            text="build_rotate_state_scenario",
        )

        req0_deadlock_remotes: set[str] = set()

        req1_deadlock_remotes: set[str] = set()

        req0_specific_args: dict[str, Any] = {
            "sender_msgs": sender_msgs,
            "deadlock_remotes": req0_deadlock_remotes,
            "sync_set_ack_remotes": set(),
            "exp_senders": set(),
            "exp_receivers": set(),
            "exp_resumed_targets": set(),
            "exp_resumers": set(),
            "exp_syncers": set(),
        }

        req1_specific_args: dict[str, Any] = {
            "sender_msgs": sender_msgs,
            "deadlock_remotes": req1_deadlock_remotes,
            "sync_set_ack_remotes": req0_name,
            "exp_senders": set(),
            "exp_receivers": set(),
            "exp_resumed_targets": set(),
            "exp_resumers": set(),
            "exp_syncers": set(),
        }

        ################################################################
        # request rtns
        ################################################################
        request_build_rtns: dict[st.ReqType, Callable[..., RequestConfirmParms]] = {
            st.ReqType.Smart_send: self.build_send_msg_request,
            st.ReqType.Smart_recv: self.build_recv_msg_request,
            st.ReqType.Smart_resume: self.build_resume_request,
            st.ReqType.Smart_sync: self.build_sync_request,
            st.ReqType.Smart_wait: self.build_wait_request,
        }

        req0_stopped_remotes: set[str] = set()
        req1_stopped_remotes: set[str] = set()
        req1_timeout_type: TimeoutType = TimeoutType.TimeoutNone
        supress_req1 = False

        reset_ops_count = False

        class ReqCategory(Enum):
            Throw = auto()
            Catch = auto()
            Handshake = auto()

        @dataclass
        class ReqFlags:
            req0_category: ReqCategory
            req1_category: ReqCategory
            req_matched: bool
            req_deadlock: bool

        request_table: dict[tuple[st.ReqType, st.ReqType], ReqFlags] = {
            (st.ReqType.Smart_send, st.ReqType.Smart_send): ReqFlags(
                req0_category=ReqCategory.Throw,
                req1_category=ReqCategory.Throw,
                req_matched=False,
                req_deadlock=False,
            ),
            (st.ReqType.Smart_send, st.ReqType.Smart_recv): ReqFlags(
                req0_category=ReqCategory.Throw,
                req1_category=ReqCategory.Catch,
                req_matched=True,
                req_deadlock=False,
            ),
            (st.ReqType.Smart_send, st.ReqType.Smart_resume): ReqFlags(
                req0_category=ReqCategory.Throw,
                req1_category=ReqCategory.Throw,
                req_matched=False,
                req_deadlock=False,
            ),
            (st.ReqType.Smart_send, st.ReqType.Smart_sync): ReqFlags(
                req0_category=ReqCategory.Throw,
                req1_category=ReqCategory.Handshake,
                req_matched=False,
                req_deadlock=False,
            ),
            (st.ReqType.Smart_send, st.ReqType.Smart_wait): ReqFlags(
                req0_category=ReqCategory.Throw,
                req1_category=ReqCategory.Catch,
                req_matched=False,
                req_deadlock=False,
            ),
            (st.ReqType.Smart_recv, st.ReqType.Smart_recv): ReqFlags(
                req0_category=ReqCategory.Catch,
                req1_category=ReqCategory.Catch,
                req_matched=False,
                req_deadlock=True,
            ),
            (st.ReqType.Smart_recv, st.ReqType.Smart_send): ReqFlags(
                req0_category=ReqCategory.Catch,
                req1_category=ReqCategory.Throw,
                req_matched=True,
                req_deadlock=False,
            ),
            (st.ReqType.Smart_recv, st.ReqType.Smart_resume): ReqFlags(
                req0_category=ReqCategory.Catch,
                req1_category=ReqCategory.Throw,
                req_matched=False,
                req_deadlock=False,
            ),
            (st.ReqType.Smart_recv, st.ReqType.Smart_sync): ReqFlags(
                req0_category=ReqCategory.Catch,
                req1_category=ReqCategory.Handshake,
                req_matched=False,
                req_deadlock=True,
            ),
            (st.ReqType.Smart_recv, st.ReqType.Smart_wait): ReqFlags(
                req0_category=ReqCategory.Catch,
                req1_category=ReqCategory.Catch,
                req_matched=False,
                req_deadlock=True,
            ),
            (st.ReqType.Smart_resume, st.ReqType.Smart_send): ReqFlags(
                req0_category=ReqCategory.Throw,
                req1_category=ReqCategory.Throw,
                req_matched=False,
                req_deadlock=False,
            ),
            (st.ReqType.Smart_resume, st.ReqType.Smart_recv): ReqFlags(
                req0_category=ReqCategory.Throw,
                req1_category=ReqCategory.Catch,
                req_matched=False,
                req_deadlock=False,
            ),
            (st.ReqType.Smart_resume, st.ReqType.Smart_resume): ReqFlags(
                req0_category=ReqCategory.Throw,
                req1_category=ReqCategory.Throw,
                req_matched=False,
                req_deadlock=False,
            ),
            (st.ReqType.Smart_resume, st.ReqType.Smart_sync): ReqFlags(
                req0_category=ReqCategory.Throw,
                req1_category=ReqCategory.Handshake,
                req_matched=False,
                req_deadlock=False,
            ),
            (st.ReqType.Smart_resume, st.ReqType.Smart_wait): ReqFlags(
                req0_category=ReqCategory.Throw,
                req1_category=ReqCategory.Catch,
                req_matched=True,
                req_deadlock=False,
            ),
            (st.ReqType.Smart_sync, st.ReqType.Smart_send): ReqFlags(
                req0_category=ReqCategory.Handshake,
                req1_category=ReqCategory.Throw,
                req_matched=False,
                req_deadlock=False,
            ),
            (st.ReqType.Smart_sync, st.ReqType.Smart_recv): ReqFlags(
                req0_category=ReqCategory.Handshake,
                req1_category=ReqCategory.Catch,
                req_matched=False,
                req_deadlock=True,
            ),
            (st.ReqType.Smart_sync, st.ReqType.Smart_resume): ReqFlags(
                req0_category=ReqCategory.Handshake,
                req1_category=ReqCategory.Throw,
                req_matched=False,
                req_deadlock=False,
            ),
            (st.ReqType.Smart_sync, st.ReqType.Smart_sync): ReqFlags(
                req0_category=ReqCategory.Handshake,
                req1_category=ReqCategory.Handshake,
                req_matched=True,
                req_deadlock=False,
            ),
            (st.ReqType.Smart_sync, st.ReqType.Smart_wait): ReqFlags(
                req0_category=ReqCategory.Handshake,
                req1_category=ReqCategory.Catch,
                req_matched=False,
                req_deadlock=True,
            ),
            (st.ReqType.Smart_wait, st.ReqType.Smart_send): ReqFlags(
                req0_category=ReqCategory.Catch,
                req1_category=ReqCategory.Throw,
                req_matched=False,
                req_deadlock=False,
            ),
            (st.ReqType.Smart_wait, st.ReqType.Smart_recv): ReqFlags(
                req0_category=ReqCategory.Catch,
                req1_category=ReqCategory.Catch,
                req_matched=False,
                req_deadlock=True,
            ),
            (st.ReqType.Smart_wait, st.ReqType.Smart_resume): ReqFlags(
                req0_category=ReqCategory.Catch,
                req1_category=ReqCategory.Throw,
                req_matched=True,
                req_deadlock=False,
            ),
            (st.ReqType.Smart_wait, st.ReqType.Smart_sync): ReqFlags(
                req0_category=ReqCategory.Catch,
                req1_category=ReqCategory.Handshake,
                req_matched=False,
                req_deadlock=True,
            ),
            (st.ReqType.Smart_wait, st.ReqType.Smart_wait): ReqFlags(
                req0_category=ReqCategory.Catch,
                req1_category=ReqCategory.Catch,
                req_matched=False,
                req_deadlock=True,
            ),
        }

        req_flags = request_table[(req0, req1)]
        req0_confirm_at_unreg: bool = False
        req0_confirm_at_active: bool = False
        req0_confirm_immediately: bool = False
        req0_will_do_refresh: bool = False
        req0_request_issued: bool = False

        req1_delay_confirm: bool = True

        self.log_test_msg(f"{req_flags=}")

        if timeout_type == TimeoutType.TimeoutTrue:
            if (
                req0_when_req1_state[0] == st.ThreadState.Unregistered
                or req0_when_req1_state[0] == st.ThreadState.Registered
            ):
                if req_flags.req1_category != ReqCategory.Throw:
                    req1_timeout_type = TimeoutType.TimeoutTrue
                else:
                    if req1_lap < req0_when_req1_lap and req_flags.req_matched:
                        supress_req1 = True

            elif req0_when_req1_state[0] == st.ThreadState.Alive:
                if req0 == st.ReqType.Smart_sync:
                    req0_specific_args["sync_set_ack_remotes"] = req1_name
                if req0_when_req1_lap == req1_lap:
                    if req_flags.req_deadlock:
                        req0_specific_args["deadlock_remotes"] = {req1_name}
                        req1_specific_args["deadlock_remotes"] = {req0_name}
                    elif req_flags.req0_category == ReqCategory.Throw:
                        timeout_type = TimeoutType.TimeoutNone
                    elif (
                        req_flags.req1_category != ReqCategory.Throw
                        or req_flags.req_matched
                    ):
                        supress_req1 = True

                elif req0_when_req1_lap < req1_lap:
                    if req_flags.req0_category == ReqCategory.Throw:
                        timeout_type = TimeoutType.TimeoutNone
                    else:
                        if req_flags.req1_category != ReqCategory.Throw:
                            req1_timeout_type = TimeoutType.TimeoutTrue

                else:  # req1_lap < req0_when_req1_lap
                    if req_flags.req0_category == ReqCategory.Throw:
                        timeout_type = TimeoutType.TimeoutNone
                    else:
                        if req_flags.req_matched:
                            supress_req1 = True
                        elif req_flags.req1_category != ReqCategory.Throw:
                            req1_timeout_type = TimeoutType.TimeoutTrue

        # not an else since we might have cases where timeout_type True
        # was changed to None in the above section
        if timeout_type != TimeoutType.TimeoutTrue:
            if (
                req0_when_req1_state[0] == st.ThreadState.Unregistered
                or req0_when_req1_state[0] == st.ThreadState.Registered
            ) and req0_when_req1_state[1] == 0:
                if req0_when_req1_lap == req1_lap:
                    req0_stopped_remotes = {req1_name}
                    req0_will_do_refresh = True
                    if req_flags.req1_category != ReqCategory.Throw:
                        # since req0 will raise stopped error it will
                        # not be replying to req1 when req1 eventually
                        # gets active and does its request. So, req1
                        # will need to use timeout to prevent hang
                        req1_timeout_type = TimeoutType.TimeoutTrue
                elif req0_when_req1_lap < req1_lap:
                    req0_stopped_remotes = {req1_name}
                    req0_will_do_refresh = True
                    if req_flags.req1_category != ReqCategory.Throw:
                        req1_timeout_type = TimeoutType.TimeoutTrue
                elif req1_lap < req0_when_req1_lap:
                    if req_flags.req1_category != ReqCategory.Throw:
                        req1_timeout_type = TimeoutType.TimeoutTrue
                        # since req1 will issue its request during lap0
                        # and req0 will issue its request in lap1,
                        # req1 will timeout, and then continue to
                        # rotate into lap1 on through active where it
                        # will not issue a request and then to stopped.
                        # So, req0 will issue its request and then see
                        # that req1 went to stopped state.
                        req0_stopped_remotes = {req1_name}
                        req0_will_do_refresh = True
                    else:
                        # if req1 issues throw request and then stops,
                        # the request will remain pending for req0 when
                        # it issues its request. So, if req0 request
                        # matches, then req0 will succeed. If not
                        # matched, req0 will see req1 go to stopped
                        # state.
                        if req_flags.req_matched:
                            # if req1 is not registered then the del
                            # deferred flag will not be off
                            if req0_when_req1_state[0] != st.ThreadState.Registered:
                                # req0 will do the refresh because its
                                # delete was deferred in lap0 and now
                                # that it has satisfied its request in
                                # lap1 and cleared its pending reasons
                                # before req0 is registered (which
                                # clears the deferred delete flag in
                                # req0), it sees that it can do the
                                # refresh
                                req0_will_do_refresh = True

                            # we also need to confirm immediately before
                            # req1 is registered since that will clear
                            # the deferred delete flag and prevent req0
                            # from doing the refresh, or if already
                            # registered then we want to complete the
                            # request before req1 is stopped to avoid
                            # having del deferred being set on
                            req0_confirm_immediately = True

                            if req0 == st.ReqType.Smart_recv:
                                req0_specific_args["exp_senders"] = req1_name
                            elif req0 == st.ReqType.Smart_wait:
                                req0_specific_args["exp_resumers"] = req1_name
                        else:
                            req0_stopped_remotes = {req1_name}

                if req0_will_do_refresh:
                    pe = self.pending_events[req0_name]
                    ref_key: CallRefKey = req0.value

                    pe[PE.calling_refresh_msg][ref_key] += 1

                    req0_confirm_at_unreg = True

            elif (
                req0_when_req1_state[0] == st.ThreadState.Unregistered
                or req0_when_req1_state[0] == st.ThreadState.Registered
                or req0_when_req1_state[0] == st.ThreadState.Alive
            ):
                if req0 == st.ReqType.Smart_sync:
                    req0_specific_args["sync_set_ack_remotes"] = req1_name
                # if req1 is alive or will be alive before being
                # stopped, a throw req0 will always work regardless of
                # lap and regardless of whether the requests are matched
                if req_flags.req0_category == ReqCategory.Throw:
                    if req0 == st.ReqType.Smart_send:
                        req0_specific_args["exp_receivers"] = req1_name
                    elif req0 == st.ReqType.Smart_resume:
                        req0_specific_args["exp_resumed_targets"] = req1_name

                if req0_when_req1_lap == req1_lap:
                    if req_flags.req_deadlock:
                        req0_specific_args["deadlock_remotes"] = {req1_name}
                        req1_specific_args["deadlock_remotes"] = {req0_name}
                    else:
                        if req_flags.req0_category == ReqCategory.Throw:
                            if not req_flags.req_matched:
                                if req_flags.req1_category != ReqCategory.Throw:
                                    req1_timeout_type = TimeoutType.TimeoutTrue
                        else:
                            if req_flags.req_matched:
                                req0_confirm_at_active = True
                                if req0 == st.ReqType.Smart_recv:
                                    req0_specific_args["exp_senders"] = req1_name
                                elif req0 == st.ReqType.Smart_wait:
                                    req0_specific_args["exp_resumers"] = req1_name
                            else:
                                req0_stopped_remotes = {req1_name}
                                if req_flags.req1_category != ReqCategory.Throw:
                                    req1_timeout_type = TimeoutType.TimeoutTrue

                elif req0_when_req1_lap < req1_lap:
                    if req_flags.req0_category == ReqCategory.Throw:
                        # even though req0 does a throw, it will not
                        # persist as req1 rotates into stopped and is
                        # then resurrected. Req1 will need to request
                        # timeout since its catch request will not be
                        # matched
                        if req_flags.req1_category != ReqCategory.Throw:
                            req1_timeout_type = TimeoutType.TimeoutTrue
                    else:
                        req0_stopped_remotes = {req1_name}
                        if req_flags.req1_category != ReqCategory.Throw:
                            req1_timeout_type = TimeoutType.TimeoutTrue

                else:  # req1_lap < req0_when_req1_lap
                    if req_flags.req1_category == ReqCategory.Throw:
                        # req1 throw will persist
                        if req_flags.req_matched:
                            # if req1 is not registered then the del
                            # deferred flag will not be off
                            if req0_when_req1_state[0] == st.ThreadState.Unregistered:
                                # req0 will do the refresh because its
                                # delete was deferred in lap0 and now
                                # that it has satisfied its request in
                                # lap1 and cleared its pending reasons
                                # before req0 is registered (which
                                # clears the deferred delete flag in
                                # req0), it sees that it can do the
                                # refresh
                                req0_will_do_refresh = True

                            # we also need to confirm immediately before
                            # req1 is registered since that will clear
                            # the deferred delete flag and prevent req0
                            # from doing the refresh, or if already
                            # registered then we want to complete the
                            # request before req1 is stopped to avoid
                            # having del deferred being set on
                            req0_confirm_immediately = True
                            if req0 == st.ReqType.Smart_recv:
                                req0_specific_args["exp_senders"] = req1_name
                            elif req0 == st.ReqType.Smart_wait:
                                req0_specific_args["exp_resumers"] = req1_name
                        else:
                            if req_flags.req0_category != ReqCategory.Throw:
                                req0_stopped_remotes = {req1_name}
                    else:
                        req1_timeout_type = TimeoutType.TimeoutTrue
                        if req_flags.req0_category != ReqCategory.Throw:
                            req0_stopped_remotes = {req1_name}
                if req0_will_do_refresh:
                    pe = self.pending_events[req0_name]
                    ref_key = req0.value

                    pe[PE.calling_refresh_msg][ref_key] += 1

        if req0_when_req1_state[0] == st.ThreadState.Stopped:
            if req0_when_req1_lap == req1_lap:
                if req_flags.req1_category == ReqCategory.Throw:
                    if req_flags.req_matched:
                        if req0 == st.ReqType.Smart_recv:
                            req0_specific_args["exp_senders"] = req1_name
                        elif req0 == st.ReqType.Smart_wait:
                            req0_specific_args["exp_resumers"] = req1_name
                        if timeout_type == TimeoutType.TimeoutTrue:
                            timeout_type = TimeoutType.TimeoutNone
                    else:
                        req0_stopped_remotes = {req1_name}
                else:
                    req1_timeout_type = TimeoutType.TimeoutTrue
                    req0_stopped_remotes = {req1_name}
            elif req0_when_req1_lap < req1_lap:
                req0_stopped_remotes = {req1_name}
                if req_flags.req1_category != ReqCategory.Throw:
                    req1_timeout_type = TimeoutType.TimeoutTrue
            else:  # req1_lap < req0_when_req1_lap
                if req_flags.req1_category == ReqCategory.Throw:
                    if req_flags.req_matched:
                        if req0 == st.ReqType.Smart_recv:
                            req0_specific_args["exp_senders"] = req1_name
                        elif req0 == st.ReqType.Smart_wait:
                            req0_specific_args["exp_resumers"] = req1_name
                        if timeout_type == TimeoutType.TimeoutTrue:
                            timeout_type = TimeoutType.TimeoutNone
                    else:
                        req0_stopped_remotes = {req1_name}
                else:
                    req1_timeout_type = TimeoutType.TimeoutTrue
                    req0_stopped_remotes = {req1_name}

        ################################################################
        # lap loop
        ################################################################
        req0_confirm_parms = RequestConfirmParms(request_name="", serial_number=0)
        current_req1_state = st.ThreadState.Unregistered
        reg_iteration = 0
        for lap in range(2):
            ############################################################
            # start loop to advance receiver through the config states
            ############################################################
            for state in (
                st.ThreadState.Unregistered,
                st.ThreadState.Registered,
                st.ThreadState.Unregistered,
                st.ThreadState.Registered,
                st.ThreadState.Alive,
                st.ThreadState.Stopped,
            ):
                state_iteration = 0
                ########################################################
                # do join to make receiver unregistered
                ########################################################
                if state == st.ThreadState.Unregistered:
                    if current_req1_state == st.ThreadState.Registered:
                        self.add_cmd(
                            Unregister(
                                cmd_runners=self.commander_name,
                                unregister_targets=req1_name,
                            )
                        )
                        self.unregistered_names |= {req1_name}
                        state_iteration = 1

                        if req0_confirm_at_unreg and req0_request_issued:
                            self.add_cmd(
                                ConfirmResponse(
                                    cmd_runners=[self.commander_name],
                                    confirm_cmd=req0_confirm_parms.request_name,
                                    confirm_serial_num=req0_confirm_parms.serial_number,
                                    confirmers=req0_name,
                                )
                            )

                    elif current_req1_state == st.ThreadState.Stopped:
                        # pause to allow req0 to recognize that req1 is
                        # stopped so that it will have time to issue
                        # the raise error log message that the test code
                        # will intercept and use to reset
                        # request_pending in the test code before we
                        # start deleting req1 from the pair_array so
                        # that we determine the correct log messages to
                        # add for log verification
                        # if req0_stopped_remotes:
                        #     self.add_cmd(
                        #         Pause(cmd_runners=self.commander_name,
                        #               pause_seconds=1))
                        if req0_request_issued:
                            self.add_cmd(
                                ConfirmResponse(
                                    cmd_runners=[self.commander_name],
                                    confirm_cmd=req0_confirm_parms.request_name,
                                    confirm_serial_num=req0_confirm_parms.serial_number,
                                    confirmers=req0_name,
                                )
                            )
                        self.build_join_suite(
                            cmd_runners=self.commander_name,
                            join_target_names=req1_name,
                            validate_config=False,
                        )
                    current_req1_state = st.ThreadState.Unregistered
                ########################################################
                # do create to make receiver registered
                ########################################################
                elif state == st.ThreadState.Registered:
                    state_iteration = reg_iteration % 2
                    reg_iteration += 1
                    self.build_create_suite(
                        f1_create_items=[
                            F1CreateItem(
                                name=req1_name,
                                auto_start=False,
                                target_rtn=outer_f1,
                                app_config=AppConfig.ScriptStyle,
                            )
                        ],
                        validate_config=False,
                    )
                    current_req1_state = st.ThreadState.Registered
                ########################################################
                # do start to make req1 alive
                ########################################################
                elif state == st.ThreadState.Alive:
                    self.build_start_suite(start_names=req1_name, validate_config=False)

                    if req1_lap == lap:
                        if not supress_req1:
                            if req_flags.req1_category == ReqCategory.Throw:
                                # regardless of lap and regardless of
                                # whether the requests are matched, a
                                # throw from req1 to req0 will always
                                # complete successfully since req0 is
                                # always alive
                                if req1 == st.ReqType.Smart_send:
                                    req1_specific_args["exp_receivers"] = req0_name
                                elif req1 == st.ReqType.Smart_resume:
                                    req1_specific_args[
                                        "exp_resumed_targets"
                                    ] = req0_name
                            elif (
                                req1_timeout_type != TimeoutType.TimeoutTrue
                                and not req_flags.req_deadlock
                            ):
                                # req1 is doing a catch or handshake and
                                # if timeout was not requested then it
                                # will work
                                if req1 == st.ReqType.Smart_recv:
                                    req1_specific_args["exp_senders"] = req0_name
                                elif req1 == st.ReqType.Smart_wait:
                                    req1_specific_args["exp_resumers"] = req0_name
                                else:
                                    # exp_syncers not really used yet
                                    # but we will code a placeholder
                                    # here is case we do use it later
                                    req1_specific_args["exp_syncers"] = req0_name
                            req1_confirm_parms = request_build_rtns[req1](
                                timeout_type=req1_timeout_type,
                                cmd_runner=req1_name,
                                target=req0_name,
                                stopped_remotes=req1_stopped_remotes,
                                request_specific_args=req1_specific_args,
                            )
                            if not req1_delay_confirm:
                                self.add_cmd(
                                    ConfirmResponse(
                                        cmd_runners=self.commander_name,
                                        confirm_cmd=(req1_confirm_parms.request_name),
                                        confirm_serial_num=(
                                            req1_confirm_parms.serial_number
                                        ),
                                        confirmers=req1_name,
                                    )
                                )
                            if req0_confirm_at_active and req0_request_issued:
                                self.add_cmd(
                                    ConfirmResponse(
                                        cmd_runners=[self.commander_name],
                                        confirm_cmd=req0_confirm_parms.request_name,
                                        confirm_serial_num=(
                                            req0_confirm_parms.serial_number
                                        ),
                                        confirmers=req0_name,
                                    )
                                )
                        if supress_req1:  # or not req0_requires_ack:
                            req1_pause_time = 1
                            self.add_cmd(
                                Pause(
                                    cmd_runners=self.commander_name,
                                    pause_seconds=req1_pause_time,
                                )
                            )
                    current_req1_state = st.ThreadState.Alive
                ########################################################
                # do stop to make receiver stopped
                ########################################################
                else:  # state == st.ThreadState.Stopped:
                    self.build_exit_suite(
                        cmd_runner=self.commander_name,
                        names=req1_name,
                        validate_config=False,
                        reset_ops_count=reset_ops_count,
                    )
                    current_req1_state = st.ThreadState.Stopped
                ########################################################
                # issue req0
                ########################################################
                if (
                    req0_when_req1_state[0] == state
                    and req0_when_req1_state[1] == state_iteration
                    and req0_when_req1_lap == lap
                ):
                    if timeout_type == TimeoutType.TimeoutTrue:
                        pause_time: IntOrFloat = 1
                    else:
                        pause_time = 0.5
                    req0_confirm_parms = request_build_rtns[req0](
                        timeout_type=timeout_type,
                        cmd_runner=req0_name,
                        target=req1_name,
                        stopped_remotes=req0_stopped_remotes,
                        request_specific_args=req0_specific_args,
                    )

                    req0_request_issued = True
                    if req0_confirm_immediately:
                        self.add_cmd(
                            ConfirmResponse(
                                cmd_runners=[self.commander_name],
                                confirm_cmd=req0_confirm_parms.request_name,
                                confirm_serial_num=req0_confirm_parms.serial_number,
                                confirmers=req0_name,
                            )
                        )

                    self.add_cmd(
                        Pause(cmd_runners=self.commander_name, pause_seconds=pause_time)
                    )

        ################################################################
        # finally, confirm req0 is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd=req0_confirm_parms.request_name,
                confirm_serial_num=req0_confirm_parms.serial_number,
                confirmers=req0_name,
            )
        )

        ################################################################
        # confirm req1 is done if delay confirm needed
        ################################################################
        if req1_delay_confirm and not supress_req1:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd=(req1_confirm_parms.request_name),
                    confirm_serial_num=(req1_confirm_parms.serial_number),
                    confirmers=req1_name,
                )
            )

    ####################################################################
    # build_send_msg_request
    ####################################################################
    def build_send_msg_request(
        self,
        timeout_type: TimeoutType,
        cmd_runner: str,
        target: str,
        stopped_remotes: set[str],
        request_specific_args: dict[str, Any],
    ) -> RequestConfirmParms:
        """Adds cmds to the cmd queue.

        Args:
            timeout_type: None, False, or True for timeout
            cmd_runner: name of thread that will do the request
            target: name of thread that is the target_rtn of the request
            stopped_remotes: names of threads that are expected to be
                detected by the request as stopped
            request_specific_args: specific args for each request

        Returns:
            the name and serial number of the request for confirmation
            purposes

        """
        timeout_time: IntOrFloat
        if timeout_type == TimeoutType.TimeoutNone:
            confirm_request_name = "SendMsg"
            request_serial_num = self.add_cmd(
                SendMsg(
                    cmd_runners=cmd_runner,
                    receivers=target,
                    exp_receivers={target} - stopped_remotes,
                    msgs_to_send=request_specific_args["sender_msgs"],
                    msg_idx=0,
                    stopped_remotes=stopped_remotes,
                )
            )
        elif timeout_type == TimeoutType.TimeoutFalse:
            confirm_request_name = "SendMsgTimeoutFalse"
            timeout_time = 6
            request_serial_num = self.add_cmd(
                SendMsgTimeoutFalse(
                    cmd_runners=cmd_runner,
                    receivers=target,
                    exp_receivers={target} - stopped_remotes,
                    msgs_to_send=request_specific_args["sender_msgs"],
                    msg_idx=0,
                    timeout=timeout_time,
                    stopped_remotes=stopped_remotes,
                )
            )
        else:  # timeout_type == TimeoutType.TimeoutTrue
            timeout_time = 0.5
            confirm_request_name = "SendMsgTimeoutTrue"
            request_serial_num = self.add_cmd(
                SendMsgTimeoutTrue(
                    cmd_runners=cmd_runner,
                    receivers=target,
                    exp_receivers=set(),
                    msgs_to_send=request_specific_args["sender_msgs"],
                    msg_idx=0,
                    timeout=timeout_time,
                    unreg_timeout_names=target,
                    fullq_timeout_names=[],
                    stopped_remotes=stopped_remotes,
                )
            )

        return RequestConfirmParms(
            request_name=confirm_request_name, serial_number=request_serial_num
        )

    ####################################################################
    # build_recv_msg_request
    ####################################################################
    def build_recv_msg_request(
        self,
        timeout_type: TimeoutType,
        cmd_runner: str,
        target: str,
        stopped_remotes: set[str],
        request_specific_args: dict[str, Any],
    ) -> RequestConfirmParms:
        """Adds cmds to the cmd queue.

        Args:
            timeout_type: None, False, or True for timeout
            cmd_runner: name of thread that will do the request
            target: name of thread that is the target_rtn of the request
            stopped_remotes: names of threads that are expected to be
                detected by the request as stopped
            request_specific_args: specific args for each request

        Returns:
            the name and serial number of the request for confirmation
            purposes

        """
        timeout_time: IntOrFloat
        if timeout_type == TimeoutType.TimeoutNone:
            confirm_request_name = "RecvMsg"
            request_serial_num = self.add_cmd(
                RecvMsg(
                    cmd_runners=cmd_runner,
                    senders=target,
                    exp_senders=request_specific_args["exp_senders"],
                    exp_msgs=request_specific_args["sender_msgs"],
                    stopped_remotes=stopped_remotes,
                    deadlock_remotes=request_specific_args["deadlock_remotes"],
                )
            )
        elif timeout_type == TimeoutType.TimeoutFalse:
            confirm_request_name = "RecvMsgTimeoutFalse"
            timeout_time = 6
            request_serial_num = self.add_cmd(
                RecvMsgTimeoutFalse(
                    cmd_runners=cmd_runner,
                    senders=target,
                    exp_senders=request_specific_args["exp_senders"],
                    exp_msgs=request_specific_args["sender_msgs"],
                    timeout=timeout_time,
                    stopped_remotes=stopped_remotes,
                    deadlock_remotes=request_specific_args["deadlock_remotes"],
                )
            )
        else:  # timeout_type == TimeoutType.TimeoutTrue
            # set timeout large enough to make sure we see stopped or
            # deadlock before we time out
            if stopped_remotes or request_specific_args["deadlock_remotes"]:
                timeout_time = 6
            else:
                timeout_time = 0.2
            confirm_request_name = "RecvMsgTimeoutTrue"
            request_serial_num = self.add_cmd(
                RecvMsgTimeoutTrue(
                    cmd_runners=cmd_runner,
                    senders=target,
                    exp_senders=request_specific_args["exp_senders"],
                    exp_msgs=request_specific_args["sender_msgs"],
                    timeout=timeout_time,
                    timeout_names=target,
                    stopped_remotes=stopped_remotes,
                    deadlock_remotes=request_specific_args["deadlock_remotes"],
                )
            )

        return RequestConfirmParms(
            request_name=confirm_request_name, serial_number=request_serial_num
        )

    ####################################################################
    # build_resume_request
    ####################################################################
    def build_resume_request(
        self,
        timeout_type: TimeoutType,
        cmd_runner: str,
        target: str,
        stopped_remotes: set[str],
        request_specific_args: dict[str, Any],
    ) -> RequestConfirmParms:
        """Adds cmds to the cmd queue.

        Args:
            timeout_type: None, False, or True for timeout
            cmd_runner: name of thread that will do the request
            target: name of thread that is the target_rtn of the request
            stopped_remotes: names of threads that are expected to be
                detected by the request as stopped
            request_specific_args: specific args for each request

        Returns:
            the name and serial number of the request for confirmation
            purposes

        """
        timeout_time: IntOrFloat
        if timeout_type == TimeoutType.TimeoutNone:
            confirm_request_name = "Resume"
            request_serial_num = self.add_cmd(
                Resume(
                    cmd_runners=cmd_runner,
                    targets=target,
                    exp_resumed_targets=request_specific_args["exp_resumed_targets"],
                    stopped_remotes=stopped_remotes,
                )
            )
        elif timeout_type == TimeoutType.TimeoutFalse:
            confirm_request_name = "ResumeTimeoutFalse"
            timeout_time = 6
            request_serial_num = self.add_cmd(
                ResumeTimeoutFalse(
                    cmd_runners=cmd_runner,
                    targets=target,
                    exp_resumed_targets=request_specific_args["exp_resumed_targets"],
                    timeout=timeout_time,
                    stopped_remotes=stopped_remotes,
                )
            )
        else:  # timeout_type == TimeoutType.TimeoutTrue
            timeout_time = 0.5
            confirm_request_name = "ResumeTimeoutTrue"
            request_serial_num = self.add_cmd(
                ResumeTimeoutTrue(
                    cmd_runners=cmd_runner,
                    targets=target,
                    exp_resumed_targets=request_specific_args["exp_resumed_targets"],
                    timeout=timeout_time,
                    timeout_names=target,
                    stopped_remotes=stopped_remotes,
                )
            )

        return RequestConfirmParms(
            request_name=confirm_request_name, serial_number=request_serial_num
        )

    ####################################################################
    # build_send_scenario
    ####################################################################
    def build_send_scenario(
        self, num_senders: int, num_receivers: int, num_msgs: int, send_type: SendType
    ) -> None:
        """Add cmds to run scenario.

        Args:
            num_senders: number of sender threads
            num_receivers: number of receiver threads
            num_msgs: number of message to send
            send_type: type of send to do

        """
        senders = get_names("sender_", num_senders)

        receivers = get_names("receiver_", num_receivers)

        self.create_config(active_names=senders | receivers)

        msgs_to_send = SendRecvMsgs(
            sender_names=senders,
            receiver_names=receivers,
            num_msgs=num_msgs,
            text="build_send_scenario",
        )

        ############################################################
        # send messages
        ############################################################
        for msg_idx in range(num_msgs):
            send_msg_serial_num = self.add_cmd(
                SendMsg(
                    cmd_runners=senders,
                    receivers=receivers,
                    exp_receivers=receivers,
                    msgs_to_send=msgs_to_send,
                    msg_idx=msg_idx,
                    send_type=send_type,
                )
            )
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd="SendMsg",
                    confirm_serial_num=send_msg_serial_num,
                    confirmers=senders,
                )
            )

        ############################################################
        # receive messages
        ############################################################
        recv_msg_serial_num = self.add_cmd(
            RecvMsg(
                cmd_runners=receivers,
                senders=senders,
                exp_senders=senders,
                exp_msgs=msgs_to_send,
            )
        )
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="RecvMsg",
                confirm_serial_num=recv_msg_serial_num,
                confirmers=receivers,
            )
        )

    ####################################################################
    # build_sender_resumer_count_scenario
    ####################################################################
    def build_sender_resumer_count_scenario(
        self,
        request_type: st.ReqType,
        pre_count: int,
        num_count_0: int,
        num_count_1: int,
    ) -> None:
        """Add cmds to run scenario.

        Args:
            request_type: the request to do
            pre_count: the sender or resumer count for 0th batch
            num_count_0: the sender or resumer count for 1st batch
            num_count_1: the sender or resumer count for 2nd batch

        """
        num_senders_resumers = 5

        senders_resumers = get_names("sender_resumer_", num_senders_resumers)

        receiver_waiter = "receiver_waiter_0"

        self.create_config(active_names=senders_resumers | {receiver_waiter})

        msgs_to_send = SendRecvMsgs(
            sender_names=senders_resumers,
            receiver_names=receiver_waiter,
            num_msgs=1,
            text="build_sender_resumer_count_scenario",
        )

        ################################################################
        # build_send_request
        ################################################################
        def build_send_request() -> tuple[str, int]:
            """Add send request to run scenario."""
            request_to_confirm = "SendMsg"
            request_serial_num = self.add_cmd(
                SendMsg(
                    cmd_runners=sender_resumer,
                    receivers=receiver_waiter,
                    exp_receivers=receiver_waiter,
                    msgs_to_send=msgs_to_send,
                    msg_idx=0,
                )
            )

            return request_to_confirm, request_serial_num

        ################################################################
        # build_receive_request
        ################################################################
        def build_recv_request() -> tuple[str, int]:
            """Add receive request to run scenario."""
            if exp_timeout:
                request_to_confirm = "RecvMsgTimeoutTrue"
                request_serial_num = self.add_cmd(
                    RecvMsgTimeoutTrue(
                        cmd_runners=receiver_waiter,
                        senders=senders_resumers,
                        exp_senders=exp_senders_resumers,
                        exp_msgs=msgs_to_send,
                        timeout=1,
                        timeout_names=senders_resumers,
                        sender_count=sender_resumer_count,
                    )
                )
            else:
                request_to_confirm = "RecvMsg"
                request_serial_num = self.add_cmd(
                    RecvMsg(
                        cmd_runners=receiver_waiter,
                        senders=senders_resumers,
                        exp_senders=exp_senders_resumers,
                        exp_msgs=msgs_to_send,
                        sender_count=sender_resumer_count,
                    )
                )
            return request_to_confirm, request_serial_num

        ################################################################
        # build_resume_request
        ################################################################
        def build_resume_request() -> tuple[str, int]:
            """Add send request to run scenario."""
            request_to_confirm = "Resume"
            request_serial_num = self.add_cmd(
                Resume(
                    cmd_runners=sender_resumer,
                    targets=receiver_waiter,
                    exp_resumed_targets=receiver_waiter,
                )
            )
            return request_to_confirm, request_serial_num

        ################################################################
        # build_wait_request
        ################################################################
        def build_wait_request() -> tuple[str, int]:
            """Add wait request to run scenario."""
            if exp_timeout:
                request_to_confirm = "WaitTimeoutTrue"
                request_serial_num = self.add_cmd(
                    WaitTimeoutTrue(
                        cmd_runners=receiver_waiter,
                        resumers=senders_resumers,
                        exp_resumers=exp_senders_resumers,
                        timeout=1,
                        timeout_remotes=senders_resumers,
                        resumer_count=sender_resumer_count,
                    )
                )
            else:
                request_to_confirm = "Wait"
                request_serial_num = self.add_cmd(
                    Wait(
                        cmd_runners=receiver_waiter,
                        resumers=senders_resumers,
                        exp_resumers=exp_senders_resumers,
                        resumer_count=sender_resumer_count,
                    )
                )
            return request_to_confirm, request_serial_num

        requests: dict[st.ReqType, Callable[..., tuple[str, int]]] = {
            st.ReqType.Smart_send: build_send_request,
            st.ReqType.Smart_recv: build_recv_request,
            st.ReqType.Smart_resume: build_resume_request,
            st.ReqType.Smart_wait: build_wait_request,
        }

        exp_timeout = False
        sorted_senders_resumers: list[str] = sorted(senders_resumers)
        max_count = max(pre_count, num_count_0)
        if num_count_0:
            exp_senders_resumers: set[str] = set(sorted_senders_resumers[0:max_count])
            sender_resumer_count = num_count_0
        else:
            exp_senders_resumers = senders_resumers
            sender_resumer_count = None

        if request_type == st.ReqType.Smart_recv:
            sender_resumer_req_type = st.ReqType.Smart_send
        else:
            sender_resumer_req_type = st.ReqType.Smart_resume

        ################################################################
        # send or resume
        ################################################################
        recv_wait_confirm_0 = ""
        recv_wait_serial_num_0 = 0
        len_exp_senders_resumers = len(exp_senders_resumers)
        pause_secs = 0.4
        for idx, sender_resumer in enumerate(sorted(senders_resumers)):
            # issue recv/wait after pre_count requests
            if idx == pre_count:
                recv_wait_confirm_0, recv_wait_serial_num_0 = requests[request_type]()

            self.add_cmd(
                Pause(cmd_runners=self.commander_name, pause_seconds=pause_secs)
            )

            if len_exp_senders_resumers < idx:
                pause_secs = 0.1  # allow remaining sends to go faster

            send_resume_confirm_0, send_resume_serial_num_0 = requests[
                sender_resumer_req_type
            ]()

            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd=send_resume_confirm_0,
                    confirm_serial_num=send_resume_serial_num_0,
                    confirmers=sender_resumer,
                )
            )

        self.add_cmd(Pause(cmd_runners=self.commander_name, pause_seconds=0.5))

        if pre_count == num_senders_resumers:
            recv_wait_confirm_0, recv_wait_serial_num_0 = requests[request_type]()

        if recv_wait_serial_num_0:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd=recv_wait_confirm_0,
                    confirm_serial_num=recv_wait_serial_num_0,
                    confirmers=receiver_waiter,
                )
            )

        ################################################################
        # receive or wait 2nd batch
        ################################################################
        if num_count_1:
            sender_resumer_count = num_count_1
        else:
            sender_resumer_count = None

        if num_count_0 == 0:
            exp_senders_resumers = set()
            exp_timeout = True
        else:
            exp_senders_resumers = set(sorted_senders_resumers[max_count:])
            if num_count_1 == 0:
                exp_timeout = True
            else:
                if len(exp_senders_resumers) < num_count_1:
                    exp_timeout = True

        recv_wait_confirm_1, recv_wait_serial_num_1 = requests[request_type]()

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd=recv_wait_confirm_1,
                confirm_serial_num=recv_wait_serial_num_1,
                confirmers=receiver_waiter,
            )
        )

    ####################################################################
    # build_recv_basic_scenario
    ####################################################################
    def build_recv_basic_scenario(
        self, num_senders: int, num_msgs: int, sender_count: int, recv_type: RecvType
    ) -> None:
        """Add cmds to run scenario.

        Args:
            num_senders: number of senders
            num_msgs: number of message to send
            sender_count: number of senders needed to satisfy smart_recv
            recv_type: type of recv to do

        """
        senders: set[str] = get_names(stem="sender_", count=num_senders)

        # non_senders are used to allow the smart_recv to specify a non
        # empty senders arg when there are no actual senders
        num_non_senders = 3
        non_senders: set[str] = get_names(stem="non_sender_", count=num_non_senders)

        receiver = "receiver_1"

        self.create_config(active_names=senders | non_senders | {receiver})

        # build msgs for non_senders since we might have no senders
        msgs_to_send = SendRecvMsgs(
            sender_names=senders | non_senders,
            receiver_names=receiver,
            num_msgs=num_msgs,
            text="build_recv_basic_scenario",
        )

        smt_recv_senders_arg: set[str] = set()
        if recv_type == RecvType.PartialSenders:
            num_smt_recv_senders_arg = len(senders) // 2
        elif recv_type == RecvType.MatchSenders:
            num_smt_recv_senders_arg = len(senders)
        elif recv_type == RecvType.ExtraSenders:
            num_smt_recv_senders_arg = len(senders)
            smt_recv_senders_arg |= non_senders
        else:  # recv_type == RecvType.UnmatchSenders:
            num_smt_recv_senders_arg = 0
            smt_recv_senders_arg |= non_senders

        for idx, sender_name in enumerate(senders):
            if num_smt_recv_senders_arg <= idx:
                break
            smt_recv_senders_arg |= {sender_name}

        # make sure we have a non-empty set for smart_recv in case
        # num_senders is zero or too small for PartialResumers to get
        # at least 1 sender
        if not smt_recv_senders_arg:
            smt_recv_senders_arg |= non_senders
        exp_senders: set[str] = senders & smt_recv_senders_arg

        recv_sender_count: Optional[int] = None
        if sender_count > 0:  # if we want sender_count
            # make sure we specify a legal value
            recv_sender_count = min(sender_count, len(smt_recv_senders_arg))

        ################################################################
        # send messages
        ################################################################
        if senders:
            for msg_idx in range(num_msgs):
                send_msg_serial_num = self.add_cmd(
                    SendMsg(
                        cmd_runners=senders,
                        receivers=receiver,
                        exp_receivers=receiver,
                        msgs_to_send=msgs_to_send,
                        msg_idx=msg_idx,
                        send_type=SendType.ToRemotes,
                    )
                )
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=self.commander_name,
                        confirm_cmd="SendMsg",
                        confirm_serial_num=send_msg_serial_num,
                        confirmers=senders,
                    )
                )

        ################################################################
        # receive messages
        ################################################################
        timeout: int = 0
        timeout_remotes: set[str] = smt_recv_senders_arg - exp_senders
        if exp_senders:
            if recv_sender_count:
                if len(exp_senders) < recv_sender_count:
                    timeout = 1
            else:
                if smt_recv_senders_arg != exp_senders:
                    timeout = 1
        else:
            timeout = 1

        if timeout == 0:
            recv_msg_serial_num = self.add_cmd(
                RecvMsg(
                    cmd_runners=receiver,
                    senders=smt_recv_senders_arg,
                    exp_senders=exp_senders,
                    sender_count=recv_sender_count,
                    exp_msgs=msgs_to_send,
                )
            )
        else:
            recv_msg_serial_num = self.add_cmd(
                RecvMsgTimeoutTrue(
                    cmd_runners=receiver,
                    senders=smt_recv_senders_arg,
                    exp_senders=exp_senders,
                    sender_count=recv_sender_count,
                    timeout=1,
                    timeout_names=timeout_remotes,
                    exp_msgs=msgs_to_send,
                )
            )
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="RecvMsg",
                confirm_serial_num=recv_msg_serial_num,
                confirmers=receiver,
            )
        )

    ####################################################################
    # build_resume_basic_scenario
    ####################################################################
    def build_resume_basic_scenario(
        self, num_resumers: int, num_waiters: int, num_reg_waiters: int
    ) -> None:
        """Add cmds to run scenario.

        Args:
            num_resumers: number of resumer threads
            num_waiters: number of waiter threads
            num_reg_waiters: number of waiters to be registered at first

        """
        resumers: set[str] = get_names("resumer_", num_resumers)

        waiters: set[str] = get_names("waiter_", num_waiters)

        reg_waiters: set[str] = get_names("reg_waiter_", num_reg_waiters)

        self.create_config(reg_names=reg_waiters, active_names=resumers | waiters)

        targets: set[str] = waiters | reg_waiters

        ################################################################
        # resume
        ################################################################
        resume_serial_num = self.add_cmd(
            Resume(cmd_runners=resumers, targets=targets, exp_resumed_targets=targets)
        )

        # make sure resume is running and sees that reg_waiters are not
        # there yet. Note that we can't include waiters in the list of
        # timeout names because resume will set the wait_flag when it
        # sees that the targets (waiters) are alive - they don't need
        # to be waiting.
        self.add_cmd(
            WaitForRequestTimeouts(
                cmd_runners=self.commander_name,
                actor_names=resumers,
                timeout_names=reg_waiters,
            )
        )

        ################################################################
        # wait
        ################################################################
        wait_serial_num = self.add_cmd(
            Wait(cmd_runners=waiters, resumers=resumers, exp_resumers=resumers)
        )

        ################################################################
        # reg_wait
        ################################################################
        self.build_start_suite(start_names=reg_waiters, validate_config=False)
        reg_wait_serial_num = self.add_cmd(
            Wait(cmd_runners=reg_waiters, resumers=resumers, exp_resumers=resumers)
        )

        ################################################################
        # confirm response
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Resume",
                confirm_serial_num=resume_serial_num,
                confirmers=resumers,
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Wait",
                confirm_serial_num=wait_serial_num,
                confirmers=waiters,
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Wait",
                confirm_serial_num=reg_wait_serial_num,
                confirmers=reg_waiters,
            )
        )

        ################################################################
        # repeat in reverse
        ################################################################
        ################################################################
        # reg_wait
        ################################################################
        reg_wait_serial_num = self.add_cmd(
            Wait(cmd_runners=reg_waiters, resumers=resumers, exp_resumers=resumers)
        )

        ################################################################
        # wait
        ################################################################
        wait_serial_num = self.add_cmd(
            Wait(cmd_runners=waiters, resumers=resumers, exp_resumers=resumers)
        )

        ################################################################
        # resume
        ################################################################
        resume_serial_num = self.add_cmd(
            Resume(cmd_runners=resumers, targets=targets, exp_resumed_targets=targets)
        )

        ################################################################
        # confirm response
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Wait",
                confirm_serial_num=reg_wait_serial_num,
                confirmers=reg_waiters,
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Wait",
                confirm_serial_num=wait_serial_num,
                confirmers=waiters,
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Resume",
                confirm_serial_num=resume_serial_num,
                confirmers=resumers,
            )
        )

    ####################################################################
    # build_wait_basic_scenario
    ####################################################################
    def build_wait_basic_scenario(
        self, num_resumers: int, resumer_count: int, wait_type: WaitType
    ) -> None:
        """Add cmds to run scenario.

        Args:
            num_resumers: number of resumers beyond what is
                required for the wait_type_arg
            resumer_count: resumer_count specification for smart_wait
            wait_type: type of wait to do

        """
        resumers: set[str] = set()
        for idx in range(num_resumers):
            resumers |= {"resume_" + str(idx)}

        non_resumers: set[str] = set()
        for idx in range(3):
            non_resumers |= {"non_resumer_" + str(idx)}

        waiter = "waiter_1"

        self.create_config(active_names=resumers | non_resumers | {waiter})

        wait_resumers: set[str] = set()
        if wait_type == WaitType.PartialResumers:
            num_wait_resumers = len(resumers) // 2
        elif wait_type == WaitType.MatchResumers:
            num_wait_resumers = len(resumers)
        elif wait_type == WaitType.ExtraResumers:
            num_wait_resumers = len(resumers)
            wait_resumers |= non_resumers
        else:  # wait_type == WaitType.UnmatchResumers:
            num_wait_resumers = 0
            wait_resumers |= non_resumers

        for idx, resumer_name in enumerate(resumers):
            if num_wait_resumers <= idx:
                break
            wait_resumers |= {resumer_name}

        # make sure we have a non-empty set for smart_wait in case
        # num_resumers is zero or too small for PartialResumers to get
        # at least 1 resumer
        if not wait_resumers:
            wait_resumers |= non_resumers
        exp_resumers: set[str] = resumers & wait_resumers

        wait_resumer_count: Optional[int] = None
        if resumer_count > 0:  # if we want resumer_count
            # make sure we specify a legal value
            wait_resumer_count = min(resumer_count, len(wait_resumers))

        ################################################################
        # resume
        ################################################################
        if resumers:
            resume_serial_num = self.add_cmd(
                Resume(cmd_runners=resumers, targets=waiter, exp_resumed_targets=waiter)
            )

            ############################################################
            # confirm resumes are done
            ############################################################
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd="Resume",
                    confirm_serial_num=resume_serial_num,
                    confirmers=resumers,
                )
            )

        ################################################################
        # wait
        ################################################################
        timeout: int = 0
        timeout_remotes: set[str] = wait_resumers - exp_resumers
        if exp_resumers:
            if wait_resumer_count:
                if len(exp_resumers) < wait_resumer_count:
                    timeout = 1
            else:
                if wait_resumers != exp_resumers:
                    timeout = 1
        else:
            timeout = 1

        if timeout == 0:
            cmd_to_confirm = "Wait"
            wait_serial_num = self.add_cmd(
                Wait(
                    cmd_runners=waiter,
                    resumers=wait_resumers,
                    resumer_count=wait_resumer_count,
                    exp_resumers=exp_resumers,
                )
            )
        else:
            cmd_to_confirm = "WaitTimeoutTrue"
            wait_serial_num = self.add_cmd(
                WaitTimeoutTrue(
                    cmd_runners=waiter,
                    resumers=wait_resumers,
                    resumer_count=wait_resumer_count,
                    exp_resumers=exp_resumers,
                    timeout=1,
                    timeout_remotes=timeout_remotes,
                )
            )

        ################################################################
        # confirm waits are done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd=cmd_to_confirm,
                confirm_serial_num=wait_serial_num,
                confirmers=waiter,
            )
        )

    ####################################################################
    # build_sync_basic_scenario
    ####################################################################
    def build_sync_basic_scenario(self, num_syncers: int, num_extras: int) -> None:
        """Add cmds to run scenario.

        Args:
            num_syncers: number of threads doing sync
            num_extras: number of extra threads not involved in the
                sync request

        """
        syncers: set[str] = set()
        for idx in range(num_syncers):
            syncers |= {"syncer_" + str(idx)}

        extras: set[str] = set()
        for idx in range(num_extras):
            extras |= {"extra_" + str(idx)}

        self.create_config(active_names=syncers | extras)

        ################################################################
        # sync
        ################################################################
        sync_serial_num = self.add_cmd(
            Sync(cmd_runners=syncers, targets=syncers, sync_set_ack_remotes=syncers)
        )

        ################################################################
        # confirm response
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Sync",
                confirm_serial_num=sync_serial_num,
                confirmers=syncers,
            )
        )

    ####################################################################
    # build_sync_request
    ####################################################################
    def build_sync_request(
        self,
        timeout_type: TimeoutType,
        cmd_runner: str,
        target: str,
        stopped_remotes: set[str],
        request_specific_args: dict[str, Any],
    ) -> RequestConfirmParms:
        """Adds cmds to the cmd queue.

        Args:
            timeout_type: None, False, or True for timeout
            cmd_runner: name of thread that will do the request
            target: name of thread that is the target_rtn of the request
            stopped_remotes: names of threads that are expected to be
                detected by the request as stopped
            request_specific_args: specific args for each request

        Returns:
            the name and serial number of the request for confirmation
            purposes

        """
        timeout_time: IntOrFloat
        if timeout_type == TimeoutType.TimeoutNone:
            confirm_request_name = "Sync"
            request_serial_num = self.add_cmd(
                Sync(
                    cmd_runners=cmd_runner,
                    targets=target,
                    sync_set_ack_remotes=request_specific_args["sync_set_ack_remotes"],
                    stopped_remotes=stopped_remotes,
                    deadlock_remotes=request_specific_args["deadlock_remotes"],
                )
            )
        elif timeout_type == TimeoutType.TimeoutFalse:
            confirm_request_name = "SyncTimeoutFalse"
            timeout_time = 6
            request_serial_num = self.add_cmd(
                SyncTimeoutFalse(
                    cmd_runners=cmd_runner,
                    targets=target,
                    sync_set_ack_remotes=request_specific_args["sync_set_ack_remotes"],
                    timeout=timeout_time,
                    stopped_remotes=stopped_remotes,
                    deadlock_remotes=request_specific_args["deadlock_remotes"],
                )
            )
        else:  # timeout_type == TimeoutType.TimeoutTrue
            timeout_time = 0.5
            confirm_request_name = "SyncTimeoutTrue"
            request_serial_num = self.add_cmd(
                SyncTimeoutTrue(
                    cmd_runners=cmd_runner,
                    targets=target,
                    sync_set_ack_remotes=request_specific_args["sync_set_ack_remotes"],
                    timeout=timeout_time,
                    timeout_remotes=target,
                    stopped_remotes=stopped_remotes,
                    deadlock_remotes=request_specific_args["deadlock_remotes"],
                )
            )

        return RequestConfirmParms(
            request_name=confirm_request_name, serial_number=request_serial_num
        )

    ####################################################################
    # build_sync_delay_scenario
    ####################################################################
    def build_sync_delay_scenario(self) -> None:
        """Return a list of ConfigCmd items for a msg timeout."""
        self.auto_calling_refresh_msg = False
        sync_names = ["sync_0", "sync_1"]

        locker_names = ["locker_0", "locker_1", "locker_2", "locker_3", "locker_4"]
        lm = LockMgr(config_ver=self, locker_names=locker_names)

        self.create_config(active_names=sync_names + locker_names)

        ################################################################
        # before: none
        # action: get lock
        # after : lock
        ################################################################
        lm.get_lock()

        ################################################################
        # In the following:
        #     _v means sync is behind lock just before
        #        _verify_thread_is_current
        #     _s means sync is behind lock just before request setup
        #     _r means sync is behind lock just before request loop
        ################################################################

        ################################################################
        # before: lock
        # action: sync_0
        # after : lock|sync_0_v|lock
        ################################################################
        sync_0_a_serial_num = self.add_cmd(
            Sync(
                cmd_runners=sync_names[0],
                targets=sync_names[1],
                sync_set_ack_remotes=sync_names[1],
            )
        )
        lm.start_request(sync_names[0])

        ################################################################
        # before: lock_0|sync_0_s|lock_1
        # action: sync_1a
        # after : lock_0|sync_0_v|lock_1|sync_1a_v|lock
        ################################################################
        sync_1_a_serial_num = self.add_cmd(
            Sync(
                cmd_runners=sync_names[1],
                targets=sync_names[0],
                sync_set_ack_remotes=sync_names[0],
            )
        )
        lm.start_request(sync_names[1])

        ################################################################
        # before: lock_0|sync_0_v|lock_1|sync_1a_v|lock
        # action: drop lock four times to advance both syncs to req loop
        # after : lock_0|sync_0_r|lock_1|sync_1a_r|lock
        ################################################################
        lm.advance_request(num_times=4)

        ################################################################
        # before: lock|sync_0_r|lock|sync_1a_r|lock
        # action: drop lock, sync_0 sets sync_1 sync_flag, loops back
        #             to top of request loop
        # after : lock|sync_1a_r|lock|sync_0_r|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_1a_r|lock|sync_0_r|lock
        # action: drop lock, sync_1a sets sync_0 sync_flag and sees
        #             its sync_flag as set and completes request
        # after : lock|sync_0_r|lock
        ################################################################
        lm.complete_request()

        ################################################################
        # before: lock|sync_0_r|lock
        # action: sync_1b
        # after : lock|sync_0_r|lock|sync_1b_v|lock
        ################################################################
        sync_1_b_serial_num = self.add_cmd(
            Sync(
                cmd_runners=sync_names[1],
                targets=sync_names[0],
                sync_set_ack_remotes=sync_names[0],
            )
        )
        lm.start_request(sync_names[1])

        ################################################################
        # before: lock|sync_0_r|lock|sync_1b_v|lock
        # action: swap sync_0 and sync_1b
        # after : lock|sync_1b_v|lock|sync_0_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|sync_1b_v|lock|sync_0_r|lock
        # action: drop lock
        # after : lock|sync_0_r|lock|sync_1b_s|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_0_r|lock|sync_1b_s|lock
        # action: swap sync_0 and sync_1b
        # after : lock|sync_1b_s|lock|sync_0_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|sync_1b_s|lock|sync_0_r|lock
        # action: drop lock
        # after : lock|sync_0_r|lock|sync_1b_r|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_0_r|lock|sync_1b_r|lock
        # action: swap sync_0 and sync_1b
        # after : lock|sync_1b_r|lock|sync_0_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|sync_1b_r|lock|sync_0_r|lock
        # action: drop lock, sync_1b sees sync_0 sync_flag is still
        #             set from sync_1a and gives sync_0 more time (i.e.,
        #             returns False which is the path we are trying to
        #             get sync_1b to take for proof of coverage)
        # after : lock|sync_0_r|lock|sync_1b_r|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_0_r|lock|sync_1b_r|lock
        # action: drop lock, sync_0_r sees its sync_flag is set and
        #             completes the request
        # after : lock|sync_1b_r|lock
        ################################################################
        lm.complete_request()

        ################################################################
        # before: lock|sync_1b_r|lock
        # action: sync_0b
        # after : lock|sync_1b_r|lock|sync_0b_v|lock
        ################################################################
        sync_0_b_serial_num = self.add_cmd(
            Sync(
                cmd_runners=sync_names[0],
                targets=sync_names[1],
                sync_set_ack_remotes=sync_names[1],
            )
        )
        lm.start_request(sync_names[0])

        ################################################################
        # before: lock|sync_1b_r|lock|sync_0b_v|lock
        # action: swap sync_0 and sync_1b
        # after : lock|sync_0b_v|lock|sync_1b_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|sync_0b_v|lock|sync_1b_r|lock
        # action: drop lock
        # after : lock|sync_1b_r|lock|sync_0b_s
        ################################################################
        lm.advance_request(trailing_lock=False)

        ################################################################
        # before: lock|sync_1b_r|lock|sync_0b_s
        # action: drop lock, sync_1b is now able to set sync_0
        #             sync_flag and loops back to top of req loop
        # after : lock|sync_0b_s|sync_1b_r
        ################################################################
        lm.advance_request(trailing_lock=False)

        ################################################################
        # before: lock|sync_0b_s|sync_1b_r
        # action: drop lock, sync_0b and sync_1b should now complete
        # after : none
        ################################################################
        lm.complete_request(free_all=True)

        ################################################################
        # confirm the sync requests
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Sync",
                confirm_serial_num=sync_0_a_serial_num,
                confirmers=sync_names[0],
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Sync",
                confirm_serial_num=sync_0_b_serial_num,
                confirmers=sync_names[0],
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Sync",
                confirm_serial_num=sync_1_a_serial_num,
                confirmers=sync_names[1],
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Sync",
                confirm_serial_num=sync_1_b_serial_num,
                confirmers=sync_names[1],
            )
        )

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures,
                obtain_reg_lock=True,
            )
        )

    ####################################################################
    # build_sync_delay2_scenario
    ####################################################################
    def build_sync_delay2_scenario(self) -> None:
        """Return a list of ConfigCmd items for a msg timeout."""
        # self.auto_calling_refresh_msg = False
        sync_names = ["sync_0", "sync_1"]
        recv_names = ["sync_0", "sync_1"]

        locker_names = ["locker_0", "locker_1", "locker_2", "locker_3", "locker_4"]
        lm = LockMgr(config_ver=self, locker_names=locker_names)

        self.create_config(active_names=sync_names + locker_names)

        sender_msgs = SendRecvMsgs(
            sender_names=sync_names,
            receiver_names=sync_names,
            num_msgs=1,
            text="build_sync_delay2_scenario",
        )

        ################################################################
        # The following are appended to the requestor names:
        #     _s means request is behind lock just before request setup
        #     _r means request is behind lock just before request loop
        #     _e means request is behind lock in error path
        ################################################################

        ################################################################
        # before: none
        # action: get lock
        # after : lock
        ################################################################
        lm.get_lock()

        ################################################################
        # before: lock
        # action: sync_0a
        # after : lock|sync_0a_v|lock
        ################################################################
        sync_0a_serial_num = self.add_cmd(
            Sync(
                cmd_runners=sync_names[0],
                targets=sync_names[1],
                sync_set_ack_remotes=sync_names[1],
                deadlock_remotes=sync_names[1],
            )
        )
        lm.start_request(sync_names[0])

        ################################################################
        # before: lock|sync_0a_v|lock
        # action: recv_1a
        # after : lock|sync_0a_v|lock|recv_1a_v|lock
        ################################################################
        recv_1a_serial_num = self.add_cmd(
            RecvMsg(
                cmd_runners=recv_names[1],
                senders=sync_names[0],
                exp_senders=set(),
                exp_msgs=sender_msgs,
                deadlock_remotes=sync_names[0],
            )
        )
        lm.start_request(recv_names[1])

        ################################################################
        # before: lock|sync_0a_v|lock|recv_1a_v|lock
        # action: advance four times to get both reqs at top of req loop
        # after : lock|sync_0a_r|lock|recv_1a_r|lock
        ################################################################
        lm.advance_request(num_times=4)

        ################################################################
        # before: lock|sync_0a_r|lock|recv_1a_r|lock
        # action: drop lock, sync_0 sets recv_1 sync_flag, loops back
        #             to wait at top of request loop
        # after : lock|recv_1a_r|lock|sync_0a_r|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|recv_1a_r|lock|sync_0a_r|lock
        # action: drop lock, recv_1 detects deadlock and sets sync_0
        #             deadlock flag and gets behind lock in error path
        # after : lock|sync_0a_r|lock|recv_1a_e|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_0a_r|lock|recv_1a_e|lock
        # action: swap sync_0 and sync_1b
        # after : lock|recv_1a_e|lock|sync_0a_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|recv_1a_e|lock|sync_0a_r|lock
        # action: drop lock_1, recv_1a raises deadlock and exits
        # after : lock|sync_0a_r|lock
        ################################################################
        lm.complete_request()

        ################################################################
        # before: lock|sync_0a_r|lock
        # action: sync_1b
        # after : lock|sync_0a_r|lock|sync_1b_v|lock
        ################################################################
        sync_1b_serial_num = self.add_cmd(
            Sync(
                cmd_runners=sync_names[1],
                targets=sync_names[0],
                sync_set_ack_remotes=sync_names[0],
            )
        )
        lm.start_request(sync_names[1])

        ################################################################
        # before: lock|sync_0a_r|lock|sync_1b_v|lock
        # action: swap
        # after : lock|sync_1b_v|lock|sync_0a_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|sync_1b_v|lock|sync_0a_r|lock
        # action: swap
        # after : lock|sync_0a_r|lock|sync_1b_s|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_0a_r|lock|sync_1b_s|lock
        # action: swap sync_0 and sync_1b
        # after : lock|sync_1b_s|lock|sync_0a_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|sync_1b_s|lock|sync_0a_r|lock
        # action: drop lock, sync_1b_s completes setup and gets behind
        #             lock in req loop
        # after : lock|sync_0a_r|lock|sync_1b_r|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_0a_r|lock|sync_1b_r|lock
        # action: swap sync_0 and sync_1b
        # after : lock|sync_1b_r|lock|sync_0a_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|sync_1b_r|lock|sync_0a_r|lock
        # action: drop lock_0, sync_1b sees sync_0 is deadlocked and
        #             gives more time (the case we are trying to get
        #             coverage for) and waits at top of req loop
        # after : lock|sync_0a_r|lock|sync_1b_r|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_0a_r|lock|sync_1b_r|lock
        # action: drop lock_1, sync_0 sees it is deadlocked and
        #             waits at start of error path
        # after : lock|sync_1b_r|lock|sync_0a_e|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_1b_r|lock|sync_0a_e|lock
        # action: drop lock_2, sync_1 sees sync_0 is still deadlocked
        #             and gives yet more time and waits in req loop
        # after : lock|sync_0a_e|lock|sync_1b_r|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_0a_e|lock|sync_1b_r|lock
        # action: drop lock_0, sync_0 raises deadlock and exits
        # after : lock|sync_1b_r|lock
        ################################################################
        lm.complete_request()

        ################################################################
        # before: lock|sync_1b_r|lock
        # action: sync_0b
        # after : lock|sync_1b_r|lock|sync_0b_v|lock
        ################################################################
        sync_0b_serial_num = self.add_cmd(
            Sync(
                cmd_runners=sync_names[0],
                targets=sync_names[1],
                sync_set_ack_remotes=sync_names[1],
            )
        )
        lm.start_request(sync_names[0])

        ################################################################
        # before: lock|sync_1b_r|lock|sync_0b_v|lock
        # action: swap
        # after : lock|sync_0b_v|lock|sync_1b_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|sync_0b_v|lock|sync_1b_r|lock
        # action: advance
        # after : lock|sync_1b_r|lock|sync_0b_s
        ################################################################
        lm.advance_request(trailing_lock=False)

        ################################################################
        # before: lock|sync_1b_r|lock|sync_0b_s
        # action: drop lock_1, sync_1b is now able to set sync_0
        #             sync_flag and loops back to top of req loop
        #             along side of sync_0b
        # after : lock|sync_0b_s|sync_1b_r
        ################################################################
        lm.advance_request(trailing_lock=False)

        ################################################################
        # before: lock|sync_0b_s|sync_1b_r
        # action: drop lock_2, sync_0b and sync_1b should now complete
        # after : none
        ################################################################
        lm.complete_request(free_all=True)

        ################################################################
        # confirm the sync requests
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Sync",
                confirm_serial_num=sync_0a_serial_num,
                confirmers=sync_names[0],
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Sync",
                confirm_serial_num=sync_0b_serial_num,
                confirmers=sync_names[0],
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="RecvMsg",
                confirm_serial_num=recv_1a_serial_num,
                confirmers=recv_names[1],
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Sync",
                confirm_serial_num=sync_1b_serial_num,
                confirmers=sync_names[1],
            )
        )

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures,
                obtain_reg_lock=True,
            )
        )

    ####################################################################
    # build_sync_create_time_scenario
    ####################################################################
    def build_sync_create_time_scenario(self) -> None:
        """Return a list of ConfigCmd items for a msg timeout."""
        # self.auto_calling_refresh_msg = False
        sync_names = ["sync_0", "sync_1"]

        locker_names = ["locker_0", "locker_1", "locker_2", "locker_3", "locker_4"]
        lm = LockMgr(config_ver=self, locker_names=locker_names)

        aux_names = ["aux_0"]

        self.create_config(active_names=sync_names + locker_names + aux_names)

        ################################################################
        # The following are appended to the requestor names:
        #     _v means request is behind lock _verify_thread_is_current
        #     _s means request is behind lock just before request setup
        #     _r means request is behind lock just before request loop
        #     _e means request is behind lock in error path
        #     -reg means register for smart_init
        ################################################################

        ################################################################
        # before: none
        # action: get lock
        # after : lock
        ################################################################
        lm.get_lock()

        ################################################################
        # before: lock
        # action: sync_0a
        # after : lock|sync_0a_v|lock
        ################################################################
        sync_0a_serial_num = self.add_cmd(
            Sync(
                cmd_runners=sync_names[0],
                targets=sync_names[1],
                sync_set_ack_remotes=set(),
                stopped_remotes=sync_names[1],
            )
        )
        lm.start_request(sync_names[0])

        ################################################################
        # before: lock|sync_0a_v|lock
        # action: advance twice, sync_0 does setup and wait at req loop
        # after : lock|sync_0a_r|lock
        ################################################################
        lm.advance_request(num_times=2)

        ################################################################
        # before: lock|sync_0a_r|lock
        # action: tell sync_1 to exit
        # after : lock|sync_0a_r|lock
        ################################################################
        self.build_exit_suite(
            cmd_runner=self.commander_name, names=sync_names[1], validate_config=False
        )

        ################################################################
        # before: lock|sync_0a_r|lock
        # action: join_0
        # after : lock|sync_0a_r|lock|join_0_v|lock
        ################################################################
        join_serial_num = self.add_cmd(
            Join(cmd_runners=aux_names[0], join_names=sync_names[1])
        )
        lm.start_request(aux_names[0])

        self.unregistered_names |= {sync_names[1]}
        self.stopped_remotes -= {sync_names[1]}

        ################################################################
        # before: lock|sync_0a_r|lock|join_0_v|lock
        # action: swap sync_0 and join_0
        # after : lock|join_0_v|lock|sync_0a_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|join_0_v|lock|sync_0a_r|lock
        # action: advance
        # after : lock|sync_0a_r|lock|join_0_r|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_0a_r|lock|join_0_r|lock
        # action: swap
        # after : lock|join_0_r|lock|sync_0a_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|join_0_r|lock|sync_0a_r|lock
        # action: drop lock, join completes
        # after : lock|sync_0a_r|lock
        ################################################################
        lm.complete_request()

        ################################################################
        # before: lock|sync_0a_r|lock
        # action: resurrect sync_1
        # after : lock|sync_0a_r|lock|aux_0_reg|lock
        ################################################################
        self.unregistered_names -= {sync_names[1]}
        self.add_cmd(
            CreateF1AutoStart(
                cmd_runners=aux_names[0],
                f1_create_items=[
                    F1CreateItem(
                        name=sync_names[1],
                        auto_start=True,
                        target_rtn=outer_f1,
                        app_config=AppConfig.ScriptStyle,
                    )
                ],
            )
        )

        self.active_names |= {sync_names[1]}

        lm.start_request(aux_names[0])

        ################################################################
        # before: lock|sync_0a_r|lock|aux_0|lock
        # action: swap sync_0 and aux_0_reg
        # after : lock|aux_0_reg|lock|sync_0a_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|aux_0_reg|lock|sync_0a_r|lock
        # action: drop lock, aux_0 does register, then goes to
        #             smart_start setup
        # after : lock|sync_0a_r|lock|aux_0_s|lock  ??? verify?
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_0a_r|lock|aux_0_s|lock
        # action: swap sync_0 and aux_0_s
        # after : lock|aux_0_s|lock|sync_0a_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|aux_0_s|lock|sync_0a_r|lock
        # action: drop lock, aux_0 completes smart_start
        # after : lock|sync_0a_r|lock
        ################################################################
        lm.complete_request()

        ################################################################
        # before: lock|sync_0a_r|lock
        # action: sync_1a_s
        # after : lock|sync_0a_r|lock|sync_1a_v|lock
        ################################################################
        sync_1a_serial_num = self.add_cmd(
            Sync(
                cmd_runners=sync_names[1],
                targets=sync_names[0],
                sync_set_ack_remotes=sync_names[0],
            )
        )
        lm.start_request(sync_names[1])

        ################################################################
        # before: lock|sync_0a_r|lock|sync_1a_v|lock
        # action: swap
        # after : lock|sync_1a_v|lock|sync_0a_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|sync_1a_v|lock|sync_0a_r|lock
        # action: advance sync1 to setup
        # after : lock|sync_0a_r|lock|sync_1a_s|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_0a_r|lock|sync_1a_s|lock
        # action: swap sync_0 and sync_1a_s
        # after : lock|sync_1a_s|lock|sync_0a_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|sync_1a_s|lock|sync_0a_r|lock
        # action: drop lock_1, sync_1a_s_s completes setup and gets
        #         behind lock in req loop
        # after : lock|sync_0a_r|lock|sync_1a_r|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_0a_r|lock|sync_1a_s_r|lock
        # action: swap sync_0a and sync_1a_s
        # after : lock|sync_1a_s_r|lock|sync_0a_r|lock
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock_0|sync_1a_s_r|lock_2|sync_0a_r|lock_1
        # action: drop lock, sync_1a_s sees sync_0 has different
        #         create time for sync_1, so sync_1 loops back to top of
        #         req loop to give sync_0 more time to recognize that
        #         sync_1 is resurrected
        # after : lock|sync_0a_r|lock|sync_1a_s_r|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_0a_r|lock|sync_1a_s_r|lock
        # action: drop lock, sync_0 sees that sync_1 is resurrected
        #             and waits in error path
        # after : lock|sync_1a_s_r|lock|sync_0a_e|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_1a_s_r|lock|sync_0a_e|lock
        # action: drop lock, sync_1 sees sync_0 is still there with
        #             the old create time for sync_1 and goes back to
        #             wait at top of req loop
        # after : lock|sync_0a_e|lock|sync_1a_s_r|lock
        ################################################################
        lm.advance_request()

        ################################################################
        # before: lock|sync_0a_e|lock|sync_1a_s_r|lock
        # action: drop lock, sync_0 raises error and exits
        # after : lock|sync_1a_s_r|lock
        ################################################################
        lm.complete_request()

        ################################################################
        # before: lock|sync_1a_s_r|lock
        # action: sync_0b
        # after : lock|sync_1a_s_r|lock|sync_0b_v
        ################################################################
        sync_0b_serial_num = self.add_cmd(
            Sync(
                cmd_runners=sync_names[0],
                targets=sync_names[1],
                sync_set_ack_remotes=sync_names[1],
            )
        )
        lm.start_request(sync_names[0], trailing_lock=False)

        ################################################################
        # before: lock|sync_1a_s_r|lock|sync_0b_v
        # action: swap
        # after : lock|sync_0b_v|lock|sync_1a_s_r
        ################################################################
        lm.swap_requestors()

        ################################################################
        # before: lock|sync_0b_v|lock|sync_1a_s_r
        # action: advance
        # after : lock|sync_1a_s_r|sync_0b_s
        ################################################################
        lm.advance_request(trailing_lock=False)

        ################################################################
        # before: lock|sync_1a_s_r|sync_0b_s
        # action: drop lock, sync_1a_s is now able to set sync_0
        #             sync_flag and loops back to top of req loop
        #             along side of sync_0b_s and then they both
        #             complete the sync
        # after : none
        ################################################################
        lm.complete_request(free_all=True)

        ################################################################
        # confirm the sync requests
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Sync",
                confirm_serial_num=sync_0a_serial_num,
                confirmers=sync_names[0],
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Sync",
                confirm_serial_num=sync_0b_serial_num,
                confirmers=sync_names[0],
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Join",
                confirm_serial_num=join_serial_num,
                confirmers=aux_names[0],
            )
        )

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd="Sync",
                confirm_serial_num=sync_1a_serial_num,
                confirmers=sync_names[1],
            )
        )

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures,
                obtain_reg_lock=True,
            )
        )

    ####################################################################
    # build_wait_request
    ####################################################################
    def build_wait_request(
        self,
        timeout_type: TimeoutType,
        cmd_runner: str,
        target: str,
        stopped_remotes: set[str],
        request_specific_args: dict[str, Any],
    ) -> RequestConfirmParms:
        """Adds cmds to the cmd queue.

        Args:
            timeout_type: None, False, or True for timeout
            cmd_runner: name of thread that will do the request
            target: name of thread that is the target_rtn of the request
            stopped_remotes: names of threads that are expected to be
                detected by the request as stopped
            request_specific_args: specific args for each request

        Returns:
            the name and serial number of the request for confirmation
            purposes

        """
        timeout_time: IntOrFloat
        if timeout_type == TimeoutType.TimeoutNone:
            confirm_request_name = "Wait"
            request_serial_num = self.add_cmd(
                Wait(
                    cmd_runners=cmd_runner,
                    resumers=target,
                    exp_resumers=request_specific_args["exp_resumers"],
                    stopped_remotes=stopped_remotes,
                    deadlock_remotes=request_specific_args["deadlock_remotes"],
                )
            )
        elif timeout_type == TimeoutType.TimeoutFalse:
            confirm_request_name = "WaitTimeoutFalse"
            timeout_time = 6
            request_serial_num = self.add_cmd(
                WaitTimeoutFalse(
                    cmd_runners=cmd_runner,
                    resumers=target,
                    exp_resumers=request_specific_args["exp_resumers"],
                    timeout=timeout_time,
                    stopped_remotes=stopped_remotes,
                    deadlock_remotes=request_specific_args["deadlock_remotes"],
                )
            )
        else:  # timeout_type == TimeoutType.TimeoutTrue
            timeout_time = 0.5
            confirm_request_name = "WaitTimeoutTrue"
            request_serial_num = self.add_cmd(
                WaitTimeoutTrue(
                    cmd_runners=cmd_runner,
                    resumers=target,
                    exp_resumers=request_specific_args["exp_resumers"],
                    timeout=timeout_time,
                    timeout_remotes=target,
                    stopped_remotes=stopped_remotes,
                    deadlock_remotes=request_specific_args["deadlock_remotes"],
                )
            )

        return RequestConfirmParms(
            request_name=confirm_request_name, serial_number=request_serial_num
        )

    ####################################################################
    # build_send_msg_timeout_scenario
    ####################################################################
    def build_send_msg_timeout_scenario(
        self,
        timeout_type: TimeoutType,
        num_senders: int = 1,
        num_active_targets: int = 1,
        num_registered_targets: int = 0,
        num_unreg_timeouts: int = 0,
        num_exit_timeouts: int = 1,
        num_full_q_timeouts: int = 0,
    ) -> None:
        """Return a list of ConfigCmd items for a msg timeout.

        Args:
            timeout_type: specifies whether to issue the send_cmd with
                timeout, and if so whether the send_cmd should timeout
                or, by starting exited threads in time, not timeout
            num_senders: specifies number of threads that will send msg
            num_active_targets: specifies number of threads to receive
                the msg
            num_registered_targets: specifies the number of targets that
                should be registered only (i.e., not yet started)
            num_unreg_timeouts: specifies the number of threads that
                should cause timeout by being unregistered
            num_exit_timeouts: specifies the number of threads that
                should be exited and joined to cause timeout
            num_full_q_timeouts: specifies the number of threads that
                should cause timeout by having a full msg queue

        """
        self.auto_calling_refresh_msg = False
        # Make sure we have enough threads
        assert (
            num_senders
            + num_active_targets
            + num_registered_targets
            + num_unreg_timeouts
            + num_exit_timeouts
            + num_full_q_timeouts
        ) <= len(self.unregistered_names)

        assert num_senders > 0

        # for the exit timeout case, we send zero msgs for the first
        # thread, then 1 for the second thread, 2 for the third, etc.,
        # so we need to make sure we don't exceed the max number of
        # messages that can be received
        assert num_exit_timeouts < self.max_msgs

        timeout_time = (
            (num_active_targets * 0.16)
            + (num_registered_targets * 0.16)
            + (num_unreg_timeouts * 0.50)
            + (num_exit_timeouts * 0.50)
            + (num_full_q_timeouts * 0.25 * self.max_msgs)
        )

        if timeout_type == TimeoutType.TimeoutFalse:
            timeout_time *= 2  # prevent timeout
            timeout_time = max(timeout_time, 1)
        elif timeout_type == TimeoutType.TimeoutTrue:
            timeout_time *= 0.5  # force timeout

        sender_names = get_names("sender_", num_senders)

        active_target_names = get_names("active_target_name_", num_active_targets)

        reg_names = get_names("reg_name_", num_registered_targets)

        unreg_timeout_names = get_names("unreg_timeout_name_", num_unreg_timeouts)

        exit_names = get_names("exit_name_", num_exit_timeouts)

        full_q_names = get_names("full_q_name_", num_full_q_timeouts)

        self.create_config(
            unreg_names=unreg_timeout_names,
            reg_names=reg_names,
            active_names=(
                sender_names | active_target_names | exit_names | full_q_names
            ),
        )

        ################################################################
        # send msgs to senders so we have some on their queues so we
        # can verify partially paired for any threads that are exited
        ################################################################
        ################################################################
        # setup the messages to send
        ################################################################
        all_targets: set[str] = (
            active_target_names
            | reg_names
            | unreg_timeout_names
            | exit_names
            | full_q_names
        )

        sender_msgs = SendRecvMsgs(
            sender_names=sender_names,
            receiver_names=all_targets,
            num_msgs=self.max_msgs,
            text="sender_msgs",
        )

        exit_msgs = SendRecvMsgs(
            sender_names=exit_names,
            receiver_names=sender_names,
            num_msgs=3,
            text="exit_msgs",
        )
        if exit_names and num_senders >= 2:
            for exit_name in exit_names:
                log_msg = f"log test: {get_ptime()}"

                send_msg_serial_num = self.add_cmd(
                    SendMsg(
                        cmd_runners=exit_name,
                        receivers="sender_1",
                        exp_receivers="sender_1",
                        msgs_to_send=exit_msgs,
                        msg_idx=0,
                        log_msg=log_msg,
                    )
                )

                ########################################################
                # confirm the smart_send
                ########################################################
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=self.commander_name,
                        confirm_cmd="SendMsg",
                        confirm_serial_num=send_msg_serial_num,
                        confirmers=[exit_name],
                    )
                )

        if exit_names and num_senders == 3:
            for exit_name in exit_names:
                send_msg_serial_num = self.add_cmd(
                    SendMsg(
                        cmd_runners=exit_name,
                        receivers="sender_2",
                        exp_receivers="sender_2",
                        msgs_to_send=exit_msgs,
                        msg_idx=1,
                    )
                )

                ########################################################
                # confirm the smart_send
                ########################################################
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="SendMsg",
                        confirm_serial_num=send_msg_serial_num,
                        confirmers=[exit_name],
                    )
                )

                log_msg = f"log test: {get_ptime()}"

                send_msg_serial_num = self.add_cmd(
                    SendMsg(
                        cmd_runners=exit_name,
                        receivers="sender_2",
                        exp_receivers="sender_2",
                        msgs_to_send=exit_msgs,
                        msg_idx=2,
                        log_msg=log_msg,
                    )
                )

                ########################################################
                # confirm the smart_send
                ########################################################
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="SendMsg",
                        confirm_serial_num=send_msg_serial_num,
                        confirmers=[exit_name],
                    )
                )

        ################################################################
        # send max msgs if needed
        ################################################################
        if full_q_names:
            for idx in range(self.max_msgs):
                # send from each sender thread to ensure we get
                # exactly max_msgs on each pair between sender and the
                # full_q receivers
                send_msg_serial_num = self.add_cmd(
                    SendMsg(
                        cmd_runners=sender_names,
                        receivers=full_q_names,
                        exp_receivers=full_q_names,
                        msgs_to_send=sender_msgs,
                        msg_idx=idx,
                    )
                )

                ########################################################
                # confirm the smart_send
                ########################################################
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd="SendMsg",
                        confirm_serial_num=send_msg_serial_num,
                        confirmers=sender_names,
                    )
                )

        ################################################################
        # build exit and join suites for the exit names
        ################################################################
        if exit_names:
            for idx in range(1, num_exit_timeouts):
                # the idea here is to have the first exit_name have zero
                # msgs, the second will have 1 msg, etc, etc, etc...
                for num_msgs in range(idx):
                    log_msg = f"log test: {get_ptime()}"
                    send_msg_serial_num = self.add_cmd(
                        SendMsg(
                            cmd_runners=sender_names,
                            receivers="exit_name_" + str(idx),
                            exp_receivers="exit_name_" + str(idx),
                            msgs_to_send=sender_msgs,
                            msg_idx=0,
                            log_msg=log_msg,
                        )
                    )

                    ####################################################
                    # confirm the smart_send
                    ####################################################
                    self.add_cmd(
                        ConfirmResponse(
                            cmd_runners=[self.commander_name],
                            confirm_cmd="SendMsg",
                            confirm_serial_num=send_msg_serial_num,
                            confirmers=sender_names,
                        )
                    )

            self.build_exit_suite(
                cmd_runner=self.commander_name,
                names=exit_names,
                send_recv_msgs=sender_msgs,
            )
            self.build_join_suite(
                cmd_runners=self.commander_name, join_target_names=exit_names
            )

            for exit_name in exit_names:
                self.add_cmd(
                    VerifyConfig(
                        cmd_runners=self.commander_name,
                        verify_type=VerifyType.VerifyNotPaired,
                        names_to_check=[exit_name, "sender_0"],
                    )
                )

            if num_senders >= 2:
                for exit_name in exit_names:
                    self.add_cmd(
                        VerifyConfig(
                            cmd_runners=self.commander_name,
                            verify_type=VerifyType.VerifyHalfPaired,
                            names_to_check="sender_1",
                            aux_names=exit_name,
                        )
                    )

            if num_senders == 3:
                for exit_name in exit_names:
                    self.add_cmd(
                        VerifyConfig(
                            cmd_runners=self.commander_name,
                            verify_type=VerifyType.VerifyHalfPaired,
                            names_to_check="sender_2",
                            aux_names=exit_name,
                        )
                    )

        if timeout_type == TimeoutType.TimeoutTrue:
            exp_receivers: set[str] = (
                all_targets - unreg_timeout_names - exit_names - full_q_names
            )
            send_msg_serial_num = self.add_cmd(
                SendMsgTimeoutTrue(
                    cmd_runners=sender_names,
                    receivers=all_targets,
                    exp_receivers=exp_receivers,
                    msgs_to_send=sender_msgs,
                    msg_idx=0,
                    timeout=timeout_time,
                    unreg_timeout_names=unreg_timeout_names | exit_names,
                    fullq_timeout_names=full_q_names,
                )
            )

            confirm_cmd_to_use = "SendMsgTimeoutTrue"
            final_recv_names = active_target_names | reg_names
        else:
            if timeout_type == TimeoutType.TimeoutFalse:
                send_msg_serial_num = self.add_cmd(
                    SendMsgTimeoutFalse(
                        cmd_runners=sender_names,
                        receivers=all_targets,
                        exp_receivers=all_targets,
                        msgs_to_send=sender_msgs,
                        msg_idx=0,
                        timeout=timeout_time,
                    )
                )

                confirm_cmd_to_use = "SendMsgTimeoutFalse"
            else:
                send_msg_serial_num = self.add_cmd(
                    SendMsg(
                        cmd_runners=sender_names,
                        receivers=all_targets,
                        exp_receivers=all_targets,
                        msgs_to_send=sender_msgs,
                        msg_idx=0,
                    )
                )
                confirm_cmd_to_use = "SendMsg"

            self.add_cmd(
                WaitForRequestTimeouts(
                    cmd_runners=self.commander_name,
                    actor_names=sender_names,
                    timeout_names=(
                        unreg_timeout_names | reg_names | exit_names | full_q_names
                    ),
                )
            )

            # restore config by adding back the exited threads and
            # creating the un_reg threads so smart_send will complete
            # before timing out
            if unreg_timeout_names or exit_names:
                f1_create_items: list[F1CreateItem] = []
                for idx, name in enumerate(unreg_timeout_names | exit_names):
                    if idx % 2:
                        app_config = AppConfig.ScriptStyle
                    else:
                        app_config = AppConfig.RemoteThreadApp

                    f1_create_items.append(
                        F1CreateItem(
                            name=name,
                            auto_start=True,
                            target_rtn=outer_f1,
                            app_config=app_config,
                        )
                    )
                self.build_create_suite(
                    f1_create_items=f1_create_items, validate_config=False
                )

            # tell the fullq threads to read the stacked up msgs
            # so that the smart_send will complete
            if full_q_names:
                self.add_cmd(
                    RecvMsg(
                        cmd_runners=full_q_names,
                        senders=sender_names,
                        exp_senders=sender_names,
                        exp_msgs=sender_msgs,
                    )
                )

            final_recv_names = all_targets

        # start any registered threads
        if reg_names:
            self.build_start_suite(start_names=reg_names)

        # do RecvMsg to verify the SendMsg for receivers
        if final_recv_names:
            log_msg = f"log test: {get_ptime()}"
            recv_msg_serial_num = self.add_cmd(
                RecvMsg(
                    cmd_runners=final_recv_names,
                    senders=sender_names,
                    exp_senders=sender_names,
                    exp_msgs=sender_msgs,
                    log_msg=log_msg,
                )
            )

            ############################################################
            # confirm the smart_recv
            ############################################################
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd="RecvMsg",
                    confirm_serial_num=recv_msg_serial_num,
                    confirmers=final_recv_names,
                )
            )

        ################################################################
        # do RecvMsg to verify the SendMsg for senders
        ################################################################
        if exit_names:
            if num_senders >= 2:
                for exit_name in exit_names:
                    recv_msg_serial_num = self.add_cmd(
                        RecvMsg(
                            cmd_runners="sender_1",
                            senders=exit_name,
                            exp_senders=exit_name,
                            exp_msgs=exit_msgs,
                        )
                    )

                    ####################################################
                    # confirm the smart_recv
                    ####################################################
                    self.add_cmd(
                        ConfirmResponse(
                            cmd_runners=[self.commander_name],
                            confirm_cmd="RecvMsg",
                            confirm_serial_num=recv_msg_serial_num,
                            confirmers=["sender_1"],
                        )
                    )

                    ####################################################
                    # we expect a refresh for del def on msg
                    ####################################################
                    if timeout_type == TimeoutType.TimeoutTrue:
                        pe = self.pending_events["sender_1"]
                        ref_key: CallRefKey = "smart_recv"
                        pe[PE.calling_refresh_msg][ref_key] += 1

            if num_senders == 3:
                for exit_name in exit_names:
                    recv_msg_serial_num = self.add_cmd(
                        RecvMsg(
                            cmd_runners="sender_2",
                            senders=exit_name,
                            exp_senders=exit_name,
                            exp_msgs=exit_msgs,
                        )
                    )

                    ####################################################
                    # confirm the smart_recv
                    ####################################################
                    self.add_cmd(
                        ConfirmResponse(
                            cmd_runners=[self.commander_name],
                            confirm_cmd="RecvMsg",
                            confirm_serial_num=recv_msg_serial_num,
                            confirmers=["sender_2"],
                        )
                    )

                    ####################################################
                    # we expect a refresh for del def on msg
                    ####################################################
                    if timeout_type == TimeoutType.TimeoutTrue:
                        pe = self.pending_events["sender_2"]
                        ref_key = "smart_recv"
                        pe[PE.calling_refresh_msg][ref_key] += 1

            # exit the exit names again after senders have read their
            # pending messages, and then verify exit names and senders
            # are no longer paired
            if timeout_type != TimeoutType.TimeoutTrue:
                self.build_exit_suite(cmd_runner=self.commander_name, names=exit_names)
                self.build_join_suite(
                    cmd_runners=self.commander_name, join_target_names=exit_names
                )

            for sender_name in sender_names:
                exp_not_paired = {sender_name} | exit_names
                # self.add_cmd(VerifyPairedNot(
                #     cmd_runners=self.commander_name,
                #     exp_not_paired_names=exp_not_paired))
                self.add_cmd(
                    VerifyConfig(
                        cmd_runners=self.commander_name,
                        verify_type=VerifyType.VerifyNotPaired,
                        names_to_check=exp_not_paired,
                    )
                )

        ################################################################
        # confirm the smart_send
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd=confirm_cmd_to_use,
                confirm_serial_num=send_msg_serial_num,
                confirmers=sender_names,
            )
        )

    ####################################################################
    # build_simple_scenario
    ####################################################################

    def build_simple_scenario(self) -> None:
        """Add config cmds to the scenario queue."""
        self.add_cmd(
            VerifyConfig(cmd_runners="alpha", verify_type=VerifyType.VerifyStructures)
        )
        self.add_cmd(
            CreateF1AutoStart(
                cmd_runners="alpha",
                f1_create_items=[
                    F1CreateItem(name="beta", auto_start=True, target_rtn=outer_f1),
                    F1CreateItem(
                        name="charlie",
                        auto_start=True,
                        target_rtn=outer_f1,
                        app_config=AppConfig.RemoteThreadApp,
                    ),
                ],
            )
        )
        self.add_cmd(Pause(cmd_runners="alpha", pause_seconds=0.5))
        self.add_cmd(
            CreateF1NoStart(
                cmd_runners="alpha",
                f1_create_items=[
                    F1CreateItem(
                        name="delta",
                        auto_start=False,
                        target_rtn=outer_f1,
                        app_config=AppConfig.ScriptStyle,
                    ),
                    F1CreateItem(
                        name="echo",
                        auto_start=False,
                        target_rtn=outer_f1,
                        app_config=AppConfig.RemoteThreadApp,
                    ),
                    F1CreateItem(
                        name="fox",
                        auto_start=False,
                        target_rtn=outer_f1,
                        app_config=AppConfig.ScriptStyle,
                    ),
                    F1CreateItem(
                        name="george",
                        auto_start=False,
                        target_rtn=outer_f1,
                        app_config=AppConfig.RemoteThreadApp,
                    ),
                ],
            )
        )
        self.add_cmd(
            VerifyConfig(
                cmd_runners="alpha",
                verify_type=VerifyType.VerifyInRegistry,
                names_to_check=[
                    "alpha",
                    "beta",
                    "charlie",
                    "delta",
                    "echo",
                    "fox",
                    "george",
                ],
            )
        )

        self.add_cmd(
            VerifyConfig(
                cmd_runners="alpha",
                verify_type=VerifyType.VerifyAlive,
                names_to_check=["alpha", "beta", "charlie"],
            )
        )

        self.add_cmd(
            VerifyConfig(
                cmd_runners="alpha",
                verify_type=VerifyType.VerifyNotAlive,
                names_to_check=["delta", "echo", "fox", "george"],
            )
        )

        self.add_cmd(
            VerifyConfig(
                cmd_runners="alpha",
                verify_type=VerifyType.VerifyAliveState,
                names_to_check=["alpha", "beta", "charlie"],
            )
        )

        self.add_cmd(
            VerifyConfig(
                cmd_runners="alpha",
                verify_type=VerifyType.VerifyRegisteredState,
                names_to_check=["delta", "echo", "fox", "george"],
            )
        )

        self.add_cmd(
            VerifyConfig(
                cmd_runners="alpha",
                verify_type=VerifyType.VerifyState,
                names_to_check=["alpha", "beta", "charlie"],
                state_to_check=st.ThreadState.Alive,
            )
        )

        self.add_cmd(
            VerifyConfig(
                cmd_runners="alpha",
                verify_type=VerifyType.VerifyState,
                names_to_check=["delta", "echo", "fox", "george"],
                state_to_check=st.ThreadState.Registered,
            )
        )

        self.add_cmd(
            VerifyConfig(
                cmd_runners="alpha",
                verify_type=VerifyType.VerifyPaired,
                names_to_check=[
                    "alpha",
                    "beta",
                    "charlie",
                    "delta",
                    "echo",
                    "fox",
                    "george",
                ],
            )
        )
        self.add_cmd(StartThread(cmd_runners="alpha", start_names=["delta", "echo"]))

        self.add_cmd(
            VerifyConfig(
                cmd_runners="alpha",
                verify_type=VerifyType.VerifyAlive,
                names_to_check=["alpha", "beta", "charlie", "delta", "echo"],
            )
        )

        self.add_cmd(
            VerifyConfig(
                cmd_runners="alpha",
                verify_type=VerifyType.VerifyAliveState,
                names_to_check=["alpha", "beta", "charlie", "delta", "echo"],
            )
        )

        self.add_cmd(
            VerifyConfig(
                cmd_runners="alpha",
                verify_type=VerifyType.VerifyState,
                names_to_check=["alpha", "beta", "charlie", "delta", "echo"],
                state_to_check=st.ThreadState.Alive,
            )
        )

        self.add_cmd(
            VerifyConfig(cmd_runners="alpha", verify_type=VerifyType.VerifyStructures)
        )
        ################################################################
        # smart_send
        ################################################################
        msgs_to_send = SendRecvMsgs(
            sender_names=["delta", "echo"],
            receiver_names=["alpha", "beta", "charlie"],
            num_msgs=1,
            text="build_simple_scenario",
        )

        send_msg_serial_num = self.add_cmd(
            SendMsg(
                cmd_runners=["delta", "echo"],
                receivers=["alpha", "beta", "charlie"],
                exp_receivers=["alpha", "beta", "charlie"],
                msgs_to_send=msgs_to_send,
                msg_idx=0,
                log_msg="SendCmd test log message 1",
            )
        )

        ################################################################
        # confirm the smart_send
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners="alpha",
                confirm_cmd="SendMsg",
                confirm_serial_num=send_msg_serial_num,
                confirmers=["delta", "echo"],
            )
        )
        ################################################################
        # smart_recv
        ################################################################
        recv_msg_serial_num = self.add_cmd(
            RecvMsg(
                cmd_runners=["alpha", "beta", "charlie"],
                senders=["delta", "echo"],
                exp_senders=["delta", "echo"],
                exp_msgs=msgs_to_send,
                log_msg="RecvMsg test log message 2",
            )
        )

        ################################################################
        # confirm the smart_recv
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners="alpha",
                confirm_cmd="RecvMsg",
                confirm_serial_num=recv_msg_serial_num,
                confirmers=["alpha", "beta", "charlie"],
            )
        )

        ################################################################
        # wait
        ################################################################
        self.add_cmd(
            Wait(
                cmd_runners="beta",
                resumers="charlie",
                exp_resumers="charlie",
                stopped_remotes=set(),
                log_msg="Wait test log message 3",
            )
        )
        ################################################################
        # resume
        ################################################################
        self.add_cmd(
            Resume(
                cmd_runners="charlie",
                targets="beta",
                exp_resumed_targets="beta",
                stopped_remotes=[],
                log_msg="Resume test log message 4",
            )
        )

        ################################################################
        # sync
        ################################################################
        self.add_cmd(
            Sync(
                cmd_runners="beta",
                targets="charlie",
                sync_set_ack_remotes="charlie",
                log_msg="Sync test log message 5",
            )
        )
        self.add_cmd(
            Sync(
                cmd_runners="charlie",
                targets="beta",
                sync_set_ack_remotes="beta",
                log_msg="Sync test log message 6",
            )
        )

        ################################################################
        # stop all threads
        ################################################################

        self.add_cmd(
            StopThread(
                cmd_runners="alpha", stop_names=["beta", "charlie", "delta", "echo"]
            )
        )

        self.add_cmd(
            VerifyConfig(
                cmd_runners="alpha",
                verify_type=VerifyType.VerifyNotAlive,
                names_to_check=["beta", "charlie", "delta", "echo", "fox", "george"],
            )
        )

        self.add_cmd(
            VerifyConfig(cmd_runners="alpha", verify_type=VerifyType.VerifyStructures)
        )
        self.add_cmd(
            Join(
                cmd_runners="alpha",
                join_names=["beta", "charlie", "delta", "echo"],
                log_msg="Join test log message 7",
            )
        )

        self.add_cmd(
            VerifyConfig(cmd_runners="alpha", verify_type=VerifyType.VerifyStructures)
        )
        self.add_cmd(
            Unregister(
                cmd_runners="alpha",
                unregister_targets=["fox", "george"],
                log_msg="Unregister test log message 8",
            )
        )

        self.add_cmd(
            VerifyConfig(
                cmd_runners="alpha",
                verify_type=VerifyType.VerifyNotInRegistry,
                names_to_check=["fox", "george"],
            )
        )

        self.add_cmd(
            VerifyConfig(cmd_runners="alpha", verify_type=VerifyType.VerifyStructures)
        )

    ####################################################################
    # build_smart_start_suite
    ####################################################################
    def build_smart_start_suite(
        self,
        num_auto_start: int,
        num_manual_start: int,
        num_unreg: int,
        num_alive: int,
        num_stopped: int,
    ) -> None:
        """Return a list of ConfigCmd items for smart_start.

        Args:
            num_auto_start: number of threads to auto start
            num_manual_start: number of threads to manually start
            num_unreg: number of thread that are unregistered
            num_alive: number of threads that are alive
            num_stopped: number of threads that are stopped

        """
        # Make sure we have enough threads
        num_alt_cmd_runners = 1

        alt_cmd_runners = get_names("alt_cmd_runner_", num_alt_cmd_runners)
        auto_start_names = get_names("auto_start_name_", num_auto_start)
        manual_start_names = get_names("manual_start_name_", num_manual_start)
        unreg_names = get_names("unreg_names_", num_unreg)
        alive_names = get_names("alive_name_", num_alive)
        stopped_remotes = get_names("stopped_remote_", num_stopped)

        self.create_config(
            unreg_names=auto_start_names | unreg_names,
            reg_names=manual_start_names,
            active_names=alt_cmd_runners | alive_names,
            stopped_names=stopped_remotes,
        )

        unreg_remotes = unreg_names | alive_names | stopped_remotes

        for idx, name in enumerate(roundrobin(auto_start_names, manual_start_names)):
            if name in auto_start_names:
                self.add_cmd(
                    CreateF1AutoStart(
                        cmd_runners="alpha",
                        f1_create_items=[
                            F1CreateItem(
                                name=name, auto_start=True, target_rtn=outer_f1
                            ),
                        ],
                    )
                )
                self.unregistered_names -= {name}
                self.active_names |= {name}

            elif name in manual_start_names:
                smart_start_serial_num = self.add_cmd(
                    StartThread(
                        cmd_runners="alt_cmd_runner_0",
                        start_names=unreg_remotes | {name},
                        unreg_remotes=unreg_remotes,
                        log_msg="smart_start test 1",
                    )
                )
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=self.commander_name,
                        confirm_cmd="StartThread",
                        confirm_serial_num=smart_start_serial_num,
                        confirmers="alt_cmd_runner_0",
                    )
                )
                self.registered_names -= {name}
                self.active_names |= {name}

    ####################################################################
    # build_start_suite
    ####################################################################
    def build_start_suite(
        self, start_names: Iterable[str], validate_config: Optional[bool] = True
    ) -> None:
        """Return a list of ConfigCmd items for smart_unreg.

        Args:
            start_names: thread names to be started
            validate_config: indicates whether to validate the config

        """
        start_names = get_set(start_names)
        if not start_names.issubset(self.registered_names):
            self.abort_all_f1_threads()
            raise InvalidInputDetected(
                f"Input {start_names} is not a subset "
                "of registered names "
                f"{self.registered_names}"
            )

        self.add_cmd(
            StartThread(cmd_runners=self.commander_name, start_names=start_names)
        )

        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyAliveState,
                names_to_check=start_names,
            )
        )

        if validate_config:
            # self.add_cmd(ValidateConfig(cmd_runners=self.commander_name))
            self.add_cmd(
                VerifyConfig(
                    cmd_runners=self.commander_name,
                    verify_type=VerifyType.VerifyStructures,
                )
            )

        self.registered_names -= set(start_names)
        self.active_names |= set(start_names)

    ####################################################################
    # build_start_suite_num
    ####################################################################
    def build_start_suite_num(self, num_to_start: int) -> None:
        """Return a list of ConfigCmd items for smart_unreg.

        Args:
            num_to_start: number of threads to be started

        """
        assert num_to_start > 0
        if len(self.registered_names) < num_to_start:
            self.abort_all_f1_threads()
            raise InvalidInputDetected(
                f"Input num_to_start {num_to_start} "
                f"is greater than the number of "
                f"registered threads "
                f"{len(self.registered_names)}"
            )

        names: list[str] = list(
            random.sample(sorted(self.registered_names), num_to_start)
        )

        return self.build_start_suite(start_names=names)

    ####################################################################
    # build_sync_scenario_suite
    ####################################################################
    def build_sync_scenario_suite(
        self,
        timeout_type: TimeoutType,
        num_syncers: int,
        num_stopped_syncers: int,
        num_timeout_syncers: int,
    ) -> None:
        """Build ConfigCmd items for sync scenarios.

        Args:
            timeout_type: timeout for None, False, or True
            num_syncers: number of threads that will successfully
                sync
            num_stopped_syncers: number of threads that will
                cause a not alive error
            num_timeout_syncers: number of threads that will be delayed
                and will succeed when timeout is None or False and
                there are no stopped syncers, or fail when timeout
                is True or there are one or more stopped syncers

        """
        timeout_time = (num_syncers * 0.64) + (num_timeout_syncers * 0.64)

        pause_time = timeout_time
        if timeout_type == TimeoutType.TimeoutFalse:
            timeout_time *= 4  # prevent timeout
        elif timeout_type == TimeoutType.TimeoutTrue:
            timeout_time *= 0.25  # force timeout

        syncer_names = get_names("syncer_", num_syncers)
        timeout_names = get_names("timeout_syncer_", num_timeout_syncers)
        stopped_names = get_names("stopped_syncer_", num_stopped_syncers)

        all_targets: set[str] = syncer_names | timeout_names | stopped_names

        self.create_config(
            reg_names=timeout_names,
            active_names=syncer_names,
            stopped_names=stopped_names,
        )

        sync_set_ack_remotes: set[str] = syncer_names.copy()
        confirmers: set[str] = syncer_names.copy()
        cmd_runners: set[str] = syncer_names.copy()
        ################################################################
        # timeout True
        ################################################################
        if timeout_type == TimeoutType.TimeoutTrue:
            confirm_cmd_to_use = "SyncTimeoutTrue"
            sync_serial_num = self.add_cmd(
                SyncTimeoutTrue(
                    cmd_runners=cmd_runners,
                    targets=all_targets,
                    sync_set_ack_remotes=sync_set_ack_remotes,
                    timeout=timeout_time,
                    timeout_remotes=timeout_names,
                    stopped_remotes=stopped_names,
                )
            )
        else:
            ############################################################
            # timeout None or False
            ############################################################
            # if stopped targets, syncers will fail before they see
            # the timeout targets, so the ack should not include them
            if not stopped_names:
                sync_set_ack_remotes |= timeout_names.copy()
                confirmers |= timeout_names.copy()
                cmd_runners |= timeout_names.copy()

            if timeout_type == TimeoutType.TimeoutFalse:
                confirm_cmd_to_use = "SyncTimeoutFalse"
                sync_serial_num = self.add_cmd(
                    SyncTimeoutFalse(
                        cmd_runners=cmd_runners,
                        targets=all_targets,
                        sync_set_ack_remotes=sync_set_ack_remotes,
                        timeout=timeout_time,
                        timeout_remotes=timeout_names,
                        stopped_remotes=stopped_names,
                    )
                )
            else:
                ########################################################
                # timeout None
                ########################################################
                confirm_cmd_to_use = "Sync"
                sync_serial_num = self.add_cmd(
                    Sync(
                        cmd_runners=confirmers,
                        targets=all_targets,
                        sync_set_ack_remotes=sync_set_ack_remotes,
                        stopped_remotes=stopped_names,
                        log_msg="sync test1",
                    )
                )

        self.add_cmd(Pause(cmd_runners=self.commander_name, pause_seconds=pause_time))
        ############################################################
        # start the registered syncers to get them active
        ############################################################
        if timeout_names:
            self.build_start_suite(start_names=timeout_names, validate_config=False)

        ################################################################
        # confirm the sync
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd=confirm_cmd_to_use,
                confirm_serial_num=sync_serial_num,
                confirmers=confirmers,
            )
        )

        ############################################################
        # join stopped syncers and then create to get them active
        ############################################################
        if stopped_names:
            self.build_join_suite(
                cmd_runners=self.commander_name, join_target_names=list(stopped_names)
            )
            f1_create_items: list[F1CreateItem] = []
            for idx, name in enumerate(stopped_names):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(
                    F1CreateItem(
                        name=name,
                        auto_start=True,
                        target_rtn=outer_f1,
                        app_config=app_config,
                    )
                )
            self.build_create_suite(
                f1_create_items=f1_create_items, validate_config=False
            )

        ############################################################
        # Now that everyone is started, do a final sync
        ############################################################
        sync_serial_num = self.add_cmd(
            Sync(
                cmd_runners=all_targets,
                targets=all_targets,
                sync_set_ack_remotes=all_targets,
                log_msg="sync test2",
            )
        )
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd="Sync",
                confirm_serial_num=sync_serial_num,
                confirmers=all_targets,
            )
        )

    ####################################################################
    # build_unreg_suite
    ####################################################################
    def build_unreg_suite(
        self, names: Iterable[str], validate_config: bool = True
    ) -> None:
        """Return a list of ConfigCmd items for smart_unreg.

        Args:
            names: thread name to be unregistered
            validate_config: specifies whether to verify the config
        """
        names = get_set(names)
        if not names.issubset(self.registered_names):
            self.abort_all_f1_threads()
            raise InvalidInputDetected(
                f"Input {names} is not a subset "
                "of registered names "
                f"{self.registered_names}"
            )

        self.add_cmd(
            Unregister(cmd_runners=self.commander_name, unregister_targets=names)
        )

        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyNotInRegistry,
                names_to_check=names,
            )
        )

        self.add_cmd(
            VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyNotPaired,
                names_to_check=names,
            )
        )

        if validate_config:
            self.add_cmd(
                VerifyConfig(
                    cmd_runners=self.commander_name,
                    verify_type=VerifyType.VerifyStructures,
                )
            )

        self.registered_names -= set(names)
        self.unregistered_names |= set(names)

    ####################################################################
    # build_unreg_suite_num
    ####################################################################
    def build_unreg_suite_num(self, num_to_unreg: int) -> None:
        """Return a list of ConfigCmd items for smart_unreg.

        Args:
            num_to_unreg: number of threads to be unregistered

        """
        assert num_to_unreg > 0
        if len(self.registered_names) < num_to_unreg:
            self.abort_all_f1_threads()
            raise InvalidInputDetected(
                f"Input num_to_unreg {num_to_unreg} "
                f"is greater than the number of "
                f"registered threads "
                f"{len(self.registered_names)}"
            )

        names: list[str] = list(
            random.sample(sorted(self.registered_names), num_to_unreg)
        )

        return self.build_unreg_suite(names=names)

    ####################################################################
    # choose_names
    ####################################################################
    def choose_names(
        self,
        name_collection: set[str],
        num_names_needed: int,
        update_collection: bool,
        var_name_for_log: str,
    ) -> list[str]:
        """Return a list of names picked from a set and issue log msg.

        Args:
            name_collection: set of names to choose from
            num_names_needed: number of names to choose
            update_collection: indicates whether to remove the chosen
                names from the set of names
            var_name_for_log: variable name to use for the log msg

        Returns:
            a list of names
        """
        chosen_names: list[str] = []
        if num_names_needed > 0:
            chosen_names = list(
                random.sample(sorted(name_collection), num_names_needed)
            )
        if update_collection:
            name_collection -= set(chosen_names)

        self.log_test_msg(f"{var_name_for_log}: {chosen_names}")

        return chosen_names

    ####################################################################
    # create_f1_thread
    ####################################################################
    def create_f1_thread(
        self,
        cmd_runner: str,
        target: Callable[[Any], None],
        name: str,
        app_config: AppConfig,
        auto_start: bool = True,
    ) -> None:
        """Create the f1_thread.

        Args:
            cmd_runner: name of thread doing the create
            target: the f1 routine that the thread will run
            name: name of the thread
            app_config: specifies the style of app to create
            auto_start: indicates whether the create should start the
                          thread
        """
        self.log_test_msg(f"create_f1_thread entry: {cmd_runner=}, " f"{name=}")
        self.f1_process_cmds[name] = True

        with self.ops_lock:
            self.monitor_pause += 1
        with self.monitor_condition:
            self.monitor_condition.wait()

        is_thread_target = False
        if app_config == AppConfig.ScriptStyle:
            is_thread_target = True

        if is_thread_target:
            thread_create: st.ThreadCreate = st.ThreadCreate.Target
        else:
            thread_create = st.ThreadCreate.Thread

        if auto_start:
            auto_start_decision: AutoStartDecision = AutoStartDecision.auto_start_yes
        else:
            auto_start_decision = AutoStartDecision.auto_start_no

        pe = self.pending_events[name]
        pe[PE.start_request].append(
            StartRequest(
                req_type=st.ReqType.Smart_init,
                targets={name},
                unreg_remotes=set(),
                not_registered_remotes=set(),
                timeout_remotes=set(),
                stopped_remotes=set(),
                deadlock_remotes=set(),
                eligible_targets=set(),
                completed_targets=set(),
                first_round_completed=set(),
                stopped_target_threads=set(),
                exp_senders=set(),
                exp_resumers=set(),
            )
        )

        req_key_entry: RequestKey = ("smart_init", "entry")

        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ("smart_init", "exit")

        pe[PE.request_msg][req_key_exit] += 1

        if auto_start:
            pe[PE.start_request].append(
                StartRequest(
                    req_type=st.ReqType.Smart_start,
                    targets={name},
                    unreg_remotes=set(),
                    not_registered_remotes=set(),
                    timeout_remotes=set(),
                    stopped_remotes=set(),
                    deadlock_remotes=set(),
                    eligible_targets=set(),
                    completed_targets=set(),
                    first_round_completed=set(),
                    stopped_target_threads=set(),
                    exp_senders=set(),
                    exp_resumers=set(),
                )
            )
            req_key_entry: RequestKey = ("smart_start", "entry")

            pe[PE.request_msg][req_key_entry] += 1

            req_key_exit: RequestKey = ("smart_start", "exit")

            pe[PE.request_msg][req_key_exit] += 1

        if app_config == AppConfig.ScriptStyle:
            f1_thread = st.SmartThread(
                group_name=self.group_name,
                name=name,
                target_rtn=target,
                args=(name, self),
                auto_start=auto_start,
                max_msgs=self.max_msgs,
            )
        elif app_config == AppConfig.RemoteThreadApp:
            f1_outer_app = OuterF1ThreadApp(
                config_ver=self,
                name=name,
                auto_start=auto_start,
                max_msgs=self.max_msgs,
            )
            f1_thread = f1_outer_app.smart_thread
        else:
            raise UnrecognizedCmd(
                "create_f1_thread does not recognize " f"{app_config=}"
            )

        self.all_threads[name] = f1_thread
        # self.expected_registered[name].thread = f1_thread
        with self.ops_lock:
            self.expected_registered[name] = ThreadTracker(
                thread=f1_thread,
                is_alive=False,
                exiting=False,
                is_auto_started=auto_start,
                is_TargetThread=is_thread_target,
                exp_init_is_alive=False,
                exp_init_thread_state=st.ThreadState.Registered,
                thread_create=thread_create,
                auto_start_decision=auto_start_decision,
                # st_state=st.ThreadState.Unregistered,
                st_state=st.ThreadState.Initialized,
                found_del_pairs=defaultdict(int),
            )

        with self.ops_lock:
            self.monitor_pause -= 1

        self.cmd_waiting_event_items[cmd_runner] = threading.Event()

        self.monitor_event.set()

        self.log_test_msg(f"{cmd_runner=} create_f1_thread waiting " f"for monitor")
        self.cmd_waiting_event_items[cmd_runner].wait()
        with self.ops_lock:
            del self.cmd_waiting_event_items[cmd_runner]

        self.log_test_msg(f"create_f1_thread exiting: {cmd_runner=}, " f"{name=}")

    ####################################################################
    # get_config_snapshot
    ####################################################################
    def create_snapshot_data(
        self, verify_name: str, verify_idx: int, verify_data: VerifyData
    ) -> None:
        """Create and save snapshot of real structures for verification.

        Args:
            verify_name: name of verify cmd
            verify_idx: index of the verify command
            verify_data: data to be saved with the snapshot

        """
        with conditional_registry_lock(
            lock=st.SmartThread._registry[self.group_name].registry_lock,
            obtain_tf=verify_data.obtain_reg_lock,
        ):
            registry_items: dict[str, RegistrySnapshotItem] = {}
            for name, item in st.SmartThread._registry[
                self.group_name
            ].registry.items():
                registry_items[name] = RegistrySnapshotItem(
                    is_alive=item.thread.is_alive(), state=item.st_state
                )

            pair_array_items: dict[st.PairKey, dict[str, StatusBlockSnapshotItem]] = {}
            for pair_key, connection_pair in st.SmartThread._registry[
                self.group_name
            ].pair_array.items():
                pair_array_items[pair_key] = {}
                for name, sb_item in connection_pair.status_blocks.items():
                    pair_array_items[pair_key][name] = StatusBlockSnapshotItem(
                        del_def_flag=sb_item.del_deferred,
                        pending_request=sb_item.request_pending,
                        pending_msg_count=sb_item.msg_q.qsize(),
                        pending_wait=sb_item.wait_flag,
                        pending_sync=sb_item.sync_flag,
                    )

        self.snap_shot_data[verify_idx] = SnapShotDataItem(
            registry_items=registry_items.copy(),
            pair_array_items=pair_array_items.copy(),
            verify_data=verify_data,
        )

        self.log_test_msg(f"Monitor Checkpoint: {verify_name} {verify_idx}")

    ####################################################################
    # dec_recv_timeout
    ####################################################################
    def dec_recv_timeout(self) -> None:
        """Decrement the receive timeout count."""
        with self.ops_lock:
            self.expected_num_recv_timeouts -= 1

    ####################################################################
    # del_thread
    ####################################################################
    def del_thread(
        self, cmd_runner: str, del_name: str, process: str, del_msg_idx: int
    ) -> None:
        """Delete the thread from the ConfigVerifier.

        Args:
            cmd_runner: name of thread doing the delete (for log msg)
            del_name: name of thread to be deleted
            process: names the process, either join or smart_unreg
            del_msg_idx: index in the log for the del message
        """
        self.log_test_msg(
            f"del_thread entered: {cmd_runner=}, " f"{del_name=}, {process=}"
        )

        self.log_test_msg(
            f"del_thread exit: {cmd_runner=}, " f"{del_name=}, {process=}"
        )

    ####################################################################
    # exit_thread
    ####################################################################
    def exit_thread(self, cmd_runner: str, stopped_by: str) -> None:
        """Drive the commands received on the command queue.

        Args:
            cmd_runner: name of thread being stopped
            stopped_by: name of thread doing the stop

        """
        self.expected_registered[cmd_runner].stopped_by = stopped_by
        self.f1_process_cmds[cmd_runner] = False

    ####################################################################
    # f1_driver
    ####################################################################
    def f1_driver(self, f1_name: str) -> None:
        """Drive the commands received on the command queue.

        Args:
            f1_name: name of thread doing the command

        """
        self.log_ver.add_call_seq(
            name="f1_driver", seq="test_smart_thread.py::ConfigVerifier.f1_driver"
        )

        # We will stay in this loop to process command while the
        # f1_process_cmds dictionary entry for f1_name is True. The
        # ConfigCmdExitThread cmd runProcess method will simply set the
        # dictionary entry for f1_name to False so that we will then
        # exit after we indicate that the cmd is complete
        while self.f1_process_cmds[f1_name]:
            cmd: ConfigCmd = self.msgs.get_msg(f1_name, timeout=None)

            cmd.run_process(cmd_runner=f1_name)

            self.completed_cmds[f1_name].append(cmd.serial_num)

    ####################################################################
    # get_log_msg
    ####################################################################
    def get_log_msg(
        self,
        search_msg: str,
        skip_num: int = 0,
        start_idx: int = 0,
        end_idx: int = -1,
        reverse_search: bool = False,
    ) -> tuple[str, int]:
        """Search for a log message and return it.

        Args:
            search_msg: log message to search for as a regex
            skip_num: number of matches to skip
            start_idx: index from which to start
            end_idx: index of 1 past the index at which to stop
            reverse_search: indicates whether to search from the bottom

        Returns:
            the log message if found, otherwise an empty string
        """
        search_pattern = re.compile(search_msg)
        num_skipped = 0
        work_log = self.caplog_to_use.record_tuples.copy()

        if end_idx == -1:
            end_idx = len(work_log)

        work_log = work_log[start_idx:end_idx]
        if reverse_search:
            work_log.reverse()

        for idx, log_tuple in enumerate(work_log):
            if search_pattern.match(log_tuple[2]):
                if num_skipped == skip_num:
                    if reverse_search:
                        ret_idx = start_idx + (len(work_log) - idx) - 1
                    else:
                        ret_idx = start_idx + idx
                    return log_tuple[2], ret_idx
                num_skipped += 1

        return "", -1

    ####################################################################
    # get_log_msgs
    ####################################################################
    def get_log_msgs(self) -> bool:
        """Search for a log messages and return them in order.

        Returns:
            True, if messages were found, False otherwise
        """
        # we should never call with a non-empty deque
        assert not self.log_found_items

        work_log = self.caplog_to_use.record_tuples.copy()

        end_idx = len(work_log)

        # return if no new log message have been issued since last call
        if self.log_start_idx >= end_idx:
            return False

        work_log = work_log[self.log_start_idx : end_idx]

        for idx, log_tuple in enumerate(work_log, self.log_start_idx):
            for log_search_item in self.log_search_items:
                if log_search_item.search_pattern.match(log_tuple[2]):
                    found_log_item = log_search_item.get_found_log_item(
                        found_log_msg=log_tuple[2], found_log_idx=idx
                    )
                    self.log_found_items.append(found_log_item)

        # update next starting point
        self.log_start_idx = end_idx

        if self.log_found_items:
            return True
        else:
            return False

    ####################################################################
    # handle_did_clean_reg_log_msg
    ####################################################################
    def handle_did_clean_reg_log_msg(
        self, cmd_runner: str, targets: list[str], log_msg: str
    ) -> None:
        """Handle the did cleanup of registry log message.

        Args:
            cmd_runner: thread name that did the cleanup
            targets: thread names that were removed
            log_msg: did cleanup log message

        """
        pe = self.pending_events[cmd_runner]

        if pe[PE.did_clean_reg_msg] <= 0:
            raise UnexpectedEvent(
                f"handle_did_clean_reg_log_msg encountered "
                f"unexpected log msg: {log_msg}"
            )

        pe[PE.did_clean_reg_msg] -= 1
        self.add_log_msg(re.escape(log_msg))

        ################################################################
        # verify list of targets
        ################################################################
        rem_reg_list = pe[PE.rem_reg_targets].pop()

        if sorted(rem_reg_list) != sorted(targets):
            raise IncorrectDataDetected(
                "handle_did_clean_reg_log_msg detected that the list of "
                f"removed targets {rem_reg_list} did not match the "
                f"log msg: {log_msg}"
            )

    ####################################################################
    # handle_join
    ####################################################################
    def handle_join(
        self,
        cmd_runner: str,
        join_names: set[str],
        unreg_names: set[str],
        log_msg: Optional[str] = None,
        timeout_type: TimeoutType = TimeoutType.TimeoutNone,
        timeout: Optional[IntOrFloat] = None,
        timeout_names: Optional[set[str]] = None,
    ) -> None:
        """Handle the join execution and log msgs.

        Args:
            cmd_runner: name of thread doing the cmd
            join_names: target_rtn threads that we will join
            unreg_names: thread names that are already unregistered
            log_msg: log message to issue on the join (name be None)
            timeout_type: None, False, or True
            timeout: value for timeout on join request
            timeout_names: threads that are expected to timeout

        """
        self.log_test_msg(
            f"handle_join entry: {cmd_runner=}, {join_names=}, "
            f"{unreg_names=}, {timeout_names=}"
        )
        self.log_ver.add_call_seq(
            name="smart_join", seq="test_smart_thread.py::ConfigVerifier.handle_join"
        )

        start_time = time.time()

        if timeout_names:
            timeout_remotes = timeout_names.copy()
        else:
            timeout_remotes = set()

        pe = self.pending_events[cmd_runner]

        pe[PE.start_request].append(
            StartRequest(
                req_type=st.ReqType.Smart_join,
                timeout_type=timeout_type,
                targets=join_names.copy(),
                unreg_remotes=unreg_names.copy(),
                not_registered_remotes=set(),
                timeout_remotes=timeout_remotes,
                stopped_remotes=set(),
                deadlock_remotes=set(),
                eligible_targets=set(),
                completed_targets=set(),
                first_round_completed=set(),
                stopped_target_threads=set(),
                exp_senders=set(),
                exp_resumers=set(),
            )
        )

        req_key_entry: RequestKey = ("smart_join", "entry")

        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ("smart_join", "exit")

        # enter_exit = ('entry', 'exit')
        if timeout_type == TimeoutType.TimeoutNone:
            pe[PE.request_msg][req_key_exit] += 1
            self.all_threads[cmd_runner].smart_join(targets=join_names, log_msg=log_msg)

        elif timeout_type == TimeoutType.TimeoutFalse:
            pe[PE.request_msg][req_key_exit] += 1
            self.all_threads[cmd_runner].smart_join(
                targets=join_names, timeout=timeout, log_msg=log_msg
            )

        elif timeout_type == TimeoutType.TimeoutTrue:
            # enter_exit = ('entry', )
            error_msg = self.get_error_msg(
                cmd_runner=cmd_runner,
                smart_request="smart_join",
                targets=join_names,
                error_str="SmartThreadRequestTimedOut",
            )
            with pytest.raises(st.SmartThreadRequestTimedOut) as exc:
                self.all_threads[cmd_runner].smart_join(
                    targets=join_names, timeout=timeout, log_msg=log_msg
                )

            err_str = str(exc.value)
            assert re.fullmatch(error_msg, err_str)

            self.add_log_msg(error_msg, log_level=logging.ERROR)

        elapsed_time: float = time.time() - start_time
        time_per_target: float = elapsed_time / len(join_names)

        self.monitor_event.set()

        self.wait_for_monitor(cmd_runner=cmd_runner, rtn_name="handle_join")

        self.log_test_msg(
            f"handle_join exiting with {elapsed_time=}, "
            f"{len(join_names)=}, {time_per_target=}"
        )

    ####################################################################
    # handle_recv_msg
    ####################################################################
    def handle_recv_msg(
        self,
        cmd_runner: str,
        senders: set[str],
        exp_senders: set[str],
        exp_msgs: SendRecvMsgs,
        stopped_remotes: set[str],
        deadlock_remotes: set[str],
        deadlock_or_timeout: bool,
        timeout_type: TimeoutType,
        timeout: IntOrFloat,
        timeout_names: set[str],
        sender_count: Optional[int] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Handle the send_recv_cmd execution and log msgs.

        Args:
            cmd_runner: name of thread doing the cmd
            senders: names of the senders
            exp_senders: senders that are expected to have sent a msg
                based on the RecvType
            exp_msgs: expected messages by sender name
            stopped_remotes: names of remotes that are stopped.
            deadlock_remotes: thread names that will cause a deadlock
            deadlock_or_timeout: expect deadlock or timeout
            timeout_type: None, False, or True
            timeout: value to use for timeout
            timeout_names: names of remotes that fail to send a message
                within the timeout time.
            sender_count: number of senders needed to satisfy smart_recv
            log_msg: log message to issue on smart_recv

        """
        self.log_test_msg(
            f"handle_recv_msg entry: {cmd_runner=}, "
            f"{senders=}, {sender_count=}, {exp_senders=}, "
            f"{stopped_remotes=}, {deadlock_remotes=}, "
            f"{timeout_type=}, {timeout=}, {timeout_names=}"
        )

        pe = self.pending_events[cmd_runner]
        pe[PE.start_request].append(
            StartRequest(
                req_type=st.ReqType.Smart_recv,
                timeout_type=timeout_type,
                targets=senders,
                timeout_remotes=timeout_names,
                stopped_remotes=stopped_remotes.copy(),
                exp_senders=exp_senders,
            )
        )

        req_key_entry: RequestKey = ("smart_recv", "entry")

        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ("smart_recv", "exit")

        if stopped_remotes:
            with pytest.raises(st.SmartThreadRemoteThreadNotAlive):
                if timeout_type == TimeoutType.TimeoutNone:
                    self.all_threads[cmd_runner].smart_recv(
                        senders=senders, sender_count=sender_count, log_msg=log_msg
                    )
                else:
                    self.all_threads[cmd_runner].smart_recv(
                        senders=senders,
                        sender_count=sender_count,
                        timeout=timeout,
                        log_msg=log_msg,
                    )

            # recover whatever message were read
            recvd_msgs = self.all_threads[cmd_runner].recvd_msgs

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request="smart_recv",
                    targets=senders,
                    error_str="SmartThreadRemoteThreadNotAlive",
                    stopped_remotes=stopped_remotes,
                ),
                log_level=logging.ERROR,
            )

        elif deadlock_remotes:
            if deadlock_or_timeout:
                expected_exceptions = (
                    st.SmartThreadDeadlockDetected,
                    st.SmartThreadRequestTimedOut,
                )
            else:
                expected_exceptions = st.SmartThreadDeadlockDetected
            with pytest.raises(expected_exceptions):
                if timeout_type == TimeoutType.TimeoutNone:
                    self.all_threads[cmd_runner].smart_recv(
                        senders=senders, sender_count=sender_count, log_msg=log_msg
                    )
                else:
                    self.all_threads[cmd_runner].smart_recv(
                        senders=senders,
                        sender_count=sender_count,
                        timeout=timeout,
                        log_msg=log_msg,
                    )
            recvd_msgs = self.all_threads[cmd_runner].recvd_msgs

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request="smart_recv",
                    targets=senders,
                    error_str="SmartThreadDeadlockDetected",
                    stopped_remotes=stopped_remotes,
                    deadlock_remotes=deadlock_remotes,
                ),
                log_level=logging.ERROR,
            )

        elif timeout_type == TimeoutType.TimeoutNone:
            pe[PE.request_msg][req_key_exit] += 1
            recvd_msgs = self.all_threads[cmd_runner].smart_recv(
                senders=senders, sender_count=sender_count, log_msg=log_msg
            )

        elif timeout_type == TimeoutType.TimeoutFalse:
            pe[PE.request_msg][req_key_exit] += 1
            recvd_msgs = self.all_threads[cmd_runner].smart_recv(
                senders=senders,
                sender_count=sender_count,
                timeout=timeout,
                log_msg=log_msg,
            )

        elif timeout_type == TimeoutType.TimeoutTrue:
            with pytest.raises(st.SmartThreadRequestTimedOut):
                self.all_threads[cmd_runner].smart_recv(
                    senders=senders,
                    sender_count=sender_count,
                    timeout=timeout,
                    log_msg=log_msg,
                )

            # recover whatever message were read
            recvd_msgs = self.all_threads[cmd_runner].recvd_msgs

            true_senders = list(recvd_msgs.keys())
            timeout_senders = senders - set(true_senders)

            for _ in timeout_senders:
                self.dec_recv_timeout()

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request="smart_recv",
                    targets=senders,
                    error_str="SmartThreadRequestTimedOut",
                    stopped_remotes=stopped_remotes,
                ),
                log_level=logging.ERROR,
            )

        assert sorted(exp_senders) == sorted(recvd_msgs.keys())
        for remote in exp_senders:
            if len(exp_msgs.exp_received_msgs[cmd_runner][remote]) > self.max_msgs:
                msgs_to_check: list[Any] = exp_msgs.exp_received_msgs[cmd_runner][
                    remote
                ][0 : self.max_msgs]

            else:
                msgs_to_check = exp_msgs.exp_received_msgs[cmd_runner][remote].copy()

            assert recvd_msgs[remote] == msgs_to_check

            exp_msgs.clear_exp_msgs_received(
                receiver_name=cmd_runner,
                sender_names=remote,
                num_msgs=len(msgs_to_check),
            )

        self.wait_for_monitor(cmd_runner=cmd_runner, rtn_name="handle_recv")

        self.log_test_msg(
            f"handle_recv_msg exit: {cmd_runner=}, "
            f"{senders=}, {sender_count=}, {exp_senders=}, "
            f"{stopped_remotes=}, {deadlock_remotes=}, "
            f"{timeout_type=}, {timeout=}, {timeout_names=}"
        )

    ####################################################################
    # handle_request_entry_exit_log_msg
    ####################################################################
    def handle_request_entry_exit_log_msg(
        self,
        cmd_runner: str,
        request_name: str,
        entry_exit: str,
        targets: list[str],
        log_msg: str,
    ) -> None:
        """Handle the request entry exit log msgs.

        Args:
            cmd_runner: name of thread doing the cmd
            request_name: smart request name
            entry_exit: specifies whether entry or exit message
            targets: targets of the request
            log_msg: log message for the request

        """
        self.log_test_msg(
            "handle_request_entry_exit_log_msg entry: "
            f"{cmd_runner=}, {request_name=}, {entry_exit=}, "
            f"{targets=}"
        )
        pe = self.pending_events[cmd_runner]

        req_key: RequestKey = (request_name, entry_exit)

        if pe[PE.request_msg][req_key] <= 0:
            error_msg = (
                f"handle_request_entry_exit_log_msg using {req_key=} "
                f"encountered unexpected log msg: {log_msg}"
            )
            self.log_test_msg(error_msg)
            self.log_test_msg(f"{pe}")
            raise UnexpectedEvent(error_msg)

        pe[PE.request_msg][req_key] -= 1

        self.add_log_msg(re.escape(log_msg))

        if entry_exit == "entry":
            try:
                req_start_item = pe[PE.start_request].popleft()
            except IndexError:
                raise UnexpectedEvent(
                    "handle_request_entry_exit_log_msg missing start_request "
                    f"for log msg: {log_msg}"
                )

            if req_start_item.req_type.value != request_name:
                raise UnexpectedEvent(
                    "handle_request_entry_exit_log_msg expected "
                    f"{req_start_item.req_type.value=} to match {request_name=} but "
                    f"for log msg: {log_msg}"
                )

            if not req_start_item.targets:
                sorted_targets = [""]
            else:
                sorted_targets = sorted(req_start_item.targets)

            if sorted_targets != sorted(targets):
                raise InvalidInputDetected(
                    "handle_request_entry_exit_log_msg expected "
                    f"{sorted_targets=} to be equal to "
                    f"{sorted(targets)=} for "
                    f"log msg: {log_msg}"
                )

            pe[PE.current_request] = req_start_item

        ################################################################
        # call handler for request
        ################################################################
        actions: dict[tuple[str, str], Callable[..., None]] = {
            ("smart_init", "entry"): self.handle_request_smart_init_entry,
            ("smart_init", "exit"): self.handle_request_smart_init_exit,
            ("smart_start", "entry"): self.handle_request_smart_start_entry,
            ("smart_start", "exit"): self.handle_request_smart_start_exit,
            ("smart_unreg", "entry"): self.handle_request_smart_unreg_entry,
            ("smart_unreg", "exit"): self.handle_request_smart_unreg_exit,
            ("smart_join", "entry"): self.handle_request_smart_join_entry,
            ("smart_join", "exit"): self.handle_request_smart_join_exit,
            ("smart_send", "entry"): self.handle_request_smart_send_entry,
            ("smart_send", "exit"): self.handle_request_smart_send_exit,
            ("smart_recv", "entry"): self.handle_request_smart_recv_entry,
            ("smart_recv", "exit"): self.handle_request_smart_recv_exit,
            ("smart_wait", "entry"): self.handle_request_smart_wait_entry,
            ("smart_wait", "exit"): self.handle_request_smart_wait_exit,
            ("smart_resume", "entry"): self.handle_request_smart_resume_entry,
            ("smart_resume", "exit"): self.handle_request_smart_resume_exit,
            ("smart_sync", "entry"): self.handle_request_smart_sync_entry,
            ("smart_sync", "exit"): self.handle_request_smart_sync_exit,
        }

        actions[(request_name, entry_exit)](cmd_runner=cmd_runner)

        if entry_exit == "exit":
            if pe[PE.current_request].req_type.value in (
                "smart_send",
                "smart_recv",
                "smart_wait",
                "smart_resume",
                "smart_sync",
            ):
                self.set_request_pending_flag(
                    cmd_runner=cmd_runner,
                    targets=set(targets),
                    pending_request_flag=False,
                )

            pe = self.pending_events[cmd_runner]

            if pe[PE.save_current_request].req_type != st.ReqType.NoReq:
                pe[PE.current_request] = pe[PE.save_current_request]
                pe[PE.save_current_request] = StartRequest(req_type=st.ReqType.NoReq)
            else:
                pe[PE.current_request] = StartRequest(req_type=st.ReqType.NoReq)

    ####################################################################
    # handle_request_smart_init_entry
    ####################################################################
    def handle_request_smart_init_entry(self, cmd_runner: str) -> None:
        """Handle the request entry for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]

        target = list(pe[PE.current_request].targets)[0]

        add_key: AddRegKey = (cmd_runner, target)
        pe[PE.add_reg_msg][add_key] += 1

        sub_key: SubProcessKey = (
            cmd_runner,
            "smart_init",
            "_register",
            "entry",
            target,
        )
        pe[PE.subprocess_msg][sub_key] += 1

        sub_key = (cmd_runner, "smart_init", "_clean_registry", "entry", cmd_runner)
        pe[PE.subprocess_msg][sub_key] += 1

        sub_key = (cmd_runner, "smart_init", "_clean_pair_array", "entry", cmd_runner)
        pe[PE.subprocess_msg][sub_key] += 1

        # determine init completion msg

        thread_create = self.expected_registered[target].thread_create
        thread_state = self.expected_registered[target].exp_init_thread_state
        auto_start = self.expected_registered[target].auto_start_decision

        comp_key: InitCompKey = (target, thread_create, thread_state, auto_start)
        pe[PE.init_comp_msg][comp_key] += 1

        self.log_test_msg(f"handle_request_smart_init_entry {comp_key=}")

    ####################################################################
    # handle_request_smart_init_exit
    ####################################################################
    def handle_request_smart_init_exit(self, cmd_runner: str) -> None:
        """Handle the request exit for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        pass

    ####################################################################
    # handle_request_smart_start_entry
    ####################################################################
    def handle_request_smart_start_entry(self, cmd_runner: str) -> None:
        """Handle the request entry for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]

        eligible_targets = (
            pe[PE.current_request].targets.copy()
            - pe[PE.current_request].not_registered_remotes.copy()
        )

        pe[PE.num_targets_remaining] = len(eligible_targets)

        for target in eligible_targets:
            state_key: SetStateKey = (
                cmd_runner,
                target,
                st.ThreadState.Registered,
                st.ThreadState.Alive,
            )
            pe[PE.set_state_msg][state_key] += 1

    ####################################################################
    # handle_request_smart_start_exit
    ####################################################################
    def handle_request_smart_start_exit(self, cmd_runner: str) -> None:
        """Handle the request exit for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_request_smart_unreg_entry
    ####################################################################
    def handle_request_smart_unreg_entry(self, cmd_runner: str) -> None:
        """Handle the request entry for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]

        eligible_targets = (
            pe[PE.current_request].targets.copy()
            - pe[PE.current_request].not_registered_remotes
        )
        pe[PE.current_request].eligible_targets = eligible_targets
        pe[PE.current_request].completed_targets = set()

        for target in eligible_targets:
            state_key = (
                cmd_runner,
                target,
                st.ThreadState.Registered,
                st.ThreadState.Unregistered,
            )
            pe[PE.set_state_msg][state_key] += 1

            self.expected_registered[target].reg_to_unreg = True

        sub_key: SubProcessKey = (
            cmd_runner,
            "smart_unreg",
            "_clean_registry",
            "entry",
            cmd_runner,
        )
        pe[PE.subprocess_msg][sub_key] += 1

        sub_key = (cmd_runner, "smart_unreg", "_clean_pair_array", "entry", cmd_runner)
        pe[PE.subprocess_msg][sub_key] += 1

    ####################################################################
    # handle_request_smart_unreg_exit
    ####################################################################
    def handle_request_smart_unreg_exit(self, cmd_runner: str) -> None:
        """Handle the request exit for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_request_smart_join_entry
    ####################################################################
    def handle_request_smart_join_entry(self, cmd_runner: str) -> None:
        """Handle the request entry for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]
        exp_first_round_completed: set[str] = set()

        if pe[PE.current_request].timeout_type == TimeoutType.TimeoutTrue:
            timeout_remotes = pe[PE.current_request].timeout_remotes
        else:
            timeout_remotes = set()

        eligible_targets = pe[PE.current_request].targets.copy() - timeout_remotes
        pe[PE.current_request].eligible_targets = eligible_targets
        pe[PE.current_request].completed_targets = set()
        for target in eligible_targets:
            if target in self.expected_registered:
                if self.expected_registered[target].st_state != st.ThreadState.Stopped:
                    # the thread may have not yet been started, but we
                    # know that eventually it will become alive if it
                    # is an eligible target_rtn
                    if self.expected_registered[target].st_state in (
                        # st.ThreadState.Unregistered,
                        st.ThreadState.Initialized,
                        st.ThreadState.Registered,
                        st.ThreadState.Alive,
                    ):
                        # either smart_join will do the _set_state or
                        # _clean_registry will do the _set_state
                        state_key: SetStateKey = (
                            cmd_runner,
                            target,
                            st.ThreadState.Alive,
                            st.ThreadState.Stopped,
                        )
                        pe[PE.set_state_msg][state_key] += 1
                        self.log_test_msg(
                            f"handle_request_smart_join_entry "
                            f"bumped set_state "
                            f"pending for {state_key=} "
                        )

                state_key = (
                    cmd_runner,
                    target,
                    st.ThreadState.Stopped,
                    st.ThreadState.Unregistered,
                )
                pe[PE.set_state_msg][state_key] += 1

                self.expected_registered[target].stopped_to_unreg = True

                if (
                    not self.expected_registered[target].is_alive
                    and self.expected_registered[target].st_state
                    == st.ThreadState.Alive
                ):
                    exp_first_round_completed |= {target}
            else:
                if target in pe[PE.current_request].unreg_remotes:
                    unreg_key: AlreadyUnregKey = (cmd_runner, target)
                    pe[PE.already_unreg_msg][unreg_key] += 1
                    exp_first_round_completed |= {target}
                else:
                    raise InvalidConfigurationDetected(
                        f"handle_request_smart_join_entry {cmd_runner=} "
                        f"found {target=} is unregistered but not in the set "
                        f"of {pe[PE.current_request].unreg_remotes=}"
                    )

        if eligible_targets:
            sub_key: SubProcessKey = (
                cmd_runner,
                "smart_join",
                "_clean_registry",
                "entry",
                cmd_runner,
            )
            pe[PE.subprocess_msg][sub_key] += 1

            sub_key = (
                cmd_runner,
                "smart_join",
                "_clean_pair_array",
                "entry",
                cmd_runner,
            )
            pe[PE.subprocess_msg][sub_key] += 1

    ####################################################################
    # handle_request_smart_join_exit
    ####################################################################
    def handle_request_smart_join_exit(self, cmd_runner: str) -> None:
        """Handle the request exit for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_request_smart_send_entry
    ####################################################################
    def handle_request_smart_send_entry(self, cmd_runner: str) -> None:
        """Handle the request entry for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]

        for target in pe[PE.current_request].exp_receivers:
            ack_key: AckKey = (target, "smart_send")

            pe[PE.ack_msg][ack_key] += 1

    ####################################################################
    # handle_request_smart_send_exit
    ####################################################################
    def handle_request_smart_send_exit(self, cmd_runner: str) -> None:
        """Handle the request exit for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_request_smart_recv_entry
    ####################################################################
    def handle_request_smart_recv_entry(self, cmd_runner: str) -> None:
        """Handle the request entry for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]

        eligible_targets = pe[PE.current_request].exp_senders.copy()

        for target in eligible_targets:
            ack_key: AckKey = (target, "smart_recv")

            pe[PE.ack_msg][ack_key] += 1

    ####################################################################
    # handle_request_smart_recv_exit
    ####################################################################
    def handle_request_smart_recv_exit(self, cmd_runner: str) -> None:
        """Handle the request exit for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_request_smart_wait_entry
    ####################################################################
    def handle_request_smart_wait_entry(self, cmd_runner: str) -> None:
        """Handle the request entry for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]

        eligible_targets = pe[PE.current_request].exp_resumers.copy()
        for target in eligible_targets:
            ack_key: AckKey = (target, "smart_wait")

            pe[PE.ack_msg][ack_key] += 1

    ####################################################################
    # handle_request_smart_wait_exit
    ####################################################################
    def handle_request_smart_wait_exit(self, cmd_runner: str) -> None:
        """Handle the request exit for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_request_smart_resume_entry
    ####################################################################
    def handle_request_smart_resume_entry(self, cmd_runner: str) -> None:
        """Handle the request entry for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]

        for target in pe[PE.current_request].exp_resumed_targets:
            ack_key: AckKey = (target, "smart_resume")

            pe[PE.ack_msg][ack_key] += 1

    ####################################################################
    # handle_request_smart_start_exit
    ####################################################################
    def handle_request_smart_resume_exit(self, cmd_runner: str) -> None:
        """Handle the request exit for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_request_smart_sync_entry
    ####################################################################
    def handle_request_smart_sync_entry(self, cmd_runner: str) -> None:
        """Handle the request entry for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]

        for target in pe[PE.current_request].sync_set_ack_remotes:
            if target == cmd_runner:
                continue

            ack_key: AckKey = (target, "smart_sync_set")

            pe[PE.ack_msg][ack_key] += 1

            if self.auto_sync_ach_or_back_msg:
                ack_key = (target, "smart_sync_ach_or_back")
                pe[PE.ack_msg][ack_key] += 1

    ####################################################################
    # handle_request_smart_sync_exit
    ####################################################################
    def handle_request_smart_sync_exit(self, cmd_runner: str) -> None:
        """Handle the request exit for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_request_entry_exit_log_msg
    ####################################################################
    def handle_request_refresh_log_msg(
        self, cmd_runner: str, request: str, targets: set[str], log_msg: str
    ) -> None:
        """Handle the request refresh log msgs.

        Args:
            cmd_runner: name of thread doing the cmd
            request: smart request name
            targets: thread names of remaining targets
            log_msg: log message for the request

        """
        pe = self.pending_events[cmd_runner]

        targets_to_reset: set[str] = pe[PE.current_request].targets - targets

        ref_key: CallRefKey = request

        if pe[PE.calling_refresh_msg][ref_key] <= 0:
            raise UnexpectedEvent(
                f"handle_request_refresh_log_msg using {ref_key=} "
                f"detected unexpected log msg: {log_msg}"
            )

        pe[PE.calling_refresh_msg][ref_key] -= 1

        self.set_request_pending_flag(
            cmd_runner=cmd_runner, targets=targets_to_reset, pending_request_flag=False
        )

        sub_key: SubProcessKey = (
            cmd_runner,
            request,
            "_clean_registry",
            "entry",
            cmd_runner,
        )
        pe[PE.subprocess_msg][sub_key] += 1

        sub_key = (cmd_runner, request, "_clean_pair_array", "entry", cmd_runner)
        pe[PE.subprocess_msg][sub_key] += 1

    ####################################################################
    # handle_recv_waiting_log_msg
    ####################################################################
    def handle_cmd_waiting_log_msg(self, cmd_runner: str) -> None:
        """Handle the send_cmd execution and log msgs.

        Args:
            cmd_runner: name of thread doing the cmd

        """
        # set the event for the cmd_runner
        self.cmd_waiting_event_items[cmd_runner].set()

    ####################################################################
    # handle_rem_reg_log_msg
    ####################################################################
    def handle_rem_reg_log_msg(
        self, cmd_runner: str, rem_name: str, process: str, log_msg: str
    ) -> None:
        """Handle the removed from registry log message.

        Args:
            cmd_runner: thread name doing the cmd
            rem_name: thread name that was removed
            process: smart_thread request that was running
            log_msg: removed from registry log message

        """
        pe = self.pending_events[cmd_runner]

        rem_key: RemRegKey = (rem_name, process)

        if pe[PE.rem_reg_msg][rem_key] <= 0:
            raise UnexpectedEvent(
                f"handle_rem_reg_log_msg encountered " f"unexpected log msg: {log_msg}"
            )

        pe[PE.rem_reg_msg][rem_key] -= 1
        self.add_log_msg(re.escape(log_msg))

    ####################################################################
    # handle_add_pair_array_log_msg
    ####################################################################
    def handle_add_pair_array_log_msg(
        self, cmd_runner: str, pair_key: st.PairKey, log_msg: str
    ) -> None:
        """Handle the reg update log msg.

        Args:
            cmd_runner: thread name adding entry to pair key
            pair_key: pair_key added to the pair_array
            log_msg: log message

        """
        pe = self.pending_events[cmd_runner]
        add_key: AddPaKey = (cmd_runner, pair_key)

        if pe[PE.add_pair_array_msg][add_key] <= 0:
            raise UnexpectedEvent(
                f"handle_add_pair_array_log_msg encountered "
                f"unexpected log msg: {log_msg}"
            )

        pe[PE.add_pair_array_msg][add_key] -= 1
        self.add_log_msg(re.escape(log_msg))

    ####################################################################
    # handle_add_reg_log_msg
    ####################################################################
    def handle_add_reg_log_msg(
        self, cmd_runner: str, target: str, log_msg: str
    ) -> None:
        """Handle the reg update log msg.

        Args:
            cmd_runner: name of thread doing the cmd
            target: name of thread added to the registry
            log_msg: register update log message

        """
        pe = self.pending_events[cmd_runner]
        add_key: AddRegKey = (cmd_runner, target)

        if pe[PE.add_reg_msg][add_key] <= 0:
            raise UnexpectedEvent(
                f"handle_add_reg_log_msg using {add_key=} "
                "encountered unexpected "
                f"log msg: {log_msg}"
            )

        pe[PE.add_reg_msg][add_key] -= 1
        self.add_log_msg(re.escape(log_msg))

        if target not in self.expected_registered:
            raise IncorrectDataDetected(
                f"handle_add_reg_log_msg detected {target=} is "
                "missing from expected_registered: "
                f"{self.expected_registered}"
            )

        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]
        state_key: SetStateKey = (
            cmd_runner,
            target,
            st.ThreadState.Initialized,
            st.ThreadState.Registered,
        )
        pe[PE.set_state_msg][state_key] += 1

    ####################################################################
    # handle_add_status_block_log_msg
    ####################################################################
    def handle_add_status_block_log_msg(
        self, cmd_runner: str, pair_key: st.PairKey, target: str, log_msg: str
    ) -> None:
        """Handle the reg update log msg.

        Args:
            cmd_runner: thread name adding entry to pair key
            pair_key: pair_key added to the pair_array
            target: thread name added to status_block
            log_msg: log message

        """
        pe = self.pending_events[cmd_runner]
        add_key: AddStatusBlockKey = (cmd_runner, pair_key, target)

        if pe[PE.add_status_block_msg][add_key] <= 0:
            raise UnexpectedEvent(
                "handle_add_status_block_log_msg using "
                f"{add_key=} encountered unexpected "
                f"log msg: {log_msg}"
            )

        pe[PE.add_status_block_msg][add_key] -= 1
        self.add_log_msg(re.escape(log_msg))

    ####################################################################
    # handle_resume
    ####################################################################
    def handle_resume(
        self,
        cmd_runner: str,
        targets: set[str],
        exp_resumed_targets: set[str],
        stopped_remotes: set[str],
        timeout: IntOrFloat,
        timeout_names: set[str],
        timeout_type: TimeoutType,
        log_msg: Optional[str] = None,
    ) -> None:
        """Resume a waiter.

        Args:
            cmd_runner: thread doing the wait
            targets: names of threads to be resumed
            exp_resumed_targets: thread names that are expected to be
                resumed
            stopped_remotes: threads that are stopped and will result in
                a not alive error being raised
            timeout: timeout value for smart_resume
            timeout_names: names that will cause timeout
            timeout_type: None, False, or True
            log_msg: log msg for smart_resume
        """
        self.log_test_msg(
            f"handle_resume entry: {cmd_runner=}, {targets=}, "
            f"{stopped_remotes=}, {timeout=}, {timeout_names=} "
            f"{timeout_type=}"
        )

        self.log_ver.add_call_seq(
            name="smart_resume",
            seq="test_smart_thread.py::ConfigVerifier.handle_resume",
        )

        pe = self.pending_events[cmd_runner]
        pe[PE.start_request].append(
            StartRequest(
                req_type=st.ReqType.Smart_resume,
                timeout_type=timeout_type,
                targets=targets,
                timeout_remotes=timeout_names,
                stopped_remotes=stopped_remotes.copy(),
                exp_resumed_targets=exp_resumed_targets,
            )
        )

        req_key_entry: RequestKey = ("smart_resume", "entry")

        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ("smart_resume", "exit")

        if stopped_remotes:
            with pytest.raises(st.SmartThreadRemoteThreadNotAlive):
                if timeout_type == TimeoutType.TimeoutNone:
                    self.all_threads[cmd_runner].smart_resume(
                        waiters=targets, log_msg=log_msg
                    )
                else:
                    self.all_threads[cmd_runner].smart_resume(
                        waiters=targets, timeout=timeout, log_msg=log_msg
                    )

            resumed_targets = self.all_threads[cmd_runner].resumed_targets

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request="smart_resume",
                    targets=targets,
                    error_str="SmartThreadRemoteThreadNotAlive",
                    stopped_remotes=stopped_remotes,
                ),
                log_level=logging.ERROR,
            )

        elif timeout_type == TimeoutType.TimeoutNone:
            pe[PE.request_msg][req_key_exit] += 1
            resumed_targets = self.all_threads[cmd_runner].smart_resume(
                waiters=targets, log_msg=log_msg
            )

        elif timeout_type == TimeoutType.TimeoutFalse:
            pe[PE.request_msg][req_key_exit] += 1
            resumed_targets = self.all_threads[cmd_runner].smart_resume(
                waiters=targets, timeout=timeout, log_msg=log_msg
            )

        elif timeout_type == TimeoutType.TimeoutTrue:
            with pytest.raises(st.SmartThreadRequestTimedOut):
                self.all_threads[cmd_runner].smart_resume(
                    waiters=targets, timeout=timeout, log_msg=log_msg
                )

            resumed_targets = self.all_threads[cmd_runner].resumed_targets

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request="smart_resume",
                    targets=targets,
                    error_str="SmartThreadRequestTimedOut",
                    stopped_remotes=stopped_remotes,
                ),
                log_level=logging.ERROR,
            )
        else:
            raise InvalidInputDetected(
                f"handle_resume for {cmd_runner=} " f"detected invalid {timeout_type=}"
            )

        assert exp_resumed_targets == resumed_targets

        self.wait_for_monitor(cmd_runner=cmd_runner, rtn_name="handle_resume")

        self.log_test_msg(f"handle_resume exit: {cmd_runner=}, {targets=}")

    ####################################################################
    # handle_send_msg
    ####################################################################
    def handle_send_msg(
        self,
        cmd_runner: str,
        receivers: set[str],
        exp_receivers: set[str],
        msgs_to_send: SendRecvMsgs,
        msg_idx: int,
        send_type: SendType,
        log_msg: Optional[str] = None,
        timeout_type: TimeoutType = TimeoutType.TimeoutNone,
        timeout: IntOrFloat = 0,
        unreg_timeout_names: Optional[set[str]] = None,
        fullq_timeout_names: Optional[set[str]] = None,
        stopped_remotes: Optional[set[str]] = None,
    ) -> None:
        """Handle the send_cmd execution and log msgs.

        Args:
            cmd_runner: name of thread doing the cmd
            receivers: names of threads to receive the message
            exp_receivers: thread names that are expected to receive
            msgs_to_send: message to send to the receivers
            msg_idx: index to use with msgs_to_send for this call
            send_type: specifies how to send the message
            log_msg: log message for smart_send to issue
            timeout_type: specifies None, False, or True
            timeout: value to use for timeout on the smart_send request
            unreg_timeout_names: names of threads that are unregistered
                and are expected to cause timeout
            fullq_timeout_names: names of threads whose msg_q is full
                and are expected to cause timeout
            stopped_remotes: names of threads that are stopped

        """
        self.log_test_msg(
            f"handle_send entry: {cmd_runner=}, {receivers=}, "
            f"{exp_receivers=}, {send_type=}, {timeout_type=}, "
            f"{unreg_timeout_names=}, {fullq_timeout_names=}, "
            f"{stopped_remotes=}"
        )
        self.log_ver.add_call_seq(
            name="smart_send",
            seq="test_smart_thread.py::ConfigVerifier.handle_send_msg",
        )

        receivers_to_use = receivers.copy()
        timeout_remotes = set()
        if timeout_type == TimeoutType.TimeoutTrue and unreg_timeout_names:
            timeout_remotes |= unreg_timeout_names
        if fullq_timeout_names:
            timeout_remotes |= fullq_timeout_names

        stopped_remotes_copy: set[str]
        if stopped_remotes:
            stopped_remotes_copy = stopped_remotes.copy()
        else:
            stopped_remotes_copy = set()

        pe = self.pending_events[cmd_runner]
        pe[PE.start_request].append(
            StartRequest(
                req_type=st.ReqType.Smart_send,
                timeout_type=timeout_type,
                targets=receivers_to_use,
                timeout_remotes=timeout_remotes,
                stopped_remotes=stopped_remotes_copy,
                exp_receivers=exp_receivers,
            )
        )

        req_key_entry: RequestKey = ("smart_send", "entry")

        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ("smart_send", "exit")

        elapsed_time: float = 0
        start_time = time.time()

        if send_type == SendType.SRMsgs:
            # for a smart_send using the msg_dict option, we need to
            # build a dict from the SendRecvMsgs test messages
            send_msg_dict = msgs_to_send.get_send_msgs(
                sender_name=cmd_runner,
                receiver_names=receivers,
                exp_receivers=exp_receivers,
                msg_idx=msg_idx,
            )
        else:
            send_msg = msgs_to_send.get_broadcast_msg(
                sender_name=cmd_runner, exp_receivers=exp_receivers, msg_idx=msg_idx
            )

        if stopped_remotes:
            with pytest.raises(st.SmartThreadRemoteThreadNotAlive):
                if timeout_type == TimeoutType.TimeoutNone:
                    if send_type == SendType.SRMsgs:
                        self.all_threads[cmd_runner].smart_send(
                            msg_dict=send_msg_dict, log_msg=log_msg
                        )
                    else:
                        self.all_threads[cmd_runner].smart_send(
                            receivers=receivers_to_use, msg=send_msg, log_msg=log_msg
                        )
                else:
                    if send_type == SendType.SRMsgs:
                        self.all_threads[cmd_runner].smart_send(
                            msg_dict=send_msg_dict, timeout=timeout, log_msg=log_msg
                        )
                    else:
                        self.all_threads[cmd_runner].smart_send(
                            receivers=receivers_to_use,
                            msg=send_msg,
                            timeout=timeout,
                            log_msg=log_msg,
                        )
            sent_targets = self.all_threads[cmd_runner].sent_targets

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request="smart_send",
                    targets=receivers_to_use,
                    error_str="SmartThreadRemoteThreadNotAlive",
                    stopped_remotes=stopped_remotes,
                ),
                log_level=logging.ERROR,
            )

        elif timeout_type == TimeoutType.TimeoutNone:
            pe[PE.request_msg][req_key_exit] += 1
            if send_type == SendType.SRMsgs:
                sent_targets = self.all_threads[cmd_runner].smart_send(
                    msg_dict=send_msg_dict, log_msg=log_msg
                )
            else:
                sent_targets = self.all_threads[cmd_runner].smart_send(
                    receivers=receivers_to_use, msg=send_msg, log_msg=log_msg
                )
            elapsed_time += time.time() - start_time
        elif timeout_type == TimeoutType.TimeoutFalse:
            pe[PE.request_msg][req_key_exit] += 1
            if send_type == SendType.SRMsgs:
                sent_targets = self.all_threads[cmd_runner].smart_send(
                    msg_dict=send_msg_dict, timeout=timeout, log_msg=log_msg
                )
            else:
                sent_targets = self.all_threads[cmd_runner].smart_send(
                    receivers=receivers_to_use,
                    msg=send_msg,
                    timeout=timeout,
                    log_msg=log_msg,
                )
            elapsed_time += time.time() - start_time
        elif timeout_type == TimeoutType.TimeoutTrue:
            with pytest.raises(st.SmartThreadRequestTimedOut):
                if send_type == SendType.SRMsgs:
                    self.all_threads[cmd_runner].smart_send(
                        msg_dict=send_msg_dict, timeout=timeout, log_msg=log_msg
                    )
                else:
                    self.all_threads[cmd_runner].smart_send(
                        receivers=receivers_to_use,
                        msg=send_msg,
                        timeout=timeout,
                        log_msg=log_msg,
                    )
            elapsed_time += time.time() - start_time

            sent_targets = self.all_threads[cmd_runner].sent_targets

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request="smart_send",
                    targets=receivers_to_use,
                    error_str="SmartThreadRequestTimedOut",
                    full_send_q_remotes=fullq_timeout_names,
                ),
                log_level=logging.ERROR,
            )

        assert sent_targets == exp_receivers

        mean_elapsed_time = elapsed_time / len(receivers)
        self.log_test_msg(
            f"handle_send exit: {cmd_runner=} "
            f"{elapsed_time=}, {len(receivers)=} "
            f"{mean_elapsed_time=}"
        )

    ####################################################################
    # handle_set_state_log_msg
    ####################################################################
    def handle_set_state_log_msg(
        self,
        cmd_runner: str,
        target: str,
        from_state: st.ThreadState,
        to_state: st.ThreadState,
        log_msg: str,
    ) -> None:
        """Handle the set state log msgs.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name whose state is being changed
            from_state: state being changed from
            to_state: ste being changed to
            log_msg: log message that is being processed

        Raises:
            UnexpectedEvent: handle_set_state_log_msg encountered
                unexpected log msg
            IncorrectDataDetected: handle_set_state_log_msg detected
                target_rtn is missing from expected_registered or
                current state does not match
        """
        pe = self.pending_events[cmd_runner]
        state_key: SetStateKey = (cmd_runner, target, from_state, to_state)
        if pe[PE.set_state_msg][state_key] <= 0:
            raise UnexpectedEvent(
                "handle_set_state_log_msg using "
                f"{state_key=} encountered "
                f"unexpected log msg: {log_msg}"
            )

        pe[PE.set_state_msg][state_key] -= 1
        self.add_log_msg(re.escape(log_msg))

        if to_state != st.ThreadState.Unregistered:
            if target not in self.expected_registered:
                raise IncorrectDataDetected(
                    f"handle_set_state_log_msg detected {target=} is "
                    "missing from expected_registered: "
                    f"{self.expected_registered}"
                )

            if self.expected_registered[target].st_state != from_state:
                raise IncorrectDataDetected(
                    "handle_set_state_log_msg detected current state "
                    f"{self.expected_registered[target].st_state=} "
                    f"does not match {from_state=} for {target=}"
                )

            # looks good, set new state
            self.expected_registered[target].st_state = to_state

        ################################################################
        # Determine next action
        ################################################################
        ################################################################
        # call handler for request
        ################################################################
        actions: dict[tuple[st.ThreadState, st.ThreadState], Callable[..., None]] = {
            # (st.ThreadState.Unregistered, st.ThreadState.Initialized):
            #     self.handle_set_state_unreg_to_init,
            (
                st.ThreadState.Initialized,
                st.ThreadState.Registered,
            ): self.handle_set_state_init_to_reg,
            (
                st.ThreadState.Registered,
                st.ThreadState.Alive,
            ): self.handle_set_state_reg_to_alive,
            (
                st.ThreadState.Alive,
                st.ThreadState.Stopped,
            ): self.handle_set_state_alive_to_stop,
            (
                st.ThreadState.Registered,
                st.ThreadState.Unregistered,
            ): self.handle_set_state_reg_to_unreg,
            (
                st.ThreadState.Stopped,
                st.ThreadState.Unregistered,
            ): self.handle_set_state_stop_to_unreg,
        }

        actions[(from_state, to_state)](cmd_runner=cmd_runner, target=target)

    ####################################################################
    # handle_set_state_unreg_to_init
    ####################################################################
    def handle_set_state_unreg_to_init(self, cmd_runner: str, target: str) -> None:
        """Determine next step for set state.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name getting its state changed

        """
        ################################################################
        # next step is register
        ################################################################
        pass

    ####################################################################
    # handle_set_state_init_to_reg
    ####################################################################
    def handle_set_state_init_to_reg(self, cmd_runner: str, target: str) -> None:
        """Determine next step for set state.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name getting its state changed

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]
        if self.expected_registered[target].exp_init_is_alive:
            key: SetStateKey = (
                cmd_runner,
                target,
                st.ThreadState.Registered,
                st.ThreadState.Alive,
            )
            pe[PE.set_state_msg][key] += 1
        # else:  # skip the reg to alive msg, proceed to reg add
        sub_key: SubProcessKey = (
            cmd_runner,
            "smart_init",
            "_add_to_pair_array",
            "entry",
            target,
        )
        pe[PE.subprocess_msg][sub_key] += 1

    ####################################################################
    # handle_set_state_reg_to_start
    ####################################################################
    def handle_set_state_reg_to_start(self, cmd_runner: str, target: str) -> None:
        """Determine next step for set state.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name getting its state changed

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_set_state_reg_to_alive
    ####################################################################
    def handle_set_state_reg_to_alive(self, cmd_runner: str, target: str) -> None:
        """Determine next step for set state.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name getting its state changed

        """
        self.expected_registered[target].is_alive = True

        ################################################################
        # next step is to add entry to pair array
        ################################################################
        pe = self.pending_events[cmd_runner]
        if pe[PE.current_request].req_type == st.ReqType.Smart_start:
            pe[PE.num_targets_remaining] -= 1

    ####################################################################
    # handle_set_state_start_to_alive
    ####################################################################
    def handle_set_state_start_to_alive(self, cmd_runner: str, target: str) -> None:
        """Determine next step for set state.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name getting its state changed

        """
        self.expected_registered[target].is_alive = True

        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]
        pe[PE.num_targets_remaining] -= 1

    ####################################################################
    # handle_set_state_reg_to_unregistering
    ####################################################################
    def handle_set_state_reg_to_unregistering(
        self, cmd_runner: str, target: str
    ) -> None:
        """Determine next step for set state.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name getting its state changed

        """
        pass

    ####################################################################
    # handle_set_state_reg_to_unreg
    ####################################################################
    def handle_set_state_reg_to_unreg(self, cmd_runner: str, target: str) -> None:
        """Determine next step for set state.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name getting its state changed

        """
        pass

    ####################################################################
    # handle_set_state_alive_to_stop
    ####################################################################
    def handle_set_state_alive_to_stop(self, cmd_runner: str, target: str) -> None:
        """Determine next step for set state.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name getting its state changed

        """
        self.expected_registered[target].is_alive = False

    ####################################################################
    # handle_set_state_alive_to_stop
    ####################################################################
    def handle_set_state_stop_to_unreging(self, cmd_runner: str, target: str) -> None:
        """Determine next step for set state.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name getting its state changed

        """
        pass

    ####################################################################
    # handle_set_state_alive_to_stop
    ####################################################################
    def handle_set_state_stop_to_unreg(self, cmd_runner: str, target: str) -> None:
        """Determine next step for set state.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name getting its state changed

        """
        pass

    ####################################################################
    # handle_set_state_alive_to_stop
    ####################################################################
    def handle_set_state_unreging_to_unreg(self, cmd_runner: str, target: str) -> None:
        """Determine next step for set state.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name getting its state changed

        """
        pass

    ####################################################################
    # handle_start
    ####################################################################
    def handle_start(
        self,
        cmd_runner: str,
        start_names: set[str],
        unreg_remotes: Optional[set[str]] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Start the named thread.

        Args:
            cmd_runner: thread doing the starts
            start_names: names of the threads to start
            unreg_remotes: names of threads that are not in the
                registered state
            log_msg: message for log
        """
        self.log_test_msg(f"{cmd_runner=} handle_start entry " f"for {start_names=}")

        self.log_ver.add_call_seq(
            name="smart_start", seq="test_smart_thread.py::ConfigVerifier.handle_start"
        )

        if unreg_remotes:
            not_reg_remotes = unreg_remotes
        else:
            not_reg_remotes = set()

        pe = self.pending_events[cmd_runner]
        pe[PE.start_request].append(
            StartRequest(
                req_type=st.ReqType.Smart_start,
                targets=start_names,
                unreg_remotes=set(),
                not_registered_remotes=not_reg_remotes,
                timeout_remotes=set(),
                stopped_remotes=set(),
                deadlock_remotes=set(),
                eligible_targets=set(),
                completed_targets=set(),
                first_round_completed=set(),
                stopped_target_threads=set(),
                exp_senders=set(),
                exp_resumers=set(),
            )
        )

        req_key_entry: RequestKey = ("smart_start", "entry")

        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ("smart_start", "exit")

        exp_started_names = start_names.copy()
        # enter_exit = ('entry', 'exit')
        if unreg_remotes:
            exp_started_names -= unreg_remotes
            # enter_exit = ('entry',)
            with pytest.raises(st.SmartThreadRemoteThreadNotRegistered):
                self.all_threads[cmd_runner].smart_start(
                    targets=start_names, log_msg=log_msg
                )

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request="smart_start",
                    targets=start_names,
                    error_str="SmartThreadRemoteThreadNotRegistered",
                    unreg_remotes=unreg_remotes,
                ),
                log_level=logging.ERROR,
            )
        else:
            pe[PE.request_msg][req_key_exit] += 1
            self.all_threads[cmd_runner].smart_start(
                targets=start_names, log_msg=log_msg
            )

        self.monitor_event.set()
        if exp_started_names:
            self.wait_for_monitor(cmd_runner=cmd_runner, rtn_name="handle_start")

        self.log_test_msg(f"{cmd_runner=} handle_start exiting " f"for {start_names=}")

    ####################################################################
    # handle_subprocess_entry_exit_log_msg
    ####################################################################
    def handle_subprocess_entry_exit_log_msg(
        self,
        cmd_runner: str,
        request_name: str,
        subprocess_name: str,
        entry_exit: str,
        target: str,
        log_msg: str,
    ) -> None:
        """Handle the subprocess message for a request.

        Args:
            cmd_runner: thread name doing the request
            request_name: request that is calling subprocess
            subprocess_name: subprocess being done
            entry_exit: specifies whether entry or exit of subprocess
            target: thread name of smart_thread
            log_msg: entry or exit log message for subprocess

        """
        pe = self.pending_events[cmd_runner]
        sub_key: SubProcessKey = (
            cmd_runner,
            request_name,
            subprocess_name,
            entry_exit,
            target,
        )
        if pe[PE.subprocess_msg][sub_key] <= 0:
            error_msg = (
                f"handle_subprocess_entry_exit_log_msg using {sub_key=}, "
                f"{pe[PE.subprocess_msg]=}, "
                f"encountered unexpected log msg: {log_msg}"
            )
            self.log_test_msg(error_msg)
            self.abort_all_f1_threads()
            raise UnexpectedEvent(error_msg)

        pe[PE.subprocess_msg][sub_key] -= 1
        self.add_log_msg(re.escape(log_msg))

        ################################################################
        # call handler for subprocess
        ################################################################
        actions: dict[tuple[str, str], Callable[..., None]] = {
            ("_register", "entry"): self.handle_subprocess_register_entry,
            ("_register", "exit"): self.handle_subprocess_register_exit,
            ("_clean_registry", "entry"): self.handle_subprocess_clean_registry_entry,
            ("_clean_registry", "exit"): self.handle_subprocess_clean_registry_exit,
            (
                "_clean_pair_array",
                "entry",
            ): self.handle_subprocess_clean_pair_array_entry,
            ("_clean_pair_array", "exit"): self.handle_subprocess_clean_pair_array_exit,
            (
                "_add_to_pair_array",
                "entry",
            ): self.handle_subprocess_add_to_pair_array_entry,
            (
                "_add_to_pair_array",
                "exit",
            ): self.handle_subprocess_add_to_pair_array_exit,
        }

        actions[(subprocess_name, entry_exit)](
            cmd_runner=cmd_runner, request_name=request_name, target=target
        )

    ####################################################################
    # handle_subprocess_register_entry
    ####################################################################
    def handle_subprocess_register_entry(
        self, cmd_runner: str, request_name: str, target: str
    ) -> None:
        """Handle the subprocess entry for a request.

        Args:
            cmd_runner: thread name doing the request
            request_name: request that is calling subprocess
            target: thread name of smart_thread

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_subprocess_register_exit
    ####################################################################
    def handle_subprocess_register_exit(
        self, cmd_runner: str, request_name: str, target: str
    ) -> None:
        """Handle the subprocess exit for a request.

        Args:
            cmd_runner: thread name doing the request
            request_name: request that is calling subprocess
            target: thread name of smart_thread

        """
        ################################################################
        # determine next step
        ################################################################
        pass
        # pe = self.pending_events[cmd_runner]
        #
        # if (
        #     self.expected_registered[target].auto_start_decision
        #     == AutoStartDecision.auto_start_yes
        # ):
        #     pe[PE.save_current_request] = pe[PE.current_request]
        #     pe[PE.start_request].append(
        #         StartRequest(
        #             req_type=st.ReqType.Smart_start,
        #             targets={target},
        #             unreg_remotes=set(),
        #             not_registered_remotes=set(),
        #             timeout_remotes=set(),
        #             stopped_remotes=set(),
        #             deadlock_remotes=set(),
        #             eligible_targets=set(),
        #             completed_targets=set(),
        #             first_round_completed=set(),
        #             stopped_target_threads=set(),
        #             exp_senders=set(),
        #             exp_resumers=set(),
        #         )
        #     )
        #
        #     req_key_entry: RequestKey = ("smart_start", "entry")
        #
        #     pe[PE.request_msg][req_key_entry] += 1
        #
        #     req_key_exit: RequestKey = ("smart_start", "exit")
        #
        #     pe[PE.request_msg][req_key_exit] += 1

    ####################################################################
    # handle_subprocess_clean_registry_entry
    ####################################################################
    def handle_subprocess_clean_registry_entry(
        self, cmd_runner: str, request_name: str, target: str
    ) -> None:
        """Handle the subprocess entry for a request.

        Args:
            cmd_runner: thread name doing the request
            request_name: request that is calling subprocess
            target: thread name of smart_thread

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]

        self.clean_registry(cmd_runner=cmd_runner, target=target)

        sub_key: SubProcessKey = (
            cmd_runner,
            request_name,
            "_clean_registry",
            "exit",
            cmd_runner,
        )
        pe[PE.subprocess_msg][sub_key] += 1

    ####################################################################
    # handle_subprocess_clean_registry_exit
    ####################################################################
    def handle_subprocess_clean_registry_exit(
        self, cmd_runner: str, request_name: str, target: str
    ) -> None:
        """Handle the subprocess exit for a request.

        Args:
            cmd_runner: thread name doing the request
            request_name: request that is calling subprocess
            target: thread name of smart_thread

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_subprocess_clean_pair_array_entry
    ####################################################################
    def handle_subprocess_clean_pair_array_entry(
        self, cmd_runner: str, request_name: str, target: str
    ) -> None:
        """Handle the subprocess entry for a request.

        Args:
            cmd_runner: thread name doing the request
            request_name: request that is calling subprocess
            target: thread name of smart_thread

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]
        # if commander is initializing, pair array is empty

        if not (
            request_name == "smart_init"
            and self.commander_name in pe[PE.current_request].targets
        ):
            self.clean_pair_array(cmd_runner=cmd_runner)

        sub_key: SubProcessKey = (
            cmd_runner,
            request_name,
            "_clean_pair_array",
            "exit",
            cmd_runner,
        )
        pe[PE.subprocess_msg][sub_key] += 1

    ####################################################################
    # handle_subprocess_clean_pair_array_exit
    ####################################################################
    def handle_subprocess_clean_pair_array_exit(
        self, cmd_runner: str, request_name: str, target: str
    ) -> None:
        """Handle the subprocess exit for a request.

        Args:
            cmd_runner: thread name doing the request
            request_name: request that is calling subprocess
            target: thread name of smart_thread

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_subprocess_add_to_pair_array_entry
    ####################################################################
    def handle_subprocess_add_to_pair_array_entry(
        self, cmd_runner: str, request_name: str, target: str
    ) -> None:
        """Handle the subprocess entry for a request.

        Args:
            cmd_runner: thread name doing the request
            request_name: request that is calling subprocess
            target: thread name of smart_thread

        """
        pe = self.pending_events[cmd_runner]
        # add_to_pair_array returns true if pair array was updated
        if self.add_to_pair_array(cmd_runner=cmd_runner, add_name=target):
            pe[PE.update_pair_array_utc_msg] += 1
            self.log_test_msg(
                f"handle_subprocess_add_to_pair_array_entry "
                f"for {cmd_runner=}, {target=} "
                f"bumped {pe[PE.update_pair_array_utc_msg]=}"
            )

        ################################################################
        # determine next step
        ################################################################

        sub_key: SubProcessKey = (
            cmd_runner,
            request_name,
            "_add_to_pair_array",
            "exit",
            target,
        )
        pe[PE.subprocess_msg][sub_key] += 1

    ####################################################################
    # handle_subprocess_add_to_pair_array_exit
    ####################################################################
    def handle_subprocess_add_to_pair_array_exit(
        self, cmd_runner: str, request_name: str, target: str
    ) -> None:
        """Handle the subprocess exit for a request.

        Args:
            cmd_runner: thread name doing the request
            request_name: request that is calling subprocess
            target: thread name of smart_thread

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]
        sub_key: SubProcessKey = (cmd_runner, request_name, "_register", "exit", target)
        pe[PE.subprocess_msg][sub_key] += 1

    ####################################################################
    # wait_for_monitor
    ####################################################################
    def wait_for_monitor(self, cmd_runner: str, rtn_name: str) -> None:
        """Start the named thread.

        Args:
            cmd_runner: thread doing the starts
            rtn_name: name of rtn that will wait

        """
        with self.ops_lock:
            self.cmd_waiting_event_items[cmd_runner] = threading.Event()
        self.log_test_msg(f"{cmd_runner=} {rtn_name} waiting for monitor")
        self.monitor_event.set()
        if self.cmd_waiting_event_items[cmd_runner].wait(timeout=60):
            with self.ops_lock:
                del self.cmd_waiting_event_items[cmd_runner]
        else:
            self.abort_all_f1_threads()
            raise CmdTimedOut(
                f"wait_for_monitor timed out for {cmd_runner=} " f"and {rtn_name=}"
            )

    ####################################################################
    # handle_stopped_log_msg
    ####################################################################
    def handle_stopped_log_msg(
        self, cmd_runner: str, stopped_name: str, log_idx: int
    ) -> None:
        """Set the status for a thread that was stopped.

        Args:
            cmd_runner: the names of the thread that did the stop
            stopped_name: name of thread that was stopped
            log_idx: index of stopped log msg

        """
        with self.ops_lock:
            self.recently_stopped[stopped_name] = log_idx
            if stopped_name in self.expected_registered:
                self.expected_registered[stopped_name].is_alive = False
            self.stopped_event_items[cmd_runner].targets.remove(stopped_name)
            if not self.stopped_event_items[cmd_runner].targets:
                self.stopped_event_items[cmd_runner].client_event.set()

    ####################################################################
    # handle_sync
    ####################################################################
    def handle_sync(
        self,
        cmd_runner: str,
        targets: set[str],
        timeout: IntOrFloat,
        timeout_remotes: set[str],
        stopped_remotes: set[str],
        deadlock_remotes: set[str],
        sync_set_ack_remotes: set[str],
        timeout_type: TimeoutType,
        log_msg: Optional[str] = None,
    ) -> None:
        """Issue smart_sync.

        Args:
            cmd_runner: the names of the thread that did the stop
            targets: name of remotes to sync with
            timeout: value to use for timeout
            timeout_remotes: names of threads that cause timeout
            stopped_remotes: remotes that will cause a not alive error
            deadlock_remotes: remotes that are doing a recv or wait
                instead of a sync which will cause a deadlock
            sync_set_ack_remotes: thread names that will get the first
                sync set ack message (but may or may not get the
                achieved sync ack if they fail to respond for timeout or
                stopped scenarios)
            timeout_type: specifies whether timeout is None, False, or
                True
            log_msg: log msg to be specified with the sync request
        """
        self.log_test_msg(
            f"{cmd_runner=} handle_sync entry for "
            f"{targets=}, {timeout_type=}, {timeout_remotes=}, "
            f"{stopped_remotes=}, {deadlock_remotes=}"
        )

        self.log_ver.add_call_seq(
            name="smart_sync", seq="test_smart_thread.py::ConfigVerifier.handle_sync"
        )

        pe = self.pending_events[cmd_runner]
        pe[PE.start_request].append(
            StartRequest(
                req_type=st.ReqType.Smart_sync,
                timeout_type=timeout_type,
                targets=targets,
                timeout_remotes=timeout_remotes,
                stopped_remotes=stopped_remotes.copy(),
                deadlock_remotes=deadlock_remotes,
                sync_set_ack_remotes=sync_set_ack_remotes,
            )
        )

        req_key_entry: RequestKey = ("smart_sync", "entry")
        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ("smart_sync", "exit")

        exp_completed_syncs: set[str] = targets.copy()

        if stopped_remotes:
            exp_completed_syncs -= stopped_remotes
            exp_completed_syncs -= timeout_remotes
            exp_completed_syncs -= deadlock_remotes
            with pytest.raises(st.SmartThreadRemoteThreadNotAlive):
                if timeout_type == TimeoutType.TimeoutNone:
                    self.all_threads[cmd_runner].smart_sync(
                        targets=targets, log_msg=log_msg
                    )
                else:
                    self.all_threads[cmd_runner].smart_sync(
                        targets=targets, timeout=timeout, log_msg=log_msg
                    )

            synced_targets = self.all_threads[cmd_runner].synced_targets

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request="smart_sync",
                    targets=targets,
                    error_str="SmartThreadRemoteThreadNotAlive",
                    stopped_remotes=stopped_remotes,
                    deadlock_remotes=deadlock_remotes,
                ),
                log_level=logging.ERROR,
            )

        elif deadlock_remotes:
            exp_completed_syncs -= timeout_remotes
            exp_completed_syncs -= deadlock_remotes
            with pytest.raises(st.SmartThreadDeadlockDetected):
                if timeout_type == TimeoutType.TimeoutNone:
                    self.all_threads[cmd_runner].smart_sync(
                        targets=targets, log_msg=log_msg
                    )
                else:
                    self.all_threads[cmd_runner].smart_sync(
                        targets=targets, timeout=timeout, log_msg=log_msg
                    )

            synced_targets = self.all_threads[cmd_runner].synced_targets

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request="smart_sync",
                    targets=targets,
                    error_str="SmartThreadDeadlockDetected",
                    stopped_remotes=stopped_remotes,
                    deadlock_remotes=deadlock_remotes,
                ),
                log_level=logging.ERROR,
            )

        elif timeout_type == TimeoutType.TimeoutNone:
            pe[PE.request_msg][req_key_exit] += 1
            synced_targets = self.all_threads[cmd_runner].smart_sync(
                targets=targets, log_msg=log_msg
            )

        elif timeout_type == TimeoutType.TimeoutFalse:
            pe[PE.request_msg][req_key_exit] += 1
            synced_targets = self.all_threads[cmd_runner].smart_sync(
                targets=targets, timeout=timeout, log_msg=log_msg
            )

        elif timeout_type == TimeoutType.TimeoutTrue:
            exp_completed_syncs -= timeout_remotes
            with pytest.raises(st.SmartThreadRequestTimedOut):
                self.all_threads[cmd_runner].smart_sync(
                    targets=targets, timeout=timeout, log_msg=log_msg
                )

            synced_targets = self.all_threads[cmd_runner].synced_targets

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request="smart_sync",
                    targets=targets,
                    error_str="SmartThreadRequestTimedOut",
                    stopped_remotes=stopped_remotes,
                    deadlock_remotes=deadlock_remotes,
                ),
                log_level=logging.ERROR,
            )

        if not (self.auto_sync_ach_or_back_msg and stopped_remotes):
            assert exp_completed_syncs == synced_targets

        self.monitor_event.set()

        if exp_completed_syncs:
            self.wait_for_monitor(cmd_runner=cmd_runner, rtn_name="handle_sync")

        self.log_test_msg(f"{cmd_runner=} handle_sync exit for " f"{targets=}")

    ####################################################################
    # get_timeout_msg
    ####################################################################
    @staticmethod
    def get_error_msg(
        cmd_runner: str,
        smart_request: str,
        targets: set[str],
        error_str: str,
        stopped_remotes: Optional[set[str]] = None,
        unreg_remotes: Optional[set[str]] = None,
        deadlock_remotes: Optional[set[str]] = None,
        full_send_q_remotes: Optional[set[str]] = None,
    ) -> str:
        """Build the timeout message.

        Args:
            cmd_runner: thread doing the request
            smart_request: name of smart_request
            targets: target_rtn of the smart request
            error_str: smart_thread error as string
            stopped_remotes: names of threads that are stopped
            unreg_remotes: names of threads that are not registered
            deadlock_remotes: names of wait/wait deadlock threads
            full_send_q_remotes: names threads whose send_q is full

        Returns:
            error msg string for log and raise

        """
        targets_msg = re.escape(
            f"while processing a {smart_request} "
            f"request with targets "
            f"{sorted(targets)}."
        )

        pending_msg = r" Remotes that are pending: \[([a-z0-9_]*|,|'| )*\]."

        if stopped_remotes:
            sp_search = r"\[(,| "
            for name in stopped_remotes:
                sp_search += "|'" + name + "'"
            sp_search += r")+\]"
            stopped_msg = f" Remotes that are stopped: " f"{sp_search}."
        else:
            stopped_msg = ""

        if unreg_remotes:
            unreg_msg = re.escape(
                " Remotes that are not registered: " f"{sorted(unreg_remotes)}."
            )
        else:
            unreg_msg = ""

        if deadlock_remotes:
            dr_search = r"\[(,| "
            for name in deadlock_remotes:
                dr_search += "|'" + name + "'"
            dr_search += r")+\]"
            deadlock_msg = f" Remotes that are deadlocked: " f"{dr_search}."
        else:
            deadlock_msg = ""

        if full_send_q_remotes:
            full_send_q_msg = re.escape(
                f" Remotes that have a full send_q: " f"{sorted(full_send_q_remotes)}."
            )
        else:
            full_send_q_msg = ""

        return (
            rf"SmartThread {cmd_runner} \(test1\) raising {error_str} {targets_msg}"
            f"{pending_msg}{stopped_msg}{unreg_msg}"
            f"{deadlock_msg}{full_send_q_msg}"
        )

    ####################################################################
    # handle_unregister
    ####################################################################
    def handle_unregister(
        self,
        cmd_runner: str,
        unregister_targets: set[str],
        not_registered_remotes: set[str],
        log_msg: Optional[str] = None,
    ) -> None:
        """Unregister the named threads.

        Args:
            cmd_runner: name of thread doing the smart_unreg
            unregister_targets: names of threads to be unregistered
            not_registered_remotes: thread names that are not is
                registered state
            log_msg: log msg for the smart_unreg request

        """
        self.log_test_msg(
            f"handle_unregister entry for {cmd_runner=}, " f"{unregister_targets=}"
        )

        self.log_ver.add_call_seq(
            name="smart_unreg",
            seq="test_smart_thread.py::ConfigVerifier.handle_unregister",
        )

        pe = self.pending_events[cmd_runner]

        pe[PE.start_request].append(
            StartRequest(
                req_type=st.ReqType.Smart_unreg,
                targets=unregister_targets.copy(),
                unreg_remotes=set(),
                not_registered_remotes=not_registered_remotes.copy(),
                timeout_remotes=set(),
                stopped_remotes=set(),
                deadlock_remotes=set(),
                eligible_targets=set(),
                completed_targets=set(),
                first_round_completed=set(),
                stopped_target_threads=set(),
                exp_senders=set(),
                exp_resumers=set(),
            )
        )

        req_key_entry: RequestKey = ("smart_unreg", "entry")
        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ("smart_unreg", "exit")

        # enter_exit = ('entry', 'exit')
        if not_registered_remotes:
            # enter_exit = ('entry',)
            with pytest.raises(st.SmartThreadRemoteThreadNotRegistered):
                self.all_threads[cmd_runner].smart_unreg(
                    targets=unregister_targets, log_msg=log_msg
                )

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request="smart_unreg",
                    targets=unregister_targets,
                    error_str="SmartThreadRemoteThreadNotRegistered",
                    unreg_remotes=not_registered_remotes,
                ),
                log_level=logging.ERROR,
            )

        else:
            pe[PE.request_msg][req_key_exit] += 1
            self.all_threads[cmd_runner].smart_unreg(
                targets=unregister_targets, log_msg=log_msg
            )

        self.monitor_event.set()

        with self.ops_lock:
            self.cmd_waiting_event_items[cmd_runner] = threading.Event()

        self.log_test_msg(f"{cmd_runner=} handle_unregister waiting for " f"monitor")

        self.cmd_waiting_event_items[cmd_runner].wait()
        with self.ops_lock:
            del self.cmd_waiting_event_items[cmd_runner]

        self.log_test_msg(f"handle_unregister exiting: {cmd_runner=}")

    ####################################################################
    # handle_wait
    ####################################################################
    def handle_wait(
        self,
        cmd_runner: str,
        resumers: set[str],
        exp_resumers: set[str],
        timeout: IntOrFloat,
        timeout_remotes: set[str],
        stopped_remotes: set[str],
        deadlock_remotes: set[str],
        deadlock_or_timeout: bool,
        timeout_type: TimeoutType,
        resumer_count: Optional[int] = None,
        log_msg: Optional[str] = None,
    ) -> None:
        """Wait for a resume.

        Args:
            cmd_runner: thread doing the wait
            resumers: threads doing the resume
            exp_resumers: thread names of resumers that the wait will
                determine did a resume
            timeout: value to use on smart_wait timeout arg
            timeout_remotes: names of threads that will cause timeout
            stopped_remotes: names of thread that will cause not_alive
            deadlock_remotes: names of threads that will cause deadlock
            deadlock_or_timeout: expect deadlock or timeout
            timeout_type: specifies None, False, or True
            resumer_count: number of resumes needed to satisfy
                smart_wait
            log_msg: optional log message to specify on the smart_wait

        """
        self.log_test_msg(
            f"handle_wait entry for {cmd_runner=}, {resumers=}, "
            f"{resumer_count=}, {stopped_remotes=}, "
            f"{timeout_remotes=}, {deadlock_remotes=}"
        )

        self.log_ver.add_call_seq(
            name="smart_wait", seq="test_smart_thread.py::ConfigVerifier.handle_wait"
        )

        pe = self.pending_events[cmd_runner]
        pe[PE.start_request].append(
            StartRequest(
                req_type=st.ReqType.Smart_wait,
                timeout_type=timeout_type,
                targets=resumers,
                timeout_remotes=timeout_remotes.copy(),
                stopped_remotes=stopped_remotes.copy(),
                deadlock_remotes=deadlock_remotes.copy(),
                exp_resumers=exp_resumers,
            )
        )

        req_key_entry: RequestKey = ("smart_wait", "entry")
        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ("smart_wait", "exit")

        exp_completed_resumers: set[str] = resumers.copy()

        if timeout_remotes:
            exp_completed_resumers -= timeout_remotes

        if deadlock_remotes:
            exp_completed_resumers -= deadlock_remotes

        if stopped_remotes:
            exp_completed_resumers -= stopped_remotes

        resumed_by: set[str] = set()
        if stopped_remotes:
            with pytest.raises(st.SmartThreadRemoteThreadNotAlive):
                if timeout_type == TimeoutType.TimeoutNone:
                    self.all_threads[cmd_runner].smart_wait(
                        resumers=resumers, resumer_count=resumer_count, log_msg=log_msg
                    )
                else:
                    self.all_threads[cmd_runner].smart_wait(
                        resumers=resumers,
                        resumer_count=resumer_count,
                        timeout=timeout,
                        log_msg=log_msg,
                    )

            resumed_by = self.all_threads[cmd_runner].resumed_by

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request="smart_wait",
                    targets=resumers,
                    error_str="SmartThreadRemoteThreadNotAlive",
                    stopped_remotes=stopped_remotes,
                    deadlock_remotes=deadlock_remotes,
                ),
                log_level=logging.ERROR,
            )

        elif deadlock_remotes:
            if deadlock_or_timeout:
                expected_exceptions = (
                    st.SmartThreadDeadlockDetected,
                    st.SmartThreadRequestTimedOut,
                )
            else:
                expected_exceptions = st.SmartThreadDeadlockDetected
            with pytest.raises(expected_exceptions):
                if timeout_type == TimeoutType.TimeoutNone:
                    self.all_threads[cmd_runner].smart_wait(
                        resumers=resumers, resumer_count=resumer_count, log_msg=log_msg
                    )
                else:
                    self.all_threads[cmd_runner].smart_wait(
                        resumers=resumers,
                        resumer_count=resumer_count,
                        timeout=timeout,
                        log_msg=log_msg,
                    )

            resumed_by = self.all_threads[cmd_runner].resumed_by

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request="smart_wait",
                    targets=resumers,
                    error_str="SmartThreadDeadlockDetected",
                    stopped_remotes=stopped_remotes,
                    deadlock_remotes=deadlock_remotes,
                ),
                log_level=logging.ERROR,
            )

        elif timeout_type == TimeoutType.TimeoutNone:
            pe[PE.request_msg][req_key_exit] += 1
            resumed_by = self.all_threads[cmd_runner].smart_wait(
                resumers=resumers, resumer_count=resumer_count, log_msg=log_msg
            )

        elif timeout_type == TimeoutType.TimeoutFalse:
            pe[PE.request_msg][req_key_exit] += 1
            resumed_by = self.all_threads[cmd_runner].smart_wait(
                resumers=resumers,
                resumer_count=resumer_count,
                timeout=timeout,
                log_msg=log_msg,
            )

        elif timeout_type == TimeoutType.TimeoutTrue:
            # enter_exit = ('entry',)
            with pytest.raises(st.SmartThreadRequestTimedOut):
                self.all_threads[cmd_runner].smart_wait(
                    resumers=resumers,
                    resumer_count=resumer_count,
                    timeout=timeout,
                    log_msg=log_msg,
                )

            resumed_by = self.all_threads[cmd_runner].resumed_by

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request="smart_wait",
                    targets=resumers,
                    error_str="SmartThreadRequestTimedOut",
                    stopped_remotes=stopped_remotes,
                    deadlock_remotes=deadlock_remotes,
                ),
                log_level=logging.ERROR,
            )

        assert resumed_by == exp_resumers

        if exp_resumers:
            self.wait_for_monitor(cmd_runner=cmd_runner, rtn_name="handle_wait")

        self.log_test_msg(
            f"handle_wait exit for {cmd_runner=}, " f"{resumers=}, {stopped_remotes=}"
        )

    ####################################################################
    # lock_obtain
    ####################################################################
    def lock_obtain(self) -> None:
        """Obtain the registry lock exclusive."""
        st.SmartThread._registry[self.group_name].registry_lock.obtain_excl(timeout=60)

    ####################################################################
    # lock_release
    ####################################################################
    def lock_release(self) -> None:
        """Increment the pending operations count."""
        st.SmartThread._registry[self.group_name].registry_lock.release()

    ####################################################################
    # lock_swap
    ####################################################################
    def lock_swap(self, cmd_runner: str, new_positions: list[str]) -> None:
        """Increment the pending operations count.

        Args:
            cmd_runner: thread name doing the cmd
            new_positions: the desired positions on the lock queue
        """
        assert len(new_positions) == len(
            st.SmartThread._registry[self.group_name].registry_lock.owner_wait_q
        )
        with self.ops_lock:
            for idx, pos_name in enumerate(new_positions):
                search_thread = (
                    st.SmartThread._registry[self.group_name]
                    .registry_lock.owner_wait_q[idx]
                    .thread
                )
                test_name = self.get_smart_thread_name(
                    search_thread=search_thread, group_name="test1"
                )
                if test_name != pos_name:
                    save_pos = st.SmartThread._registry[
                        self.group_name
                    ].registry_lock.owner_wait_q[idx]
                    # find our desired position
                    new_pos = None
                    for idx2 in range(
                        len(
                            st.SmartThread._registry[
                                self.group_name
                            ].registry_lock.owner_wait_q
                        )
                    ):
                        search_thread = (
                            st.SmartThread._registry[self.group_name]
                            .registry_lock.owner_wait_q[idx2]
                            .thread
                        )
                        test_name = self.get_smart_thread_name(
                            search_thread=search_thread, group_name="test1"
                        )
                        if test_name == pos_name:
                            new_pos = st.SmartThread._registry[
                                self.group_name
                            ].registry_lock.owner_wait_q[idx2]
                            break
                    assert new_pos is not None
                    st.SmartThread._registry[
                        self.group_name
                    ].registry_lock.owner_wait_q[idx] = new_pos
                    st.SmartThread._registry[
                        self.group_name
                    ].registry_lock.owner_wait_q[idx2] = save_pos

    ####################################################################
    # get_smart_thread_name
    ####################################################################
    @staticmethod
    def get_smart_thread_name(
        search_thread: threading.Thread,
        group_name: str,
    ) -> str:
        """Get the smart thread for the search thread or None.

        Args:
            search_thread: thread to search for
            group_name: name of group to search

        Returns:
             A list (possibly empty) of SmartThread instances that are
                 associated with the input search_thread.

        Note:
            The lock registry must be held excl or shared
        """
        if group_name in st.SmartThread._registry:
            for name, smart_thread in st.SmartThread._registry[
                group_name
            ].registry.items():
                if smart_thread.thread is search_thread:
                    return smart_thread.name

        return ""

    ####################################################################
    # lock_verify
    ####################################################################
    def lock_verify(
        self, cmd_runner: str, exp_positions: list[str], line_num: int
    ) -> None:
        """Increment the pending operations count.

        Args:
            cmd_runner: name of thread that will get the lock
            exp_positions: the expected positions on the lock queue
            line_num: the line number where the cmd was issued

        Raises:
            FailedLockVerify: lock_verify from {line_num=} timed out
                after {timeout_value} seconds waiting for the
                {exp_positions=} to match
                {st.SmartThread._registry[self.group_name].registry_lock.owner_wait_q=}.

        """
        self.log_test_msg(
            f"lock_verify entry: {cmd_runner=}, {exp_positions=}, {line_num=}"
        )
        start_time = time.time()
        timeout_value = 60
        lock_verified = False
        while not lock_verified:
            lock_verified = True  # assume lock will verify
            lock_positions: list[str] = []
            with self.ops_lock:
                for lock_item in st.SmartThread._registry[
                    self.group_name
                ].registry_lock.owner_wait_q:
                    lock_name = self.get_smart_thread_name(
                        search_thread=lock_item.thread, group_name="test1"
                    )
                    lock_positions.append(lock_name)
                self.log_test_msg(f"lock_verify: {lock_positions=}")
                if exp_positions != lock_positions:
                    lock_verified = False

            if not lock_verified:
                if (time.time() - start_time) > timeout_value:
                    self.abort_all_f1_threads()
                    raise FailedLockVerify(
                        f"lock_verify from {line_num=} timed out after"
                        f" {timeout_value} seconds waiting for match of \n"
                        f"{exp_positions=}\n"
                        f"{lock_positions=}\n"
                        f"{st.SmartThread._registry[self.group_name].registry_lock.owner_wait_q=} "
                    )
                time.sleep(0.2)
        self.log_test_msg(
            f"lock_verify exit: {cmd_runner=}, " f"{exp_positions=}, {line_num=}"
        )

    ####################################################################
    # log_name_groups
    ####################################################################
    def log_name_groups(self) -> None:
        """Issue log msgs to show the names in each set."""
        log_msg = f"unregistered_names: {sorted(self.unregistered_names)}"
        self.log_ver.add_msg(log_msg=re.escape(log_msg))
        logger.debug(log_msg)

        log_msg = f"registered_names:   {sorted(self.registered_names)}"
        self.log_ver.add_msg(log_msg=re.escape(log_msg))
        logger.debug(log_msg)

        log_msg = f"active_names:       {sorted(self.active_names)}"
        self.log_ver.add_msg(log_msg=re.escape(log_msg))
        logger.debug(log_msg)

        log_msg = f"stopped_remotes:    {sorted(self.stopped_remotes)}"
        self.log_ver.add_msg(log_msg=re.escape(log_msg))
        logger.debug(log_msg)

    ####################################################################
    # log_test_msg
    ####################################################################
    def log_test_msg(self, log_msg: str) -> None:
        """Issue log msgs for test rtn.

        Args:
            log_msg: the message to log

        """
        if (
            self.allow_log_test_msg
            or "waiting for monitor" in log_msg
            or "has been stopped by" in log_msg
        ):
            self.log_ver.add_msg(log_msg=re.escape(log_msg))
            logger.debug(log_msg, stacklevel=2)

    ####################################################################
    # main_driver
    ####################################################################
    def main_driver(self) -> None:
        """Delete the thread from the ConfigVerifier."""
        self.log_ver.add_call_seq(
            name="main_driver", seq="test_smart_thread.py::ConfigVerifier.main_driver"
        )

        while self.cmd_suite and not self.monitor_bail:
            cmd: ConfigCmd = self.cmd_suite.popleft()
            self.log_test_msg(f"config_cmd: {cmd}")

            if not cmd.cmd_runners:
                raise InvalidInputDetected(
                    "main_driver detected an empty " "set of cmd_runners"
                )
            for name in cmd.cmd_runners:
                if name == self.commander_name:
                    continue
                self.msgs.queue_msg(target=name, msg=cmd)

            if self.commander_name in cmd.cmd_runners:
                cmd.run_process(cmd_runner=self.commander_name)
                self.completed_cmds[self.commander_name].append(cmd.serial_num)

    ####################################################################
    # set_recv_timeout
    ####################################################################
    def set_recv_timeout(self, num_timeouts: int) -> None:
        """Set the expected number of receive timeouts.

        Args:
            num_timeouts: number or expected timeouts to set

        """
        with self.ops_lock:
            self.expected_num_recv_timeouts = num_timeouts

    ####################################################################
    # stop_thread
    ####################################################################
    def stop_thread(
        self,
        cmd_runner: str,
        stop_names: set[str],
        reset_ops_count: bool = False,
        send_recv_msgs: Optional[SendRecvMsgs] = None,
    ) -> None:
        """Start the named thread.

        Args:
            cmd_runner: name of thread doing the stop thread
            stop_names: names of the threads to stop
            reset_ops_count: specifies whether to set the
                pending_ops_count to zero
            send_recv_msgs: contains messages sent to stop_names
        """
        self.log_test_msg(f"{cmd_runner=} stop_thread entry for {stop_names=}")

        self.stopped_event_items[cmd_runner] = MonitorEventItem(
            client_event=threading.Event(), targets=stop_names.copy()
        )

        for stop_name in stop_names:
            self.stopping_names.append(stop_name)
            if stop_name not in self.pending_events:
                raise InvalidConfigurationDetected(
                    "stop_thread detected missing pending transition "
                    f"for {stop_name}: {self.pending_events=}"
                )
            if stop_name not in self.expected_registered:
                raise InvalidConfigurationDetected(
                    f"stop_thread attempting to stop {stop_name} which is "
                    f"not in the registry: {self.expected_registered=}"
                )

            self.monitor_event.set()
            exit_cmd = ExitThread(cmd_runners=stop_name, stopped_by=cmd_runner)
            self.add_cmd_info(exit_cmd)
            self.msgs.queue_msg(target=stop_name, msg=exit_cmd)

        work_names = stop_names.copy()
        while work_names:
            for stop_name in work_names:
                if not self.all_threads[stop_name].thread.is_alive():
                    self.log_test_msg(
                        f"{stop_name} has been stopped by " f"{cmd_runner}"
                    )
                    self.monitor_event.set()
                    if send_recv_msgs:
                        send_recv_msgs.clear_all_exp_msgs_received(stop_name)
                    if reset_ops_count:
                        with self.ops_lock:
                            for pair_key in self.expected_pairs.keys():
                                if stop_name in pair_key:
                                    self.expected_pairs[pair_key][
                                        stop_name
                                    ].reset_ops_count = True
                    work_names -= {stop_name}
                    break
                time.sleep(0.05)

        self.log_test_msg(f"{cmd_runner=} stop_thread waiting for monitor")
        self.monitor_event.set()
        if not self.stopped_event_items[cmd_runner].client_event.wait(timeout=60):
            self.abort_all_f1_threads()

        self.log_test_msg(f"{cmd_runner=} stop_thread exiting for " f"{stop_names=}")

    ####################################################################
    # add_to_pair_array
    ####################################################################
    def add_to_pair_array(self, cmd_runner: str, add_name: str) -> bool:
        """Add thread to pair array.

        Args:
            cmd_runner: thread name doing the update
            add_name: thread name to add

        Returns:
            True if name was added, False otherwise

        Raises:
            InvalidConfigurationDetected: Attempt to add thread to
                existing pair array that has an empty ThreadPairStatus
                dict, or that already has the thread in the pair array,
                or that did not have the other name in the pair array.

        """
        self.log_test_msg(f"add_to_pair_array entry: {cmd_runner=}, " f"{add_name=}")

        pe = self.pending_events[cmd_runner]

        if add_name not in self.expected_registered:
            raise IncorrectDataDetected(
                f"add_to_pair_array detected {add_name=} not "
                f"found in {self.expected_registered=}"
            )
        changed = False
        for other_name in self.expected_registered.keys():
            if (other_name == add_name) or self.expected_registered[
                other_name
            ].st_state == st.ThreadState.Initialized:
                continue

            self.log_test_msg(
                f"add_to_pair_array proceeding with " f"{add_name=}, {other_name=}"
            )
            changed = True
            pair_key = st.SmartThread._get_pair_key(add_name, other_name)

            if pair_key not in self.expected_pairs:
                self.log_test_msg(
                    f"add_to_pair_array {pair_key=} not in " f"{self.expected_pairs=}"
                )
                self.expected_pairs[pair_key] = {
                    add_name: ThreadPairStatus(reset_ops_count=False),
                    other_name: ThreadPairStatus(reset_ops_count=False),
                }
                add_key: AddPaKey = (cmd_runner, pair_key)
                pe[PE.add_pair_array_msg][add_key] += 1

                for pair_name in pair_key:
                    add_status_key: AddStatusBlockKey = (
                        cmd_runner,
                        pair_key,
                        pair_name,
                    )
                    pe[PE.add_status_block_msg][add_status_key] += 1
                ########################################################
                # determine whether we have pending cmd for new thread
                ########################################################
                other_pe = self.pending_events[other_name]
                if (
                    other_pe[PE.current_request].req_type.value in smart_reqs
                    and add_name in other_pe[PE.current_request].targets
                ):
                    self.set_request_pending_flag(
                        cmd_runner=other_name,
                        targets={add_name},
                        pending_request_flag=True,
                    )

            # if pair_key already exists, we need to add name
            # as a resurrected thread
            else:  # we already have a pair_key, need to add name
                self.log_test_msg(
                    f"add_to_pair_array {pair_key=} in " f"{self.expected_pairs=}"
                )
                if not self.expected_pairs[pair_key]:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        "Attempt to add thread to existing pair array "
                        "that has an empty ThreadPairStatus dict"
                    )
                if add_name in self.expected_pairs[pair_key].keys():
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"{cmd_runner} attempted to add {add_name} to "
                        f"pair array for {pair_key=} that already "
                        "has the thread in the pair array"
                    )

                if other_name not in self.expected_pairs[pair_key].keys():
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        "Attempt to add thread to pair array that did "
                        "not have the other name in the pair array"
                    )

                # looks OK, just add in the new name
                self.expected_pairs[pair_key][add_name] = ThreadPairStatus(
                    reset_ops_count=False
                )

                add_status_key = (cmd_runner, pair_key, add_name)
                pe[PE.add_status_block_msg][add_status_key] += 1

                if self.auto_calling_refresh_msg:
                    pot_key: PotentialDefDelKey = (pair_key, other_name)
                    self.potential_def_del_pairs[pot_key] = 0

        self.log_test_msg(f"add_to_pair_array exit: {cmd_runner=}, " f"{add_name=}")
        return changed

    ####################################################################
    # clean_pair_array
    ####################################################################
    def clean_pair_array(self, cmd_runner: str) -> None:
        """Remove entries from pair array as needed.

        Args:
            cmd_runner: thread name doing the _clean_pair_array

        Raises:
            InvalidConfigurationDetected: Attempt to add thread to
                existing pair array that has an empty ThreadPairStatus
                dict, or that already has the thread in the pair array,
                or that did not have the other name in the pair array.

        """
        self.log_test_msg(f"clean_pair_array entry: {cmd_runner=} ")

        pe = self.pending_events[cmd_runner]

        changed = False
        pair_keys_to_delete = []
        for pair_key in self.expected_pairs:
            if (
                pair_key[0] in self.expected_registered
                and self.expected_registered[pair_key[0]].st_state
                != st.ThreadState.Initialized
                and pair_key[1] in self.expected_registered
                and self.expected_registered[pair_key[1]].st_state
                != st.ThreadState.Initialized
            ):
                # self.log_test_msg('clean_pair_array continue with '
                #                   f'{pair_key=}')
                continue

            # one or both need to be removed from pair_array
            pae = self.expected_pairs[pair_key]

            for name in pair_key:
                pending_request = False
                pending_msg = False
                pending_wait = False
                pending_sync = False
                defer = False
                if name in pae:
                    if pae[name].pending_request:
                        pending_request = True
                        defer = True
                    if pae[name].pending_msg_count:
                        pending_msg = True
                        defer = True
                    if pae[name].pending_wait:
                        pending_wait = True
                        defer = True
                    if pae[name].pending_sync:
                        pending_sync = True
                        defer = True

                    def_del_reasons: DefDelReasons = DefDelReasons(
                        pending_request=pending_request,
                        pending_msg=pending_msg,
                        pending_wait=pending_wait,
                        pending_sync=pending_sync,
                    )

                    rem_sb_key: RemSbKey = (name, pair_key, def_del_reasons)

                    if name in self.expected_registered and defer:
                        self.log_test_msg(
                            "clean_pair_array deferred "
                            f"{pair_key=}, {name=}, "
                            f"{rem_sb_key=}"
                        )
                        pe[PE.rem_status_block_def_msg][rem_sb_key] += 1

                        if self.auto_calling_refresh_msg:
                            pot_key: PotentialDefDelKey = (pair_key, name)
                            self.potential_def_del_pairs[pot_key] = 1

                    else:
                        del pae[name]
                        pe[PE.rem_status_block_msg][rem_sb_key] += 1
                        self.log_test_msg(
                            "clean_pair_array removed "
                            f"{pair_key=}, {name=}, "
                            f"{rem_sb_key=}"
                        )

                        changed = True

            if not pae:
                pair_keys_to_delete.append(pair_key)

        if pair_keys_to_delete:
            changed = True
            for pair_key in pair_keys_to_delete:
                del self.expected_pairs[pair_key]
                rem_pae_key: RemPaeKey = (cmd_runner, pair_key)
                pe[PE.rem_pair_array_entry_msg][rem_pae_key] += 1

        if changed:
            pe[PE.did_cleanup_pair_array_utc_msg] += 1
            self.log_test_msg(
                f"clean_pair_array for {cmd_runner=} "
                f"{pe[PE.did_cleanup_pair_array_utc_msg]=}"
            )

        self.log_test_msg(f"clean_pair_array exit: {cmd_runner=} ")

    ####################################################################
    # clean_registry
    ####################################################################
    def clean_registry(self, cmd_runner: str, target: str) -> None:
        """Remove entries from the registry as needed.

        Args:
            cmd_runner: thread name doing the _clean_pair_array
            target: thread name that is being processed

        Raises:
            InvalidConfigurationDetected: Attempt to add thread to
                existing pair array that has an empty ThreadPairStatus
                dict, or that already has the thread in the pair array,
                or that did not have the other name in the pair array.

        """
        self.log_test_msg(f"clean_registry entry: {cmd_runner=}, {target=}")
        rem_targets: list[str] = []
        pe = self.pending_events[cmd_runner]
        request = pe[PE.current_request].req_type.value
        with self.ops_lock:
            for key, item in self.expected_registered.items():
                if item.st_state == st.ThreadState.Alive and not item.is_alive:
                    state_to_use = st.ThreadState.Stopped

                    target = key

                    state_key: SetStateKey = (
                        cmd_runner,
                        target,
                        st.ThreadState.Alive,
                        st.ThreadState.Stopped,
                    )
                    # note that we could back out the same pending we
                    # are about to bump, and this is OK
                    for key2, item2 in self.pending_events.items():
                        test_key: SetStateKey = (
                            key2,
                            target,
                            st.ThreadState.Alive,
                            st.ThreadState.Stopped,
                        )
                        if item2[PE.set_state_msg][test_key] > 0:
                            item2[PE.set_state_msg][test_key] -= 1
                            self.log_test_msg(
                                f"clean_registry backed out set_state "
                                f"pending for {test_key=} "
                            )
                            break

                    pe[PE.set_state_msg][state_key] += 1
                    self.log_test_msg(
                        f"clean_registry bumped set_state " f"pending for {state_key=} "
                    )
                else:
                    state_to_use = item.st_state

                if (
                    state_to_use != st.ThreadState.Unregistered
                    and state_to_use != st.ThreadState.Initialized
                ):
                    self.pending_events[key][PE.status_msg][
                        (item.is_alive, state_to_use)
                    ] += 1

                if not item.is_alive and (
                    (item.reg_to_unreg and item.st_state == st.ThreadState.Registered)
                    or (
                        item.stopped_to_unreg
                        and item.st_state == st.ThreadState.Stopped
                    )
                ):
                    rem_key: RemRegKey = (key, request)
                    pe[PE.rem_reg_msg][rem_key] += 1
                    rem_targets.append(key)

            completed: set[str] = set()
            if pe[PE.current_request].req_type in (
                st.ReqType.Smart_unreg,
                st.ReqType.Smart_join,
            ):
                # if this is first visit to clean_registry
                if (
                    pe[PE.current_request].unreg_remotes
                    and not pe[PE.current_request].completed_targets
                ):
                    pe[PE.current_request].completed_targets |= pe[
                        PE.current_request
                    ].unreg_remotes
                    completed |= pe[PE.current_request].unreg_remotes

            if rem_targets:
                pe[PE.did_clean_reg_msg] += 1
                pe[PE.rem_reg_targets].append(rem_targets)

                for target in rem_targets:
                    del self.expected_registered[target]
                    self.log_test_msg(f"clean_registry removed {target=}")
                    if target in pe[PE.current_request].eligible_targets:
                        pe[PE.current_request].completed_targets |= {target}
                        completed |= {target}

            if pe[PE.current_request].req_type in (
                st.ReqType.Smart_unreg,
                st.ReqType.Smart_join,
            ):
                s_com = sorted(completed)

                uj_key: UnregJoinSuccessKey = (
                    pe[PE.current_request].req_type.value,
                    s_com[0],
                )
                pe[PE.unreg_join_success_msg][uj_key] += 1

                if pe[PE.current_request].req_type == st.ReqType.Smart_join:
                    all_targets = pe[PE.current_request].targets.copy()
                    completed = pe[PE.current_request].completed_targets.copy()
                    remaining = all_targets - completed

                    prog_key: JoinProgKey = (len(completed), len(remaining))
                    pe[PE.join_progress_msg][prog_key] += 1

            if len(pe[PE.current_request].completed_targets) < len(
                pe[PE.current_request].eligible_targets
            ):
                if pe[PE.current_request].req_type == st.ReqType.Smart_join:
                    sub_key: SubProcessKey = (
                        cmd_runner,
                        "smart_join",
                        "_clean_registry",
                        "entry",
                        cmd_runner,
                    )
                    pe[PE.subprocess_msg][sub_key] += 1

                    sub_key = (
                        cmd_runner,
                        "smart_join",
                        "_clean_pair_array",
                        "entry",
                        cmd_runner,
                    )
                    pe[PE.subprocess_msg][sub_key] += 1

        self.log_test_msg(f"clean_registry exit: {cmd_runner=}, {target=}")

    ####################################################################
    # verify_config
    ####################################################################
    def verify_config(self, verify_idx: int) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            verify_idx: index for the saved snapshot data
        """
        verify_data: VerifyData = self.snap_shot_data[verify_idx].verify_data

        actions: dict[VerifyType, Callable[..., None]] = {
            VerifyType.VerifyStructures: self.verify_structures,
            VerifyType.VerifyAlive: self.verify_alive,
            VerifyType.VerifyNotAlive: self.verify_not_alive,
            VerifyType.VerifyState: self.verify_state,
            VerifyType.VerifyInRegistry: self.verify_in_registry,
            VerifyType.VerifyNotInRegistry: self.verify_not_in_registry,
            VerifyType.VerifyAliveState: self.verify_active_state,
            VerifyType.VerifyRegisteredState: self.verify_registered_state,
            VerifyType.VerifyStoppedState: self.verify_stopped_state,
            VerifyType.VerifyPaired: self.verify_paired,
            VerifyType.VerifyNotPaired: self.verify_not_paired,
            VerifyType.VerifyHalfPaired: self.verify_half_paired,
            VerifyType.VerifyPendingFlags: self.verify_pending_flags,
        }
        actions[verify_data.verify_type](
            real_reg_items=self.snap_shot_data[verify_idx].registry_items,
            real_pair_array_items=self.snap_shot_data[verify_idx].pair_array_items,
            verify_data=verify_data,
        )

    ####################################################################
    # verify_structures
    ####################################################################
    def verify_structures(
        self,
        real_reg_items: RegistryItems,
        real_pair_array_items: PairArrayItems,
        verify_data: VerifyData,
    ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        for name, real_reg_item in real_reg_items.items():
            if name not in self.expected_registered:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_config found SmartThread real registry has entry "
                    f"for {name=} that is missing from the expected_registry. "
                    f"{self.expected_registered.keys()=}"
                )
            if self.expected_registered[name].is_alive != real_reg_item.is_alive:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_config found SmartThread real registry has "
                    f"entry for {name=} that has is_alive of "
                    f"{real_reg_item.is_alive} which does not match the "
                    f"expected_registered is_alive of "
                    f"{self.expected_registered[name].is_alive}"
                )
            if self.expected_registered[name].st_state != real_reg_item.state:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_config found SmartThread real registry has "
                    f"entry for {name=} that has status of "
                    f"{real_reg_item.state} which does not match the "
                    f"mock expected_registered status of "
                    f"{self.expected_registered[name].st_state}"
                )

        # verify expected_registered matches real registry
        for name, tracker in self.expected_registered.items():
            if name not in real_reg_items:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_config found expected_registered has an entry "
                    f"for {name=} that is missing from real "
                    f"SmartThread._registry"
                )

        # verify pair_array matches expected_pairs
        for pair_key, status_blocks in real_pair_array_items.items():
            if len(status_blocks) == 0:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_config found pair_key {pair_key} in real "
                    f"SmartThread pair_array that has an empty status_blocks"
                )
            if pair_key not in self.expected_pairs:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_config found pair_key {pair_key} in real "
                    f"SmartThread pair_array that is not found in "
                    f"expected_pairs"
                )
            for name, status_item in status_blocks.items():
                if name not in real_reg_items:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_config found SmartThread real pair_array "
                        f"has a status_blocks entry for {name=} that is "
                        f"missing from the real registry. "
                    )

                if name not in self.expected_registered:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_config found {name=} in real "
                        f"SmartThread pair_array status_blocks for pair_key"
                        f" {pair_key}, but is missing in mock "
                        f"expected_registered"
                    )

                if name not in self.expected_pairs[pair_key].keys():
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_config found {name=} in real "
                        f"SmartThread pair_array status_blocks for pair_key"
                        f" {pair_key}, but is missing in expected_pairs"
                    )

                if len(status_blocks) == 1:
                    if not (
                        status_item.del_def_flag
                        or status_item.pending_request
                        or status_item.pending_msg_count
                        or status_item.pending_wait
                        or status_item.pending_sync
                    ):
                        self.abort_all_f1_threads()
                        raise InvalidConfigurationDetected(
                            f"verify_config found {name=} in real "
                            f"SmartThread pair_array status_blocks for "
                            f"pair_key {pair_key}, but it is a single "
                            f"name that has no pending reasons and is not "
                            f"del_deferred"
                        )
                mock_status_item = self.expected_pairs[pair_key][name]
                if status_item.pending_request != mock_status_item.pending_request:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_config found {name=} in real "
                        f"SmartThread pair_array status_blocks for "
                        f"pair_key {pair_key} has "
                        f"{status_item.pending_request=} which does not "
                        f"match {mock_status_item.pending_request=}"
                    )
                if status_item.pending_msg_count != mock_status_item.pending_msg_count:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_config found {name=} in real "
                        f"SmartThread pair_array status_blocks for "
                        f"pair_key {pair_key} has "
                        f"{status_item.pending_msg_count=} which does not "
                        f"match {mock_status_item.pending_msg_count=}"
                    )
                if status_item.pending_wait != mock_status_item.pending_wait:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_config found {name=} in real "
                        f"SmartThread pair_array status_blocks for "
                        f"pair_key {pair_key} has "
                        f"{status_item.pending_wait=} which does not "
                        f"match {mock_status_item.pending_wait=}"
                    )
                if status_item.pending_sync != mock_status_item.pending_sync:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_config found {name=} in real "
                        f"SmartThread pair_array status_blocks for "
                        f"pair_key {pair_key} has "
                        f"{status_item.pending_sync=} which does not "
                        f"match {mock_status_item.pending_sync=}"
                    )

        # verify expected_pairs matches pair_array
        for pair_key, mock_status_blocks in self.expected_pairs.items():
            if pair_key not in real_pair_array_items:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_config found {pair_key=} in expected_pairs but "
                    f"not in real SmartThread pair_array"
                )
            for name, mock_status_item in mock_status_blocks.items():
                if name not in real_reg_items:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_config found SmartThread mock pair_array "
                        f"has a status_blocks entry for {name=} that is "
                        f"missing from the real registry. "
                    )

                if name not in self.expected_registered:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_config found {name=} in mock "
                        f"pair_array status_blocks for pair_key"
                        f" {pair_key}, but is missing in "
                        f"mock expected_registered"
                    )

                if name not in real_pair_array_items[pair_key]:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_config found {name=} in mock "
                        f"expected_pairs for pair_key {pair_key}, but not in "
                        "real SmartThread pair_array status_blocks"
                    )

    ####################################################################
    # verify_alive
    ####################################################################
    def verify_alive(
        self,
        real_reg_items: RegistryItems,
        real_pair_array_items: PairArrayItems,
        verify_data: VerifyData,
    ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        for name in verify_data.names_to_check:
            if not real_reg_items[name].is_alive:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_alive found {name} has "
                    f"{real_reg_items[name].is_alive=} "
                    "which is not equal to the expected is_alive of True "
                )
            if not self.expected_registered[name].is_alive:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_alive found {name=} has mock "
                    f"{self.expected_registered[name].is_alive=} which is "
                    "not equal to the expected is_alive of True "
                )

    ####################################################################
    # verify_not_alive
    ####################################################################
    def verify_not_alive(
        self,
        real_reg_items: RegistryItems,
        real_pair_array_items: PairArrayItems,
        verify_data: VerifyData,
    ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        for name in verify_data.names_to_check:
            if real_reg_items[name].is_alive:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_not_alive found {name=} has real "
                    f"{real_reg_items[name].is_alive=} "
                    "which is not equal to the expected is_alive of False "
                )
            if self.expected_registered[name].is_alive:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_not_alive found {name=} has mock "
                    f"{self.expected_registered[name].is_alive=} which is "
                    "not equal to the expected is_alive of False"
                )

    ####################################################################
    # verify_state
    ####################################################################
    def verify_state(
        self,
        real_reg_items: RegistryItems,
        real_pair_array_items: PairArrayItems,
        verify_data: VerifyData,
    ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        for name in verify_data.names_to_check:
            if (
                real_reg_items[name].state != verify_data.state_to_check
                or self.expected_registered[name].st_state != verify_data.state_to_check
            ):
                self.abort_all_f1_threads()
                self.log_test_msg(
                    f"verify_state for {name=}: {verify_data.state_to_check=} "
                    f"does not match either/both {real_reg_items[name].state} "
                    f"or {self.expected_registered[name].st_state} per "
                    f"{verify_data.cmd_runner=}"
                )
                raise InvalidConfigurationDetected(
                    f"verify_state for {name=}: {verify_data.state_to_check=} "
                    f"does not match either/both {real_reg_items[name].state} "
                    f"or {self.expected_registered[name].st_state} per "
                    f"{verify_data.cmd_runner=}"
                )

    ####################################################################
    # verify_in_registry
    ####################################################################
    def verify_in_registry(
        self,
        real_reg_items: RegistryItems,
        real_pair_array_items: PairArrayItems,
        verify_data: VerifyData,
    ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        for name in verify_data.names_to_check:
            if name not in real_reg_items:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_in_registry found {name=} is not registered in "
                    f"the real SmartThread._registry per "
                    f"{verify_data.cmd_runner=}"
                )
            if name not in self.expected_registered:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_in_registry found {name=} is not registered in "
                    f"the mock SmartThread._registry per "
                    f"{verify_data.cmd_runner=}"
                )

    ####################################################################
    # verify_not_in_registry
    ####################################################################
    def verify_not_in_registry(
        self,
        real_reg_items: RegistryItems,
        real_pair_array_items: PairArrayItems,
        verify_data: VerifyData,
    ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        for name in verify_data.names_to_check:
            if name in real_reg_items:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_not_in_registry found {name=} is registered in "
                    f"the real SmartThread._registry per "
                    f"{verify_data.cmd_runner=}"
                )
            if name in self.expected_registered:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_in_registry_not found {name=} is registered in "
                    f"the mock expected_registered per "
                    f"{verify_data.cmd_runner=}"
                )

    ####################################################################
    # verify_active_state
    ####################################################################
    def verify_active_state(
        self,
        real_reg_items: RegistryItems,
        real_pair_array_items: PairArrayItems,
        verify_data: VerifyData,
    ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        self.verify_in_registry(
            real_reg_items=real_reg_items,
            real_pair_array_items=real_pair_array_items,
            verify_data=verify_data,
        )

        self.verify_alive(
            real_reg_items=real_reg_items,
            real_pair_array_items=real_pair_array_items,
            verify_data=verify_data,
        )

        verify_data.state_to_check = st.ThreadState.Alive
        self.verify_state(
            real_reg_items=real_reg_items,
            real_pair_array_items=real_pair_array_items,
            verify_data=verify_data,
        )

        if len(verify_data.names_to_check) > 1:
            self.verify_paired(
                real_reg_items=real_reg_items,
                real_pair_array_items=real_pair_array_items,
                verify_data=verify_data,
            )

    ####################################################################
    # verify_registered_state
    ####################################################################
    def verify_registered_state(
        self,
        real_reg_items: RegistryItems,
        real_pair_array_items: PairArrayItems,
        verify_data: VerifyData,
    ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        self.verify_in_registry(
            real_reg_items=real_reg_items,
            real_pair_array_items=real_pair_array_items,
            verify_data=verify_data,
        )

        self.verify_not_alive(
            real_reg_items=real_reg_items,
            real_pair_array_items=real_pair_array_items,
            verify_data=verify_data,
        )

        verify_data.state_to_check = st.ThreadState.Registered
        self.verify_state(
            real_reg_items=real_reg_items,
            real_pair_array_items=real_pair_array_items,
            verify_data=verify_data,
        )

        if len(verify_data.names_to_check) > 1:
            self.verify_paired(
                real_reg_items=real_reg_items,
                real_pair_array_items=real_pair_array_items,
                verify_data=verify_data,
            )

    ####################################################################
    # verify_stopped_state
    ####################################################################
    def verify_stopped_state(
        self,
        real_reg_items: RegistryItems,
        real_pair_array_items: PairArrayItems,
        verify_data: VerifyData,
    ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        self.verify_in_registry(
            real_reg_items=real_reg_items,
            real_pair_array_items=real_pair_array_items,
            verify_data=verify_data,
        )

        self.verify_not_alive(
            real_reg_items=real_reg_items,
            real_pair_array_items=real_pair_array_items,
            verify_data=verify_data,
        )

        for name in verify_data.names_to_check:
            if real_reg_items[name].state not in (
                st.ThreadState.Alive,
                st.ThreadState.Stopped,
            ):
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_state found {name=} has real state "
                    f"{real_reg_items[name].state} not equal to the expected "
                    f"state of {st.ThreadState.Alive} or "
                    f"{st.ThreadState.Stopped}"
                )
            if self.expected_registered[name].st_state not in (
                st.ThreadState.Alive,
                st.ThreadState.Stopped,
            ):
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_state found {name=} has mock state "
                    f"{self.expected_registered[name].st_state} not equal to "
                    f"the expected state of {st.ThreadState.Alive} or "
                    f"{st.ThreadState.Stopped}"
                )

        if len(verify_data.names_to_check) > 1:
            self.verify_paired(
                real_reg_items=real_reg_items,
                real_pair_array_items=real_pair_array_items,
                verify_data=verify_data,
            )

    ####################################################################
    # get_pair_keys
    ####################################################################
    def get_pair_keys(self, names: set[str]) -> list[st.PairKey]:
        """Verify that the SmartThread config is correct.

        Args:
            names: names whose pair keys are wanted

        Returns:
            List of PairKey items

        """
        pairs = combinations(sorted(names), 2)
        pair_keys: list[st.PairKey] = cast(list[st.PairKey], list(pairs))
        return pair_keys

    ####################################################################
    # verify_paired
    ####################################################################
    def verify_paired(
        self,
        real_reg_items: RegistryItems,
        real_pair_array_items: PairArrayItems,
        verify_data: VerifyData,
    ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        pair_keys = self.get_pair_keys(verify_data.names_to_check)
        for pair_key in pair_keys:
            if pair_key not in real_pair_array_items:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_paired found {pair_key=} is not " f"in the real pair_array"
                )

            if pair_key not in self.expected_pairs:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_paired found {pair_key=} is not " f"in the mock pair_array"
                )

            for name in pair_key:
                if name not in real_pair_array_items[pair_key]:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_paired found {name=} for {pair_key=} does "
                        f"not have a status block in the real pair_array"
                    )

                if name not in self.expected_pairs[pair_key]:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_paired found {name=} for {pair_key=} does "
                        f"not have a status block in the mock pair_array"
                    )

    ####################################################################
    # verify_not_paired
    ####################################################################
    def verify_not_paired(
        self,
        real_reg_items: RegistryItems,
        real_pair_array_items: PairArrayItems,
        verify_data: VerifyData,
    ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        pair_keys = combinations(sorted(verify_data.names_to_check), 2)
        for pair_key in pair_keys:
            if pair_key in real_pair_array_items:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_not_paired found {pair_key=} is in "
                    f"in the real pair_array"
                )

            if pair_key in self.expected_pairs:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f"verify_not_paired found {pair_key=} is in "
                    f"in the mock pair_array"
                )

    ####################################################################
    # verify_half_paired
    ####################################################################
    def verify_half_paired(
        self,
        real_reg_items: RegistryItems,
        real_pair_array_items: PairArrayItems,
        verify_data: VerifyData,
    ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        for removed_name in verify_data.aux_names:
            for exp_remaining_name in verify_data.names_to_check:
                pair_key = st.SmartThread._get_pair_key(
                    removed_name, exp_remaining_name
                )
                if pair_key not in real_pair_array_items:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_half_paired found {pair_key=} is not "
                        f"in the real pair_array"
                    )

                num_real_status_blocks = len(real_pair_array_items[pair_key])
                if num_real_status_blocks != 1:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_half_paired found {num_real_status_blocks=} "
                        f"is not equal to 1 in the real pair_array"
                    )

                if exp_remaining_name not in real_pair_array_items[pair_key]:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_half_paired found {exp_remaining_name=} does "
                        f"not have a status block in the real pair_array for "
                        f"{pair_key=}."
                    )

                if pair_key not in self.expected_pairs:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_half_paired found {pair_key=} is not "
                        f"in the mock pair_array"
                    )
                num_mock_status_blocks = len(self.expected_pairs[pair_key])
                if num_mock_status_blocks != 1:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_half_paired found {num_mock_status_blocks=} "
                        f"is not 1 in the mock pair_array"
                    )
                if exp_remaining_name not in self.expected_pairs[pair_key]:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_half_paired found {exp_remaining_name=} does "
                        f"not have a status block in the mock pair_array for "
                        f"{pair_key=}."
                    )

    ####################################################################
    # verify_half_paired
    ####################################################################
    def verify_pending_flags(
        self,
        real_reg_items: RegistryItems,
        real_pair_array_items: PairArrayItems,
        verify_data: VerifyData,
    ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        for remote_name in verify_data.aux_names:
            for check_name in verify_data.names_to_check:
                pair_key = st.SmartThread._get_pair_key(remote_name, check_name)
                if pair_key not in real_pair_array_items:
                    self.log_test_msg(
                        f"verify_pending_flags 1 found {pair_key=} is not "
                        f"in the real pair_array needed to check "
                        f"{check_name=}, {remote_name=}"
                    )
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_pending_flags found {pair_key=} is not "
                        f"in the real pair_array needed to check "
                        f"{check_name=}, {remote_name=}"
                    )

                if check_name not in real_pair_array_items[pair_key]:
                    self.log_test_msg(
                        f"verify_pending_flags 2 found {check_name=} does "
                        f"not have a status block in the real pair_array for "
                        f"{pair_key=}."
                    )
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_pending_flags found {check_name=} does "
                        f"not have a status block in the real pair_array for "
                        f"{pair_key=}."
                    )

                if pair_key not in self.expected_pairs:
                    self.log_test_msg(
                        f"verify_pending_flags 3 found {pair_key=} is not "
                        f"in the mock pair_array needed to check "
                        f"{check_name=}, {remote_name=}"
                    )
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_pending_flags found {pair_key=} is not "
                        f"in the mock pair_array needed to check "
                        f"{check_name=}, {remote_name=}"
                    )

                if check_name not in self.expected_pairs[pair_key]:
                    self.log_test_msg(
                        f"verify_pending_flags 4 found {check_name=} does "
                        f"not have a status block in the mock pair_array for "
                        f"{pair_key=}."
                    )
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_pending_flags 4 found {check_name=} does "
                        f"not have a status block in the mock pair_array for "
                        f"{pair_key=}."
                    )

                real_sb = real_pair_array_items[pair_key][check_name]
                real_pending_flags = PendingFlags(
                    pending_request=real_sb.pending_request,
                    pending_msgs=real_sb.pending_msg_count,
                    pending_wait=real_sb.pending_wait,
                    pending_sync=real_sb.pending_sync,
                )

                mock_sb = self.expected_pairs[pair_key][check_name]
                mock_pending_flags = PendingFlags(
                    pending_request=mock_sb.pending_request,
                    pending_msgs=mock_sb.pending_msg_count,
                    pending_wait=mock_sb.pending_wait,
                    pending_sync=mock_sb.pending_sync,
                )
                if (real_pending_flags != verify_data.exp_pending_flags) or (
                    mock_pending_flags != verify_data.exp_pending_flags
                ):
                    self.log_test_msg(
                        f"verify_pending_flags 5 found {pair_key=}, "
                        f"{check_name=} does have matching pending flags: "
                        f"{real_pending_flags=}, "
                        f"{mock_pending_flags=}, "
                        f"{verify_data.exp_pending_flags=}."
                    )
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f"verify_pending_flags found {pair_key=}, "
                        f"{check_name=} does not have matching pending flags: "
                        f"{real_pending_flags=}, "
                        f"{mock_pending_flags=}, "
                        f"{verify_data.exp_pending_flags=}."
                    )

    ####################################################################
    # verify_counts
    ####################################################################
    def verify_counts(self, verify_idx: int) -> None:
        """Verify that the given counts are correct.

        Args:
            verify_idx: index for the saved snapshot data

        """
        real_reg_items = self.snap_shot_data[verify_idx].registry_items
        verify_counts_data: VerifyData = self.snap_shot_data[verify_idx].verify_data

        registered_found_real = 0
        active_found_real = 0
        stopped_found_real = 0
        for name, real_reg_item in real_reg_items.items():
            if real_reg_item.is_alive:
                if real_reg_item.state == st.ThreadState.Alive:
                    active_found_real += 1
            else:
                if real_reg_item.state == st.ThreadState.Registered:
                    registered_found_real += 1
                elif (
                    real_reg_item.state == st.ThreadState.Alive
                    or real_reg_item.state == st.ThreadState.Stopped
                ):
                    stopped_found_real += 1

        registered_found_mock = 0
        active_found_mock = 0
        stopped_found_mock = 0
        for name, thread_tracker in self.expected_registered.items():
            if thread_tracker.is_alive:
                if thread_tracker.st_state == st.ThreadState.Alive:
                    active_found_mock += 1
            else:
                if thread_tracker.st_state == st.ThreadState.Registered:
                    registered_found_mock += 1
                elif (
                    thread_tracker.st_state == st.ThreadState.Alive
                    or thread_tracker.st_state == st.ThreadState.Stopped
                ):
                    stopped_found_mock += 1

        if not (
            verify_counts_data.num_registered
            == registered_found_real
            == registered_found_mock
        ):
            self.abort_all_f1_threads()
            raise InvalidConfigurationDetected(
                f"verify_counts found expected "
                f"{verify_counts_data.num_registered=} is not equal to "
                f"{registered_found_real=} and/or {registered_found_mock=}"
            )

        if not (
            verify_counts_data.num_active == active_found_real == active_found_mock
        ):
            self.abort_all_f1_threads()
            raise InvalidConfigurationDetected(
                f"verify_counts found expected "
                f"{verify_counts_data.num_active=} is not equal to "
                f"{active_found_real=} and/or {active_found_mock=}"
            )

        if not (
            verify_counts_data.num_stopped == stopped_found_real == stopped_found_mock
        ):
            self.abort_all_f1_threads()
            raise InvalidConfigurationDetected(
                f"verify_counts found expected "
                f"{verify_counts_data.num_stopped=} is not equal to "
                f"{stopped_found_real=} and/or {stopped_found_mock=}"
            )

    ####################################################################
    # verify_def_del
    ####################################################################
    def verify_def_del(
        self,
        cmd_runner: str,
        def_del_scenario: DefDelScenario,
        receiver_names: list[str],
        sender_names: list[str],
        waiter_names: list[str],
        resumer_names: list[str],
        del_names: list[str],
        add_names: list[str],
        deleter_names: list[str],
        adder_names: list[str],
    ) -> None:
        """Verify that the given counts are correct.

        Args:
            cmd_runner: name of thread doing the cmd
            def_del_scenario: deferred delete scenario to verify
            receiver_names: names that do smart_recv
            sender_names: names that do smart_send
            waiter_names: names that do smart_wait
            resumer_names: names that do smart_resume
            del_names: names deleted during recv or wait
            add_names: names added during recv or wait
            deleter_names: names that do the delete
            adder_names: names that do the add

        Raises:
            FailedDefDelVerify: verify_def_del found neither smart_recv
                nor wait initial config_cmd log messages - one and only
                one is expected.
            InvalidConfigurationDetected: verify_def_del found pair_key
                is in real or mock pair array but is not in both

        """
        ################################################################
        # start by gathering log messages, both expected and not
        ################################################################
        ################################################################
        # get first config_cmd smart_recv log msg
        ################################################################
        group_name = "test1"
        search_msg = (
            r"config_cmd: RecvMsg\(serial=[0-9]+, line=[0-9]+, "
            f"cmd_runners='{receiver_names[0]}', "
            f"senders='{sender_names[0]}'"
        )

        cc_recv_0_log_msg, cc_recv_0_log_pos = self.get_log_msg(
            search_msg=search_msg,
            skip_num=0,
            start_idx=0,
            # end_idx=log_idx,
            reverse_search=False,
        )

        ################################################################
        # get first wait config_cmd log msg
        ################################################################
        search_msg = (
            r"config_cmd: Wait\(serial=[0-9]+, line=[0-9]+, "
            f"cmd_runners='{waiter_names[0]}', "
            f"resumers="
        )

        cc_wait_0_log_msg, cc_wait_0_log_pos = self.get_log_msg(
            search_msg=search_msg,
            skip_num=0,
            start_idx=0,
            # end_idx=log_idx,
            reverse_search=False,
        )

        if not cc_recv_0_log_msg and not cc_wait_0_log_msg:
            raise FailedDefDelVerify(
                "verify_def_del found neither smart_recv "
                "nor wait initial config_cmd log "
                "messages - one and only one is "
                "expected."
            )
        if cc_recv_0_log_msg:
            start_log_idx = cc_recv_0_log_pos + 1
        else:
            start_log_idx = cc_wait_0_log_pos + 1

        ################################################################
        # get config_cmd log msg for VerifyDefDel
        ################################################################
        search_msg = (
            r"config_cmd: VerifyDefDel\(serial=[0-9]+, line=[0-9]+, "
            f"cmd_runners='{self.commander_name}', "
            f"def_del_scenario="
        )

        cc_verify_dd_log_msg, cc_verify_dd_log_pos = self.get_log_msg(
            search_msg=search_msg,
            skip_num=0,
            start_idx=start_log_idx,
            # end_idx=log_idx,
            reverse_search=False,
        )

        if not cc_verify_dd_log_msg:
            raise FailedDefDelVerify(
                "verify_def_del failed to find the " "VerifyDefDel config_cmd log msg"
            )
        end_log_idx = cc_verify_dd_log_pos

        ################################################################
        # get first smart_recv log msg
        ################################################################
        search_msg = (
            rf"SmartThread {receiver_names[0]} \({group_name}\) smart_recv "
            f"received [0-9]+ msg[s]* from {sender_names[0]}"
        )

        recv_0_log_msg, recv_0_log_pos = self.get_log_msg(
            search_msg=search_msg,
            skip_num=0,
            start_idx=start_log_idx,
            end_idx=end_log_idx,
            reverse_search=False,
        )

        ################################################################
        # get first smart_recv pair array log msgs found
        ################################################################
        recv_0_pa_msgs_found = self.find_def_del_pair_array_msgs(
            cmd_runner=receiver_names[0],
            request_type=st.ReqType.Smart_recv,
            deleted_names=[sender_names[0], resumer_names[0]],
            def_del_names=receiver_names + waiter_names,
            start_log_idx=start_log_idx,
            end_log_idx=end_log_idx,
        )

        ################################################################
        # get second smart_recv log msg
        ################################################################
        search_msg = (
            rf"SmartThread {receiver_names[1]} \({group_name}\) smart_recv "
            f"received [0-9]+ msg[s]* from {sender_names[0]}"
        )

        recv_1_log_msg, recv_1_log_pos = self.get_log_msg(
            search_msg=search_msg,
            skip_num=0,
            start_idx=start_log_idx,
            end_idx=end_log_idx,
            reverse_search=False,
        )

        ################################################################
        # get second smart_recv pair array log msgs found
        ################################################################
        recv_1_pa_msgs_found = self.find_def_del_pair_array_msgs(
            cmd_runner=receiver_names[1],
            request_type=st.ReqType.Smart_recv,
            deleted_names=[sender_names[0], resumer_names[0]],
            def_del_names=receiver_names + waiter_names,
            start_log_idx=start_log_idx,
            end_log_idx=end_log_idx,
        )
        ################################################################
        # get first wait log msg
        ################################################################
        search_msg = (
            rf"SmartThread {waiter_names[0]} \({group_name}\) smart_wait "
            f"resumed by {resumer_names[0]}"
        )

        wait_0_log_msg, wait_0_log_pos = self.get_log_msg(
            search_msg=search_msg,
            skip_num=0,
            start_idx=start_log_idx,
            end_idx=end_log_idx,
            reverse_search=False,
        )

        ################################################################
        # get first wait pair array log msgs found
        ################################################################
        wait_0_pa_msgs_found = self.find_def_del_pair_array_msgs(
            cmd_runner=waiter_names[0],
            request_type=st.ReqType.Smart_wait,
            deleted_names=[sender_names[0], resumer_names[0]],
            def_del_names=receiver_names + waiter_names,
            start_log_idx=start_log_idx,
            end_log_idx=end_log_idx,
        )

        ################################################################
        # get second wait log msg
        ################################################################
        search_msg = (
            rf"SmartThread {waiter_names[1]} \({group_name}\) smart_wait "
            f"resumed by {resumer_names[0]}"
        )

        wait_1_log_msg, wait_1_log_pos = self.get_log_msg(
            search_msg=search_msg,
            skip_num=0,
            start_idx=start_log_idx,
            end_idx=end_log_idx,
            reverse_search=False,
        )

        ################################################################
        # get second wait pair array log msgs found
        ################################################################
        wait_1_pa_msgs_found = self.find_def_del_pair_array_msgs(
            cmd_runner=waiter_names[1],
            request_type=st.ReqType.Smart_wait,
            deleted_names=[sender_names[0], resumer_names[0]],
            def_del_names=receiver_names + waiter_names,
            start_log_idx=start_log_idx,
            end_log_idx=end_log_idx,
        )

        ################################################################
        # get join log msgs found
        ################################################################
        del_pa_msgs_found = self.find_def_del_pair_array_msgs(
            cmd_runner=deleter_names[0],
            request_type=st.ReqType.Smart_join,
            deleted_names=[sender_names[0], resumer_names[0]],
            def_del_names=receiver_names + waiter_names,
            start_log_idx=start_log_idx,
            end_log_idx=end_log_idx,
        )

        ################################################################
        # get add log msgs found
        ################################################################
        add_pa_msgs_found = self.find_def_del_pair_array_msgs(
            # cmd_runner=adder_names[0],
            cmd_runner=add_names[0],
            request_type=st.ReqType.Smart_init,
            deleted_names=[sender_names[0], resumer_names[0]],
            def_del_names=receiver_names + waiter_names,
            start_log_idx=start_log_idx,
            end_log_idx=end_log_idx,
        )

        ################################################################
        # verify real variables
        ################################################################
        pair_key_exists: dict[tuple[str, str], bool] = {}
        for deleted_name in sender_names + resumer_names:
            for def_del_name in receiver_names + waiter_names:
                pair_key = st.SmartThread._get_pair_key(
                    name0=deleted_name, name1=def_del_name
                )
                if pair_key in st.SmartThread._registry[self.group_name].pair_array:
                    pair_key_exists[pair_key] = True
                    if pair_key not in self.expected_pairs:
                        raise InvalidConfigurationDetected(
                            f"verify_def_del found {pair_key=} is in real "
                            "pair array but is not in mock pair array"
                        )
                else:
                    pair_key_exists[pair_key] = False
                    if pair_key in self.expected_pairs:
                        raise InvalidConfigurationDetected(
                            f"verify_def_del found {pair_key=} is not in "
                            "real pair array but is in mock pair array"
                        )

        ################################################################
        # verify for NormalRecv and ResurrectionRecv
        ################################################################
        if (
            def_del_scenario == DefDelScenario.NormalRecv
            or def_del_scenario == DefDelScenario.ResurrectionRecv
        ):
            if not recv_0_log_msg:
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} failed to find the "
                    "recv_0_log_msg"
                )
            if recv_1_log_msg or wait_0_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected log msg: "
                    f"{recv_1_log_msg=}, "
                    f"{wait_0_log_msg=}, "
                    f"{wait_1_log_msg=}"
                )

            if (
                recv_0_pa_msgs_found.entered_rpa
                or recv_0_pa_msgs_found.updated_pa
                or recv_1_pa_msgs_found.entered_rpa
                or recv_1_pa_msgs_found.updated_pa
                or wait_0_pa_msgs_found.entered_rpa
                or wait_0_pa_msgs_found.updated_pa
                or wait_1_pa_msgs_found.entered_rpa
                or wait_1_pa_msgs_found.updated_pa
                or del_pa_msgs_found.entered_rpa
                or del_pa_msgs_found.updated_pa
                or add_pa_msgs_found.entered_rpa
                or add_pa_msgs_found.updated_pa
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"{recv_0_pa_msgs_found.entered_rpa=}, "
                    f"{recv_0_pa_msgs_found.updated_pa=}, "
                    f"{recv_1_pa_msgs_found.updated_pa=}, "
                    f"{wait_0_pa_msgs_found.entered_rpa=}, "
                    f"{wait_0_pa_msgs_found.updated_pa=}, "
                    f"{wait_1_pa_msgs_found.entered_rpa=}, "
                    f"{wait_1_pa_msgs_found.updated_pa=}, "
                    f"{del_pa_msgs_found.entered_rpa=}, "
                    f"{del_pa_msgs_found.updated_pa=}, "
                    f"{add_pa_msgs_found.entered_rpa=}, "
                    f"{add_pa_msgs_found.updated_pa=}"
                )
            if (
                len(recv_0_pa_msgs_found.removed_sb_entry)
                or len(recv_0_pa_msgs_found.removed_pa_entry)
                or len(recv_1_pa_msgs_found.removed_sb_entry)
                or len(recv_1_pa_msgs_found.removed_pa_entry)
                or len(wait_0_pa_msgs_found.removed_sb_entry)
                or len(wait_0_pa_msgs_found.removed_pa_entry)
                or len(wait_1_pa_msgs_found.removed_sb_entry)
                or len(wait_1_pa_msgs_found.removed_pa_entry)
                or len(del_pa_msgs_found.removed_sb_entry)
                or len(del_pa_msgs_found.removed_pa_entry)
                or len(add_pa_msgs_found.removed_sb_entry)
                or len(add_pa_msgs_found.removed_pa_entry)
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"{recv_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{del_pa_msgs_found.removed_sb_entry=}, "
                    f"{del_pa_msgs_found.removed_pa_entry=}, "
                    f"{add_pa_msgs_found.removed_sb_entry=}, "
                    f"{add_pa_msgs_found.removed_pa_entry=}"
                )

        ################################################################
        # verify for NormalWait and ResurrectionWait
        ################################################################
        if (
            def_del_scenario == DefDelScenario.NormalWait
            or def_del_scenario == DefDelScenario.ResurrectionWait
        ):
            if not wait_0_log_msg:
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} failed to find the "
                    "recv_0_log_msg"
                )
            if recv_0_log_msg or recv_1_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected log msg: "
                    f"{recv_1_log_msg=}, "
                    f"{wait_0_log_msg=}, "
                    f"{wait_1_log_msg=}"
                )

            if (
                recv_0_pa_msgs_found.entered_rpa
                or recv_0_pa_msgs_found.updated_pa
                or recv_1_pa_msgs_found.entered_rpa
                or recv_1_pa_msgs_found.updated_pa
                or wait_0_pa_msgs_found.entered_rpa
                or wait_0_pa_msgs_found.updated_pa
                or wait_1_pa_msgs_found.entered_rpa
                or wait_1_pa_msgs_found.updated_pa
                or del_pa_msgs_found.entered_rpa
                or del_pa_msgs_found.updated_pa
                or add_pa_msgs_found.entered_rpa
                or add_pa_msgs_found.updated_pa
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"{recv_0_pa_msgs_found.entered_rpa=}, "
                    f"{recv_0_pa_msgs_found.updated_pa=}, "
                    f"{recv_1_pa_msgs_found.updated_pa=}, "
                    f"{wait_0_pa_msgs_found.entered_rpa=}, "
                    f"{wait_0_pa_msgs_found.updated_pa=}, "
                    f"{wait_1_pa_msgs_found.entered_rpa=}, "
                    f"{wait_1_pa_msgs_found.updated_pa=}, "
                    f"{del_pa_msgs_found.entered_rpa=}, "
                    f"{del_pa_msgs_found.updated_pa=}, "
                    f"{add_pa_msgs_found.entered_rpa=}, "
                    f"{add_pa_msgs_found.updated_pa=}"
                )

            if (
                len(recv_0_pa_msgs_found.removed_sb_entry)
                or len(recv_0_pa_msgs_found.removed_pa_entry)
                or len(recv_1_pa_msgs_found.removed_sb_entry)
                or len(recv_1_pa_msgs_found.removed_pa_entry)
                or len(wait_0_pa_msgs_found.removed_sb_entry)
                or len(wait_0_pa_msgs_found.removed_pa_entry)
                or len(wait_1_pa_msgs_found.removed_sb_entry)
                or len(wait_1_pa_msgs_found.removed_pa_entry)
                or len(del_pa_msgs_found.removed_sb_entry)
                or len(del_pa_msgs_found.removed_pa_entry)
                or len(add_pa_msgs_found.removed_sb_entry)
                or len(add_pa_msgs_found.removed_pa_entry)
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"{recv_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{del_pa_msgs_found.removed_sb_entry=}, "
                    f"{del_pa_msgs_found.removed_pa_entry=}, "
                    f"{add_pa_msgs_found.removed_sb_entry=}, "
                    f"{add_pa_msgs_found.removed_pa_entry=}"
                )

        ################################################################
        # verify for Recv0Recv1
        ################################################################
        if def_del_scenario == DefDelScenario.Recv0Recv1:
            if not (recv_0_log_msg and recv_1_log_msg):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} failed to find the "
                    "one or both recv messages:  "
                    f"{recv_0_log_msg=}, "
                    f"{recv_1_log_msg=}"
                )
            if wait_0_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected log msg: "
                    f"{wait_0_log_msg=}, "
                    f"{wait_1_log_msg=}"
                )

            if (
                (not recv_0_pa_msgs_found.entered_rpa)
                or (not recv_0_pa_msgs_found.updated_pa)
                or (not recv_1_pa_msgs_found.entered_rpa)
                or recv_1_pa_msgs_found.updated_pa
                or wait_0_pa_msgs_found.entered_rpa
                or wait_0_pa_msgs_found.updated_pa
                or wait_1_pa_msgs_found.entered_rpa
                or wait_1_pa_msgs_found.updated_pa
                or del_pa_msgs_found.entered_rpa
                or del_pa_msgs_found.updated_pa
                or add_pa_msgs_found.entered_rpa
                or add_pa_msgs_found.updated_pa
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"\n{recv_0_pa_msgs_found.entered_rpa=}, "
                    f"{recv_0_pa_msgs_found.updated_pa=}, "
                    f"\n{recv_1_pa_msgs_found.entered_rpa=}, "
                    f"{recv_1_pa_msgs_found.updated_pa=}, "
                    f"\n{wait_0_pa_msgs_found.entered_rpa=}, "
                    f"{wait_0_pa_msgs_found.updated_pa=}, "
                    f"\n{wait_1_pa_msgs_found.entered_rpa=}, "
                    f"{wait_1_pa_msgs_found.updated_pa=}, "
                    f"\n{del_pa_msgs_found.entered_rpa=}, "
                    f"{del_pa_msgs_found.updated_pa=}, "
                    f"\n{add_pa_msgs_found.entered_rpa=}, "
                    f"{add_pa_msgs_found.updated_pa=}"
                )
            if (
                (len(recv_0_pa_msgs_found.removed_sb_entry) == 0)
                or (len(recv_0_pa_msgs_found.removed_pa_entry) == 0)
                or len(recv_1_pa_msgs_found.removed_sb_entry)
                or len(recv_1_pa_msgs_found.removed_pa_entry)
                or len(wait_0_pa_msgs_found.removed_sb_entry)
                or len(wait_0_pa_msgs_found.removed_pa_entry)
                or len(wait_1_pa_msgs_found.removed_sb_entry)
                or len(wait_1_pa_msgs_found.removed_pa_entry)
                or len(del_pa_msgs_found.removed_sb_entry)
                or len(del_pa_msgs_found.removed_pa_entry)
                or len(add_pa_msgs_found.removed_sb_entry)
                or len(add_pa_msgs_found.removed_pa_entry)
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"\n{recv_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_0_pa_msgs_found.removed_pa_entry=}, "
                    f"\n{recv_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_pa_entry=}, "
                    f"\n{wait_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_pa_entry=}, "
                    f"\n{wait_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_pa_entry=}, "
                    f"\n{del_pa_msgs_found.removed_sb_entry=}, "
                    f"{del_pa_msgs_found.removed_pa_entry=}, "
                    f"\n{add_pa_msgs_found.removed_sb_entry=}, "
                    f"{add_pa_msgs_found.removed_pa_entry=}"
                )
            exp_pair_keys: list[st.PairKey] = []
            pair_key = st.SmartThread._get_pair_key(
                name0=sender_names[0], name1=receiver_names[0]
            )
            exp_pair_keys.append(pair_key)
            pair_key = st.SmartThread._get_pair_key(
                name0=sender_names[0], name1=receiver_names[1]
            )
            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (
                    pair_key not in recv_0_pa_msgs_found.removed_sb_entry
                    or pair_key not in recv_0_pa_msgs_found.removed_pa_entry
                ):
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from {exp_pair_keys=} is missing "
                        f"from {recv_0_pa_msgs_found.removed_sb_entry=} or "
                        f"{recv_0_pa_msgs_found.removed_pa_entry=}"
                    )
            for pair_key in recv_0_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{recv_0_pa_msgs_found.removed_sb_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )
            for pair_key in recv_0_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{recv_0_pa_msgs_found.removed_pa_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )

        ################################################################
        # verify for Recv1Recv0
        ################################################################
        if def_del_scenario == DefDelScenario.Recv1Recv0:
            if not (recv_0_log_msg and recv_1_log_msg):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} failed to find the "
                    "one or both recv messages:  "
                    f"{recv_0_log_msg=}, "
                    f"{recv_1_log_msg=}"
                )
            if wait_0_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected log msg: "
                    f"{wait_0_log_msg=}, "
                    f"{wait_1_log_msg=}"
                )

            if (
                (not recv_0_pa_msgs_found.entered_rpa)
                or recv_0_pa_msgs_found.updated_pa
                or (not recv_1_pa_msgs_found.entered_rpa)
                or (not recv_1_pa_msgs_found.updated_pa)
                or wait_0_pa_msgs_found.entered_rpa
                or wait_0_pa_msgs_found.updated_pa
                or wait_1_pa_msgs_found.entered_rpa
                or wait_1_pa_msgs_found.updated_pa
                or del_pa_msgs_found.entered_rpa
                or del_pa_msgs_found.updated_pa
                or add_pa_msgs_found.entered_rpa
                or add_pa_msgs_found.updated_pa
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"\n{recv_0_pa_msgs_found.entered_rpa=}, "
                    f"{recv_0_pa_msgs_found.updated_pa=}, "
                    f"\n{recv_1_pa_msgs_found.entered_rpa=}, "
                    f"{recv_1_pa_msgs_found.updated_pa=}, "
                    f"\n{wait_0_pa_msgs_found.entered_rpa=}, "
                    f"{wait_0_pa_msgs_found.updated_pa=}, "
                    f"\n{wait_1_pa_msgs_found.entered_rpa=}, "
                    f"{wait_1_pa_msgs_found.updated_pa=}, "
                    f"\n{del_pa_msgs_found.entered_rpa=}, "
                    f"{del_pa_msgs_found.updated_pa=}, "
                    f"\n{add_pa_msgs_found.entered_rpa=}, "
                    f"{add_pa_msgs_found.updated_pa=}"
                )
            if (
                len(recv_0_pa_msgs_found.removed_sb_entry)
                or len(recv_0_pa_msgs_found.removed_pa_entry)
                or (len(recv_1_pa_msgs_found.removed_sb_entry) == 0)
                or (len(recv_1_pa_msgs_found.removed_pa_entry) == 0)
                or len(wait_0_pa_msgs_found.removed_sb_entry)
                or len(wait_0_pa_msgs_found.removed_pa_entry)
                or len(wait_1_pa_msgs_found.removed_sb_entry)
                or len(wait_1_pa_msgs_found.removed_pa_entry)
                or len(del_pa_msgs_found.removed_sb_entry)
                or len(del_pa_msgs_found.removed_pa_entry)
                or len(add_pa_msgs_found.removed_sb_entry)
                or len(add_pa_msgs_found.removed_pa_entry)
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"{recv_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{del_pa_msgs_found.removed_sb_entry=}, "
                    f"{del_pa_msgs_found.removed_pa_entry=}, "
                    f"{add_pa_msgs_found.removed_sb_entry=}, "
                    f"{add_pa_msgs_found.removed_pa_entry=}"
                )
            exp_pair_keys = []
            pair_key = st.SmartThread._get_pair_key(
                name0=sender_names[0], name1=receiver_names[0]
            )
            exp_pair_keys.append(pair_key)
            pair_key = st.SmartThread._get_pair_key(
                name0=sender_names[0], name1=receiver_names[1]
            )
            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (
                    pair_key not in recv_1_pa_msgs_found.removed_sb_entry
                    or pair_key not in recv_1_pa_msgs_found.removed_pa_entry
                ):
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from {exp_pair_keys=} is missing "
                        f"from {recv_1_pa_msgs_found.removed_sb_entry=} or "
                        f"{recv_1_pa_msgs_found.removed_pa_entry=}"
                    )
            for pair_key in recv_1_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{recv_1_pa_msgs_found.removed_sb_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )
            for pair_key in recv_1_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{recv_1_pa_msgs_found.removed_pa_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )

        ################################################################
        # verify for Wait0Wait1
        ################################################################
        if def_del_scenario == DefDelScenario.Wait0Wait1:
            if not (wait_0_log_msg and wait_1_log_msg):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} failed to find the "
                    "one or both wait messages:  "
                    f"{wait_0_log_msg=}, "
                    f"{wait_1_log_msg=}"
                )
            if recv_0_log_msg or recv_1_log_msg:
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected log msg: "
                    f"{recv_0_log_msg=}, "
                    f"{recv_1_log_msg=}"
                )

            if (
                recv_0_pa_msgs_found.entered_rpa
                or recv_0_pa_msgs_found.updated_pa
                or recv_1_pa_msgs_found.entered_rpa
                or recv_1_pa_msgs_found.updated_pa
                or (not wait_0_pa_msgs_found.entered_rpa)
                or (not wait_0_pa_msgs_found.updated_pa)
                or (not wait_1_pa_msgs_found.entered_rpa)
                or wait_1_pa_msgs_found.updated_pa
                or del_pa_msgs_found.entered_rpa
                or del_pa_msgs_found.updated_pa
                or add_pa_msgs_found.entered_rpa
                or add_pa_msgs_found.updated_pa
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"{recv_0_pa_msgs_found.entered_rpa=}, "
                    f"{recv_0_pa_msgs_found.updated_pa=}, "
                    f"{recv_1_pa_msgs_found.updated_pa=}, "
                    f"{wait_0_pa_msgs_found.entered_rpa=}, "
                    f"{wait_0_pa_msgs_found.updated_pa=}, "
                    f"{wait_1_pa_msgs_found.entered_rpa=}, "
                    f"{wait_1_pa_msgs_found.updated_pa=}, "
                    f"{del_pa_msgs_found.entered_rpa=}, "
                    f"{del_pa_msgs_found.updated_pa=}, "
                    f"{add_pa_msgs_found.entered_rpa=}, "
                    f"{add_pa_msgs_found.updated_pa=}"
                )
            if (
                len(recv_0_pa_msgs_found.removed_sb_entry)
                or len(recv_0_pa_msgs_found.removed_pa_entry)
                or len(recv_1_pa_msgs_found.removed_sb_entry)
                or len(recv_1_pa_msgs_found.removed_pa_entry)
                or (len(wait_0_pa_msgs_found.removed_sb_entry) == 0)
                or (len(wait_0_pa_msgs_found.removed_pa_entry) == 0)
                or len(wait_1_pa_msgs_found.removed_sb_entry)
                or len(wait_1_pa_msgs_found.removed_pa_entry)
                or len(del_pa_msgs_found.removed_sb_entry)
                or len(del_pa_msgs_found.removed_pa_entry)
                or len(add_pa_msgs_found.removed_sb_entry)
                or len(add_pa_msgs_found.removed_pa_entry)
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"{recv_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{del_pa_msgs_found.removed_sb_entry=}, "
                    f"{del_pa_msgs_found.removed_pa_entry=}, "
                    f"{add_pa_msgs_found.removed_sb_entry=}, "
                    f"{add_pa_msgs_found.removed_pa_entry=}"
                )
            exp_pair_keys = []
            pair_key = st.SmartThread._get_pair_key(
                name0=resumer_names[0], name1=waiter_names[0]
            )
            exp_pair_keys.append(pair_key)
            pair_key = st.SmartThread._get_pair_key(
                name0=resumer_names[0], name1=waiter_names[1]
            )
            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (
                    pair_key not in wait_0_pa_msgs_found.removed_sb_entry
                    or pair_key not in wait_0_pa_msgs_found.removed_pa_entry
                ):
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from {exp_pair_keys=} is missing "
                        f"from {wait_0_pa_msgs_found.removed_sb_entry=} or "
                        f"{wait_0_pa_msgs_found.removed_pa_entry=}"
                    )
            for pair_key in wait_0_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{wait_0_pa_msgs_found.removed_sb_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )
            for pair_key in wait_0_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{wait_0_pa_msgs_found.removed_pa_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )

        ################################################################
        # verify for Wait1Wait0
        ################################################################
        if def_del_scenario == DefDelScenario.Wait1Wait0:
            if not (wait_0_log_msg and wait_1_log_msg):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} failed to find the "
                    "one or both wait messages:  "
                    f"{wait_0_log_msg=}, "
                    f"{wait_1_log_msg=}"
                )
            if recv_0_log_msg or recv_1_log_msg:
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected log msg: "
                    f"{recv_0_log_msg=}, "
                    f"{recv_1_log_msg=}"
                )

            if (
                recv_0_pa_msgs_found.entered_rpa
                or recv_0_pa_msgs_found.updated_pa
                or recv_1_pa_msgs_found.entered_rpa
                or recv_1_pa_msgs_found.updated_pa
                or (not wait_0_pa_msgs_found.entered_rpa)
                or wait_0_pa_msgs_found.updated_pa
                or (not wait_1_pa_msgs_found.entered_rpa)
                or (not wait_1_pa_msgs_found.updated_pa)
                or del_pa_msgs_found.entered_rpa
                or del_pa_msgs_found.updated_pa
                or add_pa_msgs_found.entered_rpa
                or add_pa_msgs_found.updated_pa
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"{recv_0_pa_msgs_found.entered_rpa=}, "
                    f"{recv_0_pa_msgs_found.updated_pa=}, "
                    f"{recv_1_pa_msgs_found.updated_pa=}, "
                    f"{wait_0_pa_msgs_found.entered_rpa=}, "
                    f"{wait_0_pa_msgs_found.updated_pa=}, "
                    f"{wait_1_pa_msgs_found.entered_rpa=}, "
                    f"{wait_1_pa_msgs_found.updated_pa=}, "
                    f"{del_pa_msgs_found.entered_rpa=}, "
                    f"{del_pa_msgs_found.updated_pa=}, "
                    f"{add_pa_msgs_found.entered_rpa=}, "
                    f"{add_pa_msgs_found.updated_pa=}"
                )
            if (
                len(recv_0_pa_msgs_found.removed_sb_entry)
                or len(recv_0_pa_msgs_found.removed_pa_entry)
                or len(recv_1_pa_msgs_found.removed_sb_entry)
                or len(recv_1_pa_msgs_found.removed_pa_entry)
                or len(wait_0_pa_msgs_found.removed_sb_entry)
                or len(wait_0_pa_msgs_found.removed_pa_entry)
                or (len(wait_1_pa_msgs_found.removed_sb_entry) == 0)
                or (len(wait_1_pa_msgs_found.removed_pa_entry) == 0)
                or len(del_pa_msgs_found.removed_sb_entry)
                or len(del_pa_msgs_found.removed_pa_entry)
                or len(add_pa_msgs_found.removed_sb_entry)
                or len(add_pa_msgs_found.removed_pa_entry)
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"{recv_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{del_pa_msgs_found.removed_sb_entry=}, "
                    f"{del_pa_msgs_found.removed_pa_entry=}, "
                    f"{add_pa_msgs_found.removed_sb_entry=}, "
                    f"{add_pa_msgs_found.removed_pa_entry=}"
                )
            exp_pair_keys = []
            pair_key = st.SmartThread._get_pair_key(
                name0=resumer_names[0], name1=waiter_names[0]
            )
            exp_pair_keys.append(pair_key)
            pair_key = st.SmartThread._get_pair_key(
                name0=resumer_names[0], name1=waiter_names[1]
            )
            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (
                    pair_key not in wait_1_pa_msgs_found.removed_sb_entry
                    or pair_key not in wait_1_pa_msgs_found.removed_pa_entry
                ):
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from {exp_pair_keys=} is missing "
                        f"from {wait_1_pa_msgs_found.removed_sb_entry=} or "
                        f"{wait_1_pa_msgs_found.removed_pa_entry=}"
                    )
            for pair_key in wait_1_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{wait_1_pa_msgs_found.removed_sb_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )
            for pair_key in wait_1_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{wait_1_pa_msgs_found.removed_pa_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )

        ################################################################
        # verify for RecvWait
        ################################################################
        if def_del_scenario == DefDelScenario.RecvWait:
            if not (recv_0_log_msg and wait_0_log_msg):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} failed to find the "
                    "one or both wait messages:  "
                    f"{recv_0_log_msg=}, "
                    f"{wait_0_log_msg=}"
                )
            if recv_1_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected log msg: "
                    f"{recv_1_log_msg=}, "
                    f"{wait_1_log_msg=}"
                )

            if (
                (not recv_0_pa_msgs_found.entered_rpa)
                or (not recv_0_pa_msgs_found.updated_pa)
                or recv_1_pa_msgs_found.entered_rpa
                or recv_1_pa_msgs_found.updated_pa
                or (not wait_0_pa_msgs_found.entered_rpa)
                or wait_0_pa_msgs_found.updated_pa
                or wait_1_pa_msgs_found.entered_rpa
                or wait_1_pa_msgs_found.updated_pa
                or del_pa_msgs_found.entered_rpa
                or del_pa_msgs_found.updated_pa
                or add_pa_msgs_found.entered_rpa
                or add_pa_msgs_found.updated_pa
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"{recv_0_pa_msgs_found.entered_rpa=}, "
                    f"{recv_0_pa_msgs_found.updated_pa=}, "
                    f"{recv_1_pa_msgs_found.updated_pa=}, "
                    f"{wait_0_pa_msgs_found.entered_rpa=}, "
                    f"{wait_0_pa_msgs_found.updated_pa=}, "
                    f"{wait_1_pa_msgs_found.entered_rpa=}, "
                    f"{wait_1_pa_msgs_found.updated_pa=}, "
                    f"{del_pa_msgs_found.entered_rpa=}, "
                    f"{del_pa_msgs_found.updated_pa=}, "
                    f"{add_pa_msgs_found.entered_rpa=}, "
                    f"{add_pa_msgs_found.updated_pa=}"
                )
            if (
                (len(recv_0_pa_msgs_found.removed_sb_entry) == 0)
                or (len(recv_0_pa_msgs_found.removed_pa_entry) == 0)
                or len(recv_1_pa_msgs_found.removed_sb_entry)
                or len(recv_1_pa_msgs_found.removed_pa_entry)
                or len(wait_0_pa_msgs_found.removed_sb_entry)
                or len(wait_0_pa_msgs_found.removed_pa_entry)
                or len(wait_1_pa_msgs_found.removed_sb_entry)
                or len(wait_1_pa_msgs_found.removed_pa_entry)
                or len(del_pa_msgs_found.removed_sb_entry)
                or len(del_pa_msgs_found.removed_pa_entry)
                or len(add_pa_msgs_found.removed_sb_entry)
                or len(add_pa_msgs_found.removed_pa_entry)
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"{recv_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{del_pa_msgs_found.removed_sb_entry=}, "
                    f"{del_pa_msgs_found.removed_pa_entry=}, "
                    f"{add_pa_msgs_found.removed_sb_entry=}, "
                    f"{add_pa_msgs_found.removed_pa_entry=}"
                )
            exp_pair_keys = []
            pair_key = st.SmartThread._get_pair_key(
                name0=sender_names[0], name1=receiver_names[0]
            )
            exp_pair_keys.append(pair_key)
            pair_key = st.SmartThread._get_pair_key(
                name0=resumer_names[0], name1=waiter_names[0]
            )
            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (
                    pair_key not in recv_0_pa_msgs_found.removed_sb_entry
                    or pair_key not in recv_0_pa_msgs_found.removed_pa_entry
                ):
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from {exp_pair_keys=} is missing "
                        f"from {recv_0_pa_msgs_found.removed_sb_entry=} or "
                        f"{recv_0_pa_msgs_found.removed_pa_entry=}"
                    )
            for pair_key in recv_0_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{recv_0_pa_msgs_found.removed_sb_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )
            for pair_key in recv_0_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{recv_0_pa_msgs_found.removed_pa_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )

        ################################################################
        # verify for WaitRecv
        ################################################################
        if def_del_scenario == DefDelScenario.WaitRecv:
            if not (recv_0_log_msg and wait_0_log_msg):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} failed to find the "
                    "one or both wait messages:  "
                    f"{recv_0_log_msg=}, "
                    f"{wait_0_log_msg=}"
                )
            if recv_1_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected log msg: "
                    f"{recv_1_log_msg=}, "
                    f"{wait_1_log_msg=}"
                )

            if (
                (not recv_0_pa_msgs_found.entered_rpa)
                or recv_0_pa_msgs_found.updated_pa
                or recv_1_pa_msgs_found.entered_rpa
                or recv_1_pa_msgs_found.updated_pa
                or (not wait_0_pa_msgs_found.entered_rpa)
                or (not wait_0_pa_msgs_found.updated_pa)
                or wait_1_pa_msgs_found.entered_rpa
                or wait_1_pa_msgs_found.updated_pa
                or del_pa_msgs_found.entered_rpa
                or del_pa_msgs_found.updated_pa
                or add_pa_msgs_found.entered_rpa
                or add_pa_msgs_found.updated_pa
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"{recv_0_pa_msgs_found.entered_rpa=}, "
                    f"{recv_0_pa_msgs_found.updated_pa=}, "
                    f"{recv_1_pa_msgs_found.updated_pa=}, "
                    f"{wait_0_pa_msgs_found.entered_rpa=}, "
                    f"{wait_0_pa_msgs_found.updated_pa=}, "
                    f"{wait_1_pa_msgs_found.entered_rpa=}, "
                    f"{wait_1_pa_msgs_found.updated_pa=}, "
                    f"{del_pa_msgs_found.entered_rpa=}, "
                    f"{del_pa_msgs_found.updated_pa=}, "
                    f"{add_pa_msgs_found.entered_rpa=}, "
                    f"{add_pa_msgs_found.updated_pa=}"
                )
            if (
                len(recv_0_pa_msgs_found.removed_sb_entry)
                or len(recv_0_pa_msgs_found.removed_pa_entry)
                or len(recv_1_pa_msgs_found.removed_sb_entry)
                or len(recv_1_pa_msgs_found.removed_pa_entry)
                or (len(wait_0_pa_msgs_found.removed_sb_entry) == 0)
                or (len(wait_0_pa_msgs_found.removed_pa_entry) == 0)
                or len(wait_1_pa_msgs_found.removed_sb_entry)
                or len(wait_1_pa_msgs_found.removed_pa_entry)
                or len(del_pa_msgs_found.removed_sb_entry)
                or len(del_pa_msgs_found.removed_pa_entry)
                or len(add_pa_msgs_found.removed_sb_entry)
                or len(add_pa_msgs_found.removed_pa_entry)
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"{recv_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{del_pa_msgs_found.removed_sb_entry=}, "
                    f"{del_pa_msgs_found.removed_pa_entry=}, "
                    f"{add_pa_msgs_found.removed_sb_entry=}, "
                    f"{add_pa_msgs_found.removed_pa_entry=}"
                )
            exp_pair_keys = []
            pair_key = st.SmartThread._get_pair_key(
                name0=sender_names[0], name1=receiver_names[0]
            )
            exp_pair_keys.append(pair_key)
            pair_key = st.SmartThread._get_pair_key(
                name0=resumer_names[0], name1=waiter_names[0]
            )
            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (
                    pair_key not in wait_0_pa_msgs_found.removed_sb_entry
                    or pair_key not in wait_0_pa_msgs_found.removed_pa_entry
                ):
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from {exp_pair_keys=} is missing "
                        f"from {wait_0_pa_msgs_found.removed_sb_entry=} or "
                        f"{wait_0_pa_msgs_found.removed_pa_entry=}"
                    )
            for pair_key in wait_0_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{wait_0_pa_msgs_found.removed_sb_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )
            for pair_key in wait_0_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{wait_0_pa_msgs_found.removed_pa_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )

        ################################################################
        # verify for RecvDel
        ################################################################
        if def_del_scenario == DefDelScenario.RecvDel:
            if not recv_0_log_msg:
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} failed to find the "
                    "recv message:  "
                    f"{recv_0_log_msg=}"
                )
            if recv_1_log_msg or wait_0_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected log msg: "
                    f"{recv_1_log_msg=}, "
                    f"{wait_0_log_msg=}, "
                    f"{wait_1_log_msg=}"
                )

            if (
                (not recv_0_pa_msgs_found.entered_rpa)
                or recv_0_pa_msgs_found.updated_pa
                or recv_1_pa_msgs_found.entered_rpa
                or recv_1_pa_msgs_found.updated_pa
                or wait_0_pa_msgs_found.entered_rpa
                or wait_0_pa_msgs_found.updated_pa
                or wait_1_pa_msgs_found.entered_rpa
                or wait_1_pa_msgs_found.updated_pa
                or (not del_pa_msgs_found.entered_rpa)
                or (not del_pa_msgs_found.updated_pa)
                or add_pa_msgs_found.entered_rpa
                or add_pa_msgs_found.updated_pa
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"\n{recv_0_pa_msgs_found.entered_rpa=}, "
                    f"{recv_0_pa_msgs_found.updated_pa=}, "
                    f"\n{recv_1_pa_msgs_found.entered_rpa=}, "
                    f"{recv_1_pa_msgs_found.updated_pa=}, "
                    f"\n{wait_0_pa_msgs_found.entered_rpa=}, "
                    f"{wait_0_pa_msgs_found.updated_pa=}, "
                    f"\n{wait_1_pa_msgs_found.entered_rpa=}, "
                    f"{wait_1_pa_msgs_found.updated_pa=}, "
                    f"\n{del_pa_msgs_found.entered_rpa=}, "
                    f"{del_pa_msgs_found.updated_pa=}, "
                    f"\n{add_pa_msgs_found.entered_rpa=}, "
                    f"{add_pa_msgs_found.updated_pa=}"
                )
            if (
                len(recv_0_pa_msgs_found.removed_sb_entry)
                or len(recv_0_pa_msgs_found.removed_pa_entry)
                or len(recv_1_pa_msgs_found.removed_sb_entry)
                or len(recv_1_pa_msgs_found.removed_pa_entry)
                or len(wait_0_pa_msgs_found.removed_sb_entry)
                or len(wait_0_pa_msgs_found.removed_pa_entry)
                or len(wait_1_pa_msgs_found.removed_sb_entry)
                or len(wait_1_pa_msgs_found.removed_pa_entry)
                or (len(del_pa_msgs_found.removed_sb_entry) == 0)
                or (len(del_pa_msgs_found.removed_pa_entry) == 0)
                or len(add_pa_msgs_found.removed_sb_entry)
                or len(add_pa_msgs_found.removed_pa_entry)
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"{recv_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{del_pa_msgs_found.removed_sb_entry=}, "
                    f"{del_pa_msgs_found.removed_pa_entry=}, "
                    f"{add_pa_msgs_found.removed_sb_entry=}, "
                    f"{add_pa_msgs_found.removed_pa_entry=}"
                )
            exp_pair_keys = []
            pair_key = st.SmartThread._get_pair_key(
                name0=sender_names[0], name1=receiver_names[0]
            )

            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (
                    pair_key not in del_pa_msgs_found.removed_sb_entry
                    or pair_key not in del_pa_msgs_found.removed_pa_entry
                ):
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from {exp_pair_keys=} is missing "
                        f"from {del_pa_msgs_found.removed_sb_entry=} or "
                        f"{del_pa_msgs_found.removed_pa_entry=}"
                    )
            for pair_key in del_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{del_pa_msgs_found.removed_sb_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )
            for pair_key in del_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{del_pa_msgs_found.removed_pa_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )

        ################################################################
        # verify for RecvAdd
        ################################################################
        if def_del_scenario == DefDelScenario.RecvAdd:
            if not recv_0_log_msg:
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} failed to find the "
                    "recv message:  "
                    f"{recv_0_log_msg=}"
                )
            if recv_1_log_msg or wait_0_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected log msg: "
                    f"{recv_1_log_msg=}, "
                    f"{wait_0_log_msg=}, "
                    f"{wait_1_log_msg=}"
                )

            if (
                not recv_0_pa_msgs_found.entered_rpa
                or recv_0_pa_msgs_found.updated_pa
                or recv_1_pa_msgs_found.entered_rpa
                or recv_1_pa_msgs_found.updated_pa
                or wait_0_pa_msgs_found.entered_rpa
                or wait_0_pa_msgs_found.updated_pa
                or wait_1_pa_msgs_found.entered_rpa
                or wait_1_pa_msgs_found.updated_pa
                or del_pa_msgs_found.entered_rpa
                or del_pa_msgs_found.updated_pa
                or not add_pa_msgs_found.entered_rpa
                or not add_pa_msgs_found.updated_pa
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"\n{recv_0_pa_msgs_found.entered_rpa=}, "
                    f"{recv_0_pa_msgs_found.updated_pa=}, "
                    f"\n{recv_1_pa_msgs_found.entered_rpa=}, "
                    f"{recv_1_pa_msgs_found.updated_pa=}, "
                    f"\n{wait_0_pa_msgs_found.entered_rpa=}, "
                    f"{wait_0_pa_msgs_found.updated_pa=}, "
                    f"\n{wait_1_pa_msgs_found.entered_rpa=}, "
                    f"{wait_1_pa_msgs_found.updated_pa=}, "
                    f"\n{del_pa_msgs_found.entered_rpa=}, "
                    f"{del_pa_msgs_found.updated_pa=}, "
                    f"\n{add_pa_msgs_found.entered_rpa=}, "
                    f"{add_pa_msgs_found.updated_pa=}"
                )
            if (
                len(recv_0_pa_msgs_found.removed_sb_entry)
                or len(recv_0_pa_msgs_found.removed_pa_entry)
                or len(recv_1_pa_msgs_found.removed_sb_entry)
                or len(recv_1_pa_msgs_found.removed_pa_entry)
                or len(wait_0_pa_msgs_found.removed_sb_entry)
                or len(wait_0_pa_msgs_found.removed_pa_entry)
                or len(wait_1_pa_msgs_found.removed_sb_entry)
                or len(wait_1_pa_msgs_found.removed_pa_entry)
                or len(del_pa_msgs_found.removed_sb_entry)
                or len(del_pa_msgs_found.removed_pa_entry)
                or (len(add_pa_msgs_found.removed_sb_entry) == 0)
                or (len(add_pa_msgs_found.removed_pa_entry) == 0)
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"{recv_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{del_pa_msgs_found.removed_sb_entry=}, "
                    f"{del_pa_msgs_found.removed_pa_entry=}, "
                    f"{add_pa_msgs_found.removed_sb_entry=}, "
                    f"{add_pa_msgs_found.removed_pa_entry=}"
                )
            exp_pair_keys = []
            pair_key = st.SmartThread._get_pair_key(
                name0=sender_names[0], name1=receiver_names[0]
            )

            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (
                    pair_key not in add_pa_msgs_found.removed_sb_entry
                    or pair_key not in add_pa_msgs_found.removed_pa_entry
                ):
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from {exp_pair_keys=} is missing "
                        f"from {add_pa_msgs_found.removed_sb_entry=} or "
                        f"{add_pa_msgs_found.removed_pa_entry=}"
                    )
            for pair_key in add_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{add_pa_msgs_found.removed_sb_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )
            for pair_key in add_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{add_pa_msgs_found.removed_pa_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )

        ################################################################
        # verify for WaitDel
        ################################################################
        if def_del_scenario == DefDelScenario.WaitDel:
            if not wait_0_log_msg:
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} failed to find the "
                    "wait message:  "
                    f"{wait_0_log_msg=}"
                )
            if recv_0_log_msg or recv_1_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected log msg: "
                    f"{recv_0_log_msg=}, "
                    f"{recv_1_log_msg=}, "
                    f"{wait_1_log_msg=}"
                )

            if (
                recv_0_pa_msgs_found.entered_rpa
                or recv_0_pa_msgs_found.updated_pa
                or recv_1_pa_msgs_found.entered_rpa
                or recv_1_pa_msgs_found.updated_pa
                or (not wait_0_pa_msgs_found.entered_rpa)
                or wait_0_pa_msgs_found.updated_pa
                or wait_1_pa_msgs_found.entered_rpa
                or wait_1_pa_msgs_found.updated_pa
                or (not del_pa_msgs_found.entered_rpa)
                or (not del_pa_msgs_found.updated_pa)
                or add_pa_msgs_found.entered_rpa
                or add_pa_msgs_found.updated_pa
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"{recv_0_pa_msgs_found.entered_rpa=}, "
                    f"{recv_0_pa_msgs_found.updated_pa=}, "
                    f"{recv_1_pa_msgs_found.updated_pa=}, "
                    f"{wait_0_pa_msgs_found.entered_rpa=}, "
                    f"{wait_0_pa_msgs_found.updated_pa=}, "
                    f"{wait_1_pa_msgs_found.entered_rpa=}, "
                    f"{wait_1_pa_msgs_found.updated_pa=}, "
                    f"{del_pa_msgs_found.entered_rpa=}, "
                    f"{del_pa_msgs_found.updated_pa=}, "
                    f"{add_pa_msgs_found.entered_rpa=}, "
                    f"{add_pa_msgs_found.updated_pa=}"
                )
            if (
                len(recv_0_pa_msgs_found.removed_sb_entry)
                or len(recv_0_pa_msgs_found.removed_pa_entry)
                or len(recv_1_pa_msgs_found.removed_sb_entry)
                or len(recv_1_pa_msgs_found.removed_pa_entry)
                or len(wait_0_pa_msgs_found.removed_sb_entry)
                or len(wait_0_pa_msgs_found.removed_pa_entry)
                or len(wait_1_pa_msgs_found.removed_sb_entry)
                or len(wait_1_pa_msgs_found.removed_pa_entry)
                or (len(del_pa_msgs_found.removed_sb_entry) == 0)
                or (len(del_pa_msgs_found.removed_pa_entry) == 0)
                or len(add_pa_msgs_found.removed_sb_entry)
                or len(add_pa_msgs_found.removed_pa_entry)
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"{recv_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{del_pa_msgs_found.removed_sb_entry=}, "
                    f"{del_pa_msgs_found.removed_pa_entry=}, "
                    f"{add_pa_msgs_found.removed_sb_entry=}, "
                    f"{add_pa_msgs_found.removed_pa_entry=}"
                )
            exp_pair_keys = []
            pair_key = st.SmartThread._get_pair_key(
                name0=resumer_names[0], name1=waiter_names[0]
            )

            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (
                    pair_key not in del_pa_msgs_found.removed_sb_entry
                    or pair_key not in del_pa_msgs_found.removed_pa_entry
                ):
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from {exp_pair_keys=} is missing "
                        f"from {del_pa_msgs_found.removed_sb_entry=} or "
                        f"{del_pa_msgs_found.removed_pa_entry=}"
                    )
            for pair_key in del_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{del_pa_msgs_found.removed_sb_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )
            for pair_key in del_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{del_pa_msgs_found.removed_pa_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )

        ################################################################
        # verify for WaitAdd
        ################################################################
        if def_del_scenario == DefDelScenario.WaitAdd:
            if not wait_0_log_msg:
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} failed to find the "
                    "recv message:  "
                    f"{wait_0_log_msg=}"
                )
            if recv_0_log_msg or recv_1_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected log msg: "
                    f"{recv_0_log_msg=}, "
                    f"{recv_1_log_msg=}, "
                    f"{wait_1_log_msg=}"
                )

            if (
                recv_0_pa_msgs_found.entered_rpa
                or recv_0_pa_msgs_found.updated_pa
                or recv_1_pa_msgs_found.entered_rpa
                or recv_1_pa_msgs_found.updated_pa
                or not wait_0_pa_msgs_found.entered_rpa
                or wait_0_pa_msgs_found.updated_pa
                or wait_1_pa_msgs_found.entered_rpa
                or wait_1_pa_msgs_found.updated_pa
                or del_pa_msgs_found.entered_rpa
                or del_pa_msgs_found.updated_pa
                or not add_pa_msgs_found.entered_rpa
                or not add_pa_msgs_found.updated_pa
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"\n{recv_0_pa_msgs_found.entered_rpa=}, "
                    f"{recv_0_pa_msgs_found.updated_pa=}, "
                    f"\n{recv_1_pa_msgs_found.entered_rpa=}, "
                    f"{recv_1_pa_msgs_found.updated_pa=}, "
                    f"\n{wait_0_pa_msgs_found.entered_rpa=}, "
                    f"{wait_0_pa_msgs_found.updated_pa=}, "
                    f"\n{wait_1_pa_msgs_found.entered_rpa=}, "
                    f"{wait_1_pa_msgs_found.updated_pa=}, "
                    f"\n{del_pa_msgs_found.entered_rpa=}, "
                    f"{del_pa_msgs_found.updated_pa=}, "
                    f"\n{add_pa_msgs_found.entered_rpa=}, "
                    f"{add_pa_msgs_found.updated_pa=}"
                )
            if (
                len(recv_0_pa_msgs_found.removed_sb_entry)
                or len(recv_0_pa_msgs_found.removed_pa_entry)
                or len(recv_1_pa_msgs_found.removed_sb_entry)
                or len(recv_1_pa_msgs_found.removed_pa_entry)
                or len(wait_0_pa_msgs_found.removed_sb_entry)
                or len(wait_0_pa_msgs_found.removed_pa_entry)
                or len(wait_1_pa_msgs_found.removed_sb_entry)
                or len(wait_1_pa_msgs_found.removed_pa_entry)
                or len(del_pa_msgs_found.removed_sb_entry)
                or len(del_pa_msgs_found.removed_pa_entry)
                or (len(add_pa_msgs_found.removed_sb_entry) == 0)
                or (len(add_pa_msgs_found.removed_pa_entry) == 0)
            ):
                raise FailedDefDelVerify(
                    f"verify_def_del {def_del_scenario=} found an "
                    "unexpected pair array activity "
                    f"{recv_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{recv_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_0_pa_msgs_found.removed_pa_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_sb_entry=}, "
                    f"{wait_1_pa_msgs_found.removed_pa_entry=}, "
                    f"{del_pa_msgs_found.removed_sb_entry=}, "
                    f"{del_pa_msgs_found.removed_pa_entry=}, "
                    f"{add_pa_msgs_found.removed_sb_entry=}, "
                    f"{add_pa_msgs_found.removed_pa_entry=}"
                )
            exp_pair_keys = []
            pair_key = st.SmartThread._get_pair_key(
                name0=resumer_names[0], name1=waiter_names[0]
            )

            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (
                    pair_key not in add_pa_msgs_found.removed_sb_entry
                    or pair_key not in add_pa_msgs_found.removed_pa_entry
                ):
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from {exp_pair_keys=} is missing "
                        f"from {add_pa_msgs_found.removed_sb_entry=} or "
                        f"{add_pa_msgs_found.removed_pa_entry=}"
                    )
            for pair_key in add_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{add_pa_msgs_found.removed_sb_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )
            for pair_key in add_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f"verify_def_del {def_del_scenario=} detected "
                        f"that {pair_key=} from "
                        f"{add_pa_msgs_found.removed_pa_entry=} is "
                        f"missing from {exp_pair_keys=}"
                    )

    ####################################################################
    # find_pair_array_msgs
    ####################################################################
    def find_def_del_pair_array_msgs(
        self,
        cmd_runner: str,
        request_type: st.ReqType,
        deleted_names: list[str],
        def_del_names: list[str],
        start_log_idx: int,
        end_log_idx: int,
    ) -> PaLogMsgsFound:
        """Find pair array update log msgs for the given names.

        Args:
            cmd_runner: name of thread doing the pair array updates
            request_type: the ReqType for the request
            deleted_names: names of threads that were previously deleted
                that caused the def_del_names to be a deferred delete
            def_del_names: names of deferred delete threads
            start_log_idx: index of where to start the log msgs search
            end_log_idx: index where to stop the log msgs search

        Returns:
            a set of bool indicators for which messages were found
        """
        ################################################################
        # find entered refresh pair array log msg
        ################################################################
        group_name = "test1"
        search_msg = (
            f"{request_type.value} _clean_pair_array entry: {cmd_runner} "
            rf"\({group_name}\)"
        )

        log_msg, log_pos = self.get_log_msg(
            search_msg=search_msg,
            skip_num=0,
            start_idx=start_log_idx,
            end_idx=end_log_idx,
            reverse_search=False,
        )

        if log_msg:
            entered_rpa_log_msg_found = True
        else:
            entered_rpa_log_msg_found = False

        ################################################################
        # find removed status_blocks entry log msgs
        ################################################################
        found_removed_status_block_msgs: list[st.PairKey] = []
        found_removed_pa_entry_msgs: list[st.PairKey] = []
        for deleted_name in deleted_names:
            for def_del_name in def_del_names:
                pair_key = st.SmartThread._get_pair_key(
                    name0=deleted_name, name1=def_del_name
                )
                search_msg1 = (
                    rf"SmartThread {cmd_runner} \({group_name}\) removed "
                    "status_blocks entry for "
                    rf"PairKey\(name0='{pair_key[0]}', "
                    rf"name1='{pair_key[1]}'\), "
                    f"name = {def_del_name}"
                )

                search_msg2 = (
                    rf"SmartThread {cmd_runner} \({group_name}\) removed "
                    "_pair_array entry for "
                    rf"PairKey\(name0='{pair_key[0]}', "
                    rf"name1='{pair_key[1]}'\)"
                )

                log_msg1, log_pos1 = self.get_log_msg(
                    search_msg=search_msg1,
                    skip_num=0,
                    start_idx=start_log_idx,
                    end_idx=end_log_idx,
                    reverse_search=False,
                )

                if log_msg1:
                    found_removed_status_block_msgs.append(pair_key)

                log_msg2, log_pos2 = self.get_log_msg(
                    search_msg=search_msg2,
                    skip_num=0,
                    start_idx=start_log_idx,
                    end_idx=end_log_idx,
                    reverse_search=False,
                )

                if log_msg2:
                    found_removed_pa_entry_msgs.append(pair_key)

        ################################################################
        # get updated pair array log msg
        ################################################################
        search_msg = (
            rf"SmartThread {cmd_runner} \({group_name}\) did cleanup of "
            f"_pair_array at UTC {time_match}"
        )

        log_msg, log_pos = self.get_log_msg(
            search_msg=search_msg,
            skip_num=0,
            start_idx=start_log_idx,
            end_idx=end_log_idx,
            reverse_search=False,
        )

        if log_msg:
            upa_log_msg_found = True
        else:
            upa_log_msg_found = False

        return PaLogMsgsFound(
            entered_rpa=entered_rpa_log_msg_found,
            removed_sb_entry=found_removed_status_block_msgs,
            removed_pa_entry=found_removed_pa_entry_msgs,
            updated_pa=upa_log_msg_found,
        )

    ####################################################################
    # wait_for_recv_msg_timeouts
    ####################################################################
    def wait_for_recv_msg_timeouts(self, cmd_runner: str) -> None:
        """Verify that the receivers have timed out.

        Args:
            cmd_runner: thread doing the wait
        """
        start_time = time.time()
        while True:
            with self.ops_lock:
                if self.expected_num_recv_timeouts == 0:
                    return
            time.sleep(0.1)
            if start_time + 30 < time.time():
                raise CmdTimedOut(
                    "wait_for_recv_msg_timeouts timed out "
                    f"with {self.expected_num_recv_timeouts=}"
                )

    ####################################################################
    # wait_for_request_timeouts
    ####################################################################
    def wait_for_request_timeouts(
        self,
        cmd_runner: str,
        actor_names: set[str],
        timeout_names: set[str],
        use_work_remotes: bool,
        as_subset: bool,
    ) -> None:
        """Verify that the actor have detected the timeout threads.

        Args:
            cmd_runner: thread doing the WaitForTimeouts
            actor_names: thread names to verify that they recognized the
                timeout_names as being delayed
            timeout_names: threads that cause timeout by being in state
                other than a state that the actor can proceed
            use_work_remotes: if True, compare against work_remotes,
                else pk_remotes
            as_subset: if True, the wait is satisfied when the
                timeout_names are a subset of the pk_remotes

        Raises:
            CmdTimedOut: wait_for_request_timeouts timed out

        """
        work_actors = actor_names.copy()
        start_time = time.time()
        work_names: set[str] = set()
        while work_actors:
            for actor in work_actors:
                if use_work_remotes:
                    work_names = self.all_threads[actor].work_remotes
                else:
                    work_names = {
                        remote
                        for pk, remote, _ in self.all_threads[actor].work_pk_remotes
                    }
                if timeout_names == work_names or (
                    as_subset and timeout_names <= work_names
                ):
                    work_actors.remove(actor)
                    break

            time.sleep(0.1)
            if start_time + 30 < time.time():
                raise CmdTimedOut(
                    "wait_for_request_timeouts timed out "
                    f"with {work_actors=}, "
                    f"{sorted(timeout_names)=}, "
                    f"{sorted(work_names)=}"
                )


########################################################################
# expand_cmds
########################################################################
def expand_list(nested_list: list[Any]) -> list[Any]:
    """Return a list of items from a nested list of lists.

    Args:
        nested_list: a list containing nested lists of items

    Returns:
        a single list of items
    """
    ret_list: list[Any] = []
    for item in nested_list:
        if isinstance(item, list):
            ret_list.extend(expand_list(item))
        else:
            ret_list.append(item)
    return ret_list


########################################################################
# CommanderCurrentApp class
########################################################################
class CommanderCurrentApp:
    """Outer thread app for test."""

    def __init__(self, config_ver: ConfigVerifier, name: str, max_msgs: int) -> None:
        """Initialize the object.

        Args:
            config_ver: configuration verifier and test support methods
            name: name of thread
            max_msgs: max number of messages for msg_q

        """
        self.config_ver = config_ver
        self.smart_thread = st.SmartThread(
            group_name=config_ver.group_name,
            name=name,
            auto_start=False,
            max_msgs=max_msgs,
        )

        # self.config_ver.commander_thread = self.smart_thread

    def run(self) -> None:
        """Run the test."""
        self.config_ver.main_driver()


########################################################################
# OuterThreadApp class
########################################################################
class OuterThreadApp(threading.Thread):
    """Outer thread app for test."""

    def __init__(
        self,
        config_ver: ConfigVerifier,
        name: str,
        # auto_start: bool,
        max_msgs: int,
    ) -> None:
        """Initialize the object.

        Args:
            config_ver: configuration verifier and test support methods
            name: name of thread
            max_msgs: max number of messages for msg_q

        """
        super().__init__()
        threading.current_thread().name = name
        self.config_ver = config_ver
        self.smart_thread = st.SmartThread(
            group_name=config_ver.group_name,
            name=name,
            thread=self,
            auto_start=False,
            max_msgs=max_msgs,
        )

        # self.config_ver.commander_thread = self.smart_thread

    def run(self) -> None:
        """Run the test."""
        self.config_ver.log_ver.add_call_seq(
            name="smart_start", seq="test_smart_thread.py::OuterThreadApp.run"
        )

        self.config_ver.monitor_event.set()

        self.config_ver.main_driver()


########################################################################
# OuterSmartThreadApp class
########################################################################
class OuterSmartThreadApp(st.SmartThread, threading.Thread):
    """Outer thread app for test with both thread and SmartThread."""

    def __init__(self, config_ver: ConfigVerifier, name: str, max_msgs: int) -> None:
        """Initialize the object.

        Args:
            config_ver: configuration verifier and test support methods
            name: name of thread
            max_msgs: max number of messages for msg_q

        """
        # super().__init__()
        threading.Thread.__init__(self)
        threading.current_thread().name = name
        st.SmartThread.__init__(
            self,
            group_name=config_ver.group_name,
            name=name,
            thread=self,
            auto_start=False,
            max_msgs=max_msgs,
        )
        self.config_ver = config_ver
        # self.config_ver.commander_thread = self

    def run(self) -> None:
        """Run the test."""
        self.config_ver.main_driver()


########################################################################
# OuterSmartThreadApp2 class
########################################################################
class OuterSmartThreadApp2(threading.Thread, st.SmartThread):
    """Outer thread app for test with both thread and SmartThread."""

    def __init__(self, config_ver: ConfigVerifier, name: str, max_msgs: int) -> None:
        """Initialize the object.

        Args:
            config_ver: configuration verifier and test support methods
            name: name of thread
            max_msgs: max number of messages for msg_q

        """
        # super().__init__()
        threading.Thread.__init__(self)
        threading.current_thread().name = name
        st.SmartThread.__init__(
            self,
            group_name=config_ver.group_name,
            name=name,
            thread=self,
            auto_start=False,
            max_msgs=max_msgs,
        )
        self.config_ver = config_ver
        # self.config_ver.commander_thread = self

    def run(self) -> None:
        """Run the test."""
        self.config_ver.main_driver()


########################################################################
# OuterF1ThreadApp class
########################################################################
class OuterF1ThreadApp(threading.Thread):
    """Outer thread app for test."""

    def __init__(
        self, config_ver: ConfigVerifier, name: str, auto_start: bool, max_msgs: int
    ) -> None:
        """Initialize the object.

        Args:
            config_ver: configuration verifier and test support methods
            name: name of thread
            auto_start: True, start thread
            max_msgs: max number of messages for msg_q

        """
        super().__init__()
        self.config_ver = config_ver
        self.name = name
        self.smart_thread = st.SmartThread(
            group_name=config_ver.group_name,
            name=name,
            thread=self,
            # auto_start=False,
            auto_start=auto_start,
            max_msgs=max_msgs,
        )

    def run(self) -> None:
        """Run the test."""
        self.config_ver.log_test_msg(f"OuterF1ThreadApp.run() entry: {self.name}")

        # self.config_ver.f1_driver(f1_name=self.smart_thread.name)
        self.config_ver.f1_driver(f1_name=self.name)

        ################################################################
        # exit
        ################################################################
        self.config_ver.log_test_msg(f"OuterF1ThreadApp.run() exit: {self.name}")


########################################################################
# outer_f1
########################################################################
def outer_f1(f1_name: str, f1_config_ver: ConfigVerifier) -> None:
    """Target routine in the outer scope.

    Args:
        f1_name: thread name
        f1_config_ver: configuration verifier instance

    """
    f1_config_ver.log_test_msg(f"outer_f1 entry: {f1_name}")

    f1_config_ver.f1_driver(f1_name=f1_name)

    ####################################################################
    # exit
    ####################################################################
    f1_config_ver.log_test_msg(f"outer_f1 exit: {f1_name}")


########################################################################
# commander_config
########################################################################
commander_config: dict[int, AppConfig] = {
    0: AppConfig.ScriptStyle,
    1: AppConfig.CurrentThreadApp,
    2: AppConfig.RemoteThreadApp,
    3: AppConfig.RemoteSmartThreadApp,
    4: AppConfig.RemoteSmartThreadApp2,
}

num_commander_configs = len(commander_config)


########################################################################
# TestSmartThreadInterface class
########################################################################
@pytest.mark.cover
class TestSmartThreadInterface:
    """Test class for SmartThread example tests."""

    ####################################################################
    # test_smart_thread_interface_1
    ####################################################################
    @pytest.mark.parametrize(
        "num_f1_args",
        [
            (0, 0, 0),
            (0, 0, 1),
            (0, 0, 2),
            (0, 0, 3),
            (0, 1, 0),
            (0, 1, 1),
            (0, 1, 2),
            (0, 1, 3),
            (0, 2, 0),
            (0, 2, 1),
            (0, 2, 2),
            (0, 2, 3),
            (0, 3, 0),
            (0, 3, 1),
            (0, 3, 2),
            (0, 3, 3),
            (1, 0, 0),
            (1, 0, 1),
            (1, 0, 2),
            (1, 0, 3),
            (1, 1, 0),
            (1, 1, 1),
            (1, 1, 2),
            (1, 1, 3),
            (1, 2, 0),
            (1, 2, 1),
            (1, 2, 2),
            (1, 2, 3),
            (1, 3, 0),
            (1, 3, 1),
            (1, 3, 2),
            (1, 3, 3),
        ],
    )
    def test_smart_thread_interface_1(self, num_f1_args: tuple[int, int, int]) -> None:
        """Test smart_send example 1 with no parms.

        Args:
            num_f1_args: number of arguments to specify
        """
        from scottbrian_paratools.smart_thread import SmartThread, ThreadState

        def f1_0_0_0() -> None:
            logger.debug("f1 beta entry")
            logger.debug("there are no args to check")
            assert num_f1_args == (0, 0, 0)
            logger.debug("f1 beta exit")

        def f1_0_0_1(arg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            assert arg1 == 42
            assert num_f1_args == (0, 0, 1)
            logger.debug("f1 beta exit")

        def f1_0_0_2(arg1: int, arg2: str) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert num_f1_args == (0, 0, 2)
            logger.debug("f1 beta exit")

        def f1_0_0_3(arg1: int, arg2: str, arg3: list[int]) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert num_f1_args == (0, 0, 3)
            logger.debug("f1 beta exit")

        def f1_0_1_0(kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}")
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 0)
            logger.debug("f1 beta exit")

        def f1_0_1_1(arg1: int, kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 1)
            logger.debug("f1 beta exit")

        def f1_0_1_2(arg1: int, arg2: str, kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 2)
            logger.debug("f1 beta exit")

        def f1_0_1_3(arg1: int, arg2: str, arg3: list[int], kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 3)
            logger.debug("f1 beta exit")

        def f1_0_2_0(kwarg1: int, kwarg2: str) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 0)
            logger.debug("f1 beta exit")

        def f1_0_2_1(arg1: int, kwarg1: int, kwarg2: str) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 1)
            logger.debug("f1 beta exit")

        def f1_0_2_2(arg1: int, arg2: str, kwarg1: int, kwarg2: str) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 2)
            logger.debug("f1 beta exit")

        def f1_0_2_3(
            arg1: int, arg2: str, arg3: list[int], kwarg1: int, kwarg2: str
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 3)
            logger.debug("f1 beta exit")

        def f1_0_3_0(kwarg1: int, kwarg2: str, kwarg3: list[int]) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (0, 3, 0)
            logger.debug("f1 beta exit")

        def f1_0_3_1(arg1: int, kwarg1: int, kwarg2: str, kwarg3: list[int]) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (0, 3, 1)
            logger.debug("f1 beta exit")

        def f1_0_3_2(
            arg1: int, arg2: str, kwarg1: int, kwarg2: str, kwarg3: list[int]
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (0, 3, 2)
            logger.debug("f1 beta exit")

        def f1_0_3_3(
            arg1: int,
            arg2: str,
            arg3: list[int],
            kwarg1: int,
            kwarg2: str,
            kwarg3: list[int],
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg3 == [11, 22, 33]
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 3, 3)
            logger.debug("f1 beta exit")

        def f1_1_0_0(smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{smart_thread=}")
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 0, 0)
            logger.debug("f1 beta exit")

        def f1_1_0_1(arg1: int, smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            assert arg1 == 42
            logger.debug(f"{smart_thread=}")
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 0, 1)
            logger.debug("f1 beta exit")

        def f1_1_0_2(arg1: int, arg2: str, smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 0, 2)
            logger.debug("f1 beta exit")

        def f1_1_0_3(
            arg1: int, arg2: str, arg3: list[int], smart_thread: SmartThread
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 0, 3)
            logger.debug("f1 beta exit")

        def f1_1_1_0(kwarg1: int, smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}")
            logger.debug(f"{smart_thread=}")
            assert kwarg1 == 13
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 1, 0)
            logger.debug("f1 beta exit")

        def f1_1_1_1(arg1: int, smart_thread: SmartThread, kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert kwarg1 == 13
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 1, 1)
            logger.debug("f1 beta exit")

        def f1_1_1_2(
            arg1: int, arg2: str, kwarg1: int, smart_thread: SmartThread
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 1, 2)
            logger.debug("f1 beta exit")

        def f1_1_1_3(
            arg1: int,
            arg2: str,
            arg3: list[int],
            smart_thread: SmartThread,
            kwarg1: int,
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 1, 3)
            logger.debug("f1 beta exit")

        def f1_1_2_0(kwarg1: int, kwarg2: str, smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            logger.debug(f"{smart_thread=}")
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 2, 0)
            logger.debug("f1 beta exit")

        def f1_1_2_1(
            arg1: int, kwarg1: int, smart_thread: SmartThread, kwarg2: str
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 2, 1)
            logger.debug("f1 beta exit")

        def f1_1_2_2(
            arg1: int, arg2: str, kwarg1: int, kwarg2: str, smart_thread: SmartThread
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 2, 2)
            logger.debug("f1 beta exit")

        def f1_1_2_3(
            arg1: int,
            arg2: str,
            arg3: list[int],
            smart_thread: SmartThread,
            kwarg1: int,
            kwarg2: str,
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 2, 3)
            logger.debug("f1 beta exit")

        def f1_1_3_0(
            kwarg1: int, kwarg2: str, smart_thread: SmartThread, kwarg3: list[int]
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            logger.debug(f"{smart_thread=}")
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 3, 0)
            logger.debug("f1 beta exit")

        def f1_1_3_1(
            arg1: int,
            kwarg1: int,
            smart_thread: SmartThread,
            kwarg2: str,
            kwarg3: list[int],
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 3, 1)
            logger.debug("f1 beta exit")

        def f1_1_3_2(
            arg1: int,
            arg2: str,
            kwarg1: int,
            kwarg2: str,
            kwarg3: list[int],
            smart_thread: SmartThread,
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (1, 3, 2)
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            logger.debug("f1 beta exit")

        def f1_1_3_3(
            arg1: int,
            arg2: str,
            arg3: list[int],
            kwarg1: int,
            kwarg2: str,
            kwarg3: list[int],
            smart_thread: SmartThread,
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg3 == [11, 22, 33]
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 3, 3)
            logger.debug("f1 beta exit")

        logger.debug("mainline entered")

        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        if num_f1_args == (0, 0, 0):
            beta_smart_thread = SmartThread(
                group_name="test1", name="beta", target_rtn=f1_0_0_0
            )
        elif num_f1_args == (0, 0, 1):
            beta_smart_thread = SmartThread(
                group_name="test1", name="beta", target_rtn=f1_0_0_1, args=(42,)
            )
        elif num_f1_args == (0, 0, 2):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_0_0_2,
                args=(42, "my arg 2"),
            )
        elif num_f1_args == (0, 0, 3):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_0_0_3,
                args=(42, "my arg 2", [1, 2, 3]),
            )
        elif num_f1_args == (0, 1, 0):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_0_1_0,
                kwargs={"kwarg1": 13},
            )
        elif num_f1_args == (0, 1, 1):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_0_1_1,
                args=(42,),
                kwargs={"kwarg1": 13},
            )
        elif num_f1_args == (0, 1, 2):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_0_1_2,
                args=(42, "my arg 2"),
                kwargs={"kwarg1": 13},
            )
        elif num_f1_args == (0, 1, 3):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_0_1_3,
                args=(42, "my arg 2", [1, 2, 3]),
                kwargs={"kwarg1": 13},
            )
        elif num_f1_args == (0, 2, 0):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_0_2_0,
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
            )
        elif num_f1_args == (0, 2, 1):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_0_2_1,
                args=(42,),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
            )
        elif num_f1_args == (0, 2, 2):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_0_2_2,
                args=(42, "my arg 2"),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
            )
        elif num_f1_args == (0, 2, 3):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_0_2_3,
                args=(42, "my arg 2", [1, 2, 3]),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
            )
        elif num_f1_args == (0, 3, 0):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_0_3_0,
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg", "kwarg3": [11, 22, 33]},
            )
        elif num_f1_args == (0, 3, 1):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_0_3_1,
                args=(42,),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg", "kwarg3": [11, 22, 33]},
            )
        elif num_f1_args == (0, 3, 2):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_0_3_2,
                args=(42, "my arg 2"),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg", "kwarg3": [11, 22, 33]},
            )
        elif num_f1_args == (0, 3, 3):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_0_3_3,
                args=(42, "my arg 2", [1, 2, 3]),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg", "kwarg3": [11, 22, 33]},
            )
        elif num_f1_args == (1, 0, 0):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_1_0_0,
                thread_parm_name="smart_thread",
            )
        elif num_f1_args == (1, 0, 1):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_1_0_1,
                thread_parm_name="smart_thread",
                args=(42,),
            )
        elif num_f1_args == (1, 0, 2):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_1_0_2,
                thread_parm_name="smart_thread",
                args=(42, "my arg 2"),
            )
        elif num_f1_args == (1, 0, 3):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_1_0_3,
                thread_parm_name="smart_thread",
                args=(42, "my arg 2", [1, 2, 3]),
            )
        elif num_f1_args == (1, 1, 0):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_1_1_0,
                thread_parm_name="smart_thread",
                kwargs={"kwarg1": 13},
            )
        elif num_f1_args == (1, 1, 1):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_1_1_1,
                thread_parm_name="smart_thread",
                args=(42,),
                kwargs={"kwarg1": 13},
            )
        elif num_f1_args == (1, 1, 2):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_1_1_2,
                thread_parm_name="smart_thread",
                args=(42, "my arg 2"),
                kwargs={"kwarg1": 13},
            )
        elif num_f1_args == (1, 1, 3):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_1_1_3,
                thread_parm_name="smart_thread",
                args=(42, "my arg 2", [1, 2, 3]),
                kwargs={"kwarg1": 13},
            )
        elif num_f1_args == (1, 2, 0):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_1_2_0,
                thread_parm_name="smart_thread",
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
            )
        elif num_f1_args == (1, 2, 1):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_1_2_1,
                thread_parm_name="smart_thread",
                args=(42,),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
            )
        elif num_f1_args == (1, 2, 2):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_1_2_2,
                thread_parm_name="smart_thread",
                args=(42, "my arg 2"),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
            )
        elif num_f1_args == (1, 2, 3):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_1_2_3,
                thread_parm_name="smart_thread",
                args=(42, "my arg 2", [1, 2, 3]),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
            )
        elif num_f1_args == (1, 3, 0):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_1_3_0,
                thread_parm_name="smart_thread",
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg", "kwarg3": [11, 22, 33]},
            )
        elif num_f1_args == (1, 3, 1):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_1_3_1,
                thread_parm_name="smart_thread",
                args=(42,),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg", "kwarg3": [11, 22, 33]},
            )
        elif num_f1_args == (1, 3, 2):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_1_3_2,
                thread_parm_name="smart_thread",
                args=(42, "my arg 2"),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg", "kwarg3": [11, 22, 33]},
            )
        elif num_f1_args == (1, 3, 3):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1_1_3_3,
                thread_parm_name="smart_thread",
                args=(42, "my arg 2", [1, 2, 3]),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg", "kwarg3": [11, 22, 33]},
            )

        wait_for(
            lambda: beta_smart_thread.get_state(group_name="test1", name="beta")
            == ThreadState.Alive
        )

        alpha_smart_thread.smart_join(targets="beta")
        assert (
            beta_smart_thread.get_state(group_name="test1", name="beta")
            == ThreadState.Unregistered
        )
        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_thread_interface_1b
    ####################################################################
    @pytest.mark.parametrize(
        "num_f1_args",
        [
            (0, 0, 0),
            (0, 0, 1),
            (0, 0, 2),
            (0, 0, 3),
            (0, 1, 0),
            (0, 1, 1),
            (0, 1, 2),
            (0, 1, 3),
            (0, 2, 0),
            (0, 2, 1),
            (0, 2, 2),
            (0, 2, 3),
            (0, 3, 0),
            (0, 3, 1),
            (0, 3, 2),
            (0, 3, 3),
            (1, 0, 0),
            (1, 0, 1),
            (1, 0, 2),
            (1, 0, 3),
            (1, 1, 0),
            (1, 1, 1),
            (1, 1, 2),
            (1, 1, 3),
            (1, 2, 0),
            (1, 2, 1),
            (1, 2, 2),
            (1, 2, 3),
            (1, 3, 0),
            (1, 3, 1),
            (1, 3, 2),
            (1, 3, 3),
        ],
    )
    @pytest.mark.parametrize(
        "group_names_arg",
        [
            ("test1",),
            ("test1", "test2"),
            ("test1", "test2", "test3"),
        ],
    )
    def test_smart_thread_interface_1b(
        self,
        num_f1_args: tuple[int, int, int],
        group_names_arg: tuple[str],
    ) -> None:
        """Test smart_send example 1 with no parms.

        Args:
            num_f1_args: number of arguments to specify
            group_names_arg: group_names to use to create SmartThread
                instances
        """
        from scottbrian_paratools.smart_thread import SmartThread, ThreadState

        def f1_0_0_0() -> None:
            logger.debug("f1 beta entry")
            logger.debug("there are no args to check")
            assert num_f1_args == (0, 0, 0)
            logger.debug("f1 beta exit")

        def f1_0_0_1(arg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            assert arg1 == 42
            assert num_f1_args == (0, 0, 1)
            logger.debug("f1 beta exit")

        def f1_0_0_2(arg1: int, arg2: str) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert num_f1_args == (0, 0, 2)
            logger.debug("f1 beta exit")

        def f1_0_0_3(arg1: int, arg2: str, arg3: list[int]) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert num_f1_args == (0, 0, 3)
            logger.debug("f1 beta exit")

        def f1_0_1_0(kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}")
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 0)
            logger.debug("f1 beta exit")

        def f1_0_1_1(arg1: int, kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 1)
            logger.debug("f1 beta exit")

        def f1_0_1_2(arg1: int, arg2: str, kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 2)
            logger.debug("f1 beta exit")

        def f1_0_1_3(arg1: int, arg2: str, arg3: list[int], kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 3)
            logger.debug("f1 beta exit")

        def f1_0_2_0(kwarg1: int, kwarg2: str) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 0)
            logger.debug("f1 beta exit")

        def f1_0_2_1(arg1: int, kwarg1: int, kwarg2: str) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 1)
            logger.debug("f1 beta exit")

        def f1_0_2_2(arg1: int, arg2: str, kwarg1: int, kwarg2: str) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 2)
            logger.debug("f1 beta exit")

        def f1_0_2_3(
            arg1: int, arg2: str, arg3: list[int], kwarg1: int, kwarg2: str
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 3)
            logger.debug("f1 beta exit")

        def f1_0_3_0(kwarg1: int, kwarg2: str, kwarg3: list[int]) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (0, 3, 0)
            logger.debug("f1 beta exit")

        def f1_0_3_1(arg1: int, kwarg1: int, kwarg2: str, kwarg3: list[int]) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (0, 3, 1)
            logger.debug("f1 beta exit")

        def f1_0_3_2(
            arg1: int, arg2: str, kwarg1: int, kwarg2: str, kwarg3: list[int]
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (0, 3, 2)
            logger.debug("f1 beta exit")

        def f1_0_3_3(
            arg1: int,
            arg2: str,
            arg3: list[int],
            kwarg1: int,
            kwarg2: str,
            kwarg3: list[int],
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg3 == [11, 22, 33]
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 3, 3)
            logger.debug("f1 beta exit")

        def f1_1_0_0(smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{smart_thread=}")
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 0, 0)
            logger.debug("f1 beta exit")

        def f1_1_0_1(arg1: int, smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            assert arg1 == 42
            logger.debug(f"{smart_thread=}")
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 0, 1)
            logger.debug("f1 beta exit")

        def f1_1_0_2(arg1: int, arg2: str, smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 0, 2)
            logger.debug("f1 beta exit")

        def f1_1_0_3(
            arg1: int, arg2: str, arg3: list[int], smart_thread: SmartThread
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 0, 3)
            logger.debug("f1 beta exit")

        def f1_1_1_0(kwarg1: int, smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}")
            logger.debug(f"{smart_thread=}")
            assert kwarg1 == 13
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 1, 0)
            logger.debug("f1 beta exit")

        def f1_1_1_1(arg1: int, smart_thread: SmartThread, kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert kwarg1 == 13
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 1, 1)
            logger.debug("f1 beta exit")

        def f1_1_1_2(
            arg1: int, arg2: str, kwarg1: int, smart_thread: SmartThread
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 1, 2)
            logger.debug("f1 beta exit")

        def f1_1_1_3(
            arg1: int,
            arg2: str,
            arg3: list[int],
            smart_thread: SmartThread,
            kwarg1: int,
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 1, 3)
            logger.debug("f1 beta exit")

        def f1_1_2_0(kwarg1: int, kwarg2: str, smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            logger.debug(f"{smart_thread=}")
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 2, 0)
            logger.debug("f1 beta exit")

        def f1_1_2_1(
            arg1: int, kwarg1: int, smart_thread: SmartThread, kwarg2: str
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 2, 1)
            logger.debug("f1 beta exit")

        def f1_1_2_2(
            arg1: int, arg2: str, kwarg1: int, kwarg2: str, smart_thread: SmartThread
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 2, 2)
            logger.debug("f1 beta exit")

        def f1_1_2_3(
            arg1: int,
            arg2: str,
            arg3: list[int],
            smart_thread: SmartThread,
            kwarg1: int,
            kwarg2: str,
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 2, 3)
            logger.debug("f1 beta exit")

        def f1_1_3_0(
            kwarg1: int, kwarg2: str, smart_thread: SmartThread, kwarg3: list[int]
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            logger.debug(f"{smart_thread=}")
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 3, 0)
            logger.debug("f1 beta exit")

        def f1_1_3_1(
            arg1: int,
            kwarg1: int,
            smart_thread: SmartThread,
            kwarg2: str,
            kwarg3: list[int],
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 3, 1)
            logger.debug("f1 beta exit")

        def f1_1_3_2(
            arg1: int,
            arg2: str,
            kwarg1: int,
            kwarg2: str,
            kwarg3: list[int],
            smart_thread: SmartThread,
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (1, 3, 2)
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            logger.debug("f1 beta exit")

        def f1_1_3_3(
            arg1: int,
            arg2: str,
            arg3: list[int],
            kwarg1: int,
            kwarg2: str,
            kwarg3: list[int],
            smart_thread: SmartThread,
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg3 == [11, 22, 33]
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 3, 3)
            logger.debug("f1 beta exit")

        logger.debug("mainline entered")

        alpha_smart_thread: list[SmartThread] = []

        for group_name in group_names_arg:
            alpha_smart_thread.append(SmartThread(group_name=group_name, name="alpha"))

        beta_smart_thread: list[SmartThread] = []

        if num_f1_args == (0, 0, 0):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(group_name=group_name, name="beta", target_rtn=f1_0_0_0)
                )
        elif num_f1_args == (0, 0, 1):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_0_0_1,
                        args=(42,),
                    )
                )
        elif num_f1_args == (0, 0, 2):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_0_0_2,
                        args=(42, "my arg 2"),
                    )
                )
        elif num_f1_args == (0, 0, 3):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_0_0_3,
                        args=(42, "my arg 2", [1, 2, 3]),
                    )
                )
        elif num_f1_args == (0, 1, 0):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_0_1_0,
                        kwargs={"kwarg1": 13},
                    )
                )
        elif num_f1_args == (0, 1, 1):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_0_1_1,
                        args=(42,),
                        kwargs={"kwarg1": 13},
                    )
                )
        elif num_f1_args == (0, 1, 2):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_0_1_2,
                        args=(42, "my arg 2"),
                        kwargs={"kwarg1": 13},
                    )
                )
        elif num_f1_args == (0, 1, 3):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_0_1_3,
                        args=(42, "my arg 2", [1, 2, 3]),
                        kwargs={"kwarg1": 13},
                    )
                )
        elif num_f1_args == (0, 2, 0):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_0_2_0,
                        kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
                    )
                )
        elif num_f1_args == (0, 2, 1):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_0_2_1,
                        args=(42,),
                        kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
                    )
                )
        elif num_f1_args == (0, 2, 2):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_0_2_2,
                        args=(42, "my arg 2"),
                        kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
                    )
                )
        elif num_f1_args == (0, 2, 3):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_0_2_3,
                        args=(42, "my arg 2", [1, 2, 3]),
                        kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
                    )
                )
        elif num_f1_args == (0, 3, 0):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_0_3_0,
                        kwargs={
                            "kwarg1": 13,
                            "kwarg2": "second kwarg",
                            "kwarg3": [11, 22, 33],
                        },
                    )
                )
        elif num_f1_args == (0, 3, 1):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_0_3_1,
                        args=(42,),
                        kwargs={
                            "kwarg1": 13,
                            "kwarg2": "second kwarg",
                            "kwarg3": [11, 22, 33],
                        },
                    )
                )
        elif num_f1_args == (0, 3, 2):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_0_3_2,
                        args=(42, "my arg 2"),
                        kwargs={
                            "kwarg1": 13,
                            "kwarg2": "second kwarg",
                            "kwarg3": [11, 22, 33],
                        },
                    )
                )
        elif num_f1_args == (0, 3, 3):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_0_3_3,
                        args=(42, "my arg 2", [1, 2, 3]),
                        kwargs={
                            "kwarg1": 13,
                            "kwarg2": "second kwarg",
                            "kwarg3": [11, 22, 33],
                        },
                    )
                )
        elif num_f1_args == (1, 0, 0):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_1_0_0,
                        thread_parm_name="smart_thread",
                    )
                )
        elif num_f1_args == (1, 0, 1):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_1_0_1,
                        thread_parm_name="smart_thread",
                        args=(42,),
                    )
                )
        elif num_f1_args == (1, 0, 2):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_1_0_2,
                        thread_parm_name="smart_thread",
                        args=(42, "my arg 2"),
                    )
                )
        elif num_f1_args == (1, 0, 3):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_1_0_3,
                        thread_parm_name="smart_thread",
                        args=(42, "my arg 2", [1, 2, 3]),
                    )
                )
        elif num_f1_args == (1, 1, 0):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_1_1_0,
                        thread_parm_name="smart_thread",
                        kwargs={"kwarg1": 13},
                    )
                )
        elif num_f1_args == (1, 1, 1):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_1_1_1,
                        thread_parm_name="smart_thread",
                        args=(42,),
                        kwargs={"kwarg1": 13},
                    )
                )
        elif num_f1_args == (1, 1, 2):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_1_1_2,
                        thread_parm_name="smart_thread",
                        args=(42, "my arg 2"),
                        kwargs={"kwarg1": 13},
                    )
                )
        elif num_f1_args == (1, 1, 3):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_1_1_3,
                        thread_parm_name="smart_thread",
                        args=(42, "my arg 2", [1, 2, 3]),
                        kwargs={"kwarg1": 13},
                    )
                )
        elif num_f1_args == (1, 2, 0):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_1_2_0,
                        thread_parm_name="smart_thread",
                        kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
                    )
                )
        elif num_f1_args == (1, 2, 1):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_1_2_1,
                        thread_parm_name="smart_thread",
                        args=(42,),
                        kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
                    )
                )
        elif num_f1_args == (1, 2, 2):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_1_2_2,
                        thread_parm_name="smart_thread",
                        args=(42, "my arg 2"),
                        kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
                    )
                )
        elif num_f1_args == (1, 2, 3):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_1_2_3,
                        thread_parm_name="smart_thread",
                        args=(42, "my arg 2", [1, 2, 3]),
                        kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
                    )
                )
        elif num_f1_args == (1, 3, 0):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_1_3_0,
                        thread_parm_name="smart_thread",
                        kwargs={
                            "kwarg1": 13,
                            "kwarg2": "second kwarg",
                            "kwarg3": [11, 22, 33],
                        },
                    )
                )
        elif num_f1_args == (1, 3, 1):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_1_3_1,
                        thread_parm_name="smart_thread",
                        args=(42,),
                        kwargs={
                            "kwarg1": 13,
                            "kwarg2": "second kwarg",
                            "kwarg3": [11, 22, 33],
                        },
                    )
                )
        elif num_f1_args == (1, 3, 2):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_1_3_2,
                        thread_parm_name="smart_thread",
                        args=(42, "my arg 2"),
                        kwargs={
                            "kwarg1": 13,
                            "kwarg2": "second kwarg",
                            "kwarg3": [11, 22, 33],
                        },
                    )
                )
        elif num_f1_args == (1, 3, 3):
            for group_name in group_names_arg:
                beta_smart_thread.append(
                    SmartThread(
                        group_name=group_name,
                        name="beta",
                        target_rtn=f1_1_3_3,
                        thread_parm_name="smart_thread",
                        args=(42, "my arg 2", [1, 2, 3]),
                        kwargs={
                            "kwarg1": 13,
                            "kwarg2": "second kwarg",
                            "kwarg3": [11, 22, 33],
                        },
                    )
                )

        thread_state = ThreadState.Alive
        # thread_state = ThreadState.Stopped
        for group_name in reversed(group_names_arg):
            wait_for(
                lambda: SmartThread.get_state(group_name=group_name, name="beta")
                == thread_state
            )
            # thread_state = ThreadState.Stopped

        for idx, group_name in enumerate(group_names_arg):
            alpha_smart_thread[idx].smart_join(targets="beta")
            assert (
                SmartThread.get_state(group_name=group_name, name="beta")
                == ThreadState.Unregistered
            )
        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_thread_interface_2
    ####################################################################
    @pytest.mark.parametrize(
        "num_f1_args",
        [
            (0, 0, 0),
            (0, 0, 1),
            (0, 0, 2),
            (0, 0, 3),
            (0, 1, 0),
            (0, 1, 1),
            (0, 1, 2),
            (0, 1, 3),
            (0, 2, 0),
            (0, 2, 1),
            (0, 2, 2),
            (0, 2, 3),
            (0, 3, 0),
            (0, 3, 1),
            (0, 3, 2),
            (0, 3, 3),
            (1, 0, 0),
            (1, 0, 1),
            (1, 0, 2),
            (1, 0, 3),
            (1, 1, 0),
            (1, 1, 1),
            (1, 1, 2),
            (1, 1, 3),
            (1, 2, 0),
            (1, 2, 1),
            (1, 2, 2),
            (1, 2, 3),
            (1, 3, 0),
            (1, 3, 1),
            (1, 3, 2),
            (1, 3, 3),
        ],
    )
    def test_smart_thread_interface_2(self, num_f1_args: tuple[int, int, int]) -> None:
        """Test smart_send example 2 with no parms.

        Args:
            num_f1_args: number of arguments to specify
        """
        from scottbrian_paratools.smart_thread import SmartThread, ThreadState

        def f1_0_0_0() -> None:
            logger.debug("f1 beta entry")
            logger.debug("there are no args to check")
            assert num_f1_args == (0, 0, 0)
            logger.debug("f1 beta exit")

        def f1_0_0_1(arg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            assert arg1 == 42
            assert num_f1_args == (0, 0, 1)
            logger.debug("f1 beta exit")

        def f1_0_0_2(arg1: int, arg2: str) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert num_f1_args == (0, 0, 2)
            logger.debug("f1 beta exit")

        def f1_0_0_3(arg1: int, arg2: str, arg3: list[int]) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert num_f1_args == (0, 0, 3)
            logger.debug("f1 beta exit")

        def f1_0_1_0(kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}")
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 0)
            logger.debug("f1 beta exit")

        def f1_0_1_1(arg1: int, kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 1)
            logger.debug("f1 beta exit")

        def f1_0_1_2(arg1: int, arg2: str, kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 2)
            logger.debug("f1 beta exit")

        def f1_0_1_3(arg1: int, arg2: str, arg3: list[int], kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 3)
            logger.debug("f1 beta exit")

        def f1_0_2_0(kwarg1: int, kwarg2: str) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 0)
            logger.debug("f1 beta exit")

        def f1_0_2_1(arg1: int, kwarg1: int, kwarg2: str) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 1)
            logger.debug("f1 beta exit")

        def f1_0_2_2(arg1: int, arg2: str, kwarg1: int, kwarg2: str) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 2)
            logger.debug("f1 beta exit")

        def f1_0_2_3(
            arg1: int, arg2: str, arg3: list[int], kwarg1: int, kwarg2: str
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 3)
            logger.debug("f1 beta exit")

        def f1_0_3_0(kwarg1: int, kwarg2: str, kwarg3: list[int]) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (0, 3, 0)
            logger.debug("f1 beta exit")

        def f1_0_3_1(arg1: int, kwarg1: int, kwarg2: str, kwarg3: list[int]) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (0, 3, 1)
            logger.debug("f1 beta exit")

        def f1_0_3_2(
            arg1: int, arg2: str, kwarg1: int, kwarg2: str, kwarg3: list[int]
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (0, 3, 2)
            logger.debug("f1 beta exit")

        def f1_0_3_3(
            arg1: int,
            arg2: str,
            arg3: list[int],
            kwarg1: int,
            kwarg2: str,
            kwarg3: list[int],
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg3 == [11, 22, 33]
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 3, 3)
            logger.debug("f1 beta exit")

        def f1_1_0_0(smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{smart_thread=}")
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 0, 0)
            logger.debug("f1 beta exit")

        def f1_1_0_1(arg1: int, smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            assert arg1 == 42
            logger.debug(f"{smart_thread=}")
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 0, 1)
            logger.debug("f1 beta exit")

        def f1_1_0_2(arg1: int, arg2: str, smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 0, 2)
            logger.debug("f1 beta exit")

        def f1_1_0_3(
            arg1: int, arg2: str, arg3: list[int], smart_thread: SmartThread
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 0, 3)
            logger.debug("f1 beta exit")

        def f1_1_1_0(kwarg1: int, smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}")
            logger.debug(f"{smart_thread=}")
            assert kwarg1 == 13
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 1, 0)
            logger.debug("f1 beta exit")

        def f1_1_1_1(arg1: int, smart_thread: SmartThread, kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert kwarg1 == 13
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 1, 1)
            logger.debug("f1 beta exit")

        def f1_1_1_2(
            arg1: int, arg2: str, kwarg1: int, smart_thread: SmartThread
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 1, 2)
            logger.debug("f1 beta exit")

        def f1_1_1_3(
            arg1: int,
            arg2: str,
            arg3: list[int],
            smart_thread: SmartThread,
            kwarg1: int,
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 1, 3)
            logger.debug("f1 beta exit")

        def f1_1_2_0(kwarg1: int, kwarg2: str, smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            logger.debug(f"{smart_thread=}")
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 2, 0)
            logger.debug("f1 beta exit")

        def f1_1_2_1(
            arg1: int, kwarg1: int, smart_thread: SmartThread, kwarg2: str
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 2, 1)
            logger.debug("f1 beta exit")

        def f1_1_2_2(
            arg1: int, arg2: str, kwarg1: int, kwarg2: str, smart_thread: SmartThread
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 2, 2)
            logger.debug("f1 beta exit")

        def f1_1_2_3(
            arg1: int,
            arg2: str,
            arg3: list[int],
            smart_thread: SmartThread,
            kwarg1: int,
            kwarg2: str,
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 2, 3)
            logger.debug("f1 beta exit")

        def f1_1_3_0(
            kwarg1: int, kwarg2: str, smart_thread: SmartThread, kwarg3: list[int]
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            logger.debug(f"{smart_thread=}")
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 3, 0)
            logger.debug("f1 beta exit")

        def f1_1_3_1(
            arg1: int,
            kwarg1: int,
            smart_thread: SmartThread,
            kwarg2: str,
            kwarg3: list[int],
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 3, 1)
            logger.debug("f1 beta exit")

        def f1_1_3_2(
            arg1: int,
            arg2: str,
            kwarg1: int,
            kwarg2: str,
            kwarg3: list[int],
            smart_thread: SmartThread,
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 3, 2)
            logger.debug("f1 beta exit")

        def f1_1_3_3(
            arg1: int,
            arg2: str,
            arg3: list[int],
            kwarg1: int,
            kwarg2: str,
            kwarg3: list[int],
            smart_thread: SmartThread,
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg3 == [11, 22, 33]
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(group_name="test1", name="beta")
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 3, 3)
            logger.debug("f1 beta exit")

        logger.debug("mainline entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")

        f1_target_to_specify = (
            f"f1_" f"{num_f1_args[0]}_" f"{num_f1_args[1]}_" f"{num_f1_args[2]}"
        )

        smart_thread_name_to_specify = None
        # args_to_specify = None
        # kwargs_to_specify = None
        args_to_specify: Optional[tuple[Any, ...]] = None
        kwargs_to_specify: Optional[dict[str, Any]]
        if num_f1_args[0] == 1:
            smart_thread_name_to_specify = "smart_thread"

        if num_f1_args[1] == 0:
            kwargs_to_specify = None
        else:
            kwargs_to_specify = {"kwarg1": 13}
            if num_f1_args[1] >= 2:
                kwargs_to_specify["kwarg2"] = "second kwarg"
            if num_f1_args[1] == 3:
                kwargs_to_specify["kwarg3"] = [11, 22, 33]

        if num_f1_args[2] == 1:
            args_to_specify = (42,)
        if num_f1_args[2] >= 2:
            args_to_specify = (42, "my arg 2")
        if num_f1_args[2] == 3:
            args_to_specify = (42, "my arg 2", [1, 2, 3])

        logger.debug(f"Before: {kwargs_to_specify}")

        if smart_thread_name_to_specify:
            if args_to_specify:
                if kwargs_to_specify:
                    beta_smart_thread = SmartThread(
                        group_name="test1",
                        name="beta",
                        target_rtn=eval(f1_target_to_specify),
                        thread_parm_name=smart_thread_name_to_specify,
                        args=args_to_specify,
                        kwargs=kwargs_to_specify,
                    )
                else:
                    beta_smart_thread = SmartThread(
                        group_name="test1",
                        name="beta",
                        target_rtn=eval(f1_target_to_specify),
                        thread_parm_name=smart_thread_name_to_specify,
                        args=args_to_specify,
                    )
            else:
                if kwargs_to_specify:
                    beta_smart_thread = SmartThread(
                        group_name="test1",
                        name="beta",
                        target_rtn=eval(f1_target_to_specify),
                        thread_parm_name=smart_thread_name_to_specify,
                        kwargs=kwargs_to_specify,
                    )
                else:
                    beta_smart_thread = SmartThread(
                        group_name="test1",
                        name="beta",
                        target_rtn=eval(f1_target_to_specify),
                        thread_parm_name=smart_thread_name_to_specify,
                    )
        else:
            if args_to_specify:
                if kwargs_to_specify:
                    beta_smart_thread = SmartThread(
                        group_name="test1",
                        name="beta",
                        target_rtn=eval(f1_target_to_specify),
                        args=args_to_specify,
                        kwargs=kwargs_to_specify,
                    )
                else:
                    beta_smart_thread = SmartThread(
                        group_name="test1",
                        name="beta",
                        target_rtn=eval(f1_target_to_specify),
                        args=args_to_specify,
                    )
            else:
                if kwargs_to_specify:
                    beta_smart_thread = SmartThread(
                        group_name="test1",
                        name="beta",
                        target_rtn=eval(f1_target_to_specify),
                        kwargs=kwargs_to_specify,
                    )
                else:
                    beta_smart_thread = SmartThread(
                        group_name="test1",
                        name="beta",
                        target_rtn=eval(f1_target_to_specify),
                    )

        logger.debug(f"After: {kwargs_to_specify}")

        wait_for(
            lambda: beta_smart_thread.get_state(group_name="test1", name="beta")
            == ThreadState.Alive
        )

        alpha_smart_thread.smart_join(targets="beta")
        assert (
            beta_smart_thread.get_state(group_name="test1", name="beta")
            == ThreadState.Unregistered
        )
        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_thread_interface_2
    ####################################################################
    @pytest.mark.parametrize(
        "num_f1_args",
        [
            (0, 0, 0),
            (0, 0, 1),
            (0, 0, 2),
            (0, 0, 3),
            (0, 1, 0),
            (0, 1, 1),
            (0, 1, 2),
            (0, 1, 3),
            (0, 2, 0),
            (0, 2, 1),
            (0, 2, 2),
            (0, 2, 3),
            (0, 3, 0),
            (0, 3, 1),
            (0, 3, 2),
            (0, 3, 3),
            (1, 0, 0),
            (1, 0, 1),
            (1, 0, 2),
            (1, 0, 3),
            (1, 1, 0),
            (1, 1, 1),
            (1, 1, 2),
            (1, 1, 3),
            (1, 2, 0),
            (1, 2, 1),
            (1, 2, 2),
            (1, 2, 3),
            (1, 3, 0),
            (1, 3, 1),
            (1, 3, 2),
            (1, 3, 3),
        ],
    )
    @pytest.mark.parametrize(
        "group_names_arg",
        [
            ("test1",),
            ("test1", "test2"),
            ("test1", "test2", "test3"),
        ],
    )
    def test_smart_thread_interface_2b(
        self,
        num_f1_args: tuple[int, int, int],
        group_names_arg: tuple[str],
    ) -> None:
        """Test smart_send example 2 with various parms with groups.

        Args:
            num_f1_args: number of arguments to specify
            group_names_arg: group_names to use to create SmartThread
                instances
        """
        from scottbrian_paratools.smart_thread import SmartThread, ThreadState

        def f1_0_0_0() -> None:
            logger.debug("f1 beta entry")
            logger.debug("there are no args to check")
            assert num_f1_args == (0, 0, 0)
            logger.debug("f1 beta exit")

        def f1_0_0_1(arg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            assert arg1 == 42
            assert num_f1_args == (0, 0, 1)
            logger.debug("f1 beta exit")

        def f1_0_0_2(arg1: int, arg2: str) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert num_f1_args == (0, 0, 2)
            logger.debug("f1 beta exit")

        def f1_0_0_3(arg1: int, arg2: str, arg3: list[int]) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert num_f1_args == (0, 0, 3)
            logger.debug("f1 beta exit")

        def f1_0_1_0(kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}")
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 0)
            logger.debug("f1 beta exit")

        def f1_0_1_1(arg1: int, kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 1)
            logger.debug("f1 beta exit")

        def f1_0_1_2(arg1: int, arg2: str, kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 2)
            logger.debug("f1 beta exit")

        def f1_0_1_3(arg1: int, arg2: str, arg3: list[int], kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 3)
            logger.debug("f1 beta exit")

        def f1_0_2_0(kwarg1: int, kwarg2: str) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 0)
            logger.debug("f1 beta exit")

        def f1_0_2_1(arg1: int, kwarg1: int, kwarg2: str) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 1)
            logger.debug("f1 beta exit")

        def f1_0_2_2(arg1: int, arg2: str, kwarg1: int, kwarg2: str) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 2)
            logger.debug("f1 beta exit")

        def f1_0_2_3(
            arg1: int, arg2: str, arg3: list[int], kwarg1: int, kwarg2: str
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 3)
            logger.debug("f1 beta exit")

        def f1_0_3_0(kwarg1: int, kwarg2: str, kwarg3: list[int]) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (0, 3, 0)
            logger.debug("f1 beta exit")

        def f1_0_3_1(arg1: int, kwarg1: int, kwarg2: str, kwarg3: list[int]) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (0, 3, 1)
            logger.debug("f1 beta exit")

        def f1_0_3_2(
            arg1: int, arg2: str, kwarg1: int, kwarg2: str, kwarg3: list[int]
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (0, 3, 2)
            logger.debug("f1 beta exit")

        def f1_0_3_3(
            arg1: int,
            arg2: str,
            arg3: list[int],
            kwarg1: int,
            kwarg2: str,
            kwarg3: list[int],
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg3 == [11, 22, 33]
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 3, 3)
            logger.debug("f1 beta exit")

        def f1_1_0_0(smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{smart_thread=}")
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 0, 0)
            logger.debug("f1 beta exit")

        def f1_1_0_1(arg1: int, smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            assert arg1 == 42
            logger.debug(f"{smart_thread=}")
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 0, 1)
            logger.debug("f1 beta exit")

        def f1_1_0_2(arg1: int, arg2: str, smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 0, 2)
            logger.debug("f1 beta exit")

        def f1_1_0_3(
            arg1: int, arg2: str, arg3: list[int], smart_thread: SmartThread
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 0, 3)
            logger.debug("f1 beta exit")

        def f1_1_1_0(kwarg1: int, smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}")
            logger.debug(f"{smart_thread=}")
            assert kwarg1 == 13
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 1, 0)
            logger.debug("f1 beta exit")

        def f1_1_1_1(arg1: int, smart_thread: SmartThread, kwarg1: int) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert kwarg1 == 13
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 1, 1)
            logger.debug("f1 beta exit")

        def f1_1_1_2(
            arg1: int, arg2: str, kwarg1: int, smart_thread: SmartThread
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 1, 2)
            logger.debug("f1 beta exit")

        def f1_1_1_3(
            arg1: int,
            arg2: str,
            arg3: list[int],
            smart_thread: SmartThread,
            kwarg1: int,
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 1, 3)
            logger.debug("f1 beta exit")

        def f1_1_2_0(kwarg1: int, kwarg2: str, smart_thread: SmartThread) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            logger.debug(f"{smart_thread=}")
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 2, 0)
            logger.debug("f1 beta exit")

        def f1_1_2_1(
            arg1: int, kwarg1: int, smart_thread: SmartThread, kwarg2: str
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 2, 1)
            logger.debug("f1 beta exit")

        def f1_1_2_2(
            arg1: int, arg2: str, kwarg1: int, kwarg2: str, smart_thread: SmartThread
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 2, 2)
            logger.debug("f1 beta exit")

        def f1_1_2_3(
            arg1: int,
            arg2: str,
            arg3: list[int],
            smart_thread: SmartThread,
            kwarg1: int,
            kwarg2: str,
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 2, 3)
            logger.debug("f1 beta exit")

        def f1_1_3_0(
            kwarg1: int, kwarg2: str, smart_thread: SmartThread, kwarg3: list[int]
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            logger.debug(f"{smart_thread=}")
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 3, 0)
            logger.debug("f1 beta exit")

        def f1_1_3_1(
            arg1: int,
            kwarg1: int,
            smart_thread: SmartThread,
            kwarg2: str,
            kwarg3: list[int],
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 3, 1)
            logger.debug("f1 beta exit")

        def f1_1_3_2(
            arg1: int,
            arg2: str,
            kwarg1: int,
            kwarg2: str,
            kwarg3: list[int],
            smart_thread: SmartThread,
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 3, 2)
            logger.debug("f1 beta exit")

        def f1_1_3_3(
            arg1: int,
            arg2: str,
            arg3: list[int],
            kwarg1: int,
            kwarg2: str,
            kwarg3: list[int],
            smart_thread: SmartThread,
        ) -> None:
            logger.debug("f1 beta entry")
            logger.debug(f"{arg1=}, {arg2=}, {arg3=}")
            logger.debug(f"{kwarg1=}, {kwarg2=}, {kwarg3=}")
            logger.debug(f"{smart_thread=}")
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg3 == [11, 22, 33]
            assert kwarg2 == "second kwarg"
            wait_for(
                lambda: smart_thread.get_state(
                    group_name=smart_thread.group_name, name="beta"
                )
                == ThreadState.Alive
            )
            assert num_f1_args == (1, 3, 3)
            logger.debug("f1 beta exit")

        logger.debug("mainline entered")

        alpha_smart_thread: list[SmartThread] = []

        for group_name in group_names_arg:
            alpha_smart_thread.append(SmartThread(group_name=group_name, name="alpha"))

        beta_smart_thread: list[SmartThread] = []

        f1_target_to_specify = (
            f"f1_" f"{num_f1_args[0]}_" f"{num_f1_args[1]}_" f"{num_f1_args[2]}"
        )

        smart_thread_name_to_specify = None
        # args_to_specify = None
        # kwargs_to_specify = None
        args_to_specify: Optional[tuple[Any, ...]] = None
        kwargs_to_specify: Optional[dict[str, Any]]
        if num_f1_args[0] == 1:
            smart_thread_name_to_specify = "smart_thread"

        if num_f1_args[1] == 0:
            kwargs_to_specify = None
        else:
            kwargs_to_specify = {"kwarg1": 13}
            if num_f1_args[1] >= 2:
                kwargs_to_specify["kwarg2"] = "second kwarg"
            if num_f1_args[1] == 3:
                kwargs_to_specify["kwarg3"] = [11, 22, 33]

        if num_f1_args[2] == 1:
            args_to_specify = (42,)
        if num_f1_args[2] >= 2:
            args_to_specify = (42, "my arg 2")
        if num_f1_args[2] == 3:
            args_to_specify = (42, "my arg 2", [1, 2, 3])

        logger.debug(f"Before: {kwargs_to_specify}")

        if smart_thread_name_to_specify:
            if args_to_specify:
                if kwargs_to_specify:
                    for group_name in group_names_arg:
                        beta_smart_thread.append(
                            SmartThread(
                                group_name=group_name,
                                name="beta",
                                target_rtn=eval(f1_target_to_specify),
                                thread_parm_name=smart_thread_name_to_specify,
                                args=args_to_specify,
                                kwargs=kwargs_to_specify,
                            )
                        )
                else:
                    for group_name in group_names_arg:
                        beta_smart_thread.append(
                            SmartThread(
                                group_name=group_name,
                                name="beta",
                                target_rtn=eval(f1_target_to_specify),
                                thread_parm_name=smart_thread_name_to_specify,
                                args=args_to_specify,
                            )
                        )
            else:
                if kwargs_to_specify:
                    for group_name in group_names_arg:
                        beta_smart_thread.append(
                            SmartThread(
                                group_name=group_name,
                                name="beta",
                                target_rtn=eval(f1_target_to_specify),
                                thread_parm_name=smart_thread_name_to_specify,
                                kwargs=kwargs_to_specify,
                            )
                        )
                else:
                    for group_name in group_names_arg:
                        beta_smart_thread.append(
                            SmartThread(
                                group_name=group_name,
                                name="beta",
                                target_rtn=eval(f1_target_to_specify),
                                thread_parm_name=smart_thread_name_to_specify,
                            )
                        )
        else:
            if args_to_specify:
                if kwargs_to_specify:
                    for group_name in group_names_arg:
                        beta_smart_thread.append(
                            SmartThread(
                                group_name=group_name,
                                name="beta",
                                target_rtn=eval(f1_target_to_specify),
                                args=args_to_specify,
                                kwargs=kwargs_to_specify,
                            )
                        )
                else:
                    for group_name in group_names_arg:
                        beta_smart_thread.append(
                            SmartThread(
                                group_name=group_name,
                                name="beta",
                                target_rtn=eval(f1_target_to_specify),
                                args=args_to_specify,
                            )
                        )
            else:
                if kwargs_to_specify:
                    for group_name in group_names_arg:
                        beta_smart_thread.append(
                            SmartThread(
                                group_name=group_name,
                                name="beta",
                                target_rtn=eval(f1_target_to_specify),
                                kwargs=kwargs_to_specify,
                            )
                        )
                else:
                    for group_name in group_names_arg:
                        beta_smart_thread.append(
                            SmartThread(
                                group_name=group_name,
                                name="beta",
                                target_rtn=eval(f1_target_to_specify),
                            )
                        )

        logger.debug(f"After: {kwargs_to_specify}")

        thread_state = ThreadState.Alive
        for group_name in reversed(group_names_arg):
            wait_for(
                lambda: SmartThread.get_state(group_name=group_name, name="beta")
                == thread_state
            )
            # thread_state = ThreadState.Stopped

        for idx, group_name in enumerate(group_names_arg):
            alpha_smart_thread[idx].smart_join(targets="beta")
            assert (
                SmartThread.get_state(group_name=group_name, name="beta")
                == ThreadState.Unregistered
            )

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_thread_interface_3
    ####################################################################
    @pytest.mark.parametrize(
        "num_f1_args",
        [
            (0, 0, 0),
            (0, 0, 1),
            (0, 0, 2),
            (0, 0, 3),
            (0, 1, 0),
            (0, 1, 1),
            (0, 1, 2),
            (0, 1, 3),
            (0, 2, 0),
            (0, 2, 1),
            (0, 2, 2),
            (0, 2, 3),
            (0, 3, 0),
            (0, 3, 1),
            (0, 3, 2),
            (0, 3, 3),
            (1, 0, 0),
            (1, 0, 1),
            (1, 0, 2),
            (1, 0, 3),
            (1, 1, 0),
            (1, 1, 1),
            (1, 1, 2),
            (1, 1, 3),
            (1, 2, 0),
            (1, 2, 1),
            (1, 2, 2),
            (1, 2, 3),
            (1, 3, 0),
            (1, 3, 1),
            (1, 3, 2),
            (1, 3, 3),
        ],
    )
    def test_smart_thread_interface_3(self, num_f1_args: tuple[int, int, int]) -> None:
        """Test smart_send example 3 with no parms.

        Args:
            num_f1_args: number of arguments to specify
        """
        from scottbrian_paratools.smart_thread import SmartThread, ThreadState

        class ReqParms(TypedDict):
            kwarg1: NotRequired[int]
            kwarg2: NotRequired[str]
            kwarg3: NotRequired[list[int]]
            smart_thread: NotRequired[SmartThread]

        def f1(*args: Union[int, str, list[int]], **kwargs: Unpack[ReqParms]) -> None:
            logger.debug("f1 beta entry")

            exp_args = (0, 42, "my arg 2", [1, 2, 3])
            exp_kwargs = {
                "kwarg1": 13,
                "kwarg2": "second kwarg",
                "kwarg3": [11, 22, 33],
            }
            args_str = ""
            comma = ""
            for idx, arg in enumerate(args, 1):
                args_str = f"{args_str}{comma}arg{idx}={arg}"
                comma = ", "
                assert arg == exp_args[idx]
            if args_str:
                logger.debug(args_str)

            smart_thread_arg = False
            kwargs_str = ""
            comma = ""
            a_smart_thread: SmartThread
            if "smart_thread" in kwargs:
                a_smart_thread = kwargs["smart_thread"]
            for key, value in kwargs.items():
                if key == "smart_thread":
                    smart_thread_arg = True
                    # smart_thread = value
                else:
                    kwargs_str = f"{kwargs_str}{comma}{key}={value}"
                    comma = ", "
                    assert exp_kwargs[key] == value
            if kwargs_str:
                logger.debug(kwargs_str)

            if smart_thread_arg:
                logger.debug(f"{a_smart_thread=}")
                wait_for(
                    lambda: a_smart_thread.get_state(group_name="test1", name="beta")
                    == ThreadState.Alive
                )

            logger.debug("f1 beta exit")

        logger.debug("mainline entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        if num_f1_args == (0, 0, 0):
            beta_smart_thread = SmartThread(
                group_name="test1", name="beta", target_rtn=f1
            )
        elif num_f1_args == (0, 0, 1):
            beta_smart_thread = SmartThread(
                group_name="test1", name="beta", target_rtn=f1, args=(42,)
            )
        elif num_f1_args == (0, 0, 2):
            beta_smart_thread = SmartThread(
                group_name="test1", name="beta", target_rtn=f1, args=(42, "my arg 2")
            )
        elif num_f1_args == (0, 0, 3):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                args=(42, "my arg 2", [1, 2, 3]),
            )
        elif num_f1_args == (0, 1, 0):
            beta_smart_thread = SmartThread(
                group_name="test1", name="beta", target_rtn=f1, kwargs={"kwarg1": 13}
            )
        elif num_f1_args == (0, 1, 1):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                args=(42,),
                kwargs={"kwarg1": 13},
            )
        elif num_f1_args == (0, 1, 2):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                args=(42, "my arg 2"),
                kwargs={"kwarg1": 13},
            )
        elif num_f1_args == (0, 1, 3):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                args=(42, "my arg 2", [1, 2, 3]),
                kwargs={"kwarg1": 13},
            )
        elif num_f1_args == (0, 2, 0):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
            )
        elif num_f1_args == (0, 2, 1):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                args=(42,),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
            )
        elif num_f1_args == (0, 2, 2):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                args=(42, "my arg 2"),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
            )
        elif num_f1_args == (0, 2, 3):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                args=(42, "my arg 2", [1, 2, 3]),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
            )
        elif num_f1_args == (0, 3, 0):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg", "kwarg3": [11, 22, 33]},
            )
        elif num_f1_args == (0, 3, 1):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                args=(42,),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg", "kwarg3": [11, 22, 33]},
            )
        elif num_f1_args == (0, 3, 2):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                args=(42, "my arg 2"),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg", "kwarg3": [11, 22, 33]},
            )
        elif num_f1_args == (0, 3, 3):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                args=(42, "my arg 2", [1, 2, 3]),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg", "kwarg3": [11, 22, 33]},
            )
        elif num_f1_args == (1, 0, 0):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                thread_parm_name="smart_thread",
            )
        elif num_f1_args == (1, 0, 1):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                thread_parm_name="smart_thread",
                args=(42,),
            )
        elif num_f1_args == (1, 0, 2):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                thread_parm_name="smart_thread",
                args=(42, "my arg 2"),
            )
        elif num_f1_args == (1, 0, 3):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                thread_parm_name="smart_thread",
                args=(42, "my arg 2", [1, 2, 3]),
            )
        elif num_f1_args == (1, 1, 0):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                thread_parm_name="smart_thread",
                kwargs={"kwarg1": 13},
            )
        elif num_f1_args == (1, 1, 1):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                thread_parm_name="smart_thread",
                args=(42,),
                kwargs={"kwarg1": 13},
            )
        elif num_f1_args == (1, 1, 2):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                thread_parm_name="smart_thread",
                args=(42, "my arg 2"),
                kwargs={"kwarg1": 13},
            )
        elif num_f1_args == (1, 1, 3):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                thread_parm_name="smart_thread",
                args=(42, "my arg 2", [1, 2, 3]),
                kwargs={"kwarg1": 13},
            )
        elif num_f1_args == (1, 2, 0):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                thread_parm_name="smart_thread",
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
            )
        elif num_f1_args == (1, 2, 1):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                thread_parm_name="smart_thread",
                args=(42,),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
            )
        elif num_f1_args == (1, 2, 2):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                thread_parm_name="smart_thread",
                args=(42, "my arg 2"),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
            )
        elif num_f1_args == (1, 2, 3):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                thread_parm_name="smart_thread",
                args=(42, "my arg 2", [1, 2, 3]),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg"},
            )
        elif num_f1_args == (1, 3, 0):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                thread_parm_name="smart_thread",
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg", "kwarg3": [11, 22, 33]},
            )
        elif num_f1_args == (1, 3, 1):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                thread_parm_name="smart_thread",
                args=(42,),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg", "kwarg3": [11, 22, 33]},
            )
        elif num_f1_args == (1, 3, 2):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                thread_parm_name="smart_thread",
                args=(42, "my arg 2"),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg", "kwarg3": [11, 22, 33]},
            )
        elif num_f1_args == (1, 3, 3):
            beta_smart_thread = SmartThread(
                group_name="test1",
                name="beta",
                target_rtn=f1,
                thread_parm_name="smart_thread",
                args=(42, "my arg 2", [1, 2, 3]),
                kwargs={"kwarg1": 13, "kwarg2": "second kwarg", "kwarg3": [11, 22, 33]},
            )

        wait_for(
            lambda: beta_smart_thread.get_state(group_name="test1", name="beta")
            == ThreadState.Alive
        )

        alpha_smart_thread.smart_join(targets="beta")
        assert (
            beta_smart_thread.get_state(group_name="test1", name="beta")
            == ThreadState.Unregistered
        )
        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_thread_interface_4
    ####################################################################
    @pytest.mark.parametrize(
        "num_f1_args",
        [
            (0, 0, 0),
            (0, 0, 1),
            (0, 0, 2),
            (0, 0, 3),
            (0, 1, 0),
            (0, 1, 1),
            (0, 1, 2),
            (0, 1, 3),
            (0, 2, 0),
            (0, 2, 1),
            (0, 2, 2),
            (0, 2, 3),
            (0, 3, 0),
            (0, 3, 1),
            (0, 3, 2),
            (0, 3, 3),
            (1, 0, 0),
            (1, 0, 1),
            (1, 0, 2),
            (1, 0, 3),
            (1, 1, 0),
            (1, 1, 1),
            (1, 1, 2),
            (1, 1, 3),
            (1, 2, 0),
            (1, 2, 1),
            (1, 2, 2),
            (1, 2, 3),
            (1, 3, 0),
            (1, 3, 1),
            (1, 3, 2),
            (1, 3, 3),
        ],
    )
    def test_smart_thread_interface_4(self, num_f1_args: tuple[int, int, int]) -> None:
        """Test smart_send example 4 with no parms.

        Args:
            num_f1_args: number of arguments to specify
        """
        from scottbrian_paratools.smart_thread import SmartThread, ThreadState

        def f1(
            *args: Union[int, str, list[int]],
            kwarg1: Optional[int] = None,
            kwarg2: Optional[str] = None,
            kwarg3: Optional[list[int]] = None,
            smart_thread: Optional[SmartThread] = None,
        ) -> None:
            logger.debug("f1 beta entry")

            exp_args = (0, 42, "my arg 2", [1, 2, 3])
            exp_kwargs = {
                "kwarg1": 13,
                "kwarg2": "second kwarg",
                "kwarg3": [11, 22, 33],
            }
            args_str = ""
            comma = ""
            # The first element in exp_args is ignored so we start idx
            # at 1. This make the log message look better since it will
            # show arg2 as "my arg 2".
            for idx, arg in enumerate(args, 1):
                args_str = f"{args_str}{comma}arg{idx}={arg}"
                comma = ", "
                assert arg == exp_args[idx]
            if args_str:
                logger.debug(args_str)

            kwargs_str = ""
            if kwarg1:
                kwargs_str = f"{kwargs_str}{kwarg1=}"
                assert kwarg1 == exp_kwargs["kwarg1"]
            if kwarg2:
                kwargs_str = f"{kwargs_str}, {kwarg2=}"
                assert kwarg2 == exp_kwargs["kwarg2"]
            if kwarg3:
                kwargs_str = f"{kwargs_str}, {kwarg3=}"
                assert kwarg3 == exp_kwargs["kwarg3"]

            if kwargs_str:
                logger.debug(kwargs_str)

            if smart_thread:
                logger.debug(f"{smart_thread=}")
                wait_for(
                    lambda: smart_thread.get_state(group_name="test1", name="beta")
                    == ThreadState.Alive
                )

            logger.debug("f1 beta exit")

        logger.debug("mainline entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")

        smart_thread_name_to_specify = None
        args_to_specify: Optional[tuple[Any, ...]] = None
        kwargs_to_specify: Optional[dict[str, Any]]
        if num_f1_args[0] == 1:
            smart_thread_name_to_specify = "smart_thread"

        if num_f1_args[1] == 0:
            kwargs_to_specify = None
        else:
            kwargs_to_specify = {"kwarg1": 13}
            if num_f1_args[1] >= 2:
                kwargs_to_specify["kwarg2"] = "second kwarg"
            if num_f1_args[1] == 3:
                kwargs_to_specify["kwarg3"] = [11, 22, 33]

        if num_f1_args[2] == 1:
            args_to_specify = (42,)
        if num_f1_args[2] >= 2:
            args_to_specify = (42, "my arg 2")
        if num_f1_args[2] == 3:
            args_to_specify = (42, "my arg 2", [1, 2, 3])

        beta_smart_thread = SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            thread_parm_name=smart_thread_name_to_specify,
            args=args_to_specify,
            kwargs=kwargs_to_specify,
        )

        wait_for(
            lambda: beta_smart_thread.get_state(group_name="test1", name="beta")
            == ThreadState.Alive
        )

        alpha_smart_thread.smart_join(targets="beta")
        assert (
            beta_smart_thread.get_state(group_name="test1", name="beta")
            == ThreadState.Unregistered
        )
        logger.debug("mainline exiting")


########################################################################
# TestSmartThreadErrors class
########################################################################
@pytest.mark.cover
class TestSmartThreadExamples:
    """Test class for SmartThread example tests."""

    ####################################################################
    # test_smart_thread_instantiation_example_1
    ####################################################################
    def test_smart_thread_instantiation_example_1(self, capsys: Any) -> None:
        """Test smart_thread instantiation example 1.

        Create a SmartThread configuration for threads named alpha and
        beta, send and receive a message, and resume a wait. Note the
        use of auto_start=False and doing the smart_start.

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1() -> None:
            print("f1 beta entered")
            beta_smart_thread.smart_send(
                receivers="alpha", msg="hi alpha, this is beta"
            )
            beta_smart_thread.smart_wait(resumers="alpha")
            print("f1 beta exiting")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        beta_smart_thread = SmartThread(
            group_name="test1", name="beta", target_rtn=f1, auto_start=False
        )
        beta_smart_thread.smart_start()

        recvd_msgs = alpha_smart_thread.smart_recv(senders="beta")
        print(recvd_msgs["beta"])
        alpha_smart_thread.smart_resume(waiters="beta")
        alpha_smart_thread.smart_join(targets="beta")
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "f1 beta entered\n"
        expected_result += "['hi alpha, this is beta']\n"
        expected_result += "f1 beta exiting\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_thread_instantiation_example_2
    ####################################################################
    def test_smart_thread_instantiation_example_2(self, capsys: Any) -> None:
        """Test smart_thread instantiation example 2.

        Create a SmartThread configuration for threads named alpha and
        beta, send and receive a message, and resume a wait. Note the
        use of auto_start=True and passing the SmartThread instance to
        the target_rtn via the thread_parm_name.

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1(smart_thread: SmartThread) -> None:
            print("f1 beta entered")
            smart_thread.smart_send(receivers="alpha", msg="hi alpha, this is beta")
            smart_thread.smart_wait(resumers="alpha")
            print("f1 beta exiting")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            auto_start=True,
            thread_parm_name="smart_thread",
        )
        recvd_msgs = alpha_smart_thread.smart_recv(senders="beta")
        print(recvd_msgs["beta"])
        alpha_smart_thread.smart_resume(waiters="beta")
        alpha_smart_thread.smart_join(targets="beta")
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "f1 beta entered\n"
        expected_result += "['hi alpha, this is beta']\n"
        expected_result += "f1 beta exiting\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_thread_instantiation_example_3
    ####################################################################
    def test_smart_thread_instantiation_example_3(self, capsys: Any) -> None:
        """Test smart_thread instantiation example 3.

        Create a SmartThread configuration for threads named alpha and
        beta, send and receive a message, and resume a wait. Note the
        use of threading.Thread to create and start the beta thread and
        having the target_rtn thread instantiate the SmartThread.

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import threading

        def f1() -> None:
            print("f1 beta entered")
            beta_smart_thread = SmartThread(group_name="test1", name="beta")
            beta_smart_thread.smart_send(
                receivers="alpha", msg="hi alpha, this is beta"
            )
            beta_smart_thread.smart_wait(resumers="alpha")
            print("f1 beta exiting")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        beta_thread = threading.Thread(target=f1, name="beta")
        beta_thread.start()
        recvd_msgs = alpha_smart_thread.smart_recv(senders="beta")
        print(recvd_msgs["beta"])
        alpha_smart_thread.smart_resume(waiters="beta")
        alpha_smart_thread.smart_join(targets="beta")
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "f1 beta entered\n"
        expected_result += "['hi alpha, this is beta']\n"
        expected_result += "f1 beta exiting\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_thread_instantiation_example_4
    ####################################################################
    def test_smart_thread_instantiation_example_4(self, capsys: Any) -> None:
        """Test smart_thread instantiation example 4.

        Create a SmartThread configuration for threads named alpha and
        beta, send and receive a message, and resume a wait. Note the
        use of the ThreadApp class that inherits threading.Thread as a
        base and uses a run method. This example demonstrates the use of
        the *thread* argument on the SmartThread instantiation.

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import threading
        import time

        class ThreadApp(threading.Thread):
            """Example thread app."""

            def __init__(self, name: str) -> None:
                """Initialize the object.

                Args:
                    name: name of thread

                """
                super().__init__(name=name)
                self.smart_thread = SmartThread(
                    group_name="test1", name=name, thread=self, auto_start=False
                )
                self.smart_thread.smart_start()

            def run(self) -> None:
                """Run the test."""
                print(f"{self.smart_thread.name} entry to run method")
                self.smart_thread.smart_send(
                    msg="hi alpha, this is beta", receivers="alpha"
                )
                time.sleep(1)
                print(f"{self.smart_thread.name} about to wait")
                self.smart_thread.smart_wait(resumers="alpha")
                print(f"{self.smart_thread.name} exiting run method")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        ThreadApp(name="beta")
        recvd_msgs = alpha_smart_thread.smart_recv(senders="beta")
        print(recvd_msgs["beta"])
        time.sleep(2)
        print("alpha about to resume beta")
        alpha_smart_thread.smart_resume(waiters="beta")
        alpha_smart_thread.smart_join(targets="beta")
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "beta entry to run method\n"
        expected_result += "['hi alpha, this is beta']\n"
        expected_result += "beta about to wait\n"
        expected_result += "alpha about to resume beta\n"
        expected_result += "beta exiting run method\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_thread_instantiation_example_5
    ####################################################################
    def test_smart_thread_instantiation_example_5(self, capsys: Any) -> None:
        """Test smart_thread instantiation example 5.

        Create a SmartThread configuration for threads named alpha and
        beta, send and receive a message, and resume a wait. Note the
        use of the SmartThreadApp class that multipli inherits
        threading.Thread and SmartThread and uses a run method. This
        example demonstrates the use of the *thread* argument on the
        SmartThread instantiation.

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import threading
        import time

        class SmartThreadApp(threading.Thread, SmartThread):
            """Example thread app."""

            def __init__(self, name: str) -> None:
                """Initialize the object.

                Args:
                    name: name of thread

                """
                threading.Thread.__init__(self, name=name)
                SmartThread.__init__(
                    self, group_name="test1", name=name, thread=self, auto_start=True
                )

            def run(self) -> None:
                """Run the test."""
                print(f"{self.name} entry to run method")
                self.smart_send(msg="hi alpha, this is beta", receivers="alpha")
                time.sleep(1)
                print(f"{self.name} about to wait")
                self.smart_wait(resumers="alpha")
                print(f"{self.name} exiting run method")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        SmartThreadApp(name="beta")
        recvd_msgs = alpha_smart_thread.smart_recv(senders="beta")
        print(recvd_msgs["beta"])
        time.sleep(2)
        print("alpha about to resume beta")
        alpha_smart_thread.smart_resume(waiters="beta")
        alpha_smart_thread.smart_join(targets="beta")
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "beta entry to run method\n"
        expected_result += "['hi alpha, this is beta']\n"
        expected_result += "beta about to wait\n"
        expected_result += "alpha about to resume beta\n"
        expected_result += "beta exiting run method\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_start_example_1
    ####################################################################
    def test_smart_start_example_1(self, capsys: Any) -> None:
        """Test smart_start example 1.

        Create and start a SmartThread.

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1() -> None:
            print("f1 beta entered")
            print("f1 beta exiting")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        beta_smart_thread = SmartThread(
            group_name="test1", name="beta", target_rtn=f1, auto_start=False
        )
        print("alpha about to start beta")
        beta_smart_thread.smart_start()
        alpha_smart_thread.smart_join(targets="beta")
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "alpha about to start beta\n"
        expected_result += "f1 beta entered\n"
        expected_result += "f1 beta exiting\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_start_example_2
    ####################################################################
    def test_smart_start_example_2(self, capsys: Any) -> None:
        """Test smart_start example 2.

        Create and start two SmartThread threads.

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1_beta() -> None:
            print("f1_beta entered")
            print("f1_beta exiting")

        def f2_charlie() -> None:
            time.sleep(1)
            print("f2_charlie entered")
            print("f2_charlie exiting")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        SmartThread(
            group_name="test1", name="beta", target_rtn=f1_beta, auto_start=False
        )
        SmartThread(
            group_name="test1", name="charlie", target_rtn=f2_charlie, auto_start=False
        )
        print("alpha about to start beta and charlie")
        alpha_smart_thread.smart_start(targets=["beta", "charlie"])
        alpha_smart_thread.smart_join(targets=["beta", "charlie"])
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "alpha about to start beta and charlie\n"
        expected_result += "f1_beta entered\n"
        expected_result += "f1_beta exiting\n"
        expected_result += "f2_charlie entered\n"
        expected_result += "f2_charlie exiting\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_unreg_example_1
    ####################################################################
    def test_smart_unreg_example_1(self, capsys: Any) -> None:
        """Test smart_unreg example 1.

        Create and unregister a SmartThread thread.

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1_beta() -> None:
            print("f1_beta entered")
            print("f1_beta exiting")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        print("alpha about to create beta")
        SmartThread(
            group_name="test1", name="beta", target_rtn=f1_beta, auto_start=False
        )
        print("alpha about to unregister beta")
        alpha_smart_thread.smart_unreg(targets="beta")
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "alpha about to create beta\n"
        expected_result += "alpha about to unregister beta\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_join_example_1
    ####################################################################
    def test_smart_join_example_1(self, capsys: Any) -> None:
        """Test smart_join example 1.

        Create and join a SmartThread thread.

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1_beta() -> None:
            print("f1_beta entered")
            print("f1_beta exiting")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        print("alpha about to create beta")
        SmartThread(group_name="test1", name="beta", target_rtn=f1_beta)
        time.sleep(1)
        print("alpha about to join beta")
        alpha_smart_thread.smart_join(targets="beta")
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "alpha about to create beta\n"
        expected_result += "f1_beta entered\n"
        expected_result += "f1_beta exiting\n"
        expected_result += "alpha about to join beta\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_send_example_1
    ####################################################################
    def test_smart_send_example_1(self, capsys: Any) -> None:
        """Test smart_send example 1.

        send a single message to a single remote thread

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1(smart_thread: SmartThread) -> None:
            print("f1 beta entered")
            recvd_msgs = smart_thread.smart_recv(senders="alpha")
            print(recvd_msgs["alpha"])
            print("f1 beta exiting")

        print("mainline alpha entered")
        logger.debug("mainline entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            thread_parm_name="smart_thread",
        )
        alpha_smart_thread.smart_send(msg="hello beta", receivers="beta")
        alpha_smart_thread.smart_join(targets="beta")
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "f1 beta entered\n"
        expected_result += "['hello beta']\n"
        expected_result += "f1 beta exiting\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_send_example_2
    ####################################################################
    def test_smart_send_example_2(self, capsys: Any) -> None:
        """Test smart_send example 2.

        send a single message to multiple remote threads

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1(smart_thread: SmartThread) -> None:
            if smart_thread.name == "charlie":
                time.sleep(1)  # delay to control msg interleaving
            print(f"f1 {smart_thread.name} entered")
            recvd_msgs = smart_thread.smart_recv(senders="alpha")
            print(recvd_msgs["alpha"])
            print(f"f1 {smart_thread.name} exiting")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            thread_parm_name="smart_thread",
        )
        SmartThread(
            group_name="test1",
            name="charlie",
            target_rtn=f1,
            thread_parm_name="smart_thread",
        )
        alpha_smart_thread.smart_send(
            msg="hello remotes", receivers=("beta", "charlie")
        )
        alpha_smart_thread.smart_join(targets=("beta", "charlie"))
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "f1 beta entered\n"
        expected_result += "['hello remotes']\n"
        expected_result += "f1 beta exiting\n"
        expected_result += "f1 charlie entered\n"
        expected_result += "['hello remotes']\n"
        expected_result += "f1 charlie exiting\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_send_example_3
    ####################################################################
    def test_smart_send_example_3(self, capsys: Any) -> None:
        """Test smart_send example 3.

        send multiple messages to a single remote thread

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1(smart_thread: SmartThread) -> None:
            print(f"f1 {smart_thread.name} entered")
            recvd_msgs = smart_thread.smart_recv(senders="alpha")
            print(recvd_msgs["alpha"])
            print(f"f1 {smart_thread.name} exiting")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            thread_parm_name="smart_thread",
        )
        alpha_smart_thread.smart_send(
            msg=("hello beta", "have a great day", 42), receivers="beta"
        )
        alpha_smart_thread.smart_join(targets="beta")
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "f1 beta entered\n"
        expected_result += "[('hello beta', " "'have a great day', 42)]\n"
        expected_result += "f1 beta exiting\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_send_example_4
    ####################################################################
    def test_smart_send_example_4(self, capsys: Any) -> None:
        """Test smart_send example 4.

        send multiple messages to multiple remote threads

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1(
            smart_thread: SmartThread,
            wait_for: Optional[str] = None,
            resume_target: Optional[str] = None,
        ) -> None:
            if wait_for:
                smart_thread.smart_wait(resumers=wait_for)
            print(f"f1 {smart_thread.name} entered")
            recvd_msgs = smart_thread.smart_recv(senders="alpha")
            print(recvd_msgs["alpha"])
            print(f"f1 {smart_thread.name} exiting")
            if resume_target:
                smart_thread.smart_resume(waiters=resume_target)

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            thread_parm_name="smart_thread",
            kwargs={"resume_target": "charlie"},
        )
        SmartThread(
            group_name="test1",
            name="charlie",
            target_rtn=f1,
            thread_parm_name="smart_thread",
            kwargs={"wait_for": "beta", "resume_target": "delta"},
        )
        SmartThread(
            group_name="test1",
            name="delta",
            target_rtn=f1,
            thread_parm_name="smart_thread",
            kwargs={"wait_for": "charlie", "resume_target": "alpha"},
        )
        alpha_smart_thread.smart_send(
            msg=["hello remotes", "have a great day", 42],
            receivers=["beta", "charlie", "delta"],
        )
        alpha_smart_thread.smart_wait(resumers="delta")
        alpha_smart_thread.smart_join(targets=("beta", "charlie", "delta"))
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "f1 beta entered\n"
        expected_result += "[['hello remotes', " "'have a great day', 42]]\n"
        expected_result += "f1 beta exiting\n"
        expected_result += "f1 charlie entered\n"
        expected_result += "[['hello remotes', " "'have a great day', 42]]\n"
        expected_result += "f1 charlie exiting\n"
        expected_result += "f1 delta entered\n"
        expected_result += "[['hello remotes', " "'have a great day', 42]]\n"
        expected_result += "f1 delta exiting\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_send_example_5
    ####################################################################
    def test_smart_send_example_5(self, capsys: Any) -> None:
        """Test smart_send example 5.

        send any mixture of single and multiple messages individually to
        each remote thread

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1(
            smart_thread: SmartThread,
            wait_for: Optional[str] = None,
            resume_target: Optional[str] = None,
        ) -> None:
            if wait_for:
                smart_thread.smart_wait(resumers=wait_for)
            print(f"f1 {smart_thread.name} entered")
            recvd_msgs = smart_thread.smart_recv(senders="alpha")
            print(recvd_msgs["alpha"])
            print(f"f1 {smart_thread.name} exiting")
            if resume_target:
                smart_thread.smart_resume(waiters=resume_target)

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            thread_parm_name="smart_thread",
            kwargs={"resume_target": "charlie"},
        )
        SmartThread(
            group_name="test1",
            name="charlie",
            target_rtn=f1,
            thread_parm_name="smart_thread",
            kwargs={"wait_for": "beta", "resume_target": "delta"},
        )
        SmartThread(
            group_name="test1",
            name="delta",
            target_rtn=f1,
            thread_parm_name="smart_thread",
            kwargs={"wait_for": "charlie", "resume_target": "alpha"},
        )
        msgs_to_send = {
            "beta": "hi beta",
            "charlie": ("hi charlie", "have a great day"),
            "delta": [42, "hi delta", {"nums": (1, 2, 3)}],
        }
        alpha_smart_thread.smart_send(msg_dict=msgs_to_send)
        alpha_smart_thread.smart_wait(resumers="delta")
        alpha_smart_thread.smart_join(targets=("beta", "charlie", "delta"))
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "f1 beta entered\n"
        expected_result += "['hi beta']\n"
        expected_result += "f1 beta exiting\n"
        expected_result += "f1 charlie entered\n"
        expected_result += "[('hi charlie', " "'have a great day')]\n"
        expected_result += "f1 charlie exiting\n"
        expected_result += "f1 delta entered\n"
        expected_result += "[[42, 'hi delta', " "{'nums': (1, 2, 3)}]]\n"
        expected_result += "f1 delta exiting\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_recv_example_1
    ####################################################################
    def test_smart_recv_example_1(self, capsys: Any) -> None:
        """Test smart_recv example 1.

        receive a single message from a single remote thread

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1(smart_thread: SmartThread) -> None:
            print("f1 beta entered")
            smart_thread.smart_send(msg="hi alpha", receivers="alpha")
            print("f1 beta exiting")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            thread_parm_name="smart_thread",
        )
        recvd_msgs = alpha_smart_thread.smart_recv(senders="beta")
        print(recvd_msgs["beta"])
        alpha_smart_thread.smart_join(targets="beta")
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "f1 beta entered\n"
        expected_result += "f1 beta exiting\n"
        expected_result += "['hi alpha']\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_recv_example_2
    ####################################################################
    def test_smart_recv_example_2(self, capsys: Any) -> None:
        """Test smart_recv example 2.

        receive a single message from multiple remote threads

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1(smart_thread: SmartThread) -> None:
            print(f"f1 {smart_thread.name} entered")
            smart_thread.smart_send(
                msg=f"{smart_thread.name} says hi", receivers="alpha"
            )
            print(f"f1 {smart_thread.name} exiting")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            thread_parm_name="smart_thread",
        )
        time.sleep(0.2)
        SmartThread(
            group_name="test1",
            name="charlie",
            target_rtn=f1,
            thread_parm_name="smart_thread",
        )
        time.sleep(0.2)
        recvd_msgs = alpha_smart_thread.smart_recv(senders=("beta", "charlie"))
        print(recvd_msgs["beta"])
        print(recvd_msgs["charlie"])
        alpha_smart_thread.smart_join(targets=("beta", "charlie"))
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "f1 beta entered\n"
        expected_result += "f1 beta exiting\n"
        expected_result += "f1 charlie entered\n"
        expected_result += "f1 charlie exiting\n"
        expected_result += "['beta says hi']\n"
        expected_result += "['charlie says hi']\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_recv_example_3
    ####################################################################
    def test_smart_recv_example_3(self, capsys: Any) -> None:
        """Test smart_recv example 3.

        receive multiple messages from a single remote thread

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1(greeting: str, smart_thread: SmartThread) -> None:
            print(f"f1 {smart_thread.name} entered")
            smart_thread.smart_send(msg=f"{greeting}", receivers="alpha")
            smart_thread.smart_send(
                msg=["great to be here", "life is good"], receivers="alpha"
            )
            smart_thread.smart_send(
                msg=("we should do lunch sometime", "Tuesday afternoons are best"),
                receivers="alpha",
            )
            print(f"f1 {smart_thread.name} exiting")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            thread_parm_name="smart_thread",
            args=("hi",),
        )
        time.sleep(1)  # give enough time to allow all sends to complete
        recvd_msgs = alpha_smart_thread.smart_recv(senders="beta")
        print(recvd_msgs["beta"])
        alpha_smart_thread.smart_join(targets="beta")
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "f1 beta entered\n"
        expected_result += "f1 beta exiting\n"
        expected_result += "['hi', "
        expected_result += "['great to be here', 'life is good'], "
        expected_result += (
            "('we should do lunch sometime', " "'Tuesday afternoons are best')]\n"
        )
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_recv_example_4
    ####################################################################
    def test_smart_recv_example_4(self, capsys: Any) -> None:
        """Test smart_recv example 4.

        receive any mixture of single and multiple messages from
        specified remote threads

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1(
            greeting: str,
            smart_thread: SmartThread,
            wait_for: Optional[str] = None,
            resume_target: Optional[str] = None,
        ) -> None:
            if wait_for:
                smart_thread.smart_wait(resumers=wait_for)
            print(f"f1 {smart_thread.name} entered")
            smart_thread.smart_send(msg=f"{greeting}", receivers="alpha")
            if smart_thread.name in ("charlie", "delta"):
                smart_thread.smart_send(
                    msg=["miles to go", (1, 2, 3)], receivers="alpha"
                )
            if smart_thread.name == "delta":
                smart_thread.smart_send(
                    msg={"forty_two": 42, 42: 42}, receivers="alpha"
                )
            print(f"f1 {smart_thread.name} exiting")
            if resume_target:
                smart_thread.smart_resume(waiters=resume_target)

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            thread_parm_name="smart_thread",
            args=("hi",),
            kwargs={"resume_target": "charlie"},
        )
        SmartThread(
            group_name="test1",
            name="charlie",
            target_rtn=f1,
            thread_parm_name="smart_thread",
            args=("hello",),
            kwargs={"wait_for": "beta", "resume_target": "delta"},
        )
        SmartThread(
            group_name="test1",
            name="delta",
            target_rtn=f1,
            thread_parm_name="smart_thread",
            args=("aloha",),
            kwargs={"wait_for": "charlie", "resume_target": "alpha"},
        )
        alpha_smart_thread.smart_wait(resumers="delta")
        recvd_msgs = alpha_smart_thread.smart_recv(senders={"beta", "delta"})
        print(recvd_msgs["beta"])
        print(recvd_msgs["delta"])
        recvd_msgs = alpha_smart_thread.smart_recv(senders={"charlie"})
        print(recvd_msgs["charlie"])
        alpha_smart_thread.smart_join(targets=("beta", "charlie", "delta"))
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "f1 beta entered\n"
        expected_result += "f1 beta exiting\n"
        expected_result += "f1 charlie entered\n"
        expected_result += "f1 charlie exiting\n"
        expected_result += "f1 delta entered\n"
        expected_result += "f1 delta exiting\n"
        expected_result += "['hi']\n"
        expected_result += (
            "['aloha', ['miles to go', (1, 2, 3)], " "{'forty_two': 42, 42: 42}]\n"
        )
        expected_result += "['hello', " "['miles to go', (1, 2, 3)]]\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_wait_example_1
    ####################################################################
    def test_smart_wait_example_1(self, capsys: Any) -> None:
        """Test smart_wait example 1.

        smart_wait followed by smart_resume

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1(smart_thread: SmartThread) -> None:
            print(f"f1 {smart_thread.name} about to wait")
            resumed_by = smart_thread.smart_wait(resumers="alpha")
            print(f"f1 {smart_thread.name} resumed by {resumed_by}")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            thread_parm_name="smart_thread",
        )
        time.sleep(1)  # allow time for smart_wait to be issued
        print("alpha about to resume beta")
        alpha_smart_thread.smart_resume(waiters="beta")
        alpha_smart_thread.smart_join(targets="beta")
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "f1 beta about to wait\n"
        expected_result += "alpha about to resume beta\n"
        expected_result += "f1 beta resumed by {'alpha'}\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_wait_example_2
    ####################################################################
    def test_smart_wait_example_2(self, capsys: Any) -> None:
        """Test smart_wait example 2.

        smart_wait followed by smart_resume

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1(smart_thread: SmartThread) -> None:
            time.sleep(1)  # allow time for smart_resume to be issued
            print(f"f1 {smart_thread.name} about to wait")
            resumed_by = smart_thread.smart_wait(resumers="alpha")
            print(f"f1 {smart_thread.name} resumed by {resumed_by}")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            thread_parm_name="smart_thread",
        )
        print("alpha about to resume beta")
        alpha_smart_thread.smart_resume(waiters="beta")

        alpha_smart_thread.smart_join(targets="beta")
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "alpha about to resume beta\n"
        expected_result += "f1 beta about to wait\n"
        expected_result += "f1 beta resumed by {'alpha'}\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_wait_example_3
    ####################################################################
    def test_smart_wait_example_3(self, capsys: Any) -> None:
        """Test smart_wait example 3.

        smart_wait for multiple resumers with WaitFor.All

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1(smart_thread: SmartThread) -> None:
            print(f"f1 {smart_thread.name} about to resume alpha")
            smart_thread.smart_resume(waiters="alpha")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            thread_parm_name="smart_thread",
        )
        time.sleep(1)  # allow time for alpha to wait
        SmartThread(
            group_name="test1",
            name="charlie",
            target_rtn=f1,
            thread_parm_name="smart_thread",
        )
        time.sleep(1)  # allow time for alpha to wait
        SmartThread(
            group_name="test1",
            name="delta",
            target_rtn=f1,
            thread_parm_name="smart_thread",
        )
        time.sleep(1)  # allow time for alpha to wait
        print("alpha about to wait for all threads")
        resumed_by = alpha_smart_thread.smart_wait(
            resumers=["beta", "charlie", "delta"]
        )
        print(f"alpha resumed by resumers={sorted(resumed_by)}")

        alpha_smart_thread.smart_join(targets=["beta", "charlie", "delta"])
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "f1 beta about to resume alpha\n"
        expected_result += "f1 charlie about to resume alpha\n"
        expected_result += "f1 delta about to resume alpha\n"
        expected_result += "alpha about to wait for all threads\n"
        expected_result += "alpha resumed by " "resumers=['beta', 'charlie', 'delta']\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_wait_example_4
    ####################################################################
    def test_smart_wait_example_4(self, capsys: Any) -> None:
        """Test smart_wait example 4.

        smart_wait for multiple resumers with WaitFor.Any

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1(smart_thread: SmartThread) -> None:
            print(f"f1 {smart_thread.name} about to resume alpha")
            smart_thread.smart_resume(waiters="alpha")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            thread_parm_name="smart_thread",
        )
        time.sleep(1)
        SmartThread(
            group_name="test1",
            name="charlie",
            target_rtn=f1,
            thread_parm_name="smart_thread",
        )
        time.sleep(1)
        print("alpha about to wait for any threads")
        resumed_by = alpha_smart_thread.smart_wait(
            resumers=["beta", "charlie", "delta"], resumer_count=1
        )
        print(f"alpha resumed by resumers={sorted(resumed_by)}")
        SmartThread(
            group_name="test1",
            name="delta",
            target_rtn=f1,
            thread_parm_name="smart_thread",
        )
        time.sleep(1)  # allow time for alpha to wait
        print("alpha about to wait for any threads")
        resumed_by = alpha_smart_thread.smart_wait(
            resumers=["beta", "charlie", "delta"], resumer_count=1
        )
        print(f"alpha resumed by resumers={sorted(resumed_by)}")

        alpha_smart_thread.smart_join(targets=["beta", "charlie", "delta"])
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "f1 beta about to resume alpha\n"
        expected_result += "f1 charlie about to resume alpha\n"
        expected_result += "alpha about to wait for any threads\n"
        expected_result += "alpha resumed by resumers=['beta', 'charlie']\n"
        expected_result += "f1 delta about to resume alpha\n"
        expected_result += "alpha about to wait for any threads\n"
        expected_result += "alpha resumed by resumers=['delta']\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_resume_example_1
    ####################################################################
    def test_smart_resume_example_1(self, capsys: Any) -> None:
        """Test smart_resume example 1.

        Invoke ''smart_resume()'' for threads that invoke
        ''smart_wait()'' both before and after the ''smart_resume()''

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1_beta(smart_thread: SmartThread) -> None:
            print("f1_beta about to wait")
            smart_thread.smart_wait(resumers="alpha")
            print("f1_beta back from wait")

        def f2_charlie(smart_thread: SmartThread) -> None:
            time.sleep(4)
            print("f2_charlie about to wait")
            smart_thread.smart_wait(resumers="alpha")
            print("f2_charlie back from wait")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1_beta,
            thread_parm_name="smart_thread",
        )
        SmartThread(
            group_name="test1",
            name="charlie",
            target_rtn=f2_charlie,
            thread_parm_name="smart_thread",
        )
        time.sleep(2)
        print("alpha about to resume threads")
        alpha_smart_thread.smart_resume(waiters=["beta", "charlie"])
        alpha_smart_thread.smart_join(targets=["beta", "charlie"])
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "f1_beta about to wait\n"
        expected_result += "alpha about to resume threads\n"
        expected_result += "f1_beta back from wait\n"
        expected_result += "f2_charlie about to wait\n"
        expected_result += "f2_charlie back from wait\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_sync_example_1
    ####################################################################
    def test_smart_sync_example_1(self, capsys: Any) -> None:
        """Test smart_sync example 1.

        Invoke ''smart_sync()'' for three threads

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1_beta(smart_thread: SmartThread) -> None:
            print("f1_beta about to sync with alpha and charlie")
            smart_thread.smart_sync(targets=["alpha", "charlie"])
            print("f1_beta back from sync")

        def f2_charlie(smart_thread: SmartThread) -> None:
            print("f2_charlie about to sync with alpha and beta")
            smart_thread.smart_sync(targets=["alpha", "beta"])
            time.sleep(1)
            print("f2_charlie back from sync")

        print("mainline alpha entered")
        alpha_smart_thread = SmartThread(group_name="test1", name="alpha")
        SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1_beta,
            thread_parm_name="smart_thread",
        )
        time.sleep(1)
        SmartThread(
            group_name="test1",
            name="charlie",
            target_rtn=f2_charlie,
            thread_parm_name="smart_thread",
        )
        time.sleep(1)
        print("alpha about to sync with beta and charlie")
        alpha_smart_thread.smart_sync(targets=["beta", "charlie"])
        time.sleep(2)
        print("alpha back from sync")
        alpha_smart_thread.smart_join(targets=["beta", "charlie"])
        print("mainline alpha exiting")

        expected_result = "mainline alpha entered\n"
        expected_result += "f1_beta about to sync with alpha and charlie\n"
        expected_result += "f2_charlie about to sync with alpha and beta\n"
        expected_result += "alpha about to sync with beta and charlie\n"
        expected_result += "f1_beta back from sync\n"
        expected_result += "f2_charlie back from sync\n"
        expected_result += "alpha back from sync\n"
        expected_result += "mainline alpha exiting\n"

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug("mainline exiting")


####################################################################
# scenario_driver
####################################################################
def scenario_driver(
    scenario_builder: Callable[..., None],
    scenario_builder_args: dict[str, Any],
    caplog_to_use: pytest.LogCaptureFixture,
    commander_config: AppConfig = AppConfig.ScriptStyle,
) -> None:
    """Build and run a scenario.

    Args:
        scenario_builder: the ConfigVerifier builder method to call
        scenario_builder_args: the args to pass to the builder
        caplog_to_use: the capsys to capture log messages
        commander_config: specifies how the commander will run

    """

    ################################################################
    # f1
    ################################################################
    def f1(f1_name: str, f1_config_ver: ConfigVerifier) -> None:
        log_msg_f1 = f"f1 entered for {f1_name}"
        log_ver.add_msg(log_level=logging.DEBUG, log_msg=log_msg_f1)
        logger.debug(log_msg_f1)

        f1_config_ver.f1_driver(f1_name=f1_name)

        ############################################################
        # exit
        ############################################################
        log_msg_f1 = f"f1 exiting for {f1_name}"
        log_ver.add_msg(log_level=logging.DEBUG, log_msg=log_msg_f1)
        logger.debug(log_msg_f1)

    ################################################################
    # Set up log verification and start tests
    ################################################################
    commander_name = "alpha"
    log_ver = LogVer(log_name=__name__)
    log_ver.add_call_seq(name=commander_name, seq=get_formatted_call_sequence())

    random.seed(42)
    msgs = Msgs()

    config_ver = ConfigVerifier(
        group_name="test1",
        commander_name=commander_name,
        log_ver=log_ver,
        caplog_to_use=caplog_to_use,
        msgs=msgs,
        max_msgs=10,
    )

    config_ver.log_test_msg("mainline entered")
    config_ver.log_test_msg(f"scenario builder: {scenario_builder}")
    config_ver.log_test_msg(f"scenario args: {scenario_builder_args}")
    config_ver.log_test_msg(f"{commander_config=}")

    config_ver.unregistered_names -= {commander_name}
    config_ver.active_names |= {commander_name}

    scenario_builder(config_ver, **scenario_builder_args)

    # config_ver.add_cmd(ValidateConfig(cmd_runners=commander_name))
    config_ver.add_cmd(
        VerifyConfig(
            cmd_runners=commander_name, verify_type=VerifyType.VerifyStructures
        )
    )

    names = list(config_ver.active_names - {commander_name})
    config_ver.build_exit_suite(cmd_runner=commander_name, names=names)

    config_ver.build_join_suite(
        cmd_runners=[config_ver.commander_name], join_target_names=names
    )

    def initialize_config_ver(
        cmd_thread: st.SmartThread,
        auto_start: bool,
        auto_start_decision: AutoStartDecision,
        exp_alive: bool,
        thread_create: st.ThreadCreate,
        exp_state: st.ThreadState,
    ) -> None:
        """Set up the mock registry for the commander.

        Args:
            cmd_thread: the commander thread
            auto_start: specifies whether auto_start was specified
                on the init
            auto_start_decision: specifies whether an auto start is
                not needed, yes, or no
            exp_alive: specifies whether the thread is expected to
                be alive at the end of smart_init
            thread_create: specifies which create style is done
            exp_state: the expected state after smart_init

        """
        config_ver.all_threads[commander_name] = cmd_thread

        config_ver.expected_registered[commander_name] = ThreadTracker(
            thread=cmd_thread,
            is_alive=False,
            exiting=False,
            is_auto_started=auto_start,
            is_TargetThread=False,
            exp_init_is_alive=exp_alive,
            exp_init_thread_state=exp_state,
            thread_create=thread_create,
            auto_start_decision=auto_start_decision,
            # st_state=st.ThreadState.Unregistered,
            st_state=st.ThreadState.Initialized,
            found_del_pairs=defaultdict(int),
        )

        pe = config_ver.pending_events[commander_name]
        pe[PE.start_request].append(
            StartRequest(
                req_type=st.ReqType.Smart_init,
                targets={commander_name},
                unreg_remotes=set(),
                not_registered_remotes=set(),
                timeout_remotes=set(),
                stopped_remotes=set(),
                deadlock_remotes=set(),
                eligible_targets=set(),
                completed_targets=set(),
                first_round_completed=set(),
                stopped_target_threads=set(),
                exp_senders=set(),
                exp_resumers=set(),
            )
        )

        req_key_entry: RequestKey = ("smart_init", "entry")
        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ("smart_init", "exit")
        pe[PE.request_msg][req_key_exit] += 1

        config_ver.commander_thread_config_built = True

    ################################################################
    # start commander
    ################################################################
    config_ver.monitor_pause = True
    outer_thread_app: Union[OuterThreadApp, OuterSmartThreadApp, OuterSmartThreadApp2]
    if commander_config == AppConfig.ScriptStyle:
        commander_thread = st.SmartThread(group_name="test1", name=commander_name)

        initialize_config_ver(
            cmd_thread=commander_thread,
            auto_start=True,
            auto_start_decision=AutoStartDecision.auto_start_obviated,
            exp_alive=True,
            exp_state=st.ThreadState.Alive,
            thread_create=st.ThreadCreate.Current,
        )
        config_ver.monitor_pause = False
        config_ver.main_driver()
    elif commander_config == AppConfig.CurrentThreadApp:
        cmd_current_app = CommanderCurrentApp(
            config_ver=config_ver, name=commander_name, max_msgs=10
        )

        initialize_config_ver(
            cmd_thread=cmd_current_app.smart_thread,
            auto_start=False,
            auto_start_decision=AutoStartDecision.auto_start_no,
            exp_alive=True,
            exp_state=st.ThreadState.Alive,
            thread_create=st.ThreadCreate.Current,
        )
        config_ver.monitor_pause = False
        cmd_current_app.run()
    elif commander_config == AppConfig.RemoteThreadApp:
        outer_thread_app = OuterThreadApp(
            config_ver=config_ver, name=commander_name, max_msgs=10
        )

        initialize_config_ver(
            cmd_thread=outer_thread_app.smart_thread,
            auto_start=False,
            auto_start_decision=AutoStartDecision.auto_start_no,
            exp_alive=False,
            exp_state=st.ThreadState.Registered,
            thread_create=st.ThreadCreate.Thread,
        )
        config_ver.monitor_pause = False

        pe = config_ver.pending_events[commander_name]
        pe[PE.start_request].append(
            StartRequest(
                req_type=st.ReqType.Smart_start,
                targets={commander_name},
                unreg_remotes=set(),
                not_registered_remotes=set(),
                timeout_remotes=set(),
                stopped_remotes=set(),
                deadlock_remotes=set(),
                eligible_targets=set(),
                completed_targets=set(),
                first_round_completed=set(),
                stopped_target_threads=set(),
                exp_senders=set(),
                exp_resumers=set(),
            )
        )

        req_key_entry: RequestKey = ("smart_start", "entry")

        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ("smart_start", "exit")
        pe[PE.request_msg][req_key_exit] += 1

        outer_thread_app.smart_thread.smart_start()
        outer_thread_app.join()
    elif commander_config == AppConfig.RemoteSmartThreadApp:
        outer_thread_app = OuterSmartThreadApp(
            config_ver=config_ver, name=commander_name, max_msgs=10
        )

        initialize_config_ver(
            cmd_thread=outer_thread_app,
            auto_start=False,
            auto_start_decision=AutoStartDecision.auto_start_no,
            exp_alive=False,
            exp_state=st.ThreadState.Registered,
            thread_create=st.ThreadCreate.Thread,
        )
        config_ver.monitor_pause = False

        pe = config_ver.pending_events[commander_name]
        pe[PE.start_request].append(
            StartRequest(
                req_type=st.ReqType.Smart_start,
                targets={commander_name},
                unreg_remotes=set(),
                not_registered_remotes=set(),
                timeout_remotes=set(),
                stopped_remotes=set(),
                deadlock_remotes=set(),
                eligible_targets=set(),
                completed_targets=set(),
                first_round_completed=set(),
                stopped_target_threads=set(),
                exp_senders=set(),
                exp_resumers=set(),
            )
        )

        req_key_entry = ("smart_start", "entry")
        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit = ("smart_start", "exit")
        pe[PE.request_msg][req_key_exit] += 1

        outer_thread_app.smart_start(commander_name)
        threading.Thread.join(outer_thread_app)
    elif commander_config == AppConfig.RemoteSmartThreadApp2:
        outer_thread_app = OuterSmartThreadApp2(
            config_ver=config_ver, name=commander_name, max_msgs=10
        )

        initialize_config_ver(
            cmd_thread=outer_thread_app,
            auto_start=False,
            auto_start_decision=AutoStartDecision.auto_start_no,
            exp_alive=False,
            exp_state=st.ThreadState.Registered,
            thread_create=st.ThreadCreate.Thread,
        )
        config_ver.monitor_pause = False

        pe = config_ver.pending_events[commander_name]
        pe[PE.start_request].append(
            StartRequest(
                req_type=st.ReqType.Smart_start,
                targets={commander_name},
                unreg_remotes=set(),
                not_registered_remotes=set(),
                timeout_remotes=set(),
                stopped_remotes=set(),
                deadlock_remotes=set(),
                eligible_targets=set(),
                completed_targets=set(),
                first_round_completed=set(),
                stopped_target_threads=set(),
                exp_senders=set(),
                exp_resumers=set(),
            )
        )

        req_key_entry = ("smart_start", "entry")
        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit = ("smart_start", "exit")
        pe[PE.request_msg][req_key_exit] += 1

        outer_thread_app.smart_start(commander_name)
        threading.Thread.join(outer_thread_app)
    else:
        raise UnrecognizedCmd(
            "scenario_driver does not recognize " f"{commander_config=}"
        )

    ################################################################
    # check that pending events are complete
    ################################################################

    if not config_ver.monitor_exit:
        config_ver.log_test_msg("Monitor Checkpoint: check_pending_events 42")
        config_ver.monitor_event.set()
        config_ver.check_pending_events_complete_event.wait(timeout=30)

    config_ver.monitor_exit = True
    config_ver.monitor_event.set()
    config_ver.monitor_thread.join()

    ################################################################
    # check log results
    ################################################################
    match_results = log_ver.get_match_results(caplog=caplog_to_use)
    log_ver.print_match_results(match_results, print_matched=False)
    log_ver.verify_log_results(match_results)

    log_len = len(caplog_to_use.record_tuples)

    logger.debug(f"mainline exiting {log_len=}")

    print(f"scenario builder: {scenario_builder}")
    print(f"scenario args: {scenario_builder_args}")


########################################################################
# TestSmartThreadScenarios class
########################################################################
@pytest.mark.cover
class TestSmartThreadSmokeTest:
    """Test class for SmartThread scenarios."""

    ####################################################################
    # test_smart_thread_get_state
    ####################################################################
    # @pytest.mark.cover2
    def test_smart_thread_get_state(self) -> None:
        """Test get_state cases for SmartThread."""

        ################################################################
        # Variations on unknown group name and name
        ################################################################
        logger.debug("mainline entered")

        thread_state = st.SmartThread.get_state(group_name="unknown", name="alpha")
        assert thread_state == st.ThreadState.Unregistered

        st.SmartThread(group_name="test1", name="alpha")

        thread_state = st.SmartThread.get_state(group_name="unknown", name="alpha")
        assert thread_state == st.ThreadState.Unregistered

        thread_state = st.SmartThread.get_state(group_name="test1", name="unknown")
        assert thread_state == st.ThreadState.Unregistered

        thread_state = st.SmartThread.get_state(group_name="test1", name="alpha")
        assert thread_state == st.ThreadState.Alive

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_thread_log_msg
    ####################################################################
    @pytest.mark.parametrize(
        "log_level_arg",
        [
            logging.DEBUG,
            logging.INFO,
            logging.WARNING,
            logging.ERROR,
            logging.CRITICAL,
            logging.NOTSET,
        ],
    )
    # @pytest.mark.seltest
    def test_smart_thread_log_msg(
        self, log_level_arg: int, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Test smart_thread logging.

        Args:
            log_level_arg: logging level to set
            caplog: pytest fixture to capture log output

        Notes:
            1) pytest.ini log_cli_level sets the root level - it
               overrides the level set by basicConfig in conftest
            2) if pytest.ini log_cli_level is not set, conftest sets the
               level
            3) if conftest is not specified, the level defaults to
               WARNING
            4) logging.getLogger('scottbrian_paratools').setLevel(
               logging.DEBUG) overrides the root setting, whether the
               default set by conftest or set by pytest.ini
            5) logging.getLogger('scottbrian_paratools.smart_thread')
               .setLevel(logging.INFO) overrides all of the above.
            6) Basic strategy is to not specify the level with 4 or 5 -
               just let the application set the level using basicConfig

        """

        ################################################################
        # add_log_msgs
        ################################################################
        def add_log_msgs(log_msgs: StrOrList, log_name: str, log_level: int) -> None:
            """Add log message to log ver if log level is active.

            Args:
                log_msgs: messages to add
                log_name: name of log it is associated with
                log_level: log level of the msg
            """
            if isinstance(log_msgs, str):
                log_msgs = [log_msgs]

            if log_level_arg <= log_level:
                for a_log_msg in log_msgs:
                    log_ver.add_msg(
                        log_level=log_level,
                        log_msg=a_log_msg,
                        log_name=log_name,
                        fullmatch=True,
                    )

        ################################################################
        # f1
        ################################################################
        def f1(thread_name: str) -> None:
            """F1 routine.

            Args:
                thread_name: name of f1
            """
            log_msg_f1 = f"f1 entered for {thread_name}"
            add_log_msgs(
                log_msgs=log_msg_f1, log_level=logging.DEBUG, log_name=test_log_name
            )
            logger.debug(log_msg_f1)

            time.sleep(1)

            f1_st.smart_recv(senders="alpha")

            f1_st.smart_wait(resumers="alpha")

            f1_st.smart_sync(targets="alpha")

            ############################################################
            # exit
            ############################################################
            log_msg_f1 = f"f1 exiting for {thread_name}"
            add_log_msgs(
                log_msgs=log_msg_f1, log_level=logging.DEBUG, log_name=test_log_name
            )
            logger.debug(log_msg_f1)

        ################################################################
        # Set up log verification and start tests
        # The following code gets the root logger from the
        # logging Manager dictionary using the parent of smart_thread.
        # This is not the way it would normally be done, but it suits
        # our purpose to test that the log messages are being issued or
        # suppressed correctly based on logging levels.
        ################################################################
        lock_manager_logger = logging.Logger.manager.loggerDict["scottbrian_locking"]

        if isinstance(lock_manager_logger, logging.PlaceHolder):
            raise InvalidConfigurationDetected(
                "test_smart_thread_log_msg detected that the manager "
                "logger for scottbrian_locking is a PlaceHolder"
            )

        lock_manager_logger.setLevel(logging.CRITICAL)

        manager_logger = logging.Logger.manager.loggerDict["scottbrian_paratools"]

        if isinstance(manager_logger, logging.PlaceHolder):
            raise InvalidConfigurationDetected(
                "test_smart_thread_log_msg detected that the manager "
                "logger for scottbrian_paratools is a PlaceHolder"
            )

        my_root = manager_logger.parent

        if my_root is None:
            raise InvalidConfigurationDetected(
                "test_smart_thread_log_msg failed to find logger for "
                "scottbrian_paratools parent"
            )

        my_root.setLevel(log_level_arg)

        commander_name = "alpha"
        f1_name = "beta"
        log_ver = LogVer(log_name=__name__)
        log_ver.add_call_seq(name=commander_name, seq=get_formatted_call_sequence())

        test_log_name = __name__
        smart_thread_log_name = "scottbrian_paratools.smart_thread"

        log_msg = f"{my_root.name=}, {my_root.level=}"
        add_log_msgs(
            log_msgs=log_msg,
            log_level=max(log_level_arg, logging.DEBUG),
            log_name=test_log_name,
        )
        logger.log(level=max(log_level_arg, logging.DEBUG), msg=log_msg)

        log_msg = "mainline entered"
        add_log_msgs(log_msgs=log_msg, log_level=logging.WARN, log_name=test_log_name)
        logger.warning(log_msg)

        ################################################################
        # start commander
        ################################################################
        commander_thread = st.SmartThread(
            group_name="test1", name=commander_name, max_msgs=10
        )

        f1_st = st.SmartThread(
            group_name="test1",
            name=f1_name,
            target_rtn=f1,
            args=(f1_name,),
            max_msgs=10,
        )

        commander_thread.smart_send(receivers="beta", msg="alpha sends to beta")

        commander_thread.smart_resume(waiters="beta")

        commander_thread.smart_sync(targets="beta")

        commander_thread.smart_join(targets="beta")

        f1_st = st.SmartThread(
            group_name="test1",
            name=f1_name,
            target_rtn=f1,
            args=(f1_name,),
            auto_start=False,
        )

        commander_thread.smart_unreg(targets="beta")

        ################################################################
        # alpha_smart_init_alpha_debug_log_msgs
        ################################################################
        alpha_smart_init_alpha_debug_log_msgs = [
            (
                r"smart_init entry: requestor: alpha \(test1\), targets: "
                r"\['alpha'\] timeout value: None "
                "test_smart_thread.py::TestSmartThreadSmokeTest."
                "test_smart_thread_log_msg:[0-9]+"
            ),
            # ('alpha set state for thread alpha from '
            #  'ThreadState.Unregistered to ThreadState.Initialized'),
            (r"smart_init _register entry: alpha \(test1\), target: alpha"),
            (r"smart_init _clean_registry entry: alpha \(test1\)"),
            (r"smart_init _clean_registry exit: alpha \(test1\)"),
            (r"smart_init _clean_pair_array entry: alpha \(test1\)"),
            (r"smart_init _clean_pair_array exit: alpha \(test1\)"),
            (
                r"SmartThread alpha \(test1\) added alpha to SmartThread registry at "
                f"UTC {time_match}"
            ),
            (
                r"SmartThread alpha \(test1\) set state for thread alpha from "
                "ThreadState.Initialized to ThreadState.Registered"
            ),
            (
                r"SmartThread alpha \(test1\) set state for thread alpha from "
                "ThreadState.Registered to ThreadState.Alive"
            ),
            (r"smart_init _add_to_pair_array entry: alpha \(test1\), target: alpha"),
            (r"smart_init _add_to_pair_array exit: alpha \(test1\), target: alpha"),
            (r"smart_init _register exit: alpha \(test1\), target: alpha"),
            (
                r"smart_init exit: requestor: alpha \(test1\), targets: "
                r"\['alpha'\] timeout value: None "
                "test_smart_thread.py::TestSmartThreadSmokeTest."
                "test_smart_thread_log_msg:[0-9]+"
            ),
        ]

        ################################################################
        # alpha_smart_init_alpha_debug_log_msgs
        ################################################################
        alpha_smart_init_alpha_info_log_msgs = [
            (
                r"SmartThread alpha \(test1\) completed initialization of alpha: "
                "ThreadCreate.Current, ThreadState.Alive, auto_start obviated."
            )
        ]

        ################################################################
        # alpha_first_smart_init_beta_debug_log_msgs
        ################################################################
        alpha_first_smart_init_beta_debug_log_msgs = [
            (
                r"smart_init entry: requestor: beta \(test1\), targets: "
                r"\['beta'\] timeout value: None "
                "test_smart_thread.py::TestSmartThreadSmokeTest."
                "test_smart_thread_log_msg:[0-9]+"
            ),
            (r"smart_init _register entry: beta \(test1\), target: beta"),
            (r"smart_init _clean_registry entry: beta \(test1\)"),
            (
                r"name=alpha, is_alive=True, state=ThreadState.Alive, "
                r"smart_thread=SmartThread\(name='alpha', group_name=test1, "
                r"name=alpha, auto_start=True, max_msgs=10\)"
            ),
            (r"smart_init _clean_registry exit: beta \(test1\)"),
            (r"smart_init _clean_pair_array entry: beta \(test1\)"),
            (r"smart_init _clean_pair_array exit: beta \(test1\)"),
            (
                r"SmartThread beta \(test1\) added beta to SmartThread registry at UTC "
                f"{time_match}"
            ),
            (
                r"SmartThread beta \(test1\) set state for thread beta from "
                "ThreadState.Initialized to ThreadState.Registered"
            ),
            (r"smart_init _add_to_pair_array entry: beta \(test1\), target: beta"),
            (
                r"SmartThread beta \(test1\) added PairKey\(name0='alpha', "
                r"name1='beta'\) to the pair_array"
            ),
            (
                r"SmartThread beta \(test1\) added status_blocks entry "
                r"for PairKey\(name0='alpha', name1='beta'\), name = alpha"
            ),
            (
                r"SmartThread beta \(test1\) added status_blocks entry "
                r"for PairKey\(name0='alpha', name1='beta'\), name = beta"
            ),
            (rf"SmartThread beta \(test1\) updated _pair_array at UTC {time_match}"),
            (r"smart_init _add_to_pair_array exit: beta \(test1\), target: beta"),
            (r"smart_init _register exit: beta \(test1\), target: beta"),
            (
                r"smart_start entry: requestor: beta \(test1\), targets: "
                r"\['beta'\] timeout value: None "
                "smart_thread.py::SmartThread.__init__:[0-9]+"
            ),
            (
                r"SmartThread beta \(test1\) set state for thread beta from "
                "ThreadState.Registered to ThreadState.Alive"
            ),
            (
                r"smart_start exit: requestor: beta \(test1\), targets: "
                r"\['beta'\] timeout value: None "
                "smart_thread.py::SmartThread.__init__:[0-9]+"
            ),
            (
                r"smart_init exit: requestor: beta \(test1\), targets: "
                r"\['beta'\] timeout value: None "
                "test_smart_thread.py::TestSmartThreadSmokeTest."
                "test_smart_thread_log_msg:[0-9]+"
            ),
        ]

        ################################################################
        # alpha_first_smart_init_beta_info_log_msgs
        ################################################################
        alpha_first_smart_init_beta_info_log_msgs = [
            (
                r"SmartThread beta \(test1\) completed initialization of beta: "
                "ThreadCreate.Target, ThreadState.Registered, auto_start will proceed."
            )
        ]

        ################################################################
        # alpha_smart_send_debug_log_msgs
        ################################################################
        alpha_smart_send_debug_log_msgs = [
            (
                r"smart_send entry: requestor: alpha \(test1\), targets: "
                r"\['beta'\] timeout value: None "
                "test_smart_thread.py::TestSmartThreadSmokeTest."
                "test_smart_thread_log_msg:[0-9]+"
            ),
            (
                r"SmartThread alpha \(test1\) smart_send setup complete for targets: "
                r"\[PairKeyRemote\(pair_key=PairKey\(name0='alpha', "
                r"name1='beta'\), remote='beta', "
                r"create_time=[0-9]+\.[0-9]+\)\]"
            ),
            (
                r"smart_send exit: requestor: alpha \(test1\), targets: "
                r"\['beta'\] timeout value: None "
                "test_smart_thread.py::TestSmartThreadSmokeTest."
                "test_smart_thread_log_msg:[0-9]+"
            ),
        ]

        ################################################################
        # alpha_smart_send_info_log_msgs
        ################################################################
        alpha_smart_send_info_log_msgs = [
            r"SmartThread alpha \(test1\) smart_send sent message to beta"
        ]

        ################################################################
        # alpha_smart_resume_debug_log_msgs
        ################################################################
        alpha_smart_resume_debug_log_msgs = [
            (
                r"smart_resume entry: requestor: alpha \(test1\), targets: \["
                r"'beta'\] "
                "timeout value: None "
                "test_smart_thread.py::TestSmartThreadSmokeTest"
                ".test_smart_thread_log_msg:[0-9]+"
            ),
            (
                r"SmartThread alpha \(test1\) smart_resume setup complete for targets: "
                r"\[PairKeyRemote\(pair_key=PairKey\(name0='alpha', "
                r"name1='beta'\), remote='beta', "
                r"create_time=[0-9]+\.[0-9]+\)\]"
            ),
            (
                r"smart_resume exit: requestor: alpha \(test1\), targets: \["
                r"'beta'\] "
                "timeout value: None "
                "test_smart_thread.py::TestSmartThreadSmokeTest"
                ".test_smart_thread_log_msg:[0-9]+"
            ),
        ]

        ################################################################
        # alpha_smart_resume_info_log_msgs
        ################################################################
        alpha_smart_resume_info_log_msgs = [
            r"SmartThread alpha \(test1\) smart_resume resumed beta",
        ]

        ################################################################
        # alpha_smart_sync_debug_log_msgs
        ################################################################
        alpha_smart_sync_debug_log_msgs = [
            (
                r"smart_sync entry: requestor: alpha \(test1\), targets: \["
                r"'beta'\] "
                "timeout value: None "
                "test_smart_thread.py::TestSmartThreadSmokeTest."
                "test_smart_thread_log_msg:[0-9]+"
            ),
            (
                r"SmartThread alpha \(test1\) smart_sync setup complete for targets: "
                r"\[PairKeyRemote\(pair_key=PairKey\(name0='alpha', "
                r"name1='beta'\), remote='beta', "
                r"create_time=[0-9]+\.[0-9]+\)\]"
            ),
            (
                r"smart_sync exit: requestor: alpha \(test1\), targets: \["
                r"'beta'\] timeout "
                "value: None test_smart_thread.py::TestSmartThreadSmokeTest."
                "test_smart_thread_log_msg:[0-9]+"
            ),
        ]
        ################################################################
        # alpha_smart_sync_info_log_msgs
        ################################################################
        alpha_smart_sync_info_log_msgs = [
            r"SmartThread alpha \(test1\) smart_sync set flag for beta",
            r"SmartThread alpha \(test1\) smart_sync achieved with beta",
        ]

        ################################################################
        # alpha_smart_join_debug_log_msgs
        ################################################################
        alpha_smart_join_debug_log_msgs = [
            (
                r"smart_join entry: requestor: alpha \(test1\), targets: "
                r"\['beta'\] timeout value: None "
                "test_smart_thread.py::TestSmartThreadSmokeTest."
                "test_smart_thread_log_msg:[0-9]+"
            ),
            (
                r"SmartThread alpha \(test1\) set state for thread beta from "
                "ThreadState.Alive to "
                "ThreadState.Stopped"
            ),
            (r"smart_join _clean_registry entry: alpha \(test1\)"),
            (
                r"name=alpha, is_alive=True, state=ThreadState.Alive, "
                r"smart_thread=SmartThread\(name='alpha', group_name=test1, "
                r"name=alpha, auto_start=True, max_msgs=10\)"
            ),
            (
                r"name=beta, is_alive=False, state=ThreadState.Stopped, "
                r"smart_thread=SmartThread\(name='beta', group_name=test1, "
                r"name=beta, target_rtn=f1, args=\('beta',\), auto_start=True, "
                r"max_msgs=10\)"
            ),
            (
                r"SmartThread alpha \(test1\) removed beta from registry for request: "
                r"smart_join"
            ),
            (
                r"SmartThread alpha \(test1\) set state for thread beta from "
                "ThreadState.Stopped to ThreadState.Unregistered"
            ),
            (
                r"SmartThread alpha \(test1\) did cleanup of registry at UTC "
                rf"{time_match}, deleted \['beta'\]"
            ),
            (r"smart_join _clean_registry exit: alpha \(test1\)"),
            (r"smart_join _clean_pair_array entry: alpha \(test1\)"),
            (
                r"SmartThread alpha \(test1\) removed status_blocks entry for "
                r"PairKey\(name0='alpha', name1='beta'\), name = alpha"
            ),
            (
                r"SmartThread alpha \(test1\) removed status_blocks entry for "
                r"PairKey\(name0='alpha', name1='beta'\), name = beta"
            ),
            (
                r"SmartThread alpha \(test1\) removed _pair_array entry for "
                r"PairKey\(name0='alpha', name1='beta'\)"
            ),
            (
                r"SmartThread alpha \(test1\) did cleanup of _pair_array at UTC "
                f"{time_match}"
            ),
            (r"smart_join _clean_pair_array exit: alpha \(test1\)"),
            (
                r"smart_join exit: requestor: alpha \(test1\), targets: "
                r"\['beta'\] timeout value: None "
                "test_smart_thread.py::TestSmartThreadSmokeTest."
                "test_smart_thread_log_msg:[0-9]+"
            ),
        ]

        ################################################################
        # alpha_smart_join_info_log_msgs
        ################################################################
        alpha_smart_join_info_log_msgs = [
            r"SmartThread alpha \(test1\) did successful smart_join of \['beta'\].",
            (
                r"SmartThread alpha \(test1\) smart_join completed targets: "
                r"\['beta'\], pending targets: \[\]"
            ),
        ]

        ################################################################
        # alpha_second_smart_init_beta_debug_log_msgs
        ################################################################
        alpha_second_smart_init_beta_debug_log_msgs = [
            (
                r"smart_init entry: requestor: beta \(test1\), targets: "
                r"\['beta'\] timeout value: None "
                "test_smart_thread.py::TestSmartThreadSmokeTest."
                "test_smart_thread_log_msg:[0-9]+"
            ),
            (r"smart_init _register entry: beta \(test1\), target: beta"),
            (r"smart_init _clean_registry entry: beta \(test1\)"),
            (
                r"name=alpha, is_alive=True, state=ThreadState.Alive, "
                r"smart_thread=SmartThread\(name='alpha', group_name=test1, "
                r"name=alpha, auto_start=True, max_msgs=10\)"
            ),
            (r"smart_init _clean_registry exit: beta \(test1\)"),
            (r"smart_init _clean_pair_array entry: beta \(test1\)"),
            (r"smart_init _clean_pair_array exit: beta \(test1\)"),
            (
                r"SmartThread beta \(test1\) added beta to SmartThread registry at UTC "
                f"{time_match}"
            ),
            (
                r"SmartThread beta \(test1\) set state for thread beta from "
                "ThreadState.Initialized to ThreadState.Registered"
            ),
            (r"smart_init _add_to_pair_array entry: beta \(test1\), target: beta"),
            (
                r"SmartThread beta \(test1\) added PairKey\(name0='alpha', "
                r"name1='beta'\) to the pair_array"
            ),
            (
                r"SmartThread beta \(test1\) added status_blocks entry "
                r"for PairKey\(name0='alpha', name1='beta'\), name = alpha"
            ),
            (
                r"SmartThread beta \(test1\) added status_blocks entry "
                r"for PairKey\(name0='alpha', name1='beta'\), name = beta"
            ),
            (rf"SmartThread beta \(test1\) updated _pair_array at UTC {time_match}"),
            (r"smart_init _add_to_pair_array exit: beta \(test1\), target: beta"),
            (r"smart_init _register exit: beta \(test1\), target: beta"),
            (
                r"smart_init exit: requestor: beta \(test1\), targets: "
                r"\['beta'\] timeout value: None "
                "test_smart_thread.py::TestSmartThreadSmokeTest."
                "test_smart_thread_log_msg:[0-9]+"
            ),
        ]

        ################################################################
        # alpha_second_smart_init_beta_debug_log_msgs
        ################################################################
        alpha_second_smart_init_beta_info_log_msgs = [
            (
                r"SmartThread beta \(test1\) completed initialization of beta: "
                "ThreadCreate.Target, ThreadState.Registered, auto_start not requested."
            )
        ]
        ################################################################
        # alpha_smart_unreg_beta_debug_log_msgs
        ################################################################
        alpha_smart_unreg_beta_debug_log_msgs = [
            (
                r"smart_unreg entry: requestor: alpha \(test1\), targets: \["
                r"'beta'\] "
                "timeout value: None "
                "test_smart_thread.py::TestSmartThreadSmokeTest."
                "test_smart_thread_log_msg:[0-9]+"
            ),
            (r"smart_unreg _clean_registry entry: alpha \(test1\)"),
            (
                r"name=alpha, is_alive=True, state=ThreadState.Alive, "
                r"smart_thread=SmartThread\(name='alpha', group_name=test1, "
                r"name=alpha, auto_start=True, max_msgs=10\)"
            ),
            (
                r"name=beta, is_alive=False, state=ThreadState.Registered, "
                r"smart_thread=SmartThread\(name='beta', group_name=test1, "
                r"name=beta, target_rtn=f1, args=\('beta',\), auto_start=False, "
                r"max_msgs=0\)"
            ),
            (
                r"SmartThread alpha \(test1\) removed beta from registry for request: "
                r"smart_unreg"
            ),
            (
                r"SmartThread alpha \(test1\) set state for thread beta from "
                "ThreadState.Registered to ThreadState.Unregistered"
            ),
            (
                r"SmartThread alpha \(test1\) did cleanup of registry at UTC "
                rf"{time_match}, deleted \['beta'\]"
            ),
            (r"smart_unreg _clean_registry exit: alpha \(test1\)"),
            (r"smart_unreg _clean_pair_array entry: alpha \(test1\)"),
            (
                r"SmartThread alpha \(test1\) removed status_blocks entry for "
                r"PairKey\(name0='alpha', name1='beta'\), name = alpha"
            ),
            (
                r"SmartThread alpha \(test1\) removed status_blocks entry for "
                r"PairKey\(name0='alpha', name1='beta'\), name = beta"
            ),
            (
                r"SmartThread alpha \(test1\) removed _pair_array entry for "
                r"PairKey\(name0='alpha', name1='beta'\)"
            ),
            (
                r"SmartThread alpha \(test1\) did cleanup of _pair_array at UTC "
                f"{time_match}"
            ),
            (r"smart_unreg _clean_pair_array exit: alpha \(test1\)"),
            (
                r"smart_unreg exit: requestor: alpha \(test1\), targets: \["
                r"'beta'\] "
                "timeout value: None "
                "test_smart_thread.py::TestSmartThreadSmokeTest."
                "test_smart_thread_log_msg:[0-9]+"
            ),
        ]

        ################################################################
        # alpha_smart_unreg_info_log_msgs
        ################################################################
        alpha_smart_unreg_info_log_msgs = [
            (r"SmartThread alpha \(test1\) did successful smart_unreg of \['beta'\].")
        ]

        ################################################################
        # add all alpha debug and info log msgs
        ################################################################
        add_log_msgs(
            log_msgs=(
                alpha_smart_init_alpha_debug_log_msgs
                + alpha_first_smart_init_beta_debug_log_msgs
                + alpha_smart_send_debug_log_msgs
                + alpha_smart_resume_debug_log_msgs
                + alpha_smart_sync_debug_log_msgs
                + alpha_smart_join_debug_log_msgs
                + alpha_second_smart_init_beta_debug_log_msgs
                + alpha_smart_unreg_beta_debug_log_msgs
            ),
            log_level=logging.DEBUG,
            log_name=smart_thread_log_name,
        )

        add_log_msgs(
            log_msgs=(
                alpha_smart_init_alpha_info_log_msgs
                + alpha_first_smart_init_beta_info_log_msgs
                + alpha_smart_send_info_log_msgs
                + alpha_smart_resume_info_log_msgs
                + alpha_smart_sync_info_log_msgs
                + alpha_smart_join_info_log_msgs
                + alpha_second_smart_init_beta_info_log_msgs
                + alpha_smart_unreg_info_log_msgs
            ),
            log_level=logging.INFO,
            log_name=smart_thread_log_name,
        )

        ################################################################
        # beta_smart_recv_debug_log_msgs
        ################################################################
        beta_smart_recv_debug_log_msgs = [
            (
                r"smart_recv entry: requestor: beta \(test1\), targets: "
                r"\['alpha'\] timeout value: None "
                "test_smart_thread.py::f1:[0-9]+"
            ),
            (
                r"SmartThread beta \(test1\) smart_recv setup complete for targets: "
                r"\[PairKeyRemote\(pair_key=PairKey\(name0='alpha', "
                r"name1='beta'\), remote='alpha', "
                r"create_time=[0-9]+\.[0-9]+\)\]"
            ),
            (
                r"smart_recv exit: requestor: beta \(test1\), targets: "
                r"\['alpha'\] timeout value: None "
                "test_smart_thread.py::f1:[0-9]+"
            ),
        ]

        ################################################################
        # beta_smart_recv_info_log_msgs
        ################################################################
        beta_smart_recv_info_log_msgs = [
            r"SmartThread beta \(test1\) smart_recv received 1 msg from alpha",
        ]

        ################################################################
        # beta_smart_wait_debug_log_msgs
        ################################################################
        beta_smart_wait_debug_log_msgs = [
            (
                r"smart_wait entry: requestor: beta \(test1\), targets: \["
                r"'alpha'\] "
                "timeout value: None test_smart_thread.py::f1:[0-9]+"
            ),
            (
                r"SmartThread beta \(test1\) smart_wait setup complete for targets: "
                r"\[PairKeyRemote\(pair_key=PairKey\(name0='alpha', "
                r"name1='beta'\), remote='alpha', "
                r"create_time=[0-9]+\.[0-9]+\)\]"
            ),
            (
                r"smart_wait exit: requestor: beta \(test1\), targets: \['alpha'\] "
                "timeout value: None test_smart_thread.py::f1:[0-9]+"
            ),
        ]

        ################################################################
        # beta_smart_wait_info_log_msgs
        ################################################################
        beta_smart_wait_info_log_msgs = [
            r"SmartThread beta \(test1\) smart_wait resumed by alpha",
        ]

        ################################################################
        # beta_smart_sync_debug_log_msgs
        ################################################################
        beta_smart_sync_debug_log_msgs = [
            (
                r"smart_sync entry: requestor: beta \(test1\), targets: \["
                r"'alpha'\] "
                "timeout value: None test_smart_thread.py::f1:[0-9]+"
            ),
            (
                r"SmartThread beta \(test1\) smart_sync setup complete for targets: "
                r"\[PairKeyRemote\(pair_key=PairKey\(name0='alpha', "
                r"name1='beta'\), remote='alpha', "
                r"create_time=[0-9]+\.[0-9]+\)\]"
            ),
            (
                r"smart_sync exit: requestor: beta \(test1\), targets: \["
                r"'alpha'\] timeout "
                "value: None test_smart_thread.py::f1:[0-9]+"
            ),
        ]

        ################################################################
        # beta_smart_sync_info_log_msgs
        ################################################################
        beta_smart_sync_info_log_msgs = [
            r"SmartThread beta \(test1\) smart_sync set flag for alpha",
            r"SmartThread beta \(test1\) smart_sync achieved with alpha",
        ]

        ################################################################
        # add all beta debug and info log msgs
        ################################################################
        add_log_msgs(
            log_msgs=(
                beta_smart_recv_debug_log_msgs
                + beta_smart_wait_debug_log_msgs
                + beta_smart_sync_debug_log_msgs
            ),
            log_level=logging.DEBUG,
            log_name=smart_thread_log_name,
        )

        add_log_msgs(
            log_msgs=(
                beta_smart_recv_info_log_msgs
                + beta_smart_wait_info_log_msgs
                + beta_smart_sync_info_log_msgs
            ),
            log_level=logging.INFO,
            log_name=smart_thread_log_name,
        )

        ################################################################
        # check log results
        ################################################################
        match_results = log_ver.get_match_results(caplog=caplog)
        log_ver.print_match_results(match_results)
        log_ver.verify_log_results(match_results)

        logger.warning("mainline exiting")

    ####################################################################
    # test_smart_thread_simple_scenarios
    ####################################################################
    @pytest.mark.parametrize(
        "commander_config_arg",
        [
            AppConfig.ScriptStyle,
            AppConfig.CurrentThreadApp,
            AppConfig.RemoteThreadApp,
            AppConfig.RemoteSmartThreadApp,
            AppConfig.RemoteSmartThreadApp2,
        ],
    )
    def test_smart_thread_simple_scenarios(
        self, caplog: pytest.LogCaptureFixture, commander_config_arg: AppConfig
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            caplog: pytest fixture to capture log output
            commander_config_arg: specifies the config for the commander

        """
        args_for_scenario_builder: dict[str, Any] = {}

        scenario_driver(
            scenario_builder=ConfigVerifier.build_simple_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config_arg,
        )


########################################################################
# TestSmartThreadErrors class
########################################################################
@pytest.mark.cover
class TestSmartThreadErrors:
    """Test class for SmartThread error tests."""

    ####################################################################
    # test_smart_thread_instantiation_errors
    ####################################################################
    # @pytest.mark.cover2
    def test_smart_thread_instantiation_errors(self) -> None:
        """Test error cases for SmartThread."""

        ################################################################
        # f1
        ################################################################
        def f1() -> None:
            logger.debug("f1 entered")
            logger.debug("f1 exiting")

        ################################################################
        # Create smart thread with empty group_name
        ################################################################
        logger.debug("mainline entered")

        logger.debug("mainline creating bad group_name thread")

        exp_error_msg = (
            "SmartThread "
            "raising SmartThreadIncorrectNameSpecified error while "
            "processing request smart_init. "
            "It was detected that the group_name='' specified "
            "for the new thread is an empty string. Please "
            "specify a non-empty string for the group name."
        )
        logger.debug(exp_error_msg)
        with pytest.raises(
            st.SmartThreadIncorrectNameSpecified, match=exp_error_msg
        ) as exc:
            st.SmartThread(group_name="", name="alpha")

        # assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        ################################################################
        # Create smart thread with bad group_name
        ################################################################
        with pytest.raises(st.SmartThreadIncorrectNameSpecified) as exc:
            st.SmartThread(group_name=1, name="alpha")  # type: ignore

        exp_error_msg = (
            "SmartThread "
            "raising SmartThreadIncorrectNameSpecified error while "
            "processing request smart_init. "
            "It was detected that the group_name=1 specified "
            "for the new thread is not a string. Please "
            "specify a non-empty string for the group name."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        ################################################################
        # Create smart thread with empty name
        ################################################################
        logger.debug("mainline entered")

        logger.debug("mainline creating bad name thread")

        with pytest.raises(st.SmartThreadIncorrectNameSpecified) as exc:
            st.SmartThread(group_name="test1", name="")

        exp_error_msg = (
            "SmartThread "
            "raising SmartThreadIncorrectNameSpecified error while "
            "processing request smart_init. "
            "It was detected that the name='' specified "
            "for the new thread is an empty string. Please "
            "specify a non-empty string for the thread name."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        ################################################################
        # Create smart thread with bad name
        ################################################################
        with pytest.raises(st.SmartThreadIncorrectNameSpecified) as exc:
            st.SmartThread(group_name="test1", name=1)  # type: ignore

        exp_error_msg = (
            "SmartThread "
            "raising SmartThreadIncorrectNameSpecified error while "
            "processing request smart_init. "
            "It was detected that the name=1 specified "
            "for the new thread is not a string. Please "
            "specify a non-empty string for the thread name."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        ################################################################

        test_thread = threading.Thread(target=f1)

        with pytest.raises(
            st.SmartThreadMutuallyExclusiveTargetThreadSpecified
        ) as exc1:
            st.SmartThread(
                group_name="test1", name="alpha", target_rtn=f1, thread=test_thread
            )

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising "
            "SmartThreadMutuallyExclusiveTargetThreadSpecified error "
            "while processing request smart_init. "
            "Arguments for mutually exclusive parameters target_rtn and "
            "thread were both specified. Please specify only one of "
            "target_rtn or thread."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc1.value))

        print("\n", exc1.value)

        ################################################################

        with pytest.raises(st.SmartThreadArgsSpecificationWithoutTarget) as exc2:
            st.SmartThread(group_name="test1", name="alpha", args=(1,))

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising "
            "SmartThreadArgsSpecificationWithoutTarget error while "
            "processing request smart_init. "
            "Arguments for parameters args or kwargs were specified, "
            "but an argument for the target_rtn parameter was not "
            "specified. Please specify target_rtn or remove args and "
            "kwargs."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc2.value))

        print("\n", exc2.value)

        ################################################################

        with pytest.raises(st.SmartThreadArgsSpecificationWithoutTarget) as exc2:
            st.SmartThread(group_name="test1", name="alpha", kwargs={"arg1": 1})

        assert re.fullmatch(exp_error_msg, str(exc2.value))

        print("\n", exc2.value)

        with pytest.raises(st.SmartThreadArgsSpecificationWithoutTarget) as exc2:
            st.SmartThread(
                group_name="test1", name="alpha", args=(1,), kwargs={"arg1": 1}
            )

        assert re.fullmatch(exp_error_msg, str(exc2.value))

        print("\n", exc2.value)

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_thread_register_errors
    ####################################################################
    @pytest.mark.parametrize("first_name_arg", ["alpha", "beta", "charlie"])
    @pytest.mark.parametrize("first_group_name_arg", ["test1"])
    @pytest.mark.parametrize(
        "first_thread_arg",
        [st.ThreadCreate.Current, st.ThreadCreate.Target, st.ThreadCreate.Thread],
    )
    @pytest.mark.parametrize("new_name_arg", ["alpha", "beta", "charlie"])
    @pytest.mark.parametrize("new_same_thread_arg", [True, False])
    @pytest.mark.parametrize("new_group_name_arg", ["test1"])
    def test_smart_thread_register_errors(
        self,
        first_name_arg: str,
        first_group_name_arg: str,
        first_thread_arg: st.ThreadCreate,
        new_name_arg: str,
        new_group_name_arg: str,
        new_same_thread_arg: bool,
    ) -> None:
        """Test error cases for SmartThread.

        Args:
            first_name_arg: thread name for first smart_thread
            first_thread_arg: first smart_thread type of thread
            new_name_arg: thread name for second smart_thread
            new_same_thread_arg: new smart_thread will use same thread

        """

        ################################################################
        # SmartThreadRegistrationError cases
        ################################################################
        def f1() -> None:
            pass

        logger.debug("mainline entered")

        same_name = False
        if first_name_arg == new_name_arg:
            same_name = True

        check_msg = False
        new_thread = r"<Thread\(Thread-[0-9]+ \(f1\), initial\)>"
        cmd_runner = re.escape(f"{first_name_arg} ({first_group_name_arg})")
        if first_thread_arg == st.ThreadCreate.Current:
            first_smart_thread = st.SmartThread(
                group_name=first_group_name_arg, name=first_name_arg
            )
            if same_name or new_same_thread_arg:
                check_msg = True
                with pytest.raises(st.SmartThreadRegistrationError) as exc:
                    cmd_runner = re.escape(f"{new_name_arg} ({new_group_name_arg})")
                    if new_same_thread_arg:
                        new_thread = re.escape(str(first_smart_thread.thread))
                        st.SmartThread(group_name=new_group_name_arg, name=new_name_arg)
                    else:
                        st.SmartThread(
                            group_name=new_group_name_arg,
                            name=new_name_arg,
                            target_rtn=f1,
                        )
            else:
                st.SmartThread(
                    group_name=new_group_name_arg, name=new_name_arg, target_rtn=f1
                )
        elif first_thread_arg == st.ThreadCreate.Target:
            first_smart_thread = st.SmartThread(
                group_name=first_group_name_arg, name=first_name_arg, target_rtn=f1
            )
            if same_name or new_same_thread_arg:
                check_msg = True
                cmd_runner = re.escape(f"{new_name_arg} ({new_group_name_arg})")
                with pytest.raises(st.SmartThreadRegistrationError) as exc:
                    if new_same_thread_arg:
                        new_thread = re.escape(str(first_smart_thread.thread))
                        st.SmartThread(
                            group_name=new_group_name_arg,
                            name=new_name_arg,
                            thread=first_smart_thread.thread,
                        )
                    else:
                        st.SmartThread(
                            group_name=new_group_name_arg,
                            name=new_name_arg,
                            target_rtn=f1,
                        )
            else:
                st.SmartThread(
                    group_name=new_group_name_arg, name=new_name_arg, target_rtn=f1
                )
        else:  # first_thread_arg == st.ThreadCreate.Thread:
            first_thread = threading.Thread(target=f1)
            first_smart_thread = st.SmartThread(
                group_name=first_group_name_arg,
                name=first_name_arg,
                thread=first_thread,
            )
            if same_name or new_same_thread_arg:
                check_msg = True
                cmd_runner = re.escape(f"{new_name_arg} ({new_group_name_arg})")
                with pytest.raises(st.SmartThreadRegistrationError) as exc:
                    if new_same_thread_arg:
                        new_thread = re.escape(str(first_thread))
                        st.SmartThread(
                            group_name=new_group_name_arg,
                            name=new_name_arg,
                            thread=first_thread,
                        )
                    else:
                        st.SmartThread(
                            group_name=new_group_name_arg,
                            name=new_name_arg,
                            target_rtn=f1,
                        )
            else:
                st.SmartThread(
                    group_name=new_group_name_arg, name=new_name_arg, target_rtn=f1
                )

        if check_msg:
            first_thread_str = re.escape(str(first_smart_thread.thread))

            exp_error_msg = (
                f"SmartThread {cmd_runner} "
                "raising SmartThreadRegistrationError error while "
                "processing request smart_init. "
                "While attempting to register a new SmartThread "
                "instance, it was detected that another instance "
                "already in the SmartThread registry has the same "
                "name or is associated with the same threading "
                "thread. "
                f"New instance: name = {new_name_arg}, "
                "id = [0-9]+, "
                f"associated thread = {new_thread}. "
                f"Existing instance: name = {first_name_arg}, "
                f"id = {id(first_smart_thread)}, "
                f"associated thread = {first_thread_str}."
            )

            logger.debug(f"{exp_error_msg=}")

            act_error_msg = str(exc.value)
            logger.debug(f"{act_error_msg=}")

            assert re.fullmatch(exp_error_msg, str(exc.value))

            print("\n", exc.value)

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_thread_clean_registry_errors
    ####################################################################
    def test_smart_thread_clean_registry_errors(self) -> None:
        """Test error cases for SmartThread."""
        logger.debug("mainline entered")
        alpha_thread = st.SmartThread(group_name="test1", name="alpha")
        alpha_thread.name = "bad_name"
        with pytest.raises(st.SmartThreadErrorInRegistry) as exc:
            st.SmartThread(group_name="test1", name="beta")

        exp_error_msg = (
            r"SmartThread beta \(test1\) raising "
            "SmartThreadErrorInRegistry error while processing "
            "request smart_init. "
            "Registry item with key alpha has non-matching "
            "item.name of bad_name."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_thread_add_to_pair_array_errors
    ####################################################################
    def test_smart_thread_add_to_pair_array_errors(self, monkeypatch: Any) -> None:
        """Test error cases for SmartThread.

        Args:
            monkeypatch: pytest fixture to set up a mock routine

        """

        ################################################################
        # f1
        ################################################################
        def f1() -> None:
            logger.debug("f1 entered")
            logger.debug("f1 exiting")

        logger.debug("mainline entered")

        MockCleanPairArray()

        ################################################################
        # monkeypatch for SmartThread._get_target_state
        ################################################################
        monkeypatch.setattr(
            st.SmartThread,
            "_clean_pair_array",
            MockCleanPairArray.mock_clean_pair_array,
        )

        alpha_st = st.SmartThread(group_name="test1", name="alpha")

        # create an empty pair array entry_
        pair_key = st.SmartThread._get_pair_key("alpha", "beta")
        st.SmartThread._registry["test1"].pair_array[pair_key] = st.ConnectionPair(
            status_lock=threading.Lock(), status_blocks={}
        )

        with pytest.raises(st.SmartThreadIncorrectData) as exc:
            st.SmartThread(group_name="test1", name="beta", target_rtn=f1)

        exp_error_msg = (
            "SmartThread beta (test1) "
            "raising SmartThreadIncorrectData error while "
            "processing request smart_init. "
            "While attempting to add beta to the pair "
            f"array, it was detected that pair_key {pair_key} is "
            "already in the pair array with an empty "
            "status_blocks."
        )
        logger.debug(exp_error_msg)
        assert re.fullmatch(re.escape(exp_error_msg), str(exc.value))

        print("\n", exc.value)

        alpha_st.smart_unreg(targets="beta")

        ################################################################

        st.SmartThread._registry["test1"].pair_array[pair_key] = st.ConnectionPair(
            status_lock=threading.Lock(),
            status_blocks={
                "beta": st.ConnectionStatusBlock(
                    name="beta",
                    create_time=0,
                    target_create_time=0.0,
                    wait_flag=False,
                    sync_flag=False,
                    msg_q=queue.Queue(maxsize=10),
                )
            },
        )

        with pytest.raises(st.SmartThreadIncorrectData) as exc:
            st.SmartThread(group_name="test1", name="beta", target_rtn=f1)

        exp_error_msg = (
            "SmartThread beta (test1) "
            "raising SmartThreadIncorrectData error while "
            "processing request smart_init. "
            "While attempting to add beta to the pair "
            f"array, it was detected that pair_key {pair_key} "
            "is already in the pair array with a "
            "status_blocks entry containing beta."
        )
        logger.debug(exp_error_msg)
        assert re.fullmatch(re.escape(exp_error_msg), str(exc.value))

        alpha_st.smart_unreg(targets="beta")

        print("\n", exc.value)

        ################################################################

        st.SmartThread._registry["test1"].pair_array[pair_key] = st.ConnectionPair(
            status_lock=threading.Lock(),
            status_blocks={
                "alpha": st.ConnectionStatusBlock(
                    name="beta",
                    create_time=0,
                    target_create_time=0.0,
                    wait_flag=False,
                    sync_flag=False,
                    msg_q=queue.Queue(maxsize=10),
                )
            },
        )

        with pytest.raises(st.SmartThreadIncorrectData) as exc:
            st.SmartThread(group_name="test1", name="beta", target_rtn=f1)

        exp_error_msg = (
            "SmartThread beta (test1) "
            "raising SmartThreadIncorrectData error while "
            "processing request smart_init. "
            "While attempting to add beta to the pair "
            f"array, it was detected that pair_key {pair_key} "
            "is already in the pair array with a "
            "status_blocks entry containing alpha "
            "that is not del_deferred."
        )
        logger.debug(exp_error_msg)
        assert re.fullmatch(re.escape(exp_error_msg), str(exc.value))

        alpha_st.smart_unreg(targets="beta")

        print("\n", exc.value)

        ################################################################

        st.SmartThread._registry["test1"].pair_array[pair_key] = st.ConnectionPair(
            status_lock=threading.Lock(),
            status_blocks={
                "alpha": st.ConnectionStatusBlock(
                    name="beta",
                    create_time=0,
                    target_create_time=0.0,
                    wait_flag=False,
                    sync_flag=False,
                    msg_q=queue.Queue(maxsize=10),
                ),
                "beta": st.ConnectionStatusBlock(
                    name="beta",
                    create_time=0,
                    target_create_time=0.0,
                    wait_flag=False,
                    sync_flag=False,
                    msg_q=queue.Queue(maxsize=10),
                ),
            },
        )

        with pytest.raises(st.SmartThreadIncorrectData) as exc:
            st.SmartThread(group_name="test1", name="beta", target_rtn=f1)

        existing_names = (
            st.SmartThread._registry["test1"].pair_array[pair_key].status_blocks.keys()
        )

        exp_error_msg = re.escape(
            "SmartThread beta (test1) "
            "raising SmartThreadIncorrectData error while "
            "processing request smart_init. "
            "While attempting to add beta to the pair "
            f"array, it was detected that pair_key {pair_key} "
            "is already in the pair array with a "
            "status_blocks entry containing entries for "
            f"{sorted(existing_names)}."
        )
        logger.debug(exp_error_msg)
        assert re.match(exp_error_msg, str(exc.value))

        alpha_st.smart_unreg(targets="beta")

        print("\n", exc.value)

        logger.debug("mainline exiting")

    ####################################################################
    # test_get_targets_errors
    ####################################################################
    @pytest.mark.parametrize(
        "request_type_arg",
        [
            st.ReqType.Smart_start,
            st.ReqType.Smart_unreg,
            st.ReqType.Smart_join,
            st.ReqType.Smart_send,
            st.ReqType.Smart_recv,
            st.ReqType.Smart_wait,
            st.ReqType.Smart_resume,
            st.ReqType.Smart_sync,
        ],
    )
    def test_get_targets_errors(self, request_type_arg: st.ReqType) -> None:
        """Test error cases for SmartThread.

        Args:
            request_type_arg: which request type will inject the error

        """
        logger.debug("mainline entered")
        alpha_thread = st.SmartThread(group_name="test1", name="alpha")

        ################################################################
        # SmartThreadInvalidInput - not an iterable string
        ################################################################
        with pytest.raises(st.SmartThreadInvalidInput) as exc:
            if request_type_arg == st.ReqType.Smart_start:
                alpha_thread.smart_start(targets=42)  # type: ignore
            elif request_type_arg == st.ReqType.Smart_unreg:
                alpha_thread.smart_unreg(targets=42)  # type: ignore
            elif request_type_arg == st.ReqType.Smart_join:
                alpha_thread.smart_join(targets=42)  # type: ignore
            elif request_type_arg == st.ReqType.Smart_send:
                alpha_thread.smart_send(receivers=42, msg="hello")  # type: ignore
            elif request_type_arg == st.ReqType.Smart_recv:
                alpha_thread.smart_recv(senders=42)  # type: ignore
            elif request_type_arg == st.ReqType.Smart_wait:
                alpha_thread.smart_wait(resumers=42)  # type: ignore
            elif request_type_arg == st.ReqType.Smart_resume:
                alpha_thread.smart_resume(waiters=42)  # type: ignore
            elif request_type_arg == st.ReqType.Smart_sync:
                alpha_thread.smart_sync(targets=42)  # type: ignore
            else:
                raise InvalidInputDetected(
                    f"test_get_targets_errors received {request_type_arg=}"
                )

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising "
            "SmartThreadInvalidInput error while processing "
            f"request {request_type_arg}. "
            "It was detected that an argument for remote thread names "
            "is not of type Iterable. Please specify an iterable, "
            "such as a list of thread names."
        )
        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        ################################################################
        # SmartThreadInvalidInput - no remotes
        ################################################################
        with pytest.raises(st.SmartThreadInvalidInput) as exc2:
            if request_type_arg == st.ReqType.Smart_start:
                alpha_thread.smart_start(targets=set())
            elif request_type_arg == st.ReqType.Smart_unreg:
                alpha_thread.smart_unreg(targets=())
            elif request_type_arg == st.ReqType.Smart_join:
                alpha_thread.smart_join(targets=[])
            elif request_type_arg == st.ReqType.Smart_send:
                alpha_thread.smart_send(receivers=set(), msg="hello")
            elif request_type_arg == st.ReqType.Smart_recv:
                alpha_thread.smart_recv(senders={})
            elif request_type_arg == st.ReqType.Smart_wait:
                alpha_thread.smart_wait(resumers=[])
            elif request_type_arg == st.ReqType.Smart_resume:
                alpha_thread.smart_resume(waiters=set())
            elif request_type_arg == st.ReqType.Smart_sync:
                alpha_thread.smart_sync(targets=())
            else:
                raise InvalidInputDetected(
                    f"test_get_targets_errors received {request_type_arg=}"
                )

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising "
            "SmartThreadInvalidInput error while processing "
            f"request {request_type_arg}. "
            "Remote threads are required for the request but none were "
            "specified."
        )
        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc2.value))

        print("\n", exc2.value)

        ################################################################
        # SmartThreadInvalidInput - not a string
        ################################################################
        bad_name: Any = ""
        with pytest.raises(st.SmartThreadIncorrectNameSpecified) as exc3:
            if request_type_arg == st.ReqType.Smart_start:
                bad_name = 42.2
                alpha_thread.smart_start(targets=[42.2])  # type: ignore
            elif request_type_arg == st.ReqType.Smart_unreg:
                bad_name = "(42|'')"
                alpha_thread.smart_unreg(targets=[42, ""])  # type: ignore
            elif request_type_arg == st.ReqType.Smart_join:
                bad_name = 43
                alpha_thread.smart_join(targets=(43,))  # type: ignore
            elif request_type_arg == st.ReqType.Smart_send:
                bad_name = 43.7
                alpha_thread.smart_send(receivers=(43.7,), msg="hello")  # type: ignore
            elif request_type_arg == st.ReqType.Smart_recv:
                bad_name = "(''|44)"
                alpha_thread.smart_recv(senders={"", 44})  # type: ignore
            elif request_type_arg == st.ReqType.Smart_wait:
                bad_name = 45
                alpha_thread.smart_wait(resumers=[45, "beta"])  # type: ignore
            elif request_type_arg == st.ReqType.Smart_resume:
                bad_name = "''"
                alpha_thread.smart_resume(waiters="")
            elif request_type_arg == st.ReqType.Smart_sync:
                bad_name = "(47|48|'')"
                alpha_thread.smart_sync(targets=("a", 47, 48, ""))  # type: ignore
            else:
                raise InvalidInputDetected(
                    f"test_get_targets_errors received {request_type_arg=}"
                )

        exp_error_msg = (
            r"SmartThread alpha \(test1\) "
            "raising SmartThreadIncorrectNameSpecified error while "
            f"processing request {request_type_arg}. "
            f"It was detected that the name={bad_name} specified "
            "for a remote thread is (not a|an empty) string. Please "
            "specify a non-empty string for the thread name."
        )
        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc3.value))

        print("\n", exc3.value)

        ################################################################
        # extra send cases
        ################################################################
        if request_type_arg == st.ReqType.Smart_send:
            with pytest.raises(st.SmartThreadIncorrectNameSpecified) as exc4:
                alpha_thread.smart_send(receivers=(43.7,), msg="hello")  # type: ignore

            exp_error_msg = (
                r"SmartThread alpha \(test1\) "
                "raising SmartThreadIncorrectNameSpecified error while "
                "processing request smart_send. "
                "It was detected that the name=43.7 specified "
                "for a remote thread is not a string. Please "
                "specify a non-empty string for the thread name."
            )
            logger.debug(exp_error_msg)
            assert re.fullmatch(exp_error_msg, str(exc4.value))

            print("\n", exc4.value)

            ############################################################
            msgs_to_send = {42: "msg1"}
            with pytest.raises(st.SmartThreadIncorrectNameSpecified) as exc5:
                alpha_thread.smart_send(msg_dict=msgs_to_send)  # type: ignore

            exp_error_msg = (
                r"SmartThread alpha \(test1\) "
                "raising SmartThreadIncorrectNameSpecified error while "
                "processing request smart_send. "
                "It was detected that the name=42 specified "
                "for a remote thread is not a string. Please "
                "specify a non-empty string for the thread name."
            )
            logger.debug(exp_error_msg)
            assert re.fullmatch(exp_error_msg, str(exc5.value))

            print("\n", exc5.value)

            ############################################################
            msgs_to_send1 = {"": "msg2"}
            with pytest.raises(st.SmartThreadIncorrectNameSpecified) as exc6:
                alpha_thread.smart_send(msg_dict=msgs_to_send1)

            exp_error_msg = (
                r"SmartThread alpha \(test1\) "
                "raising SmartThreadIncorrectNameSpecified error while "
                "processing request smart_send. "
                "It was detected that the name='' specified "
                "for a remote thread is an empty string. Please "
                "specify a non-empty string for the thread name."
            )
            logger.debug(exp_error_msg)
            assert re.fullmatch(exp_error_msg, str(exc6.value))

            print("\n", exc6.value)

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_start_errors
    ####################################################################
    def test_smart_start_errors(self) -> None:
        """Test error cases for SmartThread."""

        ################################################################
        # f1
        ################################################################
        def f1() -> None:
            logger.debug("f1 entered")
            beta_thread.smart_wait(resumers="alpha")
            logger.debug("f1 exiting")

        logger.debug("mainline entered")
        alpha_thread = st.SmartThread(group_name="test1", name="alpha")

        beta_thread = st.SmartThread(
            group_name="test1", name="beta", target_rtn=f1, auto_start=False
        )

        with pytest.raises(st.SmartThreadMultipleTargets) as exc:
            beta_thread.smart_start(targets=("beta", "charlie"))

        targets = set(("beta", "charlie"))

        exp_error_msg = (
            "SmartThread beta (test1) "
            "raising SmartThreadMultipleTargets "
            "error while processing request smart_start. "
            "Request smart_start can not be done for multiple "
            f"targets {targets} when one of the targets is also "
            "the smart_thread instance, in this case beta."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(re.escape(exp_error_msg), str(exc.value))

        print("\n", exc.value)

        ################################################################
        beta_thread.smart_start()

        with pytest.raises(st.SmartThreadRemoteThreadNotRegistered) as exc1:
            beta_thread.smart_start()

        exp_error_msg = (
            "SmartThread beta (test1) "
            "raising SmartThreadRemoteThreadNotRegistered while "
            "processing a smart_start request with targets ['beta']. "
            "Remotes that are pending: []. "
            "Remotes that are not registered: ['beta']."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(re.escape(exp_error_msg), str(exc1.value))

        print("\n", exc1.value)

        ################################################################
        alpha_thread.smart_resume(waiters="beta")

        start_time = time.time()
        timeout_value = 30
        while True:
            if not beta_thread.thread.is_alive():
                break
            time.sleep(0.2)
            if time.time() - start_time > timeout_value:
                raise CmdTimedOut(
                    "test_smart_start_errors took longer than "
                    f"{timeout_value} seconds waiting for beta "
                    "to exit and become inactive."
                )

        with pytest.raises(st.SmartThreadRemoteThreadNotRegistered) as exc2:
            beta_thread.smart_start()

        exp_error_msg = (
            "SmartThread beta (test1) "
            "raising SmartThreadRemoteThreadNotRegistered "
            "while processing a smart_start request with targets ['beta']. "
            "Remotes that are pending: []. "
            "Remotes that are not registered: ['beta']."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(re.escape(exp_error_msg), str(exc2.value))

        print("\n", exc2.value)

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_send_errors
    ####################################################################
    def test_smart_send_errors(self) -> None:
        """Test error cases for SmartThread."""

        ################################################################
        # f1
        ################################################################
        def f1() -> None:
            logger.debug("f1 entered")
            beta_thread.smart_wait(resumers="alpha")
            logger.debug("f1 exiting")

        logger.debug("mainline entered")
        alpha_thread = st.SmartThread(group_name="test1", name="alpha")
        beta_thread = st.SmartThread(
            group_name="test1", name="beta", target_rtn=f1, auto_start=False
        )
        beta_thread.smart_start()

        with pytest.raises(st.SmartThreadInvalidInput) as exc:
            alpha_thread.smart_send(
                msg="hi beta", receivers="beta", msg_dict={"beta": "hello again"}
            )

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising "
            "SmartThreadInvalidInput error while processing request "
            "smart_send. "
            "Mutually exclusive arguments msg and msg_dict were both "
            "specified. Please specify only one of msg or msg_dict."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        ################################################################

        with pytest.raises(st.SmartThreadInvalidInput) as exc:
            alpha_thread.smart_send(msg_dict={"beta": "hi beta"}, receivers=set())

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising "
            "SmartThreadInvalidInput error while processing request "
            "smart_send. "
            "Mutually exclusive arguments msg_dict and msg or "
            "msg_dict and receivers were specified."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        ################################################################

        with pytest.raises(st.SmartThreadInvalidInput) as exc:
            alpha_thread.smart_send(msg="hi beta", msg_dict={"beta": "hello beta"})

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising "
            "SmartThreadInvalidInput error while processing request "
            "smart_send. "
            "Mutually exclusive arguments msg_dict and msg or "
            "msg_dict and receivers were specified."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        ################################################################

        with pytest.raises(st.SmartThreadInvalidInput) as exc:
            alpha_thread.smart_send()

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising "
            "SmartThreadInvalidInput error while processing request "
            "smart_send. "
            "The smart_send request failed to specify "
            "msg_dict, or failed to specify both msg and receivers."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        ################################################################

        with pytest.raises(st.SmartThreadInvalidInput) as exc:
            alpha_thread.smart_send(receivers="beta")

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising "
            "SmartThreadInvalidInput error while processing request "
            "smart_send. "
            "The smart_send request failed to specify "
            "msg_dict, or failed to specify both msg and receivers."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        ################################################################

        with pytest.raises(st.SmartThreadInvalidInput) as exc:
            alpha_thread.smart_send(msg="hi beta")

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising "
            "SmartThreadInvalidInput error while processing request "
            "smart_send. "
            "The smart_send request failed to specify "
            "msg_dict, or failed to specify both msg and receivers."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        ################################################################
        # resume and join beta
        ################################################################
        alpha_thread.smart_resume(waiters="beta", timeout=5)
        alpha_thread.smart_join(targets="beta", timeout=5)

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_recv_errors
    ####################################################################
    def test_smart_recv_errors(self) -> None:
        """Test error cases for SmartThread."""

        ################################################################
        # f1
        ################################################################
        def f1() -> None:
            logger.debug("f1 entered")
            beta_thread.smart_wait(resumers="alpha")
            logger.debug("f1 exiting")

        logger.debug("mainline entered")
        alpha_thread = st.SmartThread(group_name="test1", name="alpha")
        beta_thread = st.SmartThread(
            group_name="test1", name="beta", target_rtn=f1, auto_start=False
        )
        beta_thread.smart_start()

        with pytest.raises(st.SmartThreadInvalidInput) as exc:
            alpha_thread.smart_recv(senders="beta", sender_count=-1)

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising "
            "SmartThreadInvalidInput error while processing request "
            "smart_recv. "
            "The value specified for sender_count=-1 is not valid. "
            "The number of specified senders is "
            "1. The value for "
            "sender_count must be an integer between 1 and the "
            "number of specified senders, inclusive."
        )
        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        ################################################################

        with pytest.raises(st.SmartThreadInvalidInput) as exc:
            alpha_thread.smart_recv(senders="beta", sender_count=0)

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising "
            "SmartThreadInvalidInput error while processing request "
            "smart_recv. "
            "The value specified for sender_count=0 is not valid. "
            "The number of specified senders is "
            "1. The value for "
            "sender_count must be an integer between 1 and the "
            "number of specified senders, inclusive."
        )
        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        ################################################################

        with pytest.raises(st.SmartThreadInvalidInput) as exc:
            alpha_thread.smart_recv(senders="beta", sender_count=2)

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising "
            "SmartThreadInvalidInput error while processing request "
            "smart_recv. "
            "The value specified for sender_count=2 is not valid. "
            "The number of specified senders is "
            "1. The value for "
            "sender_count must be an integer between 1 and the "
            "number of specified senders, inclusive."
        )
        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        ################################################################
        # resume and join beta
        ################################################################
        alpha_thread.smart_resume(waiters="beta", timeout=5)
        alpha_thread.smart_join(targets="beta", timeout=5)

        logger.debug("mainline exiting")

    ####################################################################
    # test_smart_wait_errors
    ####################################################################
    def test_smart_wait_errors(self) -> None:
        """Test error cases for SmartThread."""

        ################################################################
        # f1
        ################################################################
        def f1() -> None:
            logger.debug("f1 entered")
            beta_thread.smart_wait(resumers="alpha")
            logger.debug("f1 exiting")

        logger.debug("mainline entered")
        alpha_thread = st.SmartThread(group_name="test1", name="alpha")
        beta_thread = st.SmartThread(
            group_name="test1", name="beta", target_rtn=f1, auto_start=False
        )
        beta_thread.smart_start()

        with pytest.raises(st.SmartThreadInvalidInput) as exc:
            alpha_thread.smart_wait(resumers="beta", resumer_count=-1)

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising "
            "SmartThreadInvalidInput error while processing request "
            "smart_wait. "
            "The value specified for resumer_count=-1 is not valid. "
            "The number of specified resumers is "
            "1. The value for "
            "resumer_count must be an integer between 1 and the "
            "number of specified resumers, inclusive."
        )
        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        ################################################################

        with pytest.raises(st.SmartThreadInvalidInput) as exc:
            alpha_thread.smart_wait(resumers="beta", resumer_count=0)

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising "
            "SmartThreadInvalidInput error while processing request "
            "smart_wait. "
            "The value specified for resumer_count=0 is not valid. "
            "The number of specified resumers is "
            "1. The value for "
            "resumer_count must be an integer between 1 and the "
            "number of specified resumers, inclusive."
        )
        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        ################################################################

        with pytest.raises(st.SmartThreadInvalidInput) as exc:
            alpha_thread.smart_wait(resumers="beta", resumer_count=2)

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising "
            "SmartThreadInvalidInput error while processing request "
            "smart_wait. "
            "The value specified for resumer_count=2 is not valid. "
            "The number of specified resumers is "
            "1. The value for "
            "resumer_count must be an integer between 1 and the "
            "number of specified resumers, inclusive."
        )
        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        ################################################################
        # resume and join beta
        ################################################################
        alpha_thread.smart_resume(waiters="beta", timeout=5)
        alpha_thread.smart_join(targets="beta", timeout=5)

        logger.debug("mainline exiting")

    ####################################################################
    # test_handle_found_pk_remotes_errors
    ####################################################################
    def test_handle_found_pk_remotes_errors(self, monkeypatch: Any) -> None:
        """Test error cases for SmartThread.

        Args:
            monkeypatch: pytest fixture to set up a mock routine

        """
        # from scottbrian_locking import se_lock as sel

        ################################################################
        # mock_request_loop
        ################################################################
        class MockRequestLoop:
            """Provide a way to test found_pk_remotes errors."""

            mock_action: ClassVar[str] = ""
            mock_exp_pk_remotes: ClassVar[str] = ""

            def __init__(self) -> None:
                """Initialize the mock target_rtn state."""
                # self.work_pk_remotes = []
                MockRequestLoop.mock_action = "action1"

            def mock_request_loop(
                self,
                request_block: st.RequestBlock,
            ) -> None:
                """Main loop for each request.

                Args:
                    request_block: contains requestors, timeout, etc

                """
                logger.debug("mock_request_loop entered")
                delta_added = False
                while True:
                    work_pk_remotes_copy = self.work_pk_remotes.copy()  # type: ignore
                    for pk_remote in work_pk_remotes_copy:
                        # we need to hold the lock to ensure the
                        # pair_array remains stable while getting
                        # local_sb. The request_pending flag in our
                        # entry will prevent our entry for being removed
                        # (but not the remote)
                        with sel.SELockShare(
                            st.SmartThread._registry[self.group_name].registry_lock
                        ):
                            if self.found_pk_remotes:  # type: ignore
                                wpr = self.work_pk_remotes  # type: ignore
                                if MockRequestLoop.mock_action == "action2":
                                    MockRequestLoop.mock_exp_pk_remotes = (
                                        work_pk_remotes_copy
                                    )
                                    mock_pair_key = self._get_pair_key(  # type: ignore
                                        "beta", "delta"
                                    )
                                    if not delta_added:
                                        delta_added = True
                                        wpr.append(
                                            st.PairKeyRemote(
                                                mock_pair_key, "delta", 0.0
                                            )
                                        )
                                self._handle_found_pk_remotes(  # type: ignore
                                    pk_remote=pk_remote,
                                    work_pk_remotes=work_pk_remotes_copy,
                                )
                    time.sleep(0.5)

        ################################################################
        # f1
        ################################################################
        def f1() -> None:
            logger.debug("f1 entered")
            with pytest.raises(st.SmartThreadWorkDataException) as exc:
                beta_thread.smart_wait(resumers=("alpha", "charlie"))

            action = msgs.get_msg("beta")

            pair_key = st.SmartThread._get_pair_key("beta", "delta")
            found_pk_remote = st.PairKeyRemote(
                pair_key, "delta", delta_thread.create_time
            )

            if action == "action1":
                exp_error_msg = (
                    "SmartThread beta (test1) raising "
                    "SmartThreadWorkDataException error while processing "
                    "request smart_wait. "
                    f"An expected entry for {found_pk_remote=} was not "
                    f"found in self.work_pk_remotes={exp_work_remotes}."
                )
            elif action == "action2":
                exp_error_msg = (
                    "SmartThread beta (test1) raising "
                    "SmartThreadWorkDataException error while processing "
                    "request smart_wait. "
                    f"An expected entry for {found_pk_remote=} was not "
                    f"found in work_pk_remotes="
                    f"{MockRequestLoop.mock_exp_pk_remotes}."
                )

                logger.debug(f'{" "*21}{exp_error_msg}')
            else:
                raise IncorrectActionSpecified(
                    f"test_handle_found_pk_remotes_errors received "
                    f"an unrecognized {action=} in beta f1 rtn"
                )

            assert re.fullmatch(re.escape(exp_error_msg), str(exc.value))

            print("\n", exc.value)

            logger.debug("f1 exiting")

        ################################################################
        # mainline
        ################################################################
        logger.debug("mainline entered")

        MockRequestLoop()

        msgs = Msgs()

        alpha_thread = st.SmartThread(group_name="test1", name="alpha")
        beta_thread = st.SmartThread(
            group_name="test1", name="beta", target_rtn=f1, auto_start=False
        )
        beta_thread.smart_start()

        start_time = time.time()
        timeout_value = 15
        while len(beta_thread.work_pk_remotes) < 2:
            time.sleep(0.5)
            if time.time() - start_time > timeout_value:
                raise CmdTimedOut(
                    "test_smart_start_errors took longer than "
                    f"{timeout_value} seconds waiting for beta "
                    "to exit and become inactive."
                )

        exp_work_remotes = beta_thread.work_pk_remotes
        beta_thread.missing_remotes |= {"delta"}

        delta_thread = st.SmartThread(
            group_name="test1", name="delta", target_rtn=f1, auto_start=False
        )
        msgs.queue_msg(target="beta", msg="action1")

        ################################################################
        # join beta
        ################################################################
        alpha_thread.smart_join(targets="beta", timeout=5)
        alpha_thread.smart_unreg(targets="delta")

        ################################################################
        # part 2
        ################################################################
        beta_thread = st.SmartThread(
            group_name="test1", name="beta", target_rtn=f1, auto_start=False
        )

        monkeypatch.setattr(
            st.SmartThread, "_request_loop", MockRequestLoop.mock_request_loop
        )
        MockRequestLoop.mock_action = "action2"
        beta_thread.smart_start()

        start_time = time.time()
        timeout_value = 15
        while len(beta_thread.work_pk_remotes) < 2:
            time.sleep(0.5)
            if time.time() - start_time > timeout_value:
                raise CmdTimedOut(
                    "test_smart_start_errors took longer than "
                    f"{timeout_value} seconds waiting for beta "
                    "to exit and become inactive."
                )

        exp_work_remotes = beta_thread.work_pk_remotes
        beta_thread.missing_remotes |= {"delta"}

        delta_thread = st.SmartThread(
            group_name="test1", name="delta", target_rtn=f1, auto_start=False
        )

        msgs.queue_msg(target="beta", msg="action2")

        ################################################################
        # join beta
        ################################################################
        alpha_thread.smart_join(targets="beta", timeout=5)
        alpha_thread.smart_unreg(targets="delta")

        logger.debug("mainline exiting")

    ####################################################################
    # test_handle_loop_errors_errors
    ####################################################################
    @pytest.mark.parametrize("num_pending_arg", [0, 1, 2])
    def test_handle_loop_errors_errors(self, num_pending_arg: int) -> None:
        """Test error cases for SmartThread.

        Args:
            num_pending_arg: number of threads that should be in the
                pending names array for the error message

        """

        ################################################################
        # f1
        ################################################################
        def f1(action: str) -> None:
            logger.debug("f1 entered")
            if action == "wait":
                beta_thread.smart_wait(resumers="alpha")
            elif action == "msg_wait":
                msgs.get_msg("beta")
            elif action == "deadlock":
                f1_senders = ["alpha"]
                f1_pending_targets = []
                for f1_idx in range(num_pending_arg):
                    f1_senders.append(f"pending_{f1_idx}")
                    f1_pending_targets.append(f"pending_{f1_idx}")
                with pytest.raises(st.SmartThreadDeadlockDetected) as f1_exc:
                    beta_thread.smart_recv(senders=f1_senders)
                f1_targets_msg = re.escape(
                    "while processing a smart_recv request with targets "
                    f"{f1_senders}."
                )

                f1_pending_msg = re.escape(
                    f" Remotes that are pending: {f1_pending_targets}."
                )

                f1_stopped_msg = ""

                f1_not_registered_msg = ""

                f1_deadlock_msg = " Remotes that are deadlocked: " r"\['alpha'\]."

                f1_full_send_q_msg = ""

                f1_msg_suite = (
                    f"{f1_targets_msg}{f1_pending_msg}"
                    f"{f1_stopped_msg}{f1_not_registered_msg}"
                    f"{f1_deadlock_msg}{f1_full_send_q_msg}"
                )

                f1_exp_error_msg = (
                    r"SmartThread beta \(test1\) raising SmartThreadDeadlockDetected "
                    f"{f1_msg_suite}"
                )

                logger.debug(f1_exp_error_msg)
                assert re.fullmatch(f1_exp_error_msg, str(f1_exc.value))

                print("\n", f1_exc.value)

            logger.debug("f1 exiting")

        ################################################################
        # mainline
        ################################################################
        logger.debug("mainline entered")

        msgs = Msgs()

        alpha_thread = st.SmartThread(group_name="test1", name="alpha")
        beta_thread = st.SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            kwargs={"action": "wait"},
            auto_start=False,
        )
        beta_thread.smart_start()
        alpha_thread.smart_resume(waiters="beta")

        targets = ["beta"]
        pending_targets = []
        for idx in range(num_pending_arg):
            targets.append(f"pending_{idx}")
            pending_targets.append(f"pending_{idx}")

        ################################################################
        # SmartThreadRemoteThreadNotAlive
        ################################################################
        with pytest.raises(st.SmartThreadRemoteThreadNotAlive) as exc:
            alpha_thread.smart_recv(senders=targets)

        targets_msg = re.escape(
            f"while processing a smart_recv request with targets {targets}."
        )

        pending_msg = re.escape(f" Remotes that are pending: {pending_targets}.")

        stopped_msg = " Remotes that are stopped: " r"\['beta'\]."

        not_registered_msg = ""

        deadlock_msg = ""

        full_send_q_msg = ""

        msg_suite = (
            f"{targets_msg}{pending_msg}{stopped_msg}"
            f"{not_registered_msg}{deadlock_msg}{full_send_q_msg}"
        )

        exp_error_msg = (
            rf"SmartThread alpha \(test1\) raising SmartThreadRemoteThreadNotAlive "
            f"{msg_suite}"
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        ################################################################
        # SmartThreadRemoteThreadNotRegistered
        ################################################################
        with pytest.raises(st.SmartThreadRemoteThreadNotRegistered) as exc1:
            alpha_thread.smart_start(targets=targets)

        alpha_thread.smart_join(targets="beta", timeout=5)
        targets_msg = re.escape(
            f"while processing a smart_start request with targets {targets}."
        )

        pending_msg = re.escape(" Remotes that are pending: [].")

        stopped_msg = ""

        not_registered_msg = re.escape(f" Remotes that are not registered: {targets}.")

        deadlock_msg = ""

        full_send_q_msg = ""

        msg_suite = (
            f"{targets_msg}{pending_msg}{stopped_msg}"
            f"{not_registered_msg}{deadlock_msg}{full_send_q_msg}"
        )

        exp_error_msg = (
            rf"SmartThread alpha \(test1\) raising "
            f"SmartThreadRemoteThreadNotRegistered {msg_suite}"
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc1.value))

        print("\n", exc1.value)

        ################################################################
        beta_thread = st.SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            kwargs={"action": "wait"},
            auto_start=False,
        )
        beta_thread.smart_start()

        targets_msg = re.escape(
            f"while processing a smart_unreg request with targets {targets}."
        )

        pending_msg = re.escape(" Remotes that are pending: ['beta'].")

        stopped_msg = ""

        not_registered_msg = ""

        deadlock_msg = ""

        full_send_q_msg = ""

        request_pending_msg = re.escape(
            " Remotes that are processing a request: ['beta']."
        )

        msg_suite = (
            f"{targets_msg}{pending_msg}{stopped_msg}"
            f"{not_registered_msg}{deadlock_msg}{full_send_q_msg}{request_pending_msg}"
        )

        exp_error_msg = (
            rf"SmartThread alpha \(test1\) raising SmartThreadProcessingRequest "
            f"{msg_suite}"
        )

        logger.debug(exp_error_msg)
        with pytest.raises(st.SmartThreadProcessingRequest) as exc1:
            alpha_thread.smart_unreg(targets=targets)

        alpha_thread.smart_resume(waiters="beta")
        alpha_thread.smart_join(targets="beta", timeout=5)

        assert re.fullmatch(exp_error_msg, str(exc1.value))

        print("\n", exc1.value)

        ################################################################
        # SmartThreadDeadlockDetected
        ################################################################
        beta_thread = st.SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            kwargs={"action": "deadlock"},
            auto_start=False,
        )
        beta_thread.smart_start()
        with pytest.raises(st.SmartThreadDeadlockDetected) as exc2:
            alpha_thread.smart_recv(senders=targets)

        targets_msg = re.escape(
            f"while processing a smart_recv request with targets {targets}."
        )

        pending_msg = re.escape(f" Remotes that are pending: {pending_targets}.")

        # stopped_msg = (
        #     ' Remotes that are stopped: '
        #     r"\['beta'\].")
        stopped_msg = ""

        not_registered_msg = ""

        deadlock_msg = " Remotes that are deadlocked: " r"\['beta'\]."

        full_send_q_msg = ""

        msg_suite = (
            f"{targets_msg}{pending_msg}{stopped_msg}"
            f"{not_registered_msg}{deadlock_msg}{full_send_q_msg}"
        )

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising SmartThreadDeadlockDetected "
            f"{msg_suite}"
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc2.value))

        print("\n", exc2.value)

        ################################################################
        # SmartThreadRequestTimedOut not responsive
        ################################################################
        alpha_thread.smart_join(targets="beta", timeout=5)
        beta_thread = st.SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            kwargs={"action": "msg_wait"},
            auto_start=False,
        )
        beta_thread.smart_start()
        with pytest.raises(st.SmartThreadRequestTimedOut) as exc3:
            alpha_thread.smart_recv(senders=targets, timeout=1)

        targets_msg = re.escape(
            f"while processing a smart_recv request with targets {targets}."
        )

        pending_msg = re.escape(f" Remotes that are pending: {targets}.")

        stopped_msg = ""

        not_registered_msg = ""

        deadlock_msg = ""

        full_send_q_msg = ""

        msg_suite = (
            f"{targets_msg}{pending_msg}{stopped_msg}"
            f"{not_registered_msg}{deadlock_msg}{full_send_q_msg}"
        )

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising SmartThreadRequestTimedOut "
            f"{msg_suite}"
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc3.value))

        print("\n", exc3.value)

        ################################################################
        # join beta
        ################################################################
        msgs.queue_msg("beta")
        alpha_thread.smart_join(targets="beta", timeout=5)

        ################################################################
        # SmartThreadRequestTimedOut full_msg_q
        ################################################################
        alpha_thread.smart_join(targets="beta", timeout=5)
        beta_thread = st.SmartThread(
            group_name="test1",
            name="beta",
            target_rtn=f1,
            kwargs={"action": "msg_wait"},
            auto_start=False,
            max_msgs=1,
        )
        beta_thread.smart_start()
        alpha_thread.smart_send(receivers="beta", msg="hi beta")
        with pytest.raises(st.SmartThreadRequestTimedOut) as exc3:
            alpha_thread.smart_send(receivers=targets, msg="hello again", timeout=1)

        targets_msg = re.escape(
            f"while processing a smart_send request with targets {targets}."
        )

        pending_msg = re.escape(f" Remotes that are pending: {targets}.")

        stopped_msg = ""

        not_registered_msg = ""

        deadlock_msg = ""

        full_send_q_msg = r" Remotes that have a full send_q: \['beta'\]."

        msg_suite = (
            f"{targets_msg}{pending_msg}{stopped_msg}"
            f"{not_registered_msg}{deadlock_msg}{full_send_q_msg}"
        )

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising SmartThreadRequestTimedOut "
            f"{msg_suite}"
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc3.value))

        print("\n", exc3.value)

        ################################################################
        # SmartThreadInvalidInput
        ################################################################
        with pytest.raises(st.SmartThreadInvalidInput) as exc4:
            alpha_thread._handle_loop_errors(
                request=st.ReqType.Smart_sync, remotes={"beta"}
            )

        exp_error_msg = (
            r"_handle_loop_errors alpha \(test1\) called without an "
            "error - raising SmartThreadInvalidInput"
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc4.value))

        print("\n", exc4.value)

        ################################################################
        # join beta
        ################################################################
        msgs.queue_msg("beta")
        alpha_thread.smart_join(targets="beta", timeout=5)

        logger.debug("mainline exiting")

    ####################################################################
    # test_cmd_setup_errors
    ####################################################################
    def test_cmd_setup_errors(self) -> None:
        """Test error cases for SmartThread."""
        logger.debug("mainline entered")
        alpha_thread = st.SmartThread(group_name="test1", name="alpha")

        ################################################################
        # SmartThreadInvalidInput - caller also a remote
        ################################################################
        with pytest.raises(st.SmartThreadInvalidInput) as exc:
            alpha_thread.smart_join(targets="alpha")

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising SmartThreadInvalidInput "
            f"error while processing request smart_join. "
            r"The set of targets \['alpha'\] includes alpha which is not "
            f"permitted for request smart_join."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        logger.debug("mainline exiting")

    ####################################################################
    # test_request_setup_errors
    ####################################################################
    @pytest.mark.parametrize(
        "request_type_arg",
        [
            st.ReqType.Smart_send,
            st.ReqType.Smart_recv,
            st.ReqType.Smart_wait,
            st.ReqType.Smart_resume,
            st.ReqType.Smart_sync,
        ],
    )
    def test_request_setup_errors(self, request_type_arg: st.ReqType) -> None:
        """Test error cases for SmartThread.

        Args:
            request_type_arg: which request type will inject the error

        """
        logger.debug("mainline entered")
        alpha_thread = st.SmartThread(group_name="test1", name="alpha")

        ################################################################
        # SmartThreadInvalidInput - caller also a remote
        ################################################################
        with pytest.raises(st.SmartThreadInvalidInput) as exc:
            if request_type_arg == st.ReqType.Smart_send:
                alpha_thread.smart_send(msg="hello", receivers="alpha")
            elif request_type_arg == st.ReqType.Smart_recv:
                alpha_thread.smart_recv(senders="alpha")
            elif request_type_arg == st.ReqType.Smart_wait:
                alpha_thread.smart_wait(resumers="alpha")
            elif request_type_arg == st.ReqType.Smart_resume:
                alpha_thread.smart_resume(waiters="alpha")
            elif request_type_arg == st.ReqType.Smart_sync:
                alpha_thread.smart_sync(targets="alpha")
            else:
                raise InvalidInputDetected(
                    f"test_get_targets_errors received {request_type_arg=}"
                )

        exp_error_msg = (
            r"SmartThread alpha \(test1\) raising SmartThreadInvalidInput "
            f"error while processing request {request_type_arg}. "
            r"The set of targets \['alpha'\] includes alpha which is not "
            f"permitted for request {request_type_arg}."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        logger.debug("mainline exiting")

    ####################################################################
    # test_foreign_op_scenario
    ####################################################################
    def test_foreign_op_scenario(self, caplog: pytest.LogCaptureFixture) -> None:
        """Test foreign op error for SmartThread.

        Args:
            caplog: pytest fixture to capture log output

        """

        ################################################################
        # f1
        ################################################################
        def f1(f1_name: str) -> None:
            logger.debug(f"f1 entered for {f1_name}")
            msgs.get_msg(f1_name, timeout=10)
            logger.debug(f"f1 exit for {f1_name}")
            ############################################################
            # exit
            ############################################################

        logger.debug("mainline entry")
        msgs = Msgs()
        alpha_thread = st.SmartThread(group_name="test1", name="alpha")
        beta_thread = st.SmartThread(
            group_name="test1", name="beta", target_rtn=f1, kwargs={"f1_name": "beta"}
        )
        st.SmartThread(
            group_name="test1",
            name="charlie",
            target_rtn=f1,
            kwargs={"f1_name": "charlie"},
            auto_start=False,
        )

        ################################################################
        with pytest.raises(st.SmartThreadDetectedOpFromForeignThread) as exc:
            beta_thread.smart_start(targets="charlie")

        exp_error_msg = (
            "SmartThread beta (test1) raising "
            "SmartThreadDetectedOpFromForeignThread error "
            "while processing request smart_start. "
            "The SmartThread object used for the invocation is "
            f"associated with thread {beta_thread.thread} which does not "
            "match "
            f"caller thread {threading.current_thread()} as required."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(re.escape(exp_error_msg), str(exc.value))
        print("\n", exc.value)

        ################################################################
        with pytest.raises(st.SmartThreadDetectedOpFromForeignThread) as exc:
            beta_thread.smart_unreg(targets="charlie")

        exp_error_msg = (
            "SmartThread beta (test1) raising "
            "SmartThreadDetectedOpFromForeignThread error "
            "while processing request smart_unreg. "
            "The SmartThread object used for the invocation is "
            f"associated with thread {beta_thread.thread} which does not "
            "match "
            f"caller thread {threading.current_thread()} as required."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(re.escape(exp_error_msg), str(exc.value))
        print("\n", exc.value)

        ################################################################
        with pytest.raises(st.SmartThreadDetectedOpFromForeignThread) as exc:
            beta_thread.smart_join(targets="charlie")

        exp_error_msg = (
            "SmartThread beta (test1) raising "
            "SmartThreadDetectedOpFromForeignThread error "
            "while processing request smart_join. "
            "The SmartThread object used for the invocation is "
            f"associated with thread {beta_thread.thread} which does not "
            "match "
            f"caller thread {threading.current_thread()} as required."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(re.escape(exp_error_msg), str(exc.value))
        print("\n", exc.value)

        ################################################################
        with pytest.raises(st.SmartThreadDetectedOpFromForeignThread) as exc:
            beta_thread.smart_recv(senders="alpha")

        exp_error_msg = (
            "SmartThread beta (test1) raising "
            "SmartThreadDetectedOpFromForeignThread error "
            "while processing request smart_recv. "
            "The SmartThread object used for the invocation is "
            f"associated with thread {beta_thread.thread} which does not "
            "match "
            f"caller thread {threading.current_thread()} as required."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(re.escape(exp_error_msg), str(exc.value))
        print("\n", exc.value)

        ################################################################
        with pytest.raises(st.SmartThreadDetectedOpFromForeignThread) as exc:
            beta_thread.smart_send(receivers="alpha", msg="hi alpha")

        exp_error_msg = (
            "SmartThread beta (test1) raising "
            "SmartThreadDetectedOpFromForeignThread error "
            "while processing request smart_send. "
            "The SmartThread object used for the invocation is "
            f"associated with thread {beta_thread.thread} which does not "
            "match "
            f"caller thread {threading.current_thread()} as required."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(re.escape(exp_error_msg), str(exc.value))
        print("\n", exc.value)

        ################################################################
        with pytest.raises(st.SmartThreadDetectedOpFromForeignThread) as exc:
            beta_thread.smart_wait(resumers="alpha")

        exp_error_msg = (
            "SmartThread beta (test1) raising "
            "SmartThreadDetectedOpFromForeignThread error "
            "while processing request smart_wait. "
            "The SmartThread object used for the invocation is "
            f"associated with thread {beta_thread.thread} which does not "
            "match "
            f"caller thread {threading.current_thread()} as required."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(re.escape(exp_error_msg), str(exc.value))
        print("\n", exc.value)

        ################################################################
        with pytest.raises(st.SmartThreadDetectedOpFromForeignThread) as exc:
            beta_thread.smart_resume(waiters="alpha")

        exp_error_msg = (
            "SmartThread beta (test1) raising "
            "SmartThreadDetectedOpFromForeignThread error "
            "while processing request smart_resume. "
            "The SmartThread object used for the invocation is "
            f"associated with thread {beta_thread.thread} which does not "
            "match "
            f"caller thread {threading.current_thread()} as required."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(re.escape(exp_error_msg), str(exc.value))
        print("\n", exc.value)

        ################################################################
        with pytest.raises(st.SmartThreadDetectedOpFromForeignThread) as exc:
            beta_thread.smart_sync(targets="alpha")

        exp_error_msg = (
            "SmartThread beta (test1) raising "
            "SmartThreadDetectedOpFromForeignThread error "
            "while processing request smart_sync. "
            "The SmartThread object used for the invocation is "
            f"associated with thread {beta_thread.thread} which does not "
            "match "
            f"caller thread {threading.current_thread()} as required."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(re.escape(exp_error_msg), str(exc.value))
        print("\n", exc.value)

        ################################################################
        alpha_thread.smart_start(targets="charlie")

        msgs.queue_msg("beta")
        msgs.queue_msg("charlie")
        alpha_thread.smart_join(targets=("beta", "charlie"))

        logger.debug("mainline exit")

    ####################################################################
    # test_foreign_op_scenario2
    ####################################################################
    @pytest.mark.parametrize(
        "request_type_arg",
        [st.ReqType.Smart_start, st.ReqType.Smart_unreg, st.ReqType.Smart_join],
    )
    @pytest.mark.parametrize("group_name_arg", ["test1", "test2", "test3"])
    def test_foreign_op_scenario2(
        self,
        request_type_arg: st.ReqType,
        group_name_arg: str,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test foreign op error for SmartThread.

        Args:
            request_type_arg: which request type will inject the error
            group_name_arg: group to use for beta1 thread
            caplog: pytest fixture to capture log output

        """

        ################################################################
        # f1
        ################################################################
        def f1(f1_name: str) -> None:
            logger.debug(f"f1 entered for {f1_name}")
            f1_msg = msgs.get_msg("beta_1", timeout=10)
            req: str = ""
            with pytest.raises(st.SmartThreadDetectedOpFromForeignThread) as f1_exc:
                if f1_msg == "SmartStart":
                    req = "smart_start"
                    beta_1_s_thread.smart_start(targets="charlie")
                elif f1_msg == "SmartUnreg":
                    req = "smart_unreg"
                    beta_1_s_thread.smart_unreg(targets="charlie")
                elif f1_msg == "SmartJoin":
                    req = "smart_join"
                    beta_1_s_thread.smart_join(targets="charlie")
                else:
                    raise InvalidInputDetected(
                        f"test_foreign_op_scenario2 f1 rtn received {f1_msg=}"
                    )

            f1_exp_error_msg = (
                f"SmartThread beta ({group_name_arg}) raising "
                "SmartThreadDetectedOpFromForeignThread error "
                f"while processing request {req}. "
                "The SmartThread object used for the invocation is not "
                "know to the configuration. "
                f"Group name: {group_name_arg}, "
                f"Name: {beta_1_s_thread.name}, "
                f"ID: {id(beta_1_s_thread)}, "
                f"create time: {beta_1_s_thread.create_time}, "
                f"thread: {beta_1_s_thread.thread}."
            )

            logger.debug(f1_exp_error_msg)
            assert re.fullmatch(re.escape(f1_exp_error_msg), str(f1_exc.value))
            print("\n", f1_exc.value)

            msgs.queue_msg("alpha")
            logger.debug(f"f1 exit for {f1_name}")
            ############################################################
            # exit
            ############################################################

        ################################################################
        # f2
        ################################################################
        def f2(f2_name: str) -> None:
            logger.debug(f"f2 entered for {f2_name}")
            # _ = msgs.get_msg('beta_2', timeout=10)
            logger.debug(f"f2 exit for {f2_name}")
            ############################################################
            # exit
            ############################################################

        ################################################################
        # f3
        ################################################################
        def f3(f3_name: str) -> None:
            logger.debug(f"f3 entered for {f3_name}")
            # _ = msgs.get_msg('charlie', timeout=10)
            logger.debug(f"f3 exit for {f3_name}")
            ############################################################
            # exit
            ############################################################

        logger.debug("mainline entry")
        msgs = Msgs()
        alpha_s_thread = st.SmartThread(group_name="test1", name="alpha")

        if group_name_arg != "test1":
            alpha_s_2_thread = st.SmartThread(group_name=group_name_arg, name="alpha")

        beta_1_thread = threading.Thread(target=f1, kwargs={"f1_name": "beta_1"})
        beta_1_s_thread = st.SmartThread(
            group_name=group_name_arg,
            name="beta",
            auto_start=False,
            thread=beta_1_thread,
        )

        if group_name_arg == "test1":
            alpha_s_thread.smart_unreg(targets="beta")
        elif group_name_arg == "test2":
            alpha_s_2_thread.smart_unreg(targets="beta")
        else:
            alpha_s_2_thread.smart_unreg(targets="beta")
            del st.SmartThread._registry[group_name_arg]

        beta_2_s_thread = st.SmartThread(
            group_name="test1",
            name="beta",
            auto_start=False,
            target_rtn=f2,
            kwargs={"f2_name": "beta_2"},
        )

        charlie_s_thread = st.SmartThread(
            group_name="test1",
            name="charlie",
            auto_start=False,
            target_rtn=f3,
            kwargs={"f3_name": "charlie"},
        )

        if request_type_arg == st.ReqType.Smart_start:
            # start beta_2 using beta_1 unregistered smart thread
            with pytest.raises(st.SmartThreadDetectedOpFromForeignThread) as exc:
                beta_1_s_thread.smart_start()

            # verify error message
            exp_error_msg = (
                f"SmartThread beta ({group_name_arg}) raising "
                "SmartThreadDetectedOpFromForeignThread error "
                "while processing request smart_start. "
                "The SmartThread object used for the invocation is not "
                "know to the configuration. "
                f"Group name: {group_name_arg}, "
                f"Name: {beta_1_s_thread.name}, "
                f"ID: {id(beta_1_s_thread)}, "
                f"create time: {beta_1_s_thread.create_time}, "
                f"thread: {beta_1_s_thread.thread}."
            )

            logger.debug(exp_error_msg)
            assert re.fullmatch(re.escape(exp_error_msg), str(exc.value))
            print("\n", exc.value)

            # start beta_2 legitimately
            logger.debug("starting beta2 legit")
            beta_2_s_thread.smart_start()

            logger.debug("starting beta1 threading thread")
            beta_1_thread.start()
            # start charlie using beta_1 unregistered smart thread
            msgs.queue_msg("beta_1", "SmartStart")

            _ = msgs.get_msg("alpha")
            charlie_s_thread.smart_start()
            alpha_s_thread.smart_join(targets=["beta", "charlie"])

        elif request_type_arg == st.ReqType.Smart_unreg:
            beta_1_thread.start()
            # start charlie using beta_1 unregistered smart thread
            msgs.queue_msg("beta_1", "SmartUnreg")

            alpha_s_thread.smart_unreg(targets="beta")

        elif request_type_arg == st.ReqType.Smart_join:
            alpha_s_thread.smart_unreg(targets="beta")
            charlie_s_thread.smart_start()

            beta_1_thread.start()
            msgs.queue_msg("beta_1", "SmartJoin")
        else:
            raise InvalidInputDetected(
                f"test_foreign_op_scenario2 received {request_type_arg=}"
            )

        beta_1_thread.join()

        logger.debug("mainline exit")

    ####################################################################
    # test_foreign_op_scenario3
    ####################################################################
    @pytest.mark.parametrize(
        "request_type_arg",
        [
            st.ReqType.Smart_send,
            st.ReqType.Smart_recv,
            st.ReqType.Smart_wait,
            st.ReqType.Smart_resume,
            st.ReqType.Smart_sync,
        ],
    )
    def test_foreign_op_scenario3(
        self, request_type_arg: st.ReqType, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Test foreign op error for SmartThread.

        Args:
            request_type_arg: which request type will inject the error
            caplog: pytest fixture to capture log output

        """

        # 1) create beta_1 as no start, and then unreg
        # 2) create beta_2 as no start
        # 3) smart_start beta_1 - should fail
        ################################################################
        # f1
        ################################################################
        def f1(f1_name: str, action: st.ReqType) -> None:
            logger.debug(f"f1 entered for {f1_name}")
            req: str = ""
            with pytest.raises(st.SmartThreadDetectedOpFromForeignThread) as f1_exc:
                if action == st.ReqType.Smart_send:
                    req = "smart_send"
                    logger.debug("f1 beta_1 about to send to alpha")
                    beta_1_s_thread.smart_send(
                        msg="hi alpha, this is beta_1", receivers="alpha"
                    )
                    logger.debug("f1 beta_1 back from send to alpha")
                elif action == st.ReqType.Smart_recv:
                    req = "smart_recv"
                    msg1 = beta_1_s_thread.smart_recv(senders="alpha")
                    logger.debug(f"f1 received {msg1=}")
                elif action == st.ReqType.Smart_wait:
                    req = "smart_wait"
                    beta_1_s_thread.smart_wait(resumers="alpha")
                elif action == st.ReqType.Smart_resume:
                    req = "smart_resume"
                    beta_1_s_thread.smart_resume(waiters="alpha")
                elif action == st.ReqType.Smart_sync:
                    req = "smart_sync"
                    beta_1_s_thread.smart_sync(targets="alpha")
                else:
                    raise InvalidInputDetected(
                        f"test_foreign_op_scenario3 f1 rtn received {action=}"
                    )

            f1_exp_error_msg = (
                "SmartThread beta (test1) raising "
                "SmartThreadDetectedOpFromForeignThread error "
                f"while processing request {req}. "
                "The SmartThread object used for the invocation is not "
                "know to the configuration. "
                "Group name: test1, "
                f"Name: {beta_1_s_thread.name}, "
                f"ID: {id(beta_1_s_thread)}, "
                f"create time: {beta_1_s_thread.create_time}, "
                f"thread: {beta_1_s_thread.thread}."
            )

            logger.debug(f1_exp_error_msg)
            assert re.fullmatch(re.escape(f1_exp_error_msg), str(f1_exc.value))
            print("\n", f1_exc.value)

            msgs.queue_msg(target="beta_2")

            logger.debug(f"f1 exit for {f1_name}")
            ############################################################
            # exit
            ############################################################

        ################################################################
        # f2
        ################################################################
        def f2(f2_name: str, action: st.ReqType, beta_2_st: st.SmartThread) -> None:
            logger.debug(f"f2 entered for {f2_name}")
            msgs.queue_msg(target="alpha")
            _ = msgs.get_msg("beta_2", timeout=10)
            if action == st.ReqType.Smart_send:
                logger.debug("f2 beta_2 about to send to alpha")
                beta_2_st.smart_send(msg="hi alpha, this is beta_1", receivers="alpha")
                logger.debug("f2 beta_2 back from send to alpha")
            elif action == st.ReqType.Smart_recv:
                msg1 = beta_2_st.smart_recv(senders="alpha")
                logger.debug(f"f2 received {msg1=}")
            elif action == st.ReqType.Smart_wait:
                beta_2_st.smart_wait(resumers="alpha")
            elif action == st.ReqType.Smart_resume:
                beta_2_st.smart_resume(waiters="alpha")
            elif action == st.ReqType.Smart_sync:
                beta_2_st.smart_sync(targets="alpha")
            else:
                raise InvalidInputDetected(
                    f"test_foreign_op_scenario3 f1 rtn received {action=}"
                )
            logger.debug(f"f2 exit for {f2_name}")
            ############################################################
            # exit
            ############################################################

        logger.debug("mainline entry")
        msgs = Msgs()
        alpha_s_thread = st.SmartThread(group_name="test1", name="alpha")

        beta_1_thread = threading.Thread(
            target=f1, kwargs={"f1_name": "beta_1", "action": request_type_arg}
        )
        beta_1_s_thread = st.SmartThread(
            group_name="test1", name="beta", auto_start=False, thread=beta_1_thread
        )

        alpha_s_thread.smart_unreg(targets="beta")

        st.SmartThread(
            group_name="test1",
            name="beta",
            auto_start=True,
            target_rtn=f2,
            thread_parm_name="beta_2_st",
            kwargs={"f2_name": "beta_2", "action": request_type_arg},
        )

        # start beta_1 thread directly
        beta_1_thread.start()

        _ = msgs.get_msg("alpha", timeout=10)

        if request_type_arg == st.ReqType.Smart_send:
            logger.debug("alpha about to recv from beta")
            msg3 = alpha_s_thread.smart_recv(senders="beta")
            logger.debug(f"alpha received {msg3=}")
        elif request_type_arg == st.ReqType.Smart_recv:
            logger.debug("alpha about to send to beta")
            alpha_s_thread.smart_send(msg="hi beta, this is alpha", receivers="beta")
            logger.debug("alpha sent message")
        elif request_type_arg == st.ReqType.Smart_wait:
            logger.debug("alpha about to resume beta")
            alpha_s_thread.smart_resume(waiters="beta")
            logger.debug("alpha completed resume")
        elif request_type_arg == st.ReqType.Smart_resume:
            logger.debug("alpha about to wait for beta")
            alpha_s_thread.smart_wait(resumers="beta")
            logger.debug("alpha resumed by beta")
        elif request_type_arg == st.ReqType.Smart_sync:
            logger.debug("alpha about to sync with beta")
            alpha_s_thread.smart_sync(targets="beta")
            logger.debug("alpha synced with beta")
        else:
            raise InvalidInputDetected(
                f"test_foreign_op_scenario3 mainline received {request_type_arg=}"
            )

        msgs.queue_msg("beta_2", "Exit")

        alpha_s_thread.smart_join(targets="beta")

        logger.debug("mainline exit")


########################################################################
# TestSmartThreadScenarios class
########################################################################
@pytest.mark.cover
class TestSmartBasicScenarios:
    """Test class for SmartThread scenarios."""

    ####################################################################
    # test_config_build_scenarios
    ####################################################################
    @pytest.mark.parametrize("num_registered_1_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_active_1_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_stopped_1_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_registered_2_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_active_2_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_stopped_2_arg", [0, 1, 2])
    def test_config_build_scenarios(
        self,
        num_registered_1_arg: int,
        num_active_1_arg: int,
        num_stopped_1_arg: int,
        num_registered_2_arg: int,
        num_active_2_arg: int,
        num_stopped_2_arg: int,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_registered_1_arg: number of threads to initially build
                as registered
            num_active_1_arg: number of threads to initially build as
                active
            num_stopped_1_arg: number of threads to initially build as
                stopped
            num_registered_2_arg: number of threads to reconfigure as
                registered
            num_active_2_arg: number of threads to reconfigure as
                active
            num_stopped_2_arg: number of threads to reconfigure as
                stopped
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            "num_registered_1": num_registered_1_arg,
            "num_active_1": num_active_1_arg,
            "num_stopped_1": num_stopped_1_arg,
            "num_registered_2": num_registered_2_arg,
            "num_active_2": num_active_2_arg,
            "num_stopped_2": num_stopped_2_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_config_build_suite,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_get_current_smart_thread
    ####################################################################
    # @pytest.mark.seltest
    def test_get_current_smart_thread(self) -> None:
        """Test the function that gets the current smart thread."""

        def f1() -> None:
            """Target for thread only."""

            with pytest.raises(st.SmartThreadNotFound) as f1_exc:
                st.SmartThread.get_current_smart_thread(group_name="test1")

            f1_exp_error_msg = (
                "SmartThread get_current_smart_thread raising SmartThreadNotFound. "
                f"Unable to find the current smart thread for group_name='test1'."
            )

            logger.debug(f1_exp_error_msg)
            assert re.fullmatch(f1_exp_error_msg, str(f1_exc.value))

            print("\n", f1_exc.value)

        def f2() -> None:
            """Target for smart thread."""
            f2_smart_thread = st.SmartThread.get_current_smart_thread(
                group_name="test1"
            )
            assert f2_smart_thread is not None
            assert f2_smart_thread.name is not None
            assert f2_smart_thread.name == "charlie"

        logger.debug("mainline entered")

        with pytest.raises(st.SmartThreadNotFound) as exc:
            current_smart_thread = st.SmartThread.get_current_smart_thread(
                group_name="test1"
            )

        exp_error_msg = (
            "SmartThread get_current_smart_thread raising SmartThreadNotFound. "
            f"Unable to find the current smart thread for group_name='test1'."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        alpha_smart_thread = st.SmartThread(group_name="test1", name="alpha")

        current_smart_thread = st.SmartThread.get_current_smart_thread(
            group_name="test1"
        )
        assert current_smart_thread is alpha_smart_thread

        with pytest.raises(st.SmartThreadNotFound) as exc:
            current_smart_thread = st.SmartThread.get_current_smart_thread(
                group_name="test2"
            )

        exp_error_msg = (
            "SmartThread get_current_smart_thread raising SmartThreadNotFound. "
            "Unable to find the current smart thread for group_name='test2'."
        )

        logger.debug(exp_error_msg)
        assert re.fullmatch(exp_error_msg, str(exc.value))

        print("\n", exc.value)

        alpha_smart_thread2 = st.SmartThread(group_name="test2", name="alpha")

        current_smart_thread = st.SmartThread.get_current_smart_thread(
            group_name="test2"
        )
        assert current_smart_thread is alpha_smart_thread2

        current_smart_thread = st.SmartThread.get_current_smart_thread(
            group_name="test1"
        )
        assert current_smart_thread is alpha_smart_thread

        beta_thread = threading.Thread(name="beta", target=f1)
        beta_thread.start()
        beta_thread.join()

        st.SmartThread(group_name="test1", name="charlie", target_rtn=f2)
        alpha_smart_thread.smart_join(targets="charlie")

    ####################################################################
    # test_get_current_smart_thread
    ####################################################################
    @pytest.mark.parametrize(
        "group_names_arg",
        [
            ("test1",),
            ("test1", "test2"),
            ("test1", "test2", "test3"),
        ],
    )
    @pytest.mark.parametrize(
        "thread_names_arg",
        [
            ("beta",),
            ("beta", "charlie"),
            ("beta", "charlie", "delta"),
        ],
    )
    def test_find_smart_threads(
        self,
        group_names_arg: tuple[str],
        thread_names_arg: tuple[str],
    ) -> None:
        """Test the function that returns a list of smart threads.

        Args:
            group_names_arg: group names to use
            thread_names_arg: thread names to use

        """

        def f1(smart_thread: st.SmartThread) -> None:
            """Target for thread only."""
            smart_thread.smart_wait(resumers="alpha")

        logger.debug("mainline entered")

        smart_threads = st.SmartThread.find_smart_threads(threading.current_thread())

        assert smart_threads == []
        assert len(smart_threads) == 0

        alpha_threads: list[st.SmartThread] = []

        beta_threads: list[list[st.SmartThread]] = []

        for idx, group_name in enumerate(group_names_arg):
            alpha_threads.append(st.SmartThread(group_name=group_name, name="alpha"))

            test_threads = st.SmartThread.find_smart_threads(threading.current_thread())
            assert len(test_threads) == (idx + 1)
            assert test_threads == alpha_threads

            beta_threads.append([])
            for idx2, name in enumerate(thread_names_arg):
                beta_threads[idx].append(
                    st.SmartThread(
                        group_name=group_name,
                        name=name,
                        target_rtn=f1,
                        thread_parm_name="smart_thread",
                    )
                )
                search_thread = beta_threads[idx][idx2].thread
                beta_test_threads = st.SmartThread.find_smart_threads(search_thread)

                assert len(beta_test_threads) == 1
                assert beta_test_threads == [beta_threads[idx][idx2]]

        for alpha_thread in alpha_threads:
            alpha_thread.smart_resume(waiters=thread_names_arg)
            alpha_thread.smart_join(targets=thread_names_arg)

        logger.debug("mainline exiting")

    ####################################################################
    # test_get_active_names
    ####################################################################
    @pytest.mark.parametrize("num_active_names_arg", [0, 1, 2, 3])
    @pytest.mark.parametrize("num_registered_names_arg", [0, 1, 2, 3])
    def test_get_active_names(
        self, num_active_names_arg: int, num_registered_names_arg: int
    ) -> None:
        """Test the function that returns a set of alive threads.

        Args:
           num_active_names_arg: number of active threads needed
           num_registered_names_arg: number of registered thread needed

        """

        def f1(f1_smart_thread: st.SmartThread) -> None:
            """Target for thread only.

            Args:
               f1_smart_thread: smart thread for this invocation

            """
            logger.debug(f"{f1_smart_thread.name} entered")
            f1_smart_thread.smart_wait(resumers="alpha")

            assert st.SmartThread.get_active_names(group_name="test1") - {"alpha"} == (
                active_names | reg_names
            )

            f1_smart_thread.smart_resume(waiters="alpha")

            f1_smart_thread.smart_wait(resumers="alpha")

            logger.debug(f"{f1_smart_thread.name} exiting")

        logger.debug("mainline entered")

        active_names = get_names("active_", num_active_names_arg)

        reg_names = get_names("reg_", num_registered_names_arg)

        alpha_smart_thread = st.SmartThread(group_name="test1", name="alpha")

        for name in active_names:
            st.SmartThread(
                group_name="test1",
                name=name,
                target_rtn=f1,
                thread_parm_name="f1_smart_thread",
            )

        for name in reg_names:
            st.SmartThread(
                group_name="test1",
                name=name,
                target_rtn=f1,
                thread_parm_name="f1_smart_thread",
                auto_start=False,
            )

        # get actives names - might only contain alpha
        ret_active_names = st.SmartThread.get_active_names(group_name="test1") - {
            "alpha"
        }

        assert ret_active_names == active_names

        if reg_names:
            alpha_smart_thread.smart_start(targets=reg_names)

        ret_active_names = st.SmartThread.get_active_names(group_name="test1") - {
            "alpha"
        }

        assert ret_active_names == (active_names | reg_names)

        if active_names | reg_names:
            alpha_smart_thread.smart_resume(waiters=active_names | reg_names)

            alpha_smart_thread.smart_wait(resumers=active_names | reg_names)

            alpha_smart_thread.smart_resume(waiters=active_names | reg_names)

            alpha_smart_thread.smart_join(targets=active_names | reg_names)

        logger.debug("mainline exiting")

    ####################################################################
    # test_multiple_groups
    ####################################################################
    # @pytest.mark.parametrize(
    #     "log_level_arg",
    #     [
    #         logging.DEBUG,
    #         logging.CRITICAL,
    #         logging.NOTSET,
    #     ],
    # )
    @pytest.mark.parametrize("num_groups_arg", [1, 2, 3, 32])
    @pytest.mark.parametrize("random_seed_arg", [1, 2, 3])
    def test_multiple_groups(
        self,
        num_groups_arg: int,
        random_seed_arg: int,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_groups_arg: number of groups to create
            random_seed_arg: random seed
            caplog: pytest fixture to capture log output

        """

        def f1(f1_smart_thread: st.SmartThread, f1_group_name: str) -> None:
            """Target for thread only.

            Args:
               f1_smart_thread: smart thread for this invocation
               f1_group_name: the group that this thread is in

            """
            logger.debug(f"{f1_smart_thread.name} entered for group {f1_group_name}")

            my_msg_target_name = f"{f1_group_name} {f1_smart_thread.name}"

            msgs_owed: int = 0
            while True:
                # my_msg = msg.get_msg(my_msg_target_name, timeout=120)
                my_msg = f1_msgs[f1_group_name][f1_smart_thread.name].get_msg(
                    my_msg_target_name, timeout=0
                )
                if my_msg == "exit":
                    break

                if my_msg == "smart_recv":
                    msgs_owed += 1
                    if msgs_owed > 0:
                        my_smart_msg = f1_smart_thread.smart_recv(senders="alpha")

                        for a_msg in my_smart_msg["alpha"]:
                            assert a_msg == my_msg_target_name
                            msgs_owed -= 1

                elif my_msg == "smart_send":
                    f1_smart_thread.smart_send(
                        msg=my_msg_target_name, receivers="alpha"
                    )
                elif my_msg == "smart_wait":
                    f1_smart_thread.smart_wait(resumers="alpha")
                elif my_msg == "smart_resume":
                    f1_smart_thread.smart_resume(waiters="alpha")
                elif my_msg == "smart_sync":
                    f1_smart_thread.smart_sync(targets="alpha")
                else:
                    raise UnrecognizedCmd(f"{my_msg=} is unrecognized")

            logger.debug(f"{f1_smart_thread.name} exiting")

        start_time = time.time()

        logger.debug("mainline entered")

        num_smart_reqs = 256

        max_active_names = 16

        random.seed(random_seed_arg)

        msg = Msgs()

        group_names = get_names("group_", num_groups_arg)

        active_names = get_names("active_", max_active_names)

        alpha_threads: dict[str, st.SmartThread] = {}
        f1_names_in_group: dict[str, list[str]] = {}
        f1_msgs: dict[str, dict[str, Msgs]] = defaultdict(dict)
        f1_smart_threads: dict[str, dict[str, st.SmartThread]] = defaultdict(dict)

        for group_name in group_names:
            alpha_threads[group_name] = st.SmartThread(
                group_name=group_name,
                name="alpha",
            )

            num_active = random.randint(1, max_active_names)
            f1_names_in_group[group_name] = random.sample(
                sorted(active_names), num_active
            )
            for name in f1_names_in_group[group_name]:
                # f1_msgs[group_name][name] = Msgs()
                f1_msgs[group_name][name] = msg
                f1_smart_threads[group_name][name] = st.SmartThread(
                    group_name=group_name,
                    name=name,
                    target_rtn=f1,
                    kwargs={"f1_group_name": group_name},
                    thread_parm_name="f1_smart_thread",
                )

        for idx in range(num_smart_reqs):
            if idx < len(group_names):
                group_name = sorted(group_names)[idx]
            else:
                group_name = random.sample(sorted(group_names), 1)[0]
            if idx < len(smart_reqs):
                smart_req = smart_reqs[idx]
            else:
                smart_req = random.sample(smart_reqs, 1)[0]
            num_potential_targets = len(f1_names_in_group[group_name])
            num_targets = random.randint(1, num_potential_targets)
            targets = random.sample(f1_names_in_group[group_name], num_targets)

            for target in targets:
                target_msg_name = f"{group_name} {target}"
                f1_msgs[group_name][target].queue_msg(
                    target=target_msg_name, msg=smart_req
                )

                if smart_req == "smart_recv":
                    alpha_threads[group_name].smart_send(
                        msg=target_msg_name, receivers=target
                    )
                elif smart_req == "smart_send":
                    alpha_msg = alpha_threads[group_name].smart_recv(senders=target)
                    assert alpha_msg[target][0] == target_msg_name
                elif smart_req == "smart_wait":
                    alpha_threads[group_name].smart_resume(waiters=target)
                elif smart_req == "smart_resume":
                    alpha_threads[group_name].smart_wait(resumers=target)
                elif smart_req == "smart_sync":
                    alpha_threads[group_name].smart_sync(targets=target)
                else:
                    raise UnrecognizedCmd(f"{smart_req=} is unrecognized")

        for group_name in group_names:
            for target in f1_names_in_group[group_name]:
                target_msg_name = f"{group_name} {target}"
                f1_msgs[group_name][target].queue_msg(
                    target=target_msg_name, msg="exit"
                )
                alpha_threads[group_name].smart_join(targets=target)

        elapsed_time = time.time() - start_time
        logger.debug(f"mainline exiting elapsed time: {elapsed_time}")

    ####################################################################
    # test_send_scenario
    ####################################################################
    @pytest.mark.parametrize("num_senders_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_receivers_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_msgs_arg", [1, 2, 3])
    @pytest.mark.parametrize("send_type_arg", [SendType.ToRemotes, SendType.SRMsgs])
    def test_send_scenario(
        self,
        num_senders_arg: int,
        num_receivers_arg: int,
        num_msgs_arg: int,
        send_type_arg: SendType,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_senders_arg: number of sender threads
            num_receivers_arg: number of receiver threads
            num_msgs_arg: number of message to send
            send_type_arg: type of send to do
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            "num_senders": num_senders_arg,
            "num_receivers": num_receivers_arg,
            "num_msgs": num_msgs_arg,
            "send_type": send_type_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_send_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_recv_basic_scenarios
    ####################################################################
    @pytest.mark.parametrize("num_senders_arg", [0, 1, 2, 3])
    @pytest.mark.parametrize("num_msgs_arg", [1, 2, 3])
    @pytest.mark.parametrize("sender_count_arg", [0, 1, 2, 3])
    @pytest.mark.parametrize(
        "recv_type_arg",
        [
            RecvType.PartialSenders,
            RecvType.MatchSenders,
            RecvType.ExtraSenders,
            RecvType.UnmatchSenders,
        ],
    )
    def test_recv_basic_scenario(
        self,
        num_senders_arg: int,
        num_msgs_arg: int,
        sender_count_arg: int,
        recv_type_arg: RecvType,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_senders_arg: number of senders
            num_msgs_arg: number of message to send
            sender_count_arg: number senders needed to satify smart_recv
            recv_type_arg: type of recv to do
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            "num_senders": num_senders_arg,
            "num_msgs": num_msgs_arg,
            "sender_count": sender_count_arg,
            "recv_type": recv_type_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_recv_basic_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_resume_basic_scenario
    ####################################################################
    @pytest.mark.parametrize("num_resumers_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_waiters_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_reg_waiters_arg", [1, 2])
    def test_resume_basic_scenario(
        self,
        num_resumers_arg: int,
        num_waiters_arg: int,
        num_reg_waiters_arg: int,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_resumers_arg: number of resumers
            num_waiters_arg: number of waiters
            num_reg_waiters_arg: number waiters start out as registered
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            "num_resumers": num_resumers_arg,
            "num_waiters": num_waiters_arg,
            "num_reg_waiters": num_reg_waiters_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_resume_basic_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_wait_basic_scenario
    ####################################################################
    @pytest.mark.parametrize("num_resumers_arg", [0, 1, 2, 3])
    @pytest.mark.parametrize("resumer_count_arg", [0, 1, 2, 3])
    @pytest.mark.parametrize(
        "wait_type_arg",
        [
            WaitType.PartialResumers,
            WaitType.MatchResumers,
            WaitType.ExtraResumers,
            WaitType.UnmatchResumers,
        ],
    )
    def test_wait_basic_scenario(
        self,
        num_resumers_arg: int,
        resumer_count_arg: int,
        wait_type_arg: WaitType,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_resumers_arg: number of resumers beyond what is
                required for the wait_type_arg
            resumer_count_arg: resumer_count specification for
                smart_wait
            wait_type_arg: type of wait to do
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            "num_resumers": num_resumers_arg,
            "resumer_count": resumer_count_arg,
            "wait_type": wait_type_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_wait_basic_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_sync_basic_scenario
    ####################################################################
    @pytest.mark.parametrize("num_syncers_arg", [2, 3, 4])
    @pytest.mark.parametrize("num_extras_arg", [0, 1, 2])
    def test_sync_basic_scenario(
        self,
        num_syncers_arg: int,
        num_extras_arg: int,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_syncers_arg: number of threads doing sync
            num_extras_arg: number of extra threads not involved in the
                sync request
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            "num_syncers": num_syncers_arg,
            "num_extras": num_extras_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_sync_basic_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_pending_sans_sync_scenario
    ####################################################################
    @pytest.mark.parametrize(
        "request_type_arg",
        [
            st.ReqType.Smart_send,
            st.ReqType.Smart_recv,
            st.ReqType.Smart_wait,
            st.ReqType.Smart_resume,
        ],
    )
    @pytest.mark.parametrize("pending_request_tf_arg", [True, False])
    @pytest.mark.parametrize("pending_msg_count_arg", [0, 1, 2])
    @pytest.mark.parametrize("pending_wait_tf_arg", [True, False])
    def test_pending_sans_sync_scenario(
        self,
        request_type_arg: st.ReqType,
        pending_request_tf_arg: bool,
        pending_msg_count_arg: int,
        pending_wait_tf_arg: bool,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            request_type_arg: request type that is to get the pending
                flags set on it
            pending_request_tf_arg: if True, pending_request flag is to
                be set
            pending_msg_count_arg: number of msgs to be placed on the
                pending thread
            pending_wait_tf_arg: if True, pending_wait flag is to be set
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            "request_type": request_type_arg,
            "pending_request_tf": pending_request_tf_arg,
            "pending_msg_count": pending_msg_count_arg,
            "pending_wait_tf": pending_wait_tf_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_pending_sans_sync_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_pending_sync_only_scenario
    ####################################################################
    @pytest.mark.parametrize("pending_msg_count_arg", [0, 1, 2])
    @pytest.mark.parametrize("pending_wait_tf_arg", [True, False])
    @pytest.mark.parametrize("pending_sync_tf_arg", [True, False])
    def test_pending_sync_only_scenario(
        self,
        pending_msg_count_arg: int,
        pending_wait_tf_arg: bool,
        pending_sync_tf_arg: bool,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            pending_msg_count_arg: number of msgs to be placed on the
                pending thread
            pending_wait_tf_arg: if True, pending_wait flag is to be set
            pending_sync_tf_arg: if True, pending_sync flag is to be set
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            "pending_msg_count": pending_msg_count_arg,
            "pending_wait_tf": pending_wait_tf_arg,
            "pending_sync_tf": pending_wait_tf_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_pending_sync_only_scenarios,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_remove_reasons_scenario
    ####################################################################
    @pytest.mark.parametrize("pending_msg_count_arg", [0, 1, 2])
    @pytest.mark.parametrize("pending_wait_tf_arg", [True, False])
    @pytest.mark.parametrize("pending_sync_tf_arg", [True, False])
    def test_remove_reasons_scenario(
        self,
        pending_msg_count_arg: int,
        pending_wait_tf_arg: bool,
        pending_sync_tf_arg: bool,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            pending_msg_count_arg: number of msgs to be placed on the
                pending thread
            pending_wait_tf_arg: if True, pending_wait flag is to be set
            pending_sync_tf_arg: if True, pending_sync flag is to be set
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            "pending_msg_count": pending_msg_count_arg,
            "pending_wait_tf": pending_wait_tf_arg,
            "pending_sync_tf": pending_sync_tf_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_remove_reasons_scenarios,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_backout_sync_remote_scenario
    ####################################################################
    @pytest.mark.parametrize("num_pending_arg", [1, 2, 3])
    def test_backout_sync_remote_scenario(
        self, num_pending_arg: int, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_pending_arg: number of pending threads
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {"num_pending": num_pending_arg}

        scenario_driver(
            scenario_builder=ConfigVerifier.build_backout_sync_remote_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_backout_sync_local_scenario
    ####################################################################
    def test_backout_sync_local_scenario(
        self, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {}

        scenario_driver(
            scenario_builder=ConfigVerifier.build_backout_sync_local_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_sync_delay_scenario
    ####################################################################
    def test_sync_delay_scenario(self, caplog: pytest.LogCaptureFixture) -> None:
        """Test meta configuration scenarios.

        Args:
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {}

        scenario_driver(
            scenario_builder=ConfigVerifier.build_sync_delay_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_sync_delay2_scenario
    ####################################################################
    def test_sync_delay2_scenario(self, caplog: pytest.LogCaptureFixture) -> None:
        """Test meta configuration scenarios.

        Args:
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {}

        scenario_driver(
            scenario_builder=ConfigVerifier.build_sync_delay2_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_sync_create_time_scenario
    ####################################################################
    # @pytest.mark.cover2
    def test_sync_create_time_scenario(self, caplog: pytest.LogCaptureFixture) -> None:
        """Test meta configuration scenarios.

        Args:
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {}

        scenario_driver(
            scenario_builder=ConfigVerifier.build_sync_create_time_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_send_unreg_receiver_scenario
    ####################################################################
    def test_send_unreg_receiver_scenario(
        self, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            caplog: pytest fixture to capture log output

        Notes:
            1) Test that the _get_target_state method returns
               ThreadState.Unregistered for smart_send when the receiver
               has not yet been started

        """
        args_for_scenario_builder: dict[str, Any] = {}

        scenario_driver(
            scenario_builder=ConfigVerifier.build_send_unreg_receiver_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_join_simple_timeout_scenario
    ####################################################################
    def test_join_simple_timeout_scenario(
        self, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            caplog: pytest fixture to capture log output

        Notes:
            1) Test that the _get_target_state method returns
               ThreadState.Unregistered for smart_send when the receiver
               has not yet been started

        """
        args_for_scenario_builder: dict[str, Any] = {}

        scenario_driver(
            scenario_builder=ConfigVerifier.build_join_simple_timeout_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_wait_simple_deadlock_scenario
    ####################################################################
    def test_wait_simple_deadlock_scenario(
        self, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            caplog: pytest fixture to capture log output

        Notes:
            1) Test that the _get_target_state method returns
               ThreadState.Unregistered for smart_send when the receiver
               has not yet been started

        """
        args_for_scenario_builder: dict[str, Any] = {}

        scenario_driver(
            scenario_builder=ConfigVerifier.build_wait_simple_deadlock_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_sync_unreg_simple_scenario
    ####################################################################
    def test_sync_unreg_simple_scenario(self, caplog: pytest.LogCaptureFixture) -> None:
        """Test meta configuration scenarios.

        Args:
            caplog: pytest fixture to capture log output

        Notes:
            1) Drive the path in _process_sync where _get_target_state
               method returns ThreadState.Unregistered and the local
               sync gives more time

        """
        args_for_scenario_builder: dict[str, Any] = {}

        scenario_driver(
            scenario_builder=ConfigVerifier.build_sync_unreg_simple_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_sync_init_delay_scenario
    ####################################################################
    def test_sync_init_delay_scenario(self, caplog: pytest.LogCaptureFixture) -> None:
        """Test meta configuration scenarios.

        Args:
            caplog: pytest fixture to capture log output

        Notes:
            1) Drive the path in _process_sync where _get_target_state
               method returns ThreadState.Unregistered and the local
               sync gives more time

        """
        args_for_scenario_builder: dict[str, Any] = {}

        scenario_driver(
            scenario_builder=ConfigVerifier.build_sync_init_delay_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_sync_partial_scenario
    ####################################################################
    @pytest.mark.parametrize("sync_0_targets_arg", [2, 4, 6, 8, 10, 12, 14])
    @pytest.mark.parametrize("sync_1_targets_arg", [1, 4, 5, 8, 9, 12, 13])
    @pytest.mark.parametrize("sync_2_targets_arg", [1, 2, 3, 8, 9, 10, 11])
    @pytest.mark.parametrize("sync_3_targets_arg", [1, 2, 3, 4, 5, 6, 7])
    def test_sync_partial_scenario(
        self,
        sync_0_targets_arg: int,
        sync_1_targets_arg: int,
        sync_2_targets_arg: int,
        sync_3_targets_arg: int,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            sync_0_targets_arg: targets combo
            sync_1_targets_arg: targets combo
            sync_2_targets_arg: targets combo
            sync_3_targets_arg: targets combo
            caplog: pytest fixture to capture log output

        Notes:
            1) Sync will do various combinations of targets such that
               a partial or full sync of all targets is done

        """
        args_for_scenario_builder: dict[str, Any] = {
            "sync_0_targets": sync_0_targets_arg,
            "sync_1_targets": sync_1_targets_arg,
            "sync_2_targets": sync_2_targets_arg,
            "sync_3_targets": sync_3_targets_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_sync_partial_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
        )


########################################################################
# TestSmartThreadScenarios class
########################################################################
class TestSmartThreadComboScenarios:
    """Test class for SmartThread scenarios."""

    ####################################################################
    # test_join_timeout_scenario
    ####################################################################
    @pytest.mark.parametrize(
        "timeout_type_arg",
        [TimeoutType.TimeoutNone, TimeoutType.TimeoutFalse, TimeoutType.TimeoutTrue],
    )
    @pytest.mark.parametrize("num_active_no_target_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_no_delay_exit_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_delay_exit_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_delay_unreg_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_no_delay_reg_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_delay_reg_arg", [0, 1, 2])
    # @pytest.mark.skip(reason="not now")
    def test_join_timeout_scenario(
        self,
        timeout_type_arg: TimeoutType,
        num_active_no_target_arg: int,
        num_no_delay_exit_arg: int,
        num_delay_exit_arg: int,
        num_delay_unreg_arg: int,
        num_no_delay_reg_arg: int,
        num_delay_reg_arg: int,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test error cases in the _regref remote array method.

        Args:
            timeout_type_arg: specifies whether the smart_join should
                be coded with timeout and whether the smart_join should
                succeed or fail with a timeout
            num_active_no_target_arg: number of threads that should be
                active and stay active during the join as non-targets
            num_no_delay_exit_arg: number of threads that should be
                active and targeted for join, and then exited
                immediately to allow the join to succeed
            num_delay_exit_arg: number of threads that should be active
                and targeted for join, and then be exited after a short
                delay to allow a TimeoutFalse join to succeed, and a
                long delay to cause a TimeoutTrue join to
                timeout and a TimeoutNone to eventually succeed
            num_delay_unreg_arg: number of threads that should be
                unregistered and targeted for join. These will cause the
                already unregistered log message and will be considered
                as successfully joined in the smart_join completion
                message. They will be eventually started to show that
                they are unaffected by the smart_join once they are
                recognized as already unregistered.
            num_no_delay_reg_arg: number of threads that should be
                registered and targeted for join, and then be
                be immediately started and exited to allow the
                join to succeed
            num_delay_reg_arg: number of threads that should be
                registered and targeted for join, and then be started
                and exited after a short delay to allow a TimeoutFalse
                join to succeed, and a long delay to cause a TimeoutTrue
                join to timeout and a TimeoutNone to eventually succeed
            caplog: pytest fixture to capture log output

        """
        assert num_active_no_target_arg > 0

        delay_arg_counts = (
            num_no_delay_exit_arg
            + num_delay_exit_arg
            + num_delay_unreg_arg
            + num_no_delay_reg_arg
            + num_delay_reg_arg
        )

        if timeout_type_arg == TimeoutType.TimeoutNone:
            if delay_arg_counts == 0:
                return
        else:
            if (num_delay_exit_arg + num_delay_reg_arg) == 0:
                return

        args_for_scenario_builder: dict[str, Any] = {
            "timeout_type": timeout_type_arg,
            "num_active_no_target": num_active_no_target_arg,
            "num_no_delay_exit": num_no_delay_exit_arg,
            "num_delay_exit": num_delay_exit_arg,
            "num_delay_unreg": num_delay_unreg_arg,
            "num_no_delay_reg": num_no_delay_reg_arg,
            "num_delay_reg": num_delay_reg_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_join_timeout_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config[
                (num_active_no_target_arg + delay_arg_counts) % num_commander_configs
            ],
        )

    ####################################################################
    # test_def_del_scenarios
    ####################################################################
    def_del_scenario_arg_list = [
        DefDelScenario.NormalRecv,
        DefDelScenario.NormalWait,
        DefDelScenario.ResurrectionRecv,
        DefDelScenario.ResurrectionWait,
        DefDelScenario.Recv0Recv1,
        DefDelScenario.Recv1Recv0,
        DefDelScenario.Wait0Wait1,
        DefDelScenario.Wait1Wait0,
        DefDelScenario.RecvWait,
        DefDelScenario.WaitRecv,
        DefDelScenario.RecvDel,
        DefDelScenario.RecvAdd,
        DefDelScenario.WaitDel,
        DefDelScenario.WaitAdd,
    ]

    @pytest.mark.parametrize("def_del_scenario_arg", def_del_scenario_arg_list)
    def test_def_del_scenarios(
        self, def_del_scenario_arg: DefDelScenario, caplog: pytest.LogCaptureFixture
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            def_del_scenario_arg: specifies the type of test to do
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            "def_del_scenario": def_del_scenario_arg
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_def_del_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config[
                def_del_scenario_arg.value % num_commander_configs
            ],
        )

    ####################################################################
    # test_rotate_state_scenarios
    ####################################################################
    @pytest.mark.parametrize(
        "timeout_type_arg",
        [TimeoutType.TimeoutNone, TimeoutType.TimeoutFalse, TimeoutType.TimeoutTrue],
    )
    @pytest.mark.parametrize(
        "req0_arg",
        [
            st.ReqType.Smart_send,
            st.ReqType.Smart_recv,
            st.ReqType.Smart_resume,
            st.ReqType.Smart_sync,
            st.ReqType.Smart_wait,
        ],
    )
    @pytest.mark.parametrize(
        "req1_arg",
        [
            st.ReqType.Smart_send,
            st.ReqType.Smart_recv,
            st.ReqType.Smart_resume,
            st.ReqType.Smart_sync,
            st.ReqType.Smart_wait,
        ],
    )
    @pytest.mark.parametrize(
        "req0_when_req1_state_arg",
        [
            (st.ThreadState.Unregistered, 0),
            (st.ThreadState.Registered, 0),
            (st.ThreadState.Unregistered, 1),
            (st.ThreadState.Registered, 1),
            (st.ThreadState.Alive, 0),
            (st.ThreadState.Stopped, 0),
        ],
    )
    @pytest.mark.parametrize("req0_when_req1_lap_arg", [0, 1])
    @pytest.mark.parametrize("req1_lap_arg_arg", [0, 1])
    def test_rotate_state_scenarios(
        self,
        timeout_type_arg: TimeoutType,
        req0_arg: st.ReqType,
        req1_arg: st.ReqType,
        req0_when_req1_state_arg: tuple[st.ThreadState, int],
        req0_when_req1_lap_arg: int,
        req1_lap_arg_arg: int,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            timeout_type_arg: specifies whether the SmartRequest should
                be coded with timeout and whether the SmartRequest
                should succeed or fail with a timeout
            req0_arg: the SmartRequest that req0 will make
            req1_arg: the SmartRequest that req1 will make
            req0_when_req1_state_arg: req0 will issue SmartRequest when
                req1 transitions to this state
            req0_when_req1_lap_arg: req0 will issue SmartRequest when
                req1 transitions during this lap
            req1_lap_arg_arg: lap 0 or 1 when req1 SmartRequest is to be
                issued
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            "timeout_type": timeout_type_arg,
            "req0": req0_arg,
            "req1": req1_arg,
            "req0_when_req1_state": req0_when_req1_state_arg,
            "req0_when_req1_lap": req0_when_req1_lap_arg,
            "req1_lap": req1_lap_arg_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_rotate_state_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=AppConfig.ScriptStyle,
        )

    ####################################################################
    # test_send_msg_timeout_scenarios
    ####################################################################
    @pytest.mark.parametrize(
        "timeout_type_arg",
        [TimeoutType.TimeoutNone, TimeoutType.TimeoutFalse, TimeoutType.TimeoutTrue],
    )
    @pytest.mark.parametrize("num_senders_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_active_targets_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_registered_targets_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_unreg_timeouts_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_exit_timeouts_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_full_q_timeouts_arg", [0, 1, 2])
    def test_send_msg_timeout_scenarios(
        self,
        timeout_type_arg: TimeoutType,
        num_senders_arg: int,
        num_active_targets_arg: int,
        num_registered_targets_arg: int,
        num_unreg_timeouts_arg: int,
        num_exit_timeouts_arg: int,
        num_full_q_timeouts_arg: int,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            timeout_type_arg: specifies whether the smart_send should
                be coded with timeout and whether the smart_send should
                succeed or fail with a timeout
            num_senders_arg: number of threads to send msgs
            num_active_targets_arg: number of active threads to recv
            num_registered_targets_arg: number registered thread to
                recv
            num_unreg_timeouts_arg: number of threads to be receivers
                that cause a timeout by being unregistering
            num_exit_timeouts_arg: number of threads to be receivers
                that cause a timeout by exiting
            num_full_q_timeouts_arg: number of threads to be receivers
                that cause a timeout by having a full msgq
            caplog: pytest fixture to capture log output

        """
        total_arg_counts = (
            num_active_targets_arg
            + num_registered_targets_arg
            + num_unreg_timeouts_arg
            + num_exit_timeouts_arg
            + num_full_q_timeouts_arg
        )
        if timeout_type_arg == TimeoutType.TimeoutNone:
            if total_arg_counts == 0:
                return
        else:
            if (
                num_unreg_timeouts_arg + num_exit_timeouts_arg + num_full_q_timeouts_arg
            ) == 0:
                return

        args_for_scenario_builder: dict[str, Any] = {
            "timeout_type": timeout_type_arg,
            "num_senders": num_senders_arg,
            "num_active_targets": num_active_targets_arg,
            "num_registered_targets": num_registered_targets_arg,
            "num_unreg_timeouts": num_unreg_timeouts_arg,
            "num_exit_timeouts": num_exit_timeouts_arg,
            "num_full_q_timeouts": num_full_q_timeouts_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_send_msg_timeout_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config[total_arg_counts % num_commander_configs],
        )

    ####################################################################
    # test_recv_msg_timeout_scenarios
    ####################################################################
    @pytest.mark.parametrize(
        "timeout_type_arg",
        [TimeoutType.TimeoutNone, TimeoutType.TimeoutFalse, TimeoutType.TimeoutTrue],
    )
    @pytest.mark.parametrize("num_receivers_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_active_no_delay_senders_arg", [0, 1])
    @pytest.mark.parametrize("num_active_delay_senders_arg", [0, 1])
    @pytest.mark.parametrize("num_send_exit_senders_arg", [0, 1])
    @pytest.mark.parametrize("num_nosend_exit_senders_arg", [0, 1])
    @pytest.mark.parametrize("num_unreg_senders_arg", [0, 1])
    @pytest.mark.parametrize("num_reg_senders_arg", [0, 1])
    # @pytest.mark.seltest
    def test_recv_msg_timeout_scenarios(
        self,
        timeout_type_arg: TimeoutType,
        num_receivers_arg: int,
        num_active_no_delay_senders_arg: int,
        num_active_delay_senders_arg: int,
        num_send_exit_senders_arg: int,
        num_nosend_exit_senders_arg: int,
        num_unreg_senders_arg: int,
        num_reg_senders_arg: int,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            timeout_type_arg: specifies whether the recv_msg should
                be coded with timeout and whether the recv_msg should
                succeed or fail with a timeout
            num_receivers_arg: number of threads that will do the
                recv_msg
            num_active_no_delay_senders_arg: number of threads that are
                active and will do the send_msg immediately
            num_active_delay_senders_arg: number of threads that are
                active and will do the send_msg after a delay
            num_send_exit_senders_arg: number of threads that are active
                and will do the send_msg and then exit
            num_nosend_exit_senders_arg: number of threads that are
                active and will not do the send_msg and then exit
            num_unreg_senders_arg: number of threads that are
                unregistered and will be created and started and then
                do the send_msg
            num_reg_senders_arg: number of threads that are registered
                and will be started and then do the send_msg
            caplog: pytest fixture to capture log output

        """
        total_arg_counts = (
            num_active_no_delay_senders_arg
            + num_active_delay_senders_arg
            + num_send_exit_senders_arg
            + num_nosend_exit_senders_arg
            + num_unreg_senders_arg
            + num_reg_senders_arg
        )
        if timeout_type_arg == TimeoutType.TimeoutNone:
            if total_arg_counts == 0:
                return
        else:
            if (
                num_active_delay_senders_arg
                + num_nosend_exit_senders_arg
                + num_unreg_senders_arg
                + num_reg_senders_arg
            ) == 0:
                return

        args_for_scenario_builder: dict[str, Any] = {
            "timeout_type": timeout_type_arg,
            "num_receivers": num_receivers_arg,
            "num_active_no_delay_senders": num_active_no_delay_senders_arg,
            "num_active_delay_senders": num_active_delay_senders_arg,
            "num_send_exit_senders": num_send_exit_senders_arg,
            "num_nosend_exit_senders": num_nosend_exit_senders_arg,
            "num_unreg_senders": num_unreg_senders_arg,
            "num_reg_senders": num_reg_senders_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_recv_msg_timeout_suite,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config[total_arg_counts % num_commander_configs],
        )

    ####################################################################
    # test_resume_timeout_scenarios
    ####################################################################
    @pytest.mark.parametrize(
        "timeout_type_arg",
        [TimeoutType.TimeoutNone, TimeoutType.TimeoutFalse, TimeoutType.TimeoutTrue],
    )
    @pytest.mark.parametrize("num_resumers_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_active_arg", [0, 1])
    @pytest.mark.parametrize("num_registered_before_arg", [0, 1])
    @pytest.mark.parametrize("num_registered_after_arg", [0, 1])
    @pytest.mark.parametrize("num_unreg_no_delay_arg", [0, 1])
    @pytest.mark.parametrize("num_unreg_delay_arg", [0, 1])
    @pytest.mark.parametrize("num_stopped_arg", [0, 1])
    # @pytest.mark.seltest
    def test_resume_timeout_scenarios(
        self,
        timeout_type_arg: TimeoutType,
        num_resumers_arg: int,
        num_active_arg: int,
        num_registered_before_arg: int,
        num_registered_after_arg: int,
        num_unreg_no_delay_arg: int,
        num_unreg_delay_arg: int,
        num_stopped_arg: int,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            timeout_type_arg: specifies whether to issue the resume with
                timeout, and is so whether the resume should timeout
                or, by starting exited threads in time, not timeout
            num_resumers_arg: number of threads doing resumes
            num_active_arg: number threads active, thus no timeout
            num_registered_before_arg: number threads registered, thus
                no timeout, issued before the resume is issued
            num_registered_after_arg: number threads registered, thus no
                timeout, issued after the resume is issued
            num_unreg_no_delay_arg: number threads unregistered before
                the resume is done, and are then created and started
                within the allowed timeout
            num_unreg_delay_arg: number threads unregistered before the
                resume is done, and are then created and started after
                the allowed timeout
            num_stopped_arg: number of threads stopped before
                the resume and cause a timeout
            caplog: pytest fixture to capture log output

        """
        total_arg_counts = (
            num_active_arg
            + num_registered_before_arg
            + num_registered_after_arg
            + num_unreg_no_delay_arg
            + num_unreg_delay_arg
            + num_stopped_arg
        )

        if total_arg_counts == 0:
            return

        if timeout_type_arg == TimeoutType.TimeoutTrue and num_unreg_delay_arg == 0:
            return

        args_for_scenario_builder: dict[str, Any] = {
            "timeout_type": timeout_type_arg,
            "num_resumers": num_resumers_arg,
            "num_active": num_active_arg,
            "num_registered_before": num_registered_before_arg,
            "num_registered_after": num_registered_after_arg,
            "num_unreg_no_delay": num_unreg_no_delay_arg,
            "num_unreg_delay": num_unreg_delay_arg,
            "num_stopped": num_stopped_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_resume_timeout_suite,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config[total_arg_counts % num_commander_configs],
        )

    ####################################################################
    # test_resume_scenarios
    ####################################################################
    @pytest.mark.parametrize("num_resumers_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_start_before_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_unreg_before_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_stop_before_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_unreg_after_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_stop_after_ok_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_stop_after_err_arg", [0, 1, 2])
    # @pytest.mark.seltest
    def test_resume_scenarios(
        self,
        num_resumers_arg: int,
        num_start_before_arg: int,
        num_unreg_before_arg: int,
        num_stop_before_arg: int,
        num_unreg_after_arg: int,
        num_stop_after_ok_arg: int,
        num_stop_after_err_arg: int,
        caplog: pytest.LogCaptureFixture,
        monkeypatch: Any,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_resumers_arg: number of threads doing resumes
            num_start_before_arg: number of target_rtn threads that will
                be started and issue a wait before the resume is done,
                and should succeed
            num_unreg_before_arg: number of target_rtn threads that will
                be registered and then unregistered before the resume,
                and then started after the resume, and should succeed
            num_stop_before_arg: number of target_rtn threads that will
                be started and then stopped (but not joined) before the
                resume, and should result in a not alive error
            num_unreg_after_arg: number of target_rtn threads that will
                be unregistered after the resume, and should cause an
                error
            num_stop_after_ok_arg: number of target_rtn threads that
                will be started after the resume is issued, and will
                stay alive long enough for the resume to set the
                wait_flag, and will then be stopped and joined, and
                should result in success
            num_stop_after_err_arg: number of target_rtn threads that
                will be started after the resume is issued, and will
                quickly be stopped and joined before the resume has a
                chance to see that is is alive to sety the wait_flag,
                and should result in a not alive error
            caplog: pytest fixture to capture log output
            monkeypatch: pytest fixture used to modify code for testing

        """
        ################################################################
        # monkeypatch for SmartThread._get_target_state
        ################################################################
        monkeypatch.setattr(
            st.SmartThread,
            "_get_target_state",
            MockGetTargetState.mock_get_target_state,
        )

        total_arg_counts = (
            num_resumers_arg
            + num_start_before_arg
            + num_unreg_before_arg
            + num_stop_before_arg
            + num_unreg_after_arg
            + num_stop_after_ok_arg
            + num_stop_after_err_arg
        )

        if total_arg_counts - num_resumers_arg == 0:
            return

        args_for_scenario_builder: dict[str, Any] = {
            "num_resumers": num_resumers_arg,
            "num_start_before": num_start_before_arg,
            "num_unreg_before": num_unreg_before_arg,
            "num_stop_before": num_stop_before_arg,
            "num_unreg_after": num_unreg_after_arg,
            "num_stop_after_ok": num_stop_after_ok_arg,
            "num_stop_after_err": num_stop_after_err_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_resume_scenarios,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config[total_arg_counts % num_commander_configs],
        )

    ####################################################################
    # test_srrw_scenario
    ####################################################################
    @pytest.mark.parametrize(
        "req_type_arg",
        [
            st.ReqType.Smart_send,
            st.ReqType.Smart_recv,
            st.ReqType.Smart_resume,
            st.ReqType.Smart_wait,
        ],
    )
    @pytest.mark.parametrize("num_requestors_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_start_before_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_unreg_before_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_stop_before_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_unreg_after_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_stop_after_ok_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_stop_after_err_arg", [0, 1, 2])
    # @pytest.mark.seltest
    def test_srrw_scenario(
        self,
        req_type_arg: st.ReqType,
        num_requestors_arg: int,
        num_start_before_arg: int,
        num_unreg_before_arg: int,
        num_stop_before_arg: int,
        num_unreg_after_arg: int,
        num_stop_after_ok_arg: int,
        num_stop_after_err_arg: int,
        caplog: pytest.LogCaptureFixture,
        monkeypatch: Any,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            req_type_arg: specifies whether to do resume or wait
            num_requestors_arg: number of threads doing resumes or
                waits
            num_start_before_arg: number of target_rtn threads that will
                be started and issue a wait before the resume is done,
                and should succeed
            num_unreg_before_arg: number of target_rtn threads that will
                be registered and then unregistered before the resume,
                and then started after the resume, and should succeed
            num_stop_before_arg: number of target_rtn threads that will
                be started and then stopped (but not joined) before the
                resume, and should result in a not alive error
            num_unreg_after_arg: number of target_rtn threads that will
                be unregistered after the resume, and should cause an
                error
            num_stop_after_ok_arg: number of target_rtn threads that
                will be started after the resume is issued, and will
                stay alive long enough for the resume to set the
                wait_flag, and will then be stopped and joined, and
                should result in success
            num_stop_after_err_arg: number of target_rtn threads that
                will be started after the resume is issued, and will
                quickly be stopped and joined before the resume has a
                chance to see that is is alive to sety the wait_flag,
                and should result in a not alive error
            caplog: pytest fixture to capture log output
            monkeypatch: pytest fixture used to modify code for testing

        """
        ################################################################
        # monkeypatch for SmartThread._get_target_state
        ################################################################
        monkeypatch.setattr(
            st.SmartThread,
            "_get_target_state",
            MockGetTargetState.mock_get_target_state,
        )

        total_arg_counts = (
            num_requestors_arg
            + num_start_before_arg
            + num_unreg_before_arg
            + num_stop_before_arg
            + num_unreg_after_arg
            + num_stop_after_ok_arg
            + num_stop_after_err_arg
        )

        if total_arg_counts - num_requestors_arg == 0:
            return

        args_for_scenario_builder: dict[str, Any] = {
            "req_type": req_type_arg,
            "num_requestors": num_requestors_arg,
            "num_start_before": num_start_before_arg,
            "num_unreg_before": num_unreg_before_arg,
            "num_stop_before": num_stop_before_arg,
            "num_unreg_after": num_unreg_after_arg,
            "num_stop_after_ok": num_stop_after_ok_arg,
            "num_stop_after_err": num_stop_after_err_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_srrw_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config[total_arg_counts % num_commander_configs],
        )

    ####################################################################
    # test_wait_scenario
    ####################################################################
    @pytest.mark.parametrize("num_waiters_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_start_before_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_unreg_before_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_stop_before_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_unreg_after_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_stop_after_ok_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_stop_after_err_arg", [0, 1, 2])
    # @pytest.mark.seltest
    def test_wait_scenario(
        self,
        num_waiters_arg: int,
        num_start_before_arg: int,
        num_unreg_before_arg: int,
        num_stop_before_arg: int,
        num_unreg_after_arg: int,
        num_stop_after_ok_arg: int,
        num_stop_after_err_arg: int,
        caplog: pytest.LogCaptureFixture,
        monkeypatch: Any,
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_waiters_arg: number of threads doing resumes
            num_start_before_arg: number of target_rtn threads that will
                be started and issue a wait before the resume is done,
                and should succeed
            num_unreg_before_arg: number of target_rtn threads that will
                be registered and then unregistered before the resume,
                and then started after the resume, and should succeed
            num_stop_before_arg: number of target_rtn threads that will
                be started and then stopped (but not joined) before the
                resume, and should result in a not alive error
            num_unreg_after_arg: number of target_rtn threads that will
                be unregistered after the resume, and should cause an
                error
            num_stop_after_ok_arg: number of target_rtn threads that
                will be started after the resume is issued, and will
                stay alive long enough for the resume to set the
                wait_flag, and will then be stopped and joined, and
                should result in success
            num_stop_after_err_arg: number of target_rtn threads that
                will be started after the resume is issued, and will
                quickly be stopped and joined before the resume has a
                chance to see that is is alive to sety the wait_flag,
                and should result in a not alive error
            caplog: pytest fixture to capture log output
            monkeypatch: pytest fixture used to modify code for testing

        """
        ################################################################
        # monkeypatch for SmartThread._get_target_state
        ################################################################
        monkeypatch.setattr(
            st.SmartThread,
            "_get_target_state",
            MockGetTargetState.mock_get_target_state,
        )

        total_arg_counts = (
            num_waiters_arg
            + num_start_before_arg
            + num_unreg_before_arg
            + num_stop_before_arg
            + num_unreg_after_arg
            + num_stop_after_ok_arg
            + num_stop_after_err_arg
        )

        if total_arg_counts - num_waiters_arg == 0:
            return

        args_for_scenario_builder: dict[str, Any] = {
            "num_waiters": num_waiters_arg,
            "num_start_before": num_start_before_arg,
            "num_unreg_before": num_unreg_before_arg,
            "num_stop_before": num_stop_before_arg,
            "num_unreg_after": num_unreg_after_arg,
            "num_stop_after_ok": num_stop_after_ok_arg,
            "num_stop_after_err": num_stop_after_err_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_wait_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config[total_arg_counts % num_commander_configs],
        )

    ####################################################################
    # wait_scenario2_actor_arg_list
    ####################################################################
    wait_scenario2_actor_arg_list = [
        Actors.ActiveBeforeActor,
        Actors.ActiveAfterActor,
        Actors.ActionExitActor,
        Actors.ExitActionActor,
        Actors.UnregActor,
        Actors.RegActor,
    ]

    ####################################################################
    # test_wait_scenario2_part_1_1
    ####################################################################
    @pytest.mark.parametrize("actor_1_arg", wait_scenario2_actor_arg_list)
    @pytest.mark.parametrize("actor_2_arg", wait_scenario2_actor_arg_list)
    @pytest.mark.parametrize("actor_3_arg", wait_scenario2_actor_arg_list)
    # @pytest.mark.seltest
    def test_wait_scenario2_part_1_1(
        self,
        actor_1_arg: Actors,
        actor_2_arg: Actors,
        actor_3_arg: Actors,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test wait scenarios.

        Args:
            actor_1_arg: type of actor that will do the first resume
            actor_2_arg: type of actor that will do the second resume
            actor_3_arg: type of actor that will do the third resume
            caplog: pytest fixture to capture log output

        """
        self.build_wait_scenario2(
            num_waiters_arg=1,
            num_actors_arg=1,
            actor_1_arg=actor_1_arg,
            actor_2_arg=actor_2_arg,
            actor_3_arg=actor_3_arg,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_wait_scenario2_part_1_2
    ####################################################################
    @pytest.mark.parametrize("actor_1_arg", wait_scenario2_actor_arg_list)
    @pytest.mark.parametrize("actor_2_arg", wait_scenario2_actor_arg_list)
    @pytest.mark.parametrize("actor_3_arg", wait_scenario2_actor_arg_list)
    # @pytest.mark.seltest
    def test_wait_scenario2_part_1_2(
        self,
        actor_1_arg: Actors,
        actor_2_arg: Actors,
        actor_3_arg: Actors,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test wait scenarios.

        Args:
            actor_1_arg: type of actor that will do the first resume
            actor_2_arg: type of actor that will do the second resume
            actor_3_arg: type of actor that will do the third resume
            caplog: pytest fixture to capture log output

        """
        self.build_wait_scenario2(
            num_waiters_arg=1,
            num_actors_arg=2,
            actor_1_arg=actor_1_arg,
            actor_2_arg=actor_2_arg,
            actor_3_arg=actor_3_arg,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_wait_scenario2_part_1_3
    ####################################################################
    @pytest.mark.parametrize("actor_1_arg", wait_scenario2_actor_arg_list)
    @pytest.mark.parametrize("actor_2_arg", wait_scenario2_actor_arg_list)
    @pytest.mark.parametrize("actor_3_arg", wait_scenario2_actor_arg_list)
    # @pytest.mark.seltest
    def test_wait_scenario2_part_1_3(
        self,
        actor_1_arg: Actors,
        actor_2_arg: Actors,
        actor_3_arg: Actors,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test wait scenarios.

        Args:
            actor_1_arg: type of actor that will do the first resume
            actor_2_arg: type of actor that will do the second resume
            actor_3_arg: type of actor that will do the third resume
            caplog: pytest fixture to capture log output

        """
        self.build_wait_scenario2(
            num_waiters_arg=1,
            num_actors_arg=3,
            actor_1_arg=actor_1_arg,
            actor_2_arg=actor_2_arg,
            actor_3_arg=actor_3_arg,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_wait_scenario2_part_2_1
    ####################################################################
    @pytest.mark.parametrize("actor_1_arg", wait_scenario2_actor_arg_list)
    @pytest.mark.parametrize("actor_2_arg", wait_scenario2_actor_arg_list)
    @pytest.mark.parametrize("actor_3_arg", wait_scenario2_actor_arg_list)
    # @pytest.mark.seltest
    def test_wait_scenario2_part_2_1(
        self,
        actor_1_arg: Actors,
        actor_2_arg: Actors,
        actor_3_arg: Actors,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test wait scenarios.

        Args:
            actor_1_arg: type of actor that will do the first resume
            actor_2_arg: type of actor that will do the second resume
            actor_3_arg: type of actor that will do the third resume
            caplog: pytest fixture to capture log output

        """
        self.build_wait_scenario2(
            num_waiters_arg=2,
            num_actors_arg=1,
            actor_1_arg=actor_1_arg,
            actor_2_arg=actor_2_arg,
            actor_3_arg=actor_3_arg,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_wait_scenario2_part_2_2
    ####################################################################
    @pytest.mark.parametrize("actor_1_arg", wait_scenario2_actor_arg_list)
    @pytest.mark.parametrize("actor_2_arg", wait_scenario2_actor_arg_list)
    @pytest.mark.parametrize("actor_3_arg", wait_scenario2_actor_arg_list)
    # @pytest.mark.seltest
    def test_wait_scenario2_part_2_2(
        self,
        actor_1_arg: Actors,
        actor_2_arg: Actors,
        actor_3_arg: Actors,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test wait scenarios.

        Args:
            actor_1_arg: type of actor that will do the first resume
            actor_2_arg: type of actor that will do the second resume
            actor_3_arg: type of actor that will do the third resume
            caplog: pytest fixture to capture log output

        """
        self.build_wait_scenario2(
            num_waiters_arg=2,
            num_actors_arg=2,
            actor_1_arg=actor_1_arg,
            actor_2_arg=actor_2_arg,
            actor_3_arg=actor_3_arg,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_wait_scenario2_part_2_3
    ####################################################################
    @pytest.mark.parametrize("actor_1_arg", wait_scenario2_actor_arg_list)
    @pytest.mark.parametrize("actor_2_arg", wait_scenario2_actor_arg_list)
    @pytest.mark.parametrize("actor_3_arg", wait_scenario2_actor_arg_list)
    # @pytest.mark.seltest
    def test_wait_scenario2_part_2_3(
        self,
        actor_1_arg: Actors,
        actor_2_arg: Actors,
        actor_3_arg: Actors,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test wait scenarios.

        Args:
            actor_1_arg: type of actor that will do the first resume
            actor_2_arg: type of actor that will do the second resume
            actor_3_arg: type of actor that will do the third resume
            caplog: pytest fixture to capture log output

        """
        self.build_wait_scenario2(
            num_waiters_arg=2,
            num_actors_arg=3,
            actor_1_arg=actor_1_arg,
            actor_2_arg=actor_2_arg,
            actor_3_arg=actor_3_arg,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_wait_scenario2_part_3_1
    ####################################################################
    @pytest.mark.parametrize("actor_1_arg", wait_scenario2_actor_arg_list)
    @pytest.mark.parametrize("actor_2_arg", wait_scenario2_actor_arg_list)
    @pytest.mark.parametrize("actor_3_arg", wait_scenario2_actor_arg_list)
    # @pytest.mark.seltest
    def test_wait_scenario2_part_3_1(
        self,
        actor_1_arg: Actors,
        actor_2_arg: Actors,
        actor_3_arg: Actors,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test wait scenarios.

        Args:
            actor_1_arg: type of actor that will do the first resume
            actor_2_arg: type of actor that will do the second resume
            actor_3_arg: type of actor that will do the third resume
            caplog: pytest fixture to capture log output

        """
        self.build_wait_scenario2(
            num_waiters_arg=3,
            num_actors_arg=1,
            actor_1_arg=actor_1_arg,
            actor_2_arg=actor_2_arg,
            actor_3_arg=actor_3_arg,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_wait_scenario2_part_3_2
    ####################################################################
    @pytest.mark.parametrize("actor_1_arg", wait_scenario2_actor_arg_list)
    @pytest.mark.parametrize("actor_2_arg", wait_scenario2_actor_arg_list)
    @pytest.mark.parametrize("actor_3_arg", wait_scenario2_actor_arg_list)
    # @pytest.mark.seltest
    def test_wait_scenario2_part_3_2(
        self,
        actor_1_arg: Actors,
        actor_2_arg: Actors,
        actor_3_arg: Actors,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test wait scenarios.

        Args:
            actor_1_arg: type of actor that will do the first resume
            actor_2_arg: type of actor that will do the second resume
            actor_3_arg: type of actor that will do the third resume
            caplog: pytest fixture to capture log output

        """
        self.build_wait_scenario2(
            num_waiters_arg=3,
            num_actors_arg=2,
            actor_1_arg=actor_1_arg,
            actor_2_arg=actor_2_arg,
            actor_3_arg=actor_3_arg,
            caplog_to_use=caplog,
        )

    ####################################################################
    # test_wait_scenario2_part_3_3
    ####################################################################
    @pytest.mark.parametrize("actor_1_arg", wait_scenario2_actor_arg_list)
    @pytest.mark.parametrize("actor_2_arg", wait_scenario2_actor_arg_list)
    @pytest.mark.parametrize("actor_3_arg", wait_scenario2_actor_arg_list)
    # @pytest.mark.seltest
    def test_wait_scenario2_part_3_3(
        self,
        actor_1_arg: Actors,
        actor_2_arg: Actors,
        actor_3_arg: Actors,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test wait scenarios.

        Args:
            actor_1_arg: type of actor that will do the first resume
            actor_2_arg: type of actor that will do the second resume
            actor_3_arg: type of actor that will do the third resume
            caplog: pytest fixture to capture log output

        """
        self.build_wait_scenario2(
            num_waiters_arg=3,
            num_actors_arg=3,
            actor_1_arg=actor_1_arg,
            actor_2_arg=actor_2_arg,
            actor_3_arg=actor_3_arg,
            caplog_to_use=caplog,
        )

    ####################################################################
    # build_wait_scenario2
    ####################################################################
    @staticmethod
    def build_wait_scenario2(
        num_waiters_arg: int,
        num_actors_arg: int,
        actor_1_arg: Actors,
        actor_2_arg: Actors,
        actor_3_arg: Actors,
        caplog_to_use: pytest.LogCaptureFixture,
    ) -> None:
        """Test wait scenarios.

        Args:
            num_waiters_arg: number of threads that will do the wait
            num_actors_arg: number of actor threads
            actor_1_arg: type of actor that will do the first resume
            actor_2_arg: type of actor that will do the second resume
            actor_3_arg: type of actor that will do the third resume
            caplog_to_use: pytest fixture to capture log output

        """
        total_arg_counts = num_waiters_arg + num_actors_arg

        args_for_scenario_builder: dict[str, Any] = {
            "num_waiters": num_waiters_arg,
            "num_actors": num_actors_arg,
            "actor_list": [actor_1_arg, actor_2_arg, actor_3_arg],
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_wait_scenario_suite,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog_to_use,
            commander_config=commander_config[total_arg_counts % num_commander_configs],
        )

    ####################################################################
    # test_sync_scenarios
    ####################################################################
    @pytest.mark.parametrize(
        "timeout_type_arg",
        [TimeoutType.TimeoutNone, TimeoutType.TimeoutFalse, TimeoutType.TimeoutTrue],
    )
    @pytest.mark.parametrize("num_syncers_arg", [1, 2, 3, 16])
    @pytest.mark.parametrize("num_stopped_syncers_arg", [0, 1, 2, 3])
    @pytest.mark.parametrize("num_timeout_syncers_arg", [0, 1, 2, 3])
    # @pytest.mark.seltest
    def test_sync_scenarios(
        self,
        timeout_type_arg: TimeoutType,
        num_syncers_arg: int,
        num_stopped_syncers_arg: int,
        num_timeout_syncers_arg: int,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test smart_sync scenarios.

        Args:
            timeout_type_arg: timeout for None, False, or True
            num_syncers_arg: number of threads that will successfully
                sync
            num_stopped_syncers_arg: number of threads that will
                cause a not alive error
            num_timeout_syncers_arg: number of threads that will
                cause a timeout error
            caplog: pytest fixture to capture log output

        """
        total_arg_counts = (
            num_syncers_arg + num_stopped_syncers_arg + num_timeout_syncers_arg
        )

        if total_arg_counts < 2:  # we need at least two to sync
            return

        if timeout_type_arg == TimeoutType.TimeoutTrue and (
            num_timeout_syncers_arg == 0
        ):
            return

        args_for_scenario_builder: dict[str, Any] = {
            "timeout_type": timeout_type_arg,
            "num_syncers": num_syncers_arg,
            "num_stopped_syncers": num_stopped_syncers_arg,
            "num_timeout_syncers": num_timeout_syncers_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_sync_scenario_suite,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config[total_arg_counts % num_commander_configs],
        )

    ####################################################################
    # test_deadlock_scenario
    ####################################################################
    deadlock_arg_list = [
        DeadlockScenario.NormalSendRecv,
        DeadlockScenario.NormalResumeWait,
        DeadlockScenario.NormalSync,
        DeadlockScenario.SendSyncRecv,
        DeadlockScenario.ResumeSyncWait,
        DeadlockScenario.RecvDeadlock,
        DeadlockScenario.WaitDeadlock,
        DeadlockScenario.SyncDeadlock,
    ]

    # @pytest.mark.parametrize("conflict_deadlock_1_arg", deadlock_arg_list)
    # @pytest.mark.parametrize("conflict_deadlock_2_arg", deadlock_arg_list)
    # @pytest.mark.parametrize("conflict_deadlock_3_arg", deadlock_arg_list)
    # @pytest.mark.parametrize("num_cd_actors_arg", [3, 6, 9, 12])
    @pytest.mark.parametrize(
        "conflict_deadlock_1_arg",
        [
            DeadlockScenario.NormalSync,
            DeadlockScenario.SyncDeadlock,
            DeadlockScenario.RecvDeadlock,
        ],
    )
    @pytest.mark.parametrize(
        "conflict_deadlock_2_arg",
        [
            DeadlockScenario.RecvDeadlock,
            DeadlockScenario.WaitDeadlock,
            DeadlockScenario.NormalSendRecv,
        ],
    )
    @pytest.mark.parametrize(
        "conflict_deadlock_3_arg",
        [
            DeadlockScenario.NormalSync,
            DeadlockScenario.WaitDeadlock,
            DeadlockScenario.SyncDeadlock,
        ],
    )
    @pytest.mark.parametrize("num_cd_actors_arg", [3])
    @pytest.mark.seltest
    def test_deadlock_scenario(
        self,
        conflict_deadlock_1_arg: DeadlockScenario,
        conflict_deadlock_2_arg: DeadlockScenario,
        conflict_deadlock_3_arg: DeadlockScenario,
        num_cd_actors_arg: int,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test smart_sync scenarios.

        Args:
            conflict_deadlock_1_arg: first scenario
            conflict_deadlock_2_arg: second scenario
            conflict_deadlock_3_arg: third scenario
            num_cd_actors_arg: number syncers, resumers, and waiters
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            "scenario_list": [
                conflict_deadlock_1_arg,
                conflict_deadlock_2_arg,
                conflict_deadlock_3_arg,
            ],
            "num_cd_actors": num_cd_actors_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_deadlock_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config[
                num_cd_actors_arg % num_commander_configs
            ],
        )

    ####################################################################
    # test_smart_start_scenarios
    ####################################################################
    @pytest.mark.parametrize("num_auto_start_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_manual_start_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_unreg_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_alive_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_stopped_arg", [0, 1, 2])
    # @pytest.mark.seltest
    def test_smart_start_scenarios(
        self,
        num_auto_start_arg: int,
        num_manual_start_arg: int,
        num_unreg_arg: int,
        num_alive_arg: int,
        num_stopped_arg: int,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test smart_sync scenarios.

        Args:
            num_auto_start_arg: number of threads to auto start
            num_manual_start_arg: number of thread to manually start
            num_unreg_arg: number threads to not create for timeout
            num_alive_arg: number threads alive already
            num_stopped_arg: number threads stopped
            caplog: pytest fixture to capture log output

        """
        total_num_targets = (
            num_auto_start_arg
            + num_manual_start_arg
            + num_unreg_arg
            + num_alive_arg
            + num_stopped_arg
        )

        if total_num_targets == 0:
            return

        args_for_scenario_builder: dict[str, Any] = {
            "num_auto_start": num_auto_start_arg,
            "num_manual_start": num_manual_start_arg,
            "num_unreg": num_unreg_arg,
            "num_alive": num_alive_arg,
            "num_stopped": num_stopped_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_smart_start_suite,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config[
                total_num_targets % num_commander_configs
            ],
        )

    ####################################################################
    # test_smart_recv_sender_count_scenario
    ####################################################################
    @pytest.mark.parametrize(
        "request_type_arg", [st.ReqType.Smart_recv, st.ReqType.Smart_wait]
    )
    @pytest.mark.parametrize("pre_count_arg", [0, 1, 2, 3, 4, 5])
    @pytest.mark.parametrize("num_count_0_arg", [0, 1, 2, 3, 4, 5])
    @pytest.mark.parametrize("num_count_1_arg", [0, 1, 2, 3, 4, 5])
    # @pytest.mark.seltest
    def test_sender_resumer_count_scenario(
        self,
        request_type_arg: st.ReqType,
        pre_count_arg: int,
        num_count_0_arg: int,
        num_count_1_arg: int,
        caplog: pytest.LogCaptureFixture,
    ) -> None:
        """Test smart_sync scenarios.

        Args:
            request_type_arg: the request to do
            pre_count_arg: the sender or resumer count pre 1st batch
            num_count_0_arg: the sender or resumer count for 1st batch
            num_count_1_arg: the sender or resumer count for 2nd batch
            caplog: pytest fixture to capture log output

        """
        total_counts = num_count_0_arg + num_count_1_arg
        args_for_scenario_builder: dict[str, Any] = {
            "request_type": request_type_arg,
            "pre_count": pre_count_arg,
            "num_count_0": num_count_0_arg,
            "num_count_1": num_count_1_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_sender_resumer_count_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config[total_counts % num_commander_configs],
        )

    # ##################################################################
    # # test_smart_thread_scenarios
    # ##################################################################
    # @pytest.mark.parametrize("random_seed_arg", [1, 2, 3])
    # def test_smart_thread_random_scenarios(
    #         self,
    #         random_seed_arg: int,
    #         caplog: pytest.LogCaptureFixture
    # ) -> None:
    #     """Test meta configuration scenarios.
    #
    #     Args:
    #         caplog: pytest fixture to capture log output
    #
    #     """
    #
    #     random.seed(random_seed_arg)
    #     num_threads = random.randint(2, 8)
    #
    #     f1_names = list(config_ver.f1_thread_names.keys())
    #
    #     f1_names_to_use = random.sample(f1_names, num_threads)
    #
    #     names = ['alpha'] + f1_names_to_use
