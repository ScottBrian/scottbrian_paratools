"""test_smart_thread.py module."""

########################################################################
# Standard Library
########################################################################
from abc import ABC, abstractmethod
from collections import deque, defaultdict
from collections.abc import Iterable
from contextlib import contextmanager
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum, auto
from itertools import combinations, chain, product

import logging

from more_itertools import roundrobin
import random
import re
from sys import _getframe
import time
from typing import (Any, Callable, cast, ClassVar, NamedTuple, Type, TypeAlias,
                    TYPE_CHECKING, Optional, Union)
import threading

########################################################################
# Third Party
########################################################################
import pytest
from scottbrian_utils.msgs import Msgs
from scottbrian_utils.log_verifier import LogVer
from scottbrian_utils.diag_msg import (get_formatted_call_sequence,
                                       get_caller_info)
from scottbrian_locking import se_lock as sel

########################################################################
# Local
########################################################################
import scottbrian_paratools.smart_thread as st

logger = logging.getLogger(__name__)
logger.debug('about to start the tests')


########################################################################
# Type alias
########################################################################
IntOrFloat: TypeAlias = Union[int, float]

StrOrList: TypeAlias = Union[str, list[str]]
StrOrSet: TypeAlias = Union[str, set[str]]

ThreadStatePair: TypeAlias = tuple[st.ThreadState, st.ThreadState]

SetStateKey: TypeAlias = tuple[str, str, st.ThreadState, st.ThreadState]

AddRegKey: TypeAlias = tuple[str, str]

AddPaKey: TypeAlias = tuple[str, st.PairKey]

AddStatusBlockKey: TypeAlias = tuple[str, st.PairKey, str]

RequestKey: TypeAlias = tuple[str, str]

SubProcessKey: TypeAlias = tuple[str, str, str, str, str]

RemRegKey: TypeAlias = tuple[str, str]

AckKey: TypeAlias = tuple[str, str]

ConfirmStopKey: TypeAlias = tuple[str, str]

AlreadyUnregKey: TypeAlias = tuple[str, str]

UnregJoinSuccessKey: TypeAlias = tuple[str, str]

JoinProgKey: TypeAlias = tuple[int, int]

InitCompKey: TypeAlias = tuple[str,
                               st.ThreadCreate,
                               st.ThreadState,
                               "AutoStartDecision"]

CallRefKey: TypeAlias = str

PendEvents: TypeAlias = dict["PE", Any]

CheckPendArg: TypeAlias = tuple[str, st.PairKey]


class DefDelReasons(NamedTuple):
    pending_request: bool = False
    pending_msg: bool = False
    pending_wait: bool = False
    pending_sync: bool = False


RemSbKey: TypeAlias = tuple[str, tuple[str, str], DefDelReasons]

RemPaeKey: TypeAlias = tuple[str, tuple[str, str]]

########################################################################
# text units
########################################################################
list_of_extra_texts = ('(auto_start requested but not needed since '
                               'thread is already alive'
                               '|auto_start requested and will now be done'
                               '|auto_start was not requested)')


class AutoStartDecision(Enum):
    auto_start_obviated = auto()
    auto_start_yes = auto()
    auto_start_no = auto()


init_complete_text_units: dict[AutoStartDecision, str] = {
    AutoStartDecision.auto_start_obviated: 'auto_start obviated',
    AutoStartDecision.auto_start_yes: 'auto_start will proceed',
    AutoStartDecision.auto_start_no: 'auto_start not requested'
}


########################################################################
# get_ptime
########################################################################
def get_ptime() -> str:
    """Returns a printable UTC time stamp.

    Returns:
        a timestamp as a string
    """
    now_time = datetime.utcnow()
    print_time = now_time.strftime("%H:%M:%S.%f")

    return print_time


########################################################################
# SendRecvMsgs
########################################################################
# SrMsgKey: TypeAlias = tuple[str, str]
class SrMsgKey(NamedTuple):
    sender: str
    receiver: str


BaseMsgKey: TypeAlias = tuple[int, SrMsgKey, str]
BaseMsgs: TypeAlias = dict[BaseMsgKey, list[Any]]


@dataclass
class SendRecvPacket:
    msgs_to_send: list[Any]


class SendType(Enum):
    ToRemotes = auto()
    Broadcast = auto()
    SRMsgs = auto()


class RecvType(Enum):
    PartialSenders = auto()
    MatchSenders = auto()
    ExtraSenders = auto()
    UnmatchSenders = auto()


class MsgType(Enum):
    Text = auto()
    # Int = auto()
    # Object = auto()


class MsgCollectionType(Enum):
    Simple = auto()
    List = auto()
    # Dict = auto()


class SendRecvMsgs:
    def __init__(self,
                 sender_names: Iterable,
                 receiver_names: Iterable,
                 num_msgs: int,
                 send_type: SendType = SendType.ToRemotes) -> None:
        self.sender_names = get_set(sender_names)
        self.receiver_names = get_set(receiver_names)
        self.num_msgs = num_msgs
        self.send_type = send_type
        self.broadcast_msgs: list[dict[str, Any]] = []
        self.directed_msgs: list[dict[str, dict[str, Any]]] = []
        self.exp_received_msgs: dict[
            str, dict[str, list[Any]]] = defaultdict(lambda: defaultdict(list))
        self.msg_lock = threading.Lock()
        self.build_msgs()

    def build_msgs(self):
        for msg_idx in range(self.num_msgs):
            self.broadcast_msgs.append({})
            for sender_name in self.sender_names:
                self.broadcast_msgs[msg_idx][
                    sender_name] = (f'{sender_name} broadcast message'
                                    f' {msg_idx}')

                self.directed_msgs.append(
                    defaultdict(lambda: defaultdict(str)))
                for receiver_name in self.receiver_names:
                    self.directed_msgs[msg_idx][sender_name][
                        receiver_name] = (f'{sender_name} message {msg_idx} '
                                          f'to {receiver_name}')

    def get_broadcast_msg(self,
                          sender_name: str,
                          receiver_names: Iterable,
                          msg_idx: int) -> str:
        with self.msg_lock:
            msg = self.broadcast_msgs[msg_idx][sender_name]
            for receiver_name in receiver_names:
                self.add_exp_msg_received(receiver_name=receiver_name,
                                          sender_name=sender_name,
                                          msg=msg)
        return msg

    def get_send_msgs(self,
                      sender_name: str,
                      receiver_names: Iterable,
                      msg_idx: int) -> st.SendMsgs:
        send_msgs: st.SendMsgs = st.SendMsgs(send_msgs={})
        for receiver_name in receiver_names:
            msg = self.directed_msgs[msg_idx][sender_name][receiver_name]
            send_msgs.send_msgs[receiver_name] = msg
            self.add_exp_msg_received(receiver_name=receiver_name,
                                      sender_name=sender_name,
                                      msg=msg)
        return send_msgs

    def add_exp_msg_received(self,
                             receiver_name: str,
                             sender_name: str,
                             msg: Any):
        self.exp_received_msgs[receiver_name][sender_name].append(msg)


########################################################################
# WaitType
########################################################################
class WaitType(Enum):
    PartialResumers = auto()
    MatchResumers = auto()
    ExtraResumers = auto()
    UnmatchResumers = auto()


########################################################################
# VerifyData items
########################################################################
class VerifyType(Enum):
    VerifyStructures = auto()
    VerifyAlive = auto()
    VerifyNotAlive = auto()
    VerifyState = auto()
    VerifyInRegistry = auto()
    VerifyNotInRegistry = auto()
    VerifyAliveState = auto()
    VerifyRegisteredState = auto()
    VerifyStoppedState = auto()
    VerifyPaired = auto()
    VerifyNotPaired = auto()
    VerifyHalfPaired = auto()
    VerifyPendingFlags = auto()


@dataclass
class PendingFlags:
    pending_request: bool = False
    pending_msgs: int = 0
    pending_wait: bool = False
    pending_sync: bool = False


@dataclass
class VerifyData:
    cmd_runner: str
    verify_type: VerifyType
    names_to_check: set[str]
    aux_names: set[str]
    state_to_check: st.ThreadState
    exp_pending_flags: PendingFlags
    obtain_reg_lock: bool


# @dataclass
# class VerifyActiveData:
#     cmd_runner: str
#     exp_active_names: set[str]


@dataclass
class VerifyCountsData:
    num_registered: int
    num_active: int
    num_stopped: int
    obtain_reg_lock: bool = True

# @dataclass
# class VerifyStateData:
#     cmd_runner: str
#     check_state_names: set[str]
#     expected_state: st.ThreadState


VerifyDataItems: TypeAlias = Union[
    VerifyData,
    VerifyCountsData]


@dataclass
class RegistrySnapshotItem:
    is_alive: bool
    state: st.ThreadState


@dataclass
class StatusBlockSnapshotItem:
    pending_request: bool = False
    pending_msg_count: int = 0
    pending_wait: bool = False
    pending_sync: bool = False


RegistryItems: TypeAlias = dict[str, RegistrySnapshotItem]
StatusBlockItems: TypeAlias = dict[str, StatusBlockSnapshotItem]
PairArrayItems: TypeAlias = dict[st.PairKey, StatusBlockItems]


@dataclass
class SnapShotDataItem:
    registry_items: RegistryItems
    pair_array_items: PairArrayItems
    verify_data: VerifyDataItems


@contextmanager
def conditional_registry_lock(*args, **kwds) -> None:
    """Obtain the connection_block lock.

    This method is called to conditionally obtain a lock using a with
    statement.

    Args:
        args: the lock to obtain
        kwds: whether to obtain the lock

    """
    # if request needs the lock
    if kwds['obtain_tf']:
        kwds['lock'].obtain_excl()
    try:
        yield
    finally:
        # release the lock if it was obtained
        if kwds['obtain_tf']:
            kwds['lock'].release()


########################################################################
# Log level arg list
########################################################################
log_level_arg_list = [logging.DEBUG,
                      logging.INFO,
                      logging.WARNING,
                      logging.ERROR,
                      logging.CRITICAL,
                      logging.NOTSET]


########################################################################
# CommanderConfig
########################################################################
class AppConfig(Enum):
    """Commander configuration choices."""
    ScriptStyle = auto()
    CurrentThreadApp = auto()
    RemoteThreadApp = auto()
    RemoteSmartThreadApp = auto()
    RemoteSmartThreadApp2 = auto()


########################################################################
# ResumeStyles
########################################################################
class Actors(Enum):
    """Resume scenario cases."""
    ActiveBeforeActor = auto()
    ActiveAfterActor = auto()
    ActionExitActor = auto()
    ExitActionActor = auto()
    UnregActor = auto()
    RegActor = auto()


########################################################################
# ConflictDeadlockScenario
########################################################################
class ConflictDeadlockScenario(Enum):
    """Deadlock scenario cases to test."""
    NormalSync = auto()
    NormalResumeWait = auto()
    ResumeSyncSyncWait = auto()
    SyncConflict = auto()
    WaitDeadlock = auto()


########################################################################
# DefDelScenario
########################################################################
class DefDelScenario(Enum):
    """Deferred delete scenario cases."""
    NormalRecv = auto()
    NormalWait = auto()
    ResurrectionRecv = auto()
    ResurrectionWait = auto()
    Recv0Recv1 = auto()
    Recv1Recv0 = auto()
    Wait0Wait1 = auto()
    Wait1Wait0 = auto()
    RecvWait = auto()
    WaitRecv = auto()
    RecvDel = auto()
    RecvAdd = auto()
    WaitDel = auto()
    WaitAdd = auto()


########################################################################
# RequestConfirmParms
########################################################################
@dataclass()
class RequestConfirmParms:
    """Request confirm parms."""
    request_name: str
    serial_number: int


########################################################################
# Test settings for conflict_deadlock_scenarios
########################################################################
conflict_deadlock_arg_list = [
    ConflictDeadlockScenario.NormalSync,
    ConflictDeadlockScenario.NormalResumeWait,
    ConflictDeadlockScenario.ResumeSyncSyncWait,
    ConflictDeadlockScenario.SyncConflict,
    ConflictDeadlockScenario.WaitDeadlock,
]
# conflict_deadlock_arg_list = [ConflictDeadlockScenario.WaitDeadlock]

conflict_deadlock_arg_list2 = [
    ConflictDeadlockScenario.NormalSync,
    ConflictDeadlockScenario.NormalResumeWait,
    ConflictDeadlockScenario.ResumeSyncSyncWait,
    ConflictDeadlockScenario.SyncConflict,
    ConflictDeadlockScenario.WaitDeadlock,
]
# conflict_deadlock_arg_list2 = [ConflictDeadlockScenario.NormalResumeWait]

conflict_deadlock_arg_list3 = [
    ConflictDeadlockScenario.NormalSync,
    ConflictDeadlockScenario.NormalResumeWait,
    ConflictDeadlockScenario.ResumeSyncSyncWait,
    ConflictDeadlockScenario.SyncConflict,
    ConflictDeadlockScenario.WaitDeadlock,
]
# conflict_deadlock_arg_list3 = [ConflictDeadlockScenario.SyncConflict]

num_cd_actors_arg_list = [3, 4, 5, 6, 7, 8, 9]

# num_cd_actors_arg_list = [6]


########################################################################
# Test settings
########################################################################
commander_config_arg_list = [AppConfig.ScriptStyle,
                             AppConfig.CurrentThreadApp,
                             AppConfig.RemoteThreadApp,
                             AppConfig.RemoteSmartThreadApp,
                             AppConfig.RemoteSmartThreadApp2]

# commander_config_arg_list = [AppConfig.ScriptStyle]


########################################################################
# timeout_type used to specify whether to use timeout on various cmds
########################################################################
class TimeoutType(Enum):
    """Timeout type for test."""
    TimeoutNone = auto()
    TimeoutFalse = auto()
    TimeoutTrue = auto()


########################################################################
# Test settings
########################################################################
timeout_type_arg_list = [TimeoutType.TimeoutNone,
                         TimeoutType.TimeoutFalse,
                         TimeoutType.TimeoutTrue]
# timeout_type_arg_list = [TimeoutType.TimeoutTrue]

########################################################################
# Test settings for test_def_del_scenarios
########################################################################
def_del_scenario_arg_list = [
    DefDelScenario.NormalRecv,
    DefDelScenario.NormalWait,
    DefDelScenario.ResurrectionRecv,
    DefDelScenario.ResurrectionWait,
    DefDelScenario.Recv0Recv1,
    DefDelScenario.Recv1Recv0,
    DefDelScenario.Wait0Wait1,
    DefDelScenario.Wait1Wait0,
    DefDelScenario.RecvWait,
    DefDelScenario.WaitRecv,
    DefDelScenario.RecvDel,
    DefDelScenario.RecvAdd,
    DefDelScenario.WaitDel,
    DefDelScenario.WaitAdd
]
# def_del_scenario_arg_list = [DefDelScenario.Recv0Recv1]


########################################################################
# Test settings for test_smart_start_scenarios
########################################################################
num_auto_start_arg_list = [0, 1, 2]
num_manual_start_arg_list = [0, 1, 2]
num_unreg_arg_list = [0, 1, 2]
num_alive_arg_list = [0, 1, 2]
num_stopped_arg_list = [0, 1, 2]


########################################################################
# Test settings for test_config_build_scenarios
########################################################################
num_registered_1_arg_list = [0, 1, 2]
# num_registered_1_arg_list = [0, 0, 0]

num_active_1_arg_list = [1, 2, 3]
# num_active_1_arg_list = [2]

num_stopped_1_arg_list = [0, 1, 2]
# num_stopped_1_arg_list = [2]

num_registered_2_arg_list = [0, 1, 2]
# num_registered_2_arg_list = [2]

num_active_2_arg_list = [1, 2, 3]
# num_active_2_arg_list = [1]

num_stopped_2_arg_list = [0, 1, 2]
# num_stopped_2_arg_list = [0]


########################################################################
# Test settings for test_recv_msg_scenarios
########################################################################
recv_msg_state_arg_list = [
    (st.ThreadState.Unregistered, 0),
    (st.ThreadState.Unregistered, 1),
    (st.ThreadState.Registered, 0),
    (st.ThreadState.Registered, 1),
    (st.ThreadState.Alive, 0),
    (st.ThreadState.Stopped, 0)]

recv_msg_lap_arg_list = [0, 1]

send_msg_lap_arg_list = [0, 1]

send_resume_arg_list = ['send', 'resume', 'sync', 'sync_send']


########################################################################
# Test settings for test_wait_scenarios2
########################################################################
wait_state_arg_list = [
    st.ThreadState.Unregistered,
    st.ThreadState.Registered,
    st.ThreadState.Alive,
    st.ThreadState.Stopped]

wait_lap_arg_list = [0, 1]

resume_lap_arg_list = [0, 1]


########################################################################
# Test settings for test_rotate_state_scenarios
########################################################################
class SmartRequestType(Enum):
    """SmartThread requests."""
    Start = auto()
    Unreg = auto()
    Join = auto()
    SendMsg = auto()
    RecvMsg = auto()
    Resume = auto()
    Sync = auto()
    Wait = auto()


req0_arg_list = [
    SmartRequestType.SendMsg,
    SmartRequestType.RecvMsg,
    SmartRequestType.Resume,
    SmartRequestType.Sync,
    SmartRequestType.Wait]

# req0_arg_list = [SmartRequestType.Sync]

req1_arg_list = [
    SmartRequestType.SendMsg,
    SmartRequestType.RecvMsg,
    SmartRequestType.Resume,
    SmartRequestType.Sync,
    SmartRequestType.Wait]

# req1_arg_list = [SmartRequestType.RecvMsg]

req0_when_req1_state_arg_list = [
    (st.ThreadState.Unregistered, 0),
    (st.ThreadState.Registered, 0),
    (st.ThreadState.Unregistered, 1),
    (st.ThreadState.Registered, 1),
    (st.ThreadState.Alive, 0),
    (st.ThreadState.Stopped, 0)]

# req0_when_req1_state_arg_list = [(st.ThreadState.Alive, 0)]

req0_when_req1_lap_arg_list = [0, 1]

req1_lap_arg_list = [0, 1]
########################################################################
# Test settings for test_recv_timeout_scenarios
########################################################################
num_receivers_arg_list = [1]
# num_receivers_arg_list = [2]

num_active_no_delay_senders_arg_list = [0, 1]
# num_active_no_delay_senders_arg_list = [1]  # .001

num_active_delay_senders_arg_list = [0, 1]
# num_active_delay_senders_arg_list = [1]  # .65  0.0005

num_send_exit_senders_arg_list = [0, 1]
# num_send_exit_senders_arg_list = [2]  # .65  0.0007

num_nosend_exit_senders_arg_list = [0, 1]
# num_nosend_exit_senders_arg_list = [2]  # 1.05  0.50

num_unreg_senders_arg_list = [0, 1]
# num_unreg_senders_arg_list = [2]  # .75 0.15

num_reg_senders_arg_list = [0, 1]
# num_reg_senders_arg_list = [2]  # .75 .06

########################################################################
# Test settings for test_send_msg_timeout_scenarios
########################################################################
num_senders_arg_list = [1, 2, 3]
# num_senders_arg_list = [2]

num_active_targets_arg_list = [0, 1, 2]
# num_active_targets_arg_list = [3]  # 0.12

num_registered_targets_arg_list = [0, 1, 2]
# num_registered_targets_arg_list = [3]  # 0.11

num_unreg_timeouts_arg_list = [0, 1, 2]
# num_unreg_timeouts_arg_list = [3]  # 0.15

num_exit_timeouts_arg_list = [0, 1, 2]
# num_exit_timeouts_arg_list = [1]  # 0.11

num_full_q_timeouts_arg_list = [0, 1, 2]
# num_full_q_timeouts_arg_list = [3]  # 0.11


# ########################################################################
# # Test settings for test_resume_timeout_scenarios
# ########################################################################
# # num_resumers_arg_list = [1, 2, 3]
# num_active_arg_list = [0, 1, 2]
# num_registered_before_arg_list = [0, 1, 2]
# num_registered_after_arg_list = [0, 1, 2]
# num_unreg_no_delay_arg_list = [0, 1, 2]
# num_unreg_delay_arg_list = [0, 1, 2]
# num_stopped_no_delay_arg_list = [0, 1, 2]
# num_stopped_delay_arg_list = [0, 1, 2]


########################################################################
# Test settings for test_wait_timeout_scenarios
########################################################################
num_waiters_arg_list = [1, 2, 3]
# num_waiters_arg_list = [1]

num_actors_arg_list = [1, 2, 3]
# num_actors_arg_list = [1, 2]

actor_1_arg_list = [Actors.ActiveBeforeActor,
                    Actors.ActiveAfterActor,
                    Actors.ActionExitActor,
                    Actors.ExitActionActor,
                    Actors.UnregActor,
                    Actors.RegActor]
# actor_1_arg_list = [Actors.ActiveAfterActor, Actors.ActionExitActor]

num_actor_1_arg_list = [1, 2, 3]

actor_2_arg_list = [Actors.ActiveBeforeActor,
                    Actors.ActiveAfterActor,
                    Actors.ActionExitActor,
                    Actors.ExitActionActor,
                    Actors.UnregActor,
                    Actors.RegActor]
# actor_2_arg_list = [Actors.ExitActionActor, Actors.UnregActor]

num_actor_2_arg_list = [1, 2, 3]

actor_3_arg_list = [Actors.ActiveBeforeActor,
                    Actors.ActiveAfterActor,
                    Actors.ActionExitActor,
                    Actors.ExitActionActor,
                    Actors.UnregActor,
                    Actors.RegActor]
# actor_3_arg_list = [Actors.ExitActionActor, Actors.UnregActor]
num_actor_3_arg_list = [1, 2, 3]


########################################################################
# Test settings for test_sync_scenarios
########################################################################
num_syncers_arg_list = [1, 2, 3, 16]
num_stopped_syncers_arg_list = [0, 1, 2, 3]
num_timeout_syncers_arg_list = [0, 1, 2, 3]


########################################################################
# SmartThread test exceptions
########################################################################
class ErrorTstSmartThread(Exception):
    """Base class for exception in this module."""
    pass


class IncorrectActionSpecified(ErrorTstSmartThread):
    """IncorrectActionSpecified exception class."""
    pass


class IncorrectDataDetected(ErrorTstSmartThread):
    """IncorrectDataDetected exception class."""
    pass


class UnexpectedEvent(ErrorTstSmartThread):
    """Unexpected action encountered exception class."""
    pass


class UnrecognizedEvent(ErrorTstSmartThread):
    """Unrecognized event ws detected."""
    pass


class UnrecognizedCmd(ErrorTstSmartThread):
    """UnrecognizedCmd exception class."""
    pass


class InvalidConfigurationDetected(ErrorTstSmartThread):
    """UnrecognizedCmd exception class."""
    pass


class InvalidInputDetected(ErrorTstSmartThread):
    """The input is not correct."""
    pass


class CmdTimedOut(ErrorTstSmartThread):
    """The cmd took to long."""
    pass


class CmdFailed(ErrorTstSmartThread):
    """The cmd failed."""
    pass


class FailedToFindLogMsg(ErrorTstSmartThread):
    """An expected log message was not found."""
    pass


class FailedLockVerify(ErrorTstSmartThread):
    """An expected lock position was not found."""
    pass


class FailedDefDelVerify(ErrorTstSmartThread):
    """An expected condition was incorrect."""
    pass


class RemainingPendingEvents(ErrorTstSmartThread):
    """There are remaining pending events."""
    pass


########################################################################
# get_set
########################################################################
def get_set(item: Optional[Iterable] = None) -> set[Any]:
    """Return a set given the iterable input.

    Args:
        item: iterable to be returned as a set

    Returns:
        A set created from the input iterable item. Note that the set
        will be empty if None was passed in.
    """
    return set({item} if isinstance(item, str) else item or '')


########################################################################
# ConfigCmd
########################################################################
class ConfigCmd(ABC):
    """Configuration command base class."""
    def __init__(self,
                 cmd_runners: Iterable):
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command

        """
        # The serial number, line_num, and config_ver are filled in
        # by the ConfigVerifier add_cmd method just before queueing
        # the command.
        self.serial_num: int = 0
        self.line_num: int = 0
        self.config_ver: Optional["ConfigVerifier"] = None

        # specified_args are set in each subclass
        self.specified_args: dict[str, Any] = {}

        self.cmd_runners = get_set(cmd_runners)

        self.arg_list: list[str] = ['cmd_runners',
                                    'serial_num',
                                    'line_num']

    def __repr__(self):
        """Method to provide repr."""
        if TYPE_CHECKING:
            __class__: Type[ConfigVerifier]  # noqa: F842
        classname = self.__class__.__name__
        parms = (f'serial={self.serial_num}, '
                 f'line={self.line_num}')
        comma = ', '
        for key, item in self.specified_args.items():
            if item:  # if not None
                if key in self.arg_list:
                    if type(item) is str:
                        parms += comma + f"{key}='{item}'"
                    else:
                        parms += comma + f"{key}={item}"
                    # comma = ', '  # after first item, now need comma
            if key == 'f1_create_items':
                create_names: list[str] = []
                for create_item in item:
                    create_names.append(create_item.name)
                parms += comma + f"{create_names=}"

        return f'{classname}({parms})'

    @abstractmethod
    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
           cmd_runner: name of thread running the command
        """
        pass


########################################################################
# ConfirmResponse
########################################################################
class ConfirmResponse(ConfigCmd):
    """Confirm that an earlier command has completed."""
    def __init__(self,
                 cmd_runners: Iterable,
                 confirm_cmd: str,
                 confirm_serial_num: int,
                 confirmers: Iterable
                 ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            confirm_cmd: command to be confirmed
            confirm_serial_num: serial number of command to confirm
            confirmers: cmd runners of the cmd to be confirmed
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.confirm_cmd = confirm_cmd
        self.confirm_serial_num = confirm_serial_num

        self.confirmers = get_set(confirmers)

        self.arg_list += ['confirm_cmd',
                          'confirm_serial_num',
                          'confirmers']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
           cmd_runner: name of thread running the command
        """
        start_time = time.time()
        work_confirmers = self.confirmers.copy()
        if not work_confirmers:
            raise InvalidInputDetected('ConfirmResponse detected an empty set '
                                       'of confirmers')
        while work_confirmers:
            for name in work_confirmers:
                # If the serial number is in the completed_cmds for
                # this name then the command was completed. Remove the
                # target name and break to start looking again with one
                # less target until no targets remain.
                if (self.confirm_serial_num in
                        self.config_ver.completed_cmds[name]):
                    work_confirmers.remove(name)
                    break
            time.sleep(0.2)
            timeout_value = 60
            if time.time() - start_time > timeout_value:
                self.config_ver.abort_all_f1_threads()
                raise CmdTimedOut('ConfirmResponse serial_num '
                                  f'{self.serial_num} took longer than '
                                  f'{timeout_value} seconds waiting '
                                  f'for {work_confirmers} to complete '
                                  f'cmd {self.confirm_cmd} with '
                                  f'serial_num {self.confirm_serial_num}.')


########################################################################
# ConfirmResponseNot
########################################################################
class ConfirmResponseNot(ConfirmResponse):
    """Confirm that an earlier command has not yet completed."""
    def __init__(self,
                 cmd_runners: Iterable,
                 confirm_cmd: str,
                 confirm_serial_num: int,
                 confirmers: Iterable
                 ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            confirm_cmd: command to be confirmed as not yet completed
            confirm_serial_num: serial number of command to not confirm
            confirmers: cmd runners of the cmd to be not confirmed
        """
        super().__init__(cmd_runners=cmd_runners,
                         confirm_cmd=confirm_cmd,
                         confirm_serial_num=confirm_serial_num,
                         confirmers=confirmers)
        self.specified_args = locals()  # used for __repr__

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
           cmd_runner: name of thread running the command
        """
        for name in self.confirmers:
            # If the serial number is in the completed_cmds for
            # this name then the command was completed. Remove the
            # target name and break to start looking again with one
            # less target until no targets remain.
            if (self.confirm_serial_num in
                    self.config_ver.completed_cmds[name]):
                raise CmdFailed('ConfirmResponseNot found that '
                                f'{name} completed {self.confirm_cmd=} '
                                f'with {self.serial_num=}.')


########################################################################
# CreateF1AutoStart
########################################################################
class CreateF1AutoStart(ConfigCmd):
    """Create an f1 thread with autostart."""
    def __init__(self,
                 cmd_runners: Iterable,
                 f1_create_items: list["F1CreateItem"],
                 ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            f1_create_items: list of names and attributes to be used
                when creating the threads
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.f1_create_items = f1_create_items

        self.args_list = ['f1_create_items']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
           cmd_runner: name of thread running the command
        """
        for f1_item in self.f1_create_items:
            self.config_ver.create_f1_thread(
                cmd_runner=cmd_runner,
                name=f1_item.name,
                target=f1_item.target_rtn,
                app_config=f1_item.app_config,
                auto_start=True)


########################################################################
# CreateF1NoStart
########################################################################
class CreateF1NoStart(CreateF1AutoStart):
    """Create an f1 thread with no autostart."""
    def __init__(self,
                 cmd_runners: Iterable,
                 f1_create_items: list["F1CreateItem"],
                 ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            f1_create_items: list of names and attributes to be used
                when creating the threads
        """
        super().__init__(cmd_runners=cmd_runners,
                         f1_create_items=f1_create_items)
        self.specified_args = locals()  # used for __repr__

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        for f1_item in self.f1_create_items:
            self.config_ver.create_f1_thread(
                cmd_runner=cmd_runner,
                name=f1_item.name,
                target=f1_item.target_rtn,
                app_config=f1_item.app_config,
                auto_start=False)


########################################################################
# ExitThread
########################################################################
class ExitThread(ConfigCmd):
    """Cause thread to exit its command loop."""
    def __init__(self,
                 cmd_runners: Iterable,
                 stopped_by: str) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            stopped_by: name of thread that did the stop
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.stopped_by = stopped_by

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.exit_thread(
            cmd_runner=cmd_runner,
            stopped_by=self.stopped_by)


########################################################################
# Join
########################################################################
class Join(ConfigCmd):
    """Do smart_join."""
    def __init__(self,
                 cmd_runners: Iterable,
                 join_names: Iterable,
                 unreg_names: Optional[Iterable] = None,
                 log_msg: Optional[str] = None) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            join_names: thread names to join
            unreg_names: thread names that are already unregistered
            log_msg: log message specification for the smart_join
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.join_names = get_set(join_names)
        self.unreg_names = get_set(unreg_names)
        self.log_msg = log_msg
        self.arg_list += ['join_names',
                          'unreg_names']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_join(cmd_runner=cmd_runner,
                                    join_names=self.join_names,
                                    unreg_names=self.unreg_names,
                                    timeout_type=TimeoutType.TimeoutNone,
                                    timeout=0,
                                    log_msg=self.log_msg)


########################################################################
# JoinTimeoutFalse
########################################################################
class JoinTimeoutFalse(Join):
    """Do smart_join with timeout false."""
    def __init__(self,
                 cmd_runners: Iterable,
                 join_names: Iterable,
                 timeout: IntOrFloat,
                 unreg_names: Optional[Iterable] = None,
                 log_msg: Optional[str] = None) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            join_names: thread names to join
            unreg_names: thread names that are already unregistered
            timeout: timeout specification for the smart_join
            log_msg: log message specification for the smart_join
        """
        super().__init__(cmd_runners=cmd_runners,
                         join_names=join_names,
                         unreg_names=unreg_names,
                         log_msg=log_msg)
        self.specified_args = locals()  # used for __repr__

        self.timeout = timeout
        self.arg_list += ['timeout']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_join(cmd_runner=cmd_runner,
                                    join_names=self.join_names,
                                    unreg_names=self.unreg_names,
                                    timeout_type=TimeoutType.TimeoutFalse,
                                    timeout=self.timeout,
                                    log_msg=self.log_msg)


########################################################################
# JoinTimeoutTrue
########################################################################
class JoinTimeoutTrue(JoinTimeoutFalse):
    """Do smart_join with timeout true."""
    def __init__(self,
                 cmd_runners: Iterable,
                 join_names: Iterable,
                 timeout: IntOrFloat,
                 timeout_names: Iterable,
                 unreg_names: Optional[Iterable] = None,
                 log_msg: Optional[str] = None) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            join_names: thread names to join
            unreg_names: thread names that are already unregistered
            timeout: timeout specification for the smart_join
            timeout_names: thread names expected to cause timeout
            log_msg: log message specification for the smart_join
        """
        super().__init__(cmd_runners=cmd_runners,
                         join_names=join_names,
                         unreg_names=unreg_names,
                         timeout=timeout,
                         log_msg=log_msg)
        self.specified_args = locals()  # used for __repr__

        self.timeout_names = get_set(timeout_names)
        self.arg_list += ['timeout_names']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        if self.timeout_names:
            self.config_ver.handle_join(cmd_runner=cmd_runner,
                                        join_names=self.join_names,
                                        unreg_names=self.unreg_names,
                                        timeout_type=TimeoutType.TimeoutTrue,
                                        timeout=self.timeout,
                                        timeout_names=self.timeout_names,
                                        log_msg=self.log_msg)
        else:
            self.config_ver.handle_join(cmd_runner=cmd_runner,
                                        join_names=self.join_names,
                                        unreg_names=self.unreg_names,
                                        timeout_type=TimeoutType.TimeoutFalse,
                                        timeout=self.timeout,
                                        log_msg=self.log_msg)


########################################################################
# LockObtain
########################################################################
class LockObtain(ConfigCmd):
    """Obtain the registry lock."""
    def __init__(self,
                 cmd_runners: Iterable) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command

        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.lock_obtain()


########################################################################
# LockRelease
########################################################################
class LockRelease(ConfigCmd):
    """Release the registry lock."""
    def __init__(self,
                 cmd_runners: Iterable) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command

        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.lock_release()


########################################################################
# LockSwap
########################################################################
class LockSwap(ConfigCmd):
    """Swap the lock positions."""
    def __init__(self,
                 cmd_runners: Iterable,
                 new_positions: list[str]) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            new_positions: list of thread names for new position
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.new_positions = new_positions
        self.arg_list += ['new_positions']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.lock_swap(cmd_runner=cmd_runner,
                                  new_positions=self.new_positions)


########################################################################
# LockSwap
########################################################################
class LockVerify(ConfigCmd):
    """Verify the registry lock has the expected owners and waiters."""
    def __init__(self,
                 cmd_runners: Iterable,
                 exp_positions: list[str]) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            exp_positions: thread names for expected positions
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.exp_positions = exp_positions
        self.arg_list += ['exp_positions']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.lock_verify(cmd_runner=cmd_runner,
                                    exp_positions=self.exp_positions,
                                    line_num=self.line_num)


########################################################################
# Pause
########################################################################
class Pause(ConfigCmd):
    """Pause the commands."""
    def __init__(self,
                 cmd_runners: Iterable,
                 pause_seconds: IntOrFloat) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            pause_seconds: number seconds to sleep
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.pause_seconds = pause_seconds

        self.arg_list += ['pause_seconds']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        time.sleep(self.pause_seconds)


########################################################################
# RecvMsg
########################################################################
class RecvMsg(ConfigCmd):
    """Do smart_recv."""
    def __init__(self,
                 cmd_runners: Iterable,
                 senders: Iterable,
                 exp_senders: Iterable,
                 exp_msgs: SendRecvMsgs,
                 sender_count: Optional[int] = None,
                 stopped_remotes: Optional[Iterable] = None,
                 log_msg: Optional[str] = None) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            senders: thread names that will do smart_send
            exp_senders: names of threads that are expected to send a
                msg depending on the RcvType
            exp_msgs: messages to be sent and verified
            sender_count: specification for smart_recv for how many
                senders are needed to satisfy the smart_recv
            stopped_remotes: thread names that are stopped
            log_msg: log message to specify on the smart_recv
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.senders = get_set(senders)

        self.exp_senders = get_set(exp_senders)

        self.exp_msgs = exp_msgs

        self.sender_count = sender_count

        self.log_msg = log_msg

        self.stopped_remotes = get_set(stopped_remotes)

        self.arg_list += ['senders',
                          'exp_senders',
                          'sender_count',
                          'stopped_remotes']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_recv_msg(
            cmd_runner=cmd_runner,
            senders=self.senders,
            exp_senders=self.exp_senders,
            exp_msgs=self.exp_msgs,
            sender_count=self.sender_count,
            stopped_remotes=self.stopped_remotes,
            timeout_type=TimeoutType.TimeoutNone,
            timeout=0,
            timeout_names=set(),
            log_msg=self.log_msg)


########################################################################
# RecvMsgTimeoutFalse
########################################################################
class RecvMsgTimeoutFalse(RecvMsg):
    """Do smart_recv with timeout false."""
    def __init__(self,
                 cmd_runners: Iterable,
                 senders: Iterable,
                 exp_senders: Iterable,
                 exp_msgs: SendRecvMsgs,
                 timeout: IntOrFloat,
                 sender_count: Optional[int] = None,
                 stopped_remotes: Optional[Iterable] = None,
                 log_msg: Optional[str] = None) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            senders: thread names that will do smart_send
            exp_senders: names of threads that are expected to send a
                msg depending on the RcvType
            exp_msgs: messages to be sent and verified
            timeout: value to specify on the smart_recv
            sender_count: specification for smart_recv for how many
                senders are needed to satisfy the smart_recv
            stopped_remotes: thread names that are stopped
            log_msg: log message to specify on the smart_recv
        """
        super().__init__(cmd_runners=cmd_runners,
                         senders=senders,
                         exp_senders=exp_senders,
                         exp_msgs=exp_msgs,
                         sender_count=sender_count,
                         stopped_remotes=stopped_remotes,
                         log_msg=log_msg)
        self.specified_args = locals()  # used for __repr__

        self.timeout = timeout

        self.arg_list += ['timeout']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_recv_msg(
            cmd_runner=cmd_runner,
            senders=self.senders,
            exp_senders=self.exp_senders,
            exp_msgs=self.exp_msgs,
            sender_count=self.sender_count,
            stopped_remotes=self.stopped_remotes,
            timeout_type=TimeoutType.TimeoutFalse,
            timeout=self.timeout,
            timeout_names=set(),
            log_msg=self.log_msg)


########################################################################
# RecvMsgTimeoutTrue
########################################################################
class RecvMsgTimeoutTrue(RecvMsgTimeoutFalse):
    """Do smart_recv with timeout true."""
    def __init__(self,
                 cmd_runners: Iterable,
                 senders: Iterable,
                 exp_senders: Iterable,
                 exp_msgs: SendRecvMsgs,
                 timeout: IntOrFloat,
                 timeout_names: Iterable,
                 sender_count: Optional[int] = None,
                 stopped_remotes: Optional[Iterable] = None,
                 log_msg: Optional[str] = None) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            senders: thread names that will do smart_send
            exp_senders: names of threads that are expected to send a
                msg depending on the RcvType
            exp_msgs: messages to be sent and verified
            timeout: value to specify on the smart_recv
            timeout_names: thread names that are expected to cause a
                timeout
            sender_count: specification for smart_recv for how many
                senders are needed to satisfy the smart_recv
            stopped_remotes: thread names that are stopped
            log_msg: log message to specify on the smart_recv
        """
        super().__init__(cmd_runners=cmd_runners,
                         senders=senders,
                         exp_senders=exp_senders,
                         exp_msgs=exp_msgs,
                         timeout=timeout,
                         sender_count=sender_count,
                         stopped_remotes=stopped_remotes,
                         log_msg=log_msg)
        self.specified_args = locals()  # used for __repr__

        self.timeout_names = get_set(timeout_names)

        self.arg_list += ['timeout_names']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_recv_msg(
            cmd_runner=cmd_runner,
            senders=self.senders,
            exp_senders=self.exp_senders,
            exp_msgs=self.exp_msgs,
            sender_count=self.sender_count,
            stopped_remotes=self.stopped_remotes,
            timeout_type=TimeoutType.TimeoutTrue,
            timeout=self.timeout,
            timeout_names=self.timeout_names,
            log_msg=self.log_msg)


########################################################################
# Resume
########################################################################
class Resume(ConfigCmd):
    """Do smart_resume."""
    def __init__(self,
                 cmd_runners: Iterable,
                 targets: Iterable,
                 exp_resumed_targets: Iterable,
                 stopped_remotes: Optional[Iterable] = None,
                 log_msg: Optional[str] = None) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            targets: thread names to resume
            exp_resumed_targets: thread names expected to be resumed
            stopped_remotes: thread names that are stopped
            log_msg: log msg for smart_resume
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.targets = get_set(targets)

        self.exp_resumed_targets = exp_resumed_targets

        self.stopped_remotes = get_set(stopped_remotes)

        self.log_msg = log_msg

        self.arg_list += ['targets',
                          'exp_resumed_targets',
                          'stopped_remotes']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_resume(
            cmd_runner=cmd_runner,
            targets=self.targets,
            exp_resumed_targets=self.exp_resumed_targets,
            stopped_remotes=self.stopped_remotes,
            timeout=0,
            timeout_names=set(),
            timeout_type=TimeoutType.TimeoutNone,
            log_msg=self.log_msg)


########################################################################
# ResumeTimeoutFalse
########################################################################
class ResumeTimeoutFalse(Resume):
    """Do smart_resume with timeout false."""
    def __init__(self,
                 cmd_runners: Iterable,
                 targets: Iterable,
                 exp_resumed_targets: Iterable,
                 timeout: IntOrFloat,
                 stopped_remotes: Optional[Iterable] = None,
                 log_msg: Optional[str] = None) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            targets: thread names to resume
            exp_resumed_targets: thread names expected to be resumed
            stopped_remotes: thread names that are stopped
            timeout: value for smart_resume
            log_msg: log msg for smart_resume
        """
        super().__init__(cmd_runners=cmd_runners,
                         targets=targets,
                         exp_resumed_targets=exp_resumed_targets,
                         stopped_remotes=stopped_remotes,
                         log_msg=log_msg)
        self.specified_args = locals()  # used for __repr__

        self.timeout = timeout

        self.arg_list += ['timeout']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_resume(
            cmd_runner=cmd_runner,
            targets=self.targets,
            exp_resumed_targets=self.exp_resumed_targets,
            stopped_remotes=self.stopped_remotes,
            timeout=self.timeout,
            timeout_names=set(),
            timeout_type=TimeoutType.TimeoutFalse,
            log_msg=self.log_msg)


########################################################################
# ResumeTimeoutFalse
########################################################################
class ResumeTimeoutTrue(ResumeTimeoutFalse):
    """Do smart_resume with timeout true."""
    def __init__(self,
                 cmd_runners: Iterable,
                 targets: Iterable,
                 exp_resumed_targets: Iterable,
                 timeout: IntOrFloat,
                 timeout_names: Iterable,
                 stopped_remotes: Optional[Iterable] = None,
                 log_msg: Optional[str] = None) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            targets: thread names to resume
            exp_resumed_targets: thread names expected to be resumed
            stopped_remotes: thread names that are stopped
            timeout: value for smart_resume
            timeout_names: thread names expected to cause timeout
            log_msg: log msg for smart_resume
        """
        super().__init__(cmd_runners=cmd_runners,
                         targets=targets,
                         exp_resumed_targets=exp_resumed_targets,
                         stopped_remotes=stopped_remotes,
                         timeout=timeout,
                         log_msg=log_msg)
        self.specified_args = locals()  # used for __repr__

        self.timeout_names = get_set(timeout_names)

        self.arg_list += ['timeout_names']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_resume(
            cmd_runner=cmd_runner,
            targets=self.targets,
            exp_resumed_targets=self.exp_resumed_targets,
            stopped_remotes=self.stopped_remotes,
            timeout=self.timeout,
            timeout_names=self.timeout_names,
            timeout_type=TimeoutType.TimeoutTrue,
            log_msg=self.log_msg)


########################################################################
# SendMsg
########################################################################
class SendMsg(ConfigCmd):
    """Do smart_send."""
    def __init__(self,
                 cmd_runners: Iterable,
                 receivers: Iterable,
                 msgs_to_send: SendRecvMsgs,
                 msg_idx: int,
                 send_type: SendType = SendType.ToRemotes,
                 stopped_remotes: Optional[Iterable] = None,
                 log_msg: Optional[str] = None) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            receivers: thread names that will receive the message
            msgs_to_send: messages to send and verify
            msg_idx: index to use with msgs_to_send for this call
            send_type: specifies how to send the messages
            stopped_remotes: thread names that are stopped
            log_msg: log message for smart_send
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.receivers = get_set(receivers)
        self.msgs_to_send = msgs_to_send
        self.msg_idx = msg_idx

        self.send_type = send_type

        self.stopped_remotes = get_set(stopped_remotes)

        self.log_msg = log_msg

        self.arg_list += ['receivers',
                          'stopped_remotes',
                          'send_type',
                          'msg_idx']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_send_msg(
            cmd_runner=cmd_runner,
            receivers=self.receivers,
            msgs_to_send=self.msgs_to_send,
            msg_idx=self.msg_idx,
            send_type=self.send_type,
            timeout_type=TimeoutType.TimeoutNone,
            timeout=0,
            unreg_timeout_names=None,
            fullq_timeout_names=None,
            stopped_remotes=self.stopped_remotes,
            log_msg=self.log_msg)


########################################################################
# SendMsgTimeoutFalse
########################################################################
class SendMsgTimeoutFalse(SendMsg):
    """Do smart_send with timeout false."""
    def __init__(self,
                 cmd_runners: Iterable,
                 msgs_to_send: SendRecvMsgs,
                 msg_idx: int,
                 timeout: IntOrFloat,
                 send_type: SendType = SendType.ToRemotes,
                 receivers: Optional[Iterable] = None,
                 stopped_remotes: Optional[StrOrSet] = None,
                 log_msg: Optional[str] = None) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            receivers: thread names that will receive the message
            msgs_to_send: messages to send and verify
            msg_idx: index to use with msgs_to_send for this call
            timeout: value for smart_send
            send_type: specifies how to send the messages
            stopped_remotes: thread names that are stopped
            log_msg: log message for smart_send
        """
        super().__init__(
            cmd_runners=cmd_runners,
            receivers=receivers,
            msgs_to_send=msgs_to_send,
            msg_idx=msg_idx,
            send_type=send_type,
            stopped_remotes=stopped_remotes,
            log_msg=log_msg)
        self.specified_args = locals()  # used for __repr__

        self.timeout = timeout

        self.arg_list += ['timeout']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_send_msg(
            cmd_runner=cmd_runner,
            receivers=self.receivers,
            msgs_to_send=self.msgs_to_send,
            msg_idx=self.msg_idx,
            send_type=self.send_type,
            timeout_type=TimeoutType.TimeoutFalse,
            timeout=self.timeout,
            unreg_timeout_names=None,
            fullq_timeout_names=None,
            stopped_remotes=self.stopped_remotes,
            log_msg=self.log_msg)


########################################################################
# SendMsgTimeoutTrue
########################################################################
class SendMsgTimeoutTrue(SendMsgTimeoutFalse):
    """Do smart_send with timeout true."""
    def __init__(self,
                 cmd_runners: Iterable,
                 msgs_to_send: SendRecvMsgs,
                 msg_idx: int,
                 receivers: Iterable,
                 timeout: IntOrFloat,
                 unreg_timeout_names: Iterable,
                 fullq_timeout_names: Iterable,
                 send_type: SendType = SendType.ToRemotes,
                 stopped_remotes: Optional[StrOrSet] = None,
                 log_msg: Optional[str] = None) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            receivers: thread names that will receive the message
            msgs_to_send: messages to send and verify
            msg_idx: index to use with msgs_to_send for this call
            timeout: value for smart_send
            unreg_timeout_names: thread names that are not registered
            fullq_timeout_names: thread names whose msg_q is full
            send_type: specifies how to send the messages
            stopped_remotes: thread names that are stopped
            log_msg: log message for smart_send
        """
        super().__init__(
            cmd_runners=cmd_runners,
            receivers=receivers,
            msgs_to_send=msgs_to_send,
            msg_idx=msg_idx,
            timeout=timeout,
            send_type=send_type,
            stopped_remotes=stopped_remotes,
            log_msg=log_msg)
        self.specified_args = locals()  # used for __repr__

        self.arg_list += ['unreg_timeout_names',
                          'fullq_timeout_names']

        self.unreg_timeout_names = get_set(unreg_timeout_names)

        self.fullq_timeout_names = get_set(fullq_timeout_names)

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_send_msg(
            cmd_runner=cmd_runner,
            receivers=self.receivers,
            msgs_to_send=self.msgs_to_send,
            msg_idx=self.msg_idx,
            send_type=self.send_type,
            timeout_type=TimeoutType.TimeoutTrue,
            timeout=self.timeout,
            unreg_timeout_names=set(self.unreg_timeout_names),
            fullq_timeout_names=set(self.fullq_timeout_names),
            stopped_remotes=self.stopped_remotes,
            log_msg=self.log_msg)


########################################################################
# StartThread
########################################################################
class StartThread(ConfigCmd):
    """Start a thread with smart_start."""
    def __init__(self,
                 cmd_runners: Iterable,
                 start_names: Iterable,
                 unreg_remotes: Optional[Iterable] = None,
                 log_msg: Optional[str] = None) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            start_names: thread names to start
            unreg_remotes: thread names that are not registered state
            log_msg: log message for smart_start
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.start_names = get_set(start_names)

        self.unreg_remotes = get_set(unreg_remotes)

        self.log_msg = log_msg

        self.arg_list += ['start_names',
                          'unreg_remotes']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_start(
            cmd_runner=cmd_runner,
            start_names=self.start_names,
            unreg_remotes=self.unreg_remotes,
            log_msg=self.log_msg)


########################################################################
# StopThread
########################################################################
class StopThread(ConfigCmd):
    """Stop a thread."""
    def __init__(self,
                 cmd_runners: Iterable,
                 stop_names: Iterable,
                 reset_ops_count: bool = False) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            stop_names: thread names to stop
            reset_ops_count: specifies whether to reset ops count for
                the stop names
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.stop_names = get_set(stop_names)

        self.reset_ops_count = reset_ops_count

        self.arg_list += ['stop_names',
                          'reset_ops_count']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.stop_thread(cmd_runner=cmd_runner,
                                    stop_names=self.stop_names,
                                    reset_ops_count=self.reset_ops_count)


########################################################################
# Sync
########################################################################
class Sync(ConfigCmd):
    """Do smart_sync."""
    def __init__(self,
                 cmd_runners: Iterable,
                 targets: Iterable,
                 timeout: IntOrFloat = 0,
                 timeout_remotes: Optional[Iterable] = None,
                 stopped_remotes: Optional[Iterable] = None,
                 conflict_remotes: Optional[Iterable] = None,
                 log_msg: Optional[str] = None) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            targets: thread names who will sync with each other
            timeout: value for smart_sync
            timeout_remotes: thread names that cause timeout
            stopped_remotes: thread names that are stopped
            conflict_remotes: thread names that cause deadlock
            log_msg: log message for smart_sync
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.targets = get_set(targets)

        self.timeout = timeout

        self.timeout_remotes = get_set(timeout_remotes)

        self.stopped_remotes = get_set(stopped_remotes)

        self.conflict_remotes = get_set(conflict_remotes)

        self.log_msg = log_msg

        self.arg_list += ['targets',
                          'timeout',
                          'stopped_remotes',
                          'timeout_remotes',
                          'conflict_remotes']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        targets = self.targets - {cmd_runner}
        self.config_ver.handle_sync(
            cmd_runner=cmd_runner,
            targets=targets,
            timeout=self.timeout,
            timeout_remotes=self.timeout_remotes,
            stopped_remotes=self.stopped_remotes,
            conflict_remotes=self.conflict_remotes,
            timeout_type=TimeoutType.TimeoutNone,
            log_msg=self.log_msg)


########################################################################
# SyncTimeoutFalse
########################################################################
class SyncTimeoutFalse(Sync):
    """Do smart_sync with timeout of false."""
    def __init__(self,
                 cmd_runners: Iterable,
                 targets: Iterable,
                 timeout: IntOrFloat,
                 stopped_remotes: Optional[Iterable] = None,
                 timeout_remotes: Optional[Iterable] = None,
                 conflict_remotes: Optional[Iterable] = None,
                 log_msg: Optional[str] = None) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            targets: thread names who will sync with each other
            timeout: value for smart_sync
            timeout_remotes: thread names that cause timeout
            stopped_remotes: thread names that are stopped
            conflict_remotes: thread names that cause deadlock
            log_msg: log message for smart_sync
        """
        super().__init__(cmd_runners=cmd_runners,
                         targets=targets,
                         timeout=timeout,
                         timeout_remotes=timeout_remotes,
                         stopped_remotes=stopped_remotes,
                         conflict_remotes=conflict_remotes,
                         log_msg=log_msg)
        self.specified_args = locals()  # used for __repr__

        self.arg_list += ['timeout']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        targets = self.targets - {cmd_runner}
        self.config_ver.handle_sync(
            cmd_runner=cmd_runner,
            targets=targets,
            timeout=self.timeout,
            timeout_remotes=self.timeout_remotes,
            stopped_remotes=self.stopped_remotes,
            conflict_remotes=self.conflict_remotes,
            timeout_type=TimeoutType.TimeoutFalse,
            log_msg=self.log_msg)


########################################################################
# SyncTimeoutFalse
########################################################################
class SyncTimeoutTrue(SyncTimeoutFalse):
    """Do smart_sync with timeout of true."""
    def __init__(self,
                 cmd_runners: Iterable,
                 targets: Iterable,
                 timeout: IntOrFloat,
                 timeout_remotes: Iterable,
                 stopped_remotes: Optional[Iterable] = None,
                 conflict_remotes: Optional[Iterable] = None,
                 log_msg: Optional[str] = None) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            targets: thread names who will sync with each other
            timeout: value for smart_sync
            timeout_remotes: thread names that cause timeout
            stopped_remotes: thread names that are stopped
            conflict_remotes: thread names that cause deadlock
            log_msg: log message for smart_sync
        """
        super().__init__(cmd_runners=cmd_runners,
                         targets=targets,
                         timeout=timeout,
                         timeout_remotes=timeout_remotes,
                         stopped_remotes=stopped_remotes,
                         conflict_remotes=conflict_remotes,
                         log_msg=log_msg)
        self.specified_args = locals()  # used for __repr__

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        targets = self.targets - {cmd_runner}
        self.config_ver.handle_sync(
            cmd_runner=cmd_runner,
            targets=targets,
            timeout=self.timeout,
            timeout_remotes=self.timeout_remotes,
            stopped_remotes=self.stopped_remotes,
            conflict_remotes=self.conflict_remotes,
            timeout_type=TimeoutType.TimeoutTrue,
            log_msg=self.log_msg)


########################################################################
# Unregister
########################################################################
class Unregister(ConfigCmd):
    """Do the smart_unreg."""
    def __init__(self,
                 cmd_runners: Iterable,
                 unregister_targets: Iterable,
                 not_registered_remotes: Optional[Iterable] = None,
                 log_msg: Optional[str] = None) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            unregister_targets: thread names to be unregistered
            log_msg: log message for smart_unreg
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.unregister_targets = get_set(unregister_targets)

        self.not_registered_remotes = get_set(not_registered_remotes)

        self.log_msg = log_msg

        self.arg_list += ['unregister_targets',
                          'not_registered_remotes']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_unregister(
            cmd_runner=cmd_runner,
            unregister_targets=self.unregister_targets,
            not_registered_remotes=self.not_registered_remotes,
            log_msg=self.log_msg)


########################################################################
# ValidateConfig
########################################################################
# class ValidateConfig(ConfigCmd):
#     """Validate the configuration."""
#     def __init__(self,
#                  cmd_runners: Iterable) -> None:
#         """Initialize the instance.
#
#         Args:
#             cmd_runners: thread names that will execute the command
#         """
#         super().__init__(cmd_runners=cmd_runners)
#         self.specified_args = locals()  # used for __repr__
#
#     def run_process(self, cmd_runner: str) -> None:
#         """Run the command.
#
#         Args:
#             cmd_runner: name of thread running the command
#         """
#         self.config_ver.create_snapshot_data(verify_name='verify_config',
#                                              verify_idx=self.serial_num)
#         # self.config_ver.log_test_msg('Monitor Checkpoint: validate_config')
#
#         self.config_ver.verify_config_complete_event.wait()
#         self.config_ver.verify_config_complete_event.clear()
#
#         # self.config_ver.validate_config()


########################################################################
# ValidateConfig
########################################################################
class VerifyConfig(ConfigCmd):
    """Validate the configuration."""
    def __init__(self,
                 cmd_runners: Iterable,
                 verify_type: VerifyType,
                 names_to_check: Optional[Iterable] = None,
                 aux_names: Optional[Iterable] = None,
                 state_to_check: Optional[st.ThreadState] = None,
                 exp_pending_flags: Optional[PendingFlags] = None,
                 obtain_reg_lock: bool = True) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            verify_type: type of verification to do
            names_to_check: thread names to verify
            aux_names: thread names associated with names_to_check
            state_to_check: expected ThreadState
            exp_pending_flags: expected pending flags
            obtain_reg_lock: if True, obtain the smart_thread lock

        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.verify_type = verify_type
        self.names_to_check = get_set(names_to_check)
        self.aux_names = get_set(aux_names)
        self.state_to_check = state_to_check
        self.exp_pending_flags = exp_pending_flags
        self.obtain_reg_lock = obtain_reg_lock

        self.arg_list += ['verify_type',
                          'names_to_check',
                          'aux_names',
                          'state_to_check',
                          'exp_pending_flags']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        verify_data: VerifyData = VerifyData(
            cmd_runner=cmd_runner,
            verify_type=self.verify_type,
            names_to_check=self.names_to_check,
            aux_names=self.aux_names,
            state_to_check=self.state_to_check,
            exp_pending_flags=self.exp_pending_flags,
            obtain_reg_lock=self.obtain_reg_lock
        )

        self.config_ver.create_snapshot_data(verify_name='verify_config',
                                             verify_idx=self.serial_num,
                                             verify_data=verify_data)
        # self.config_ver.log_test_msg('Monitor Checkpoint: validate_config')

        self.config_ver.verify_config_complete_event.wait()
        self.config_ver.verify_config_complete_event.clear()

########################################################################
# VerifyAlive
########################################################################
# class VerifyAlive(ConfigCmd):
#     """Verify that the threads are alive."""
#     def __init__(self,
#                  cmd_runners: Iterable,
#                  exp_alive_names: Iterable) -> None:
#         """Initialize the instance.
#
#         Args:
#             cmd_runners: thread names that will execute the command
#             exp_alive_names: thread names expected to be alive
#         """
#         super().__init__(cmd_runners=cmd_runners)
#         self.specified_args = locals()  # used for __repr__
#
#         self.exp_alive_names = get_set(exp_alive_names)
#
#         self.arg_list += ['exp_alive_names']
#
#     def run_process(self, cmd_runner: str) -> None:
#         """Run the command.
#
#         Args:
#             cmd_runner: name of thread running the command
#         """
#         self.config_ver.verify_is_alive(names=self.exp_alive_names)


########################################################################
# VerifyAliveNot
########################################################################
# class VerifyAliveNot(ConfigCmd):
#     """Verify that the threads are not alive."""
#     def __init__(self,
#                  cmd_runners: Iterable,
#                  exp_not_alive_names: Iterable) -> None:
#         """Initialize the instance.
#
#         Args:
#             cmd_runners: thread names that will execute the command
#             exp_not_alive_names: thread names expected to be not alive
#         """
#         super().__init__(cmd_runners=cmd_runners)
#         self.specified_args = locals()  # used for __repr__
#
#         self.exp_not_alive_names = get_set(exp_not_alive_names)
#
#         self.arg_list += ['exp_not_alive_names']
#
#     def run_process(self, cmd_runner: str) -> None:
#         """Run the command.
#
#         Args:
#             cmd_runner: name of thread running the command
#         """
#         self.config_ver.verify_is_alive_not(names=self.exp_not_alive_names)


########################################################################
# VerifyActive
########################################################################
# class VerifyActive(ConfigCmd):
#     """Verify that the threads are in the alive state."""
#     def __init__(self,
#                  cmd_runners: Iterable,
#                  exp_active_names: Iterable) -> None:
#         """Initialize the instance.
#
#         Args:
#             cmd_runners: thread names that will execute the command
#             exp_active_names: thread names expected to be active
#         """
#         super().__init__(cmd_runners=cmd_runners)
#         self.specified_args = locals()  # used for __repr__
#
#         self.exp_active_names = get_set(exp_active_names)
#
#         self.arg_list += ['exp_active_names']
#
#     def run_process(self, cmd_runner: str) -> None:
#         """Run the command.
#
#         Args:
#             cmd_runner: name of thread running the command
#         """
#         verify_active_data: VerifyActiveData = VerifyActiveData(
#             cmd_runner=cmd_runner,
#             exp_active_names=self.exp_active_names
#         )
#         self.config_ver.create_snapshot_data(verify_name='verify_active',
#                                              verify_idx=self.serial_num,
#                                              verify_data=verify_active_data)


########################################################################
# VerifyCounts
########################################################################
class VerifyCounts(ConfigCmd):
    """Verify the number of threads at various states in the config."""
    def __init__(self,
                 cmd_runners: Iterable,
                 exp_num_registered: int,
                 exp_num_active: int,
                 exp_num_stopped: int) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            exp_num_registered: number thread expected to be registered
                state
            exp_num_active: number thread expected to be alive state
            exp_num_stopped: number thread expected to be stopped state
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.exp_num_registered = exp_num_registered
        self.exp_num_active = exp_num_active
        self.exp_num_stopped = exp_num_stopped

        self.arg_list += ['exp_num_registered',
                          'exp_num_active',
                          'exp_num_stopped']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        verify_counts_data: VerifyCountsData = VerifyCountsData(
            num_registered=self.exp_num_registered,
            num_active=self.exp_num_active,
            num_stopped=self.exp_num_stopped
        )
        self.config_ver.create_snapshot_data(verify_name='verify_counts',
                                             verify_idx=self.serial_num,
                                             verify_data=verify_counts_data)


########################################################################
# VerifyDefDel
########################################################################
class VerifyDefDel(ConfigCmd):
    """Verify deferred deletes."""
    def __init__(self,
                 cmd_runners: Iterable,
                 def_del_scenario: DefDelScenario,
                 receiver_names: list[str],
                 sender_names: list[str],
                 waiter_names: list[str],
                 resumer_names: list[str],
                 del_names: list[str],
                 add_names: list[str],
                 deleter_names: list[str],
                 adder_names: list[str]
                 ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            def_del_scenario: scenario to run
            receiver_names: thread names
            sender_names: thread names
            waiter_names: thread names
            resumer_names: thread names
            del_names: thread names
            add_names: thread names
            deleter_names: thread names
            adder_names: thread names
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.def_del_scenario = def_del_scenario
        self.receiver_names = receiver_names
        self.sender_names = sender_names
        self.waiter_names = waiter_names
        self.resumer_names = resumer_names
        self.del_names = del_names
        self.add_names = add_names
        self.deleter_names = deleter_names
        self.adder_names = adder_names

        self.arg_list += ['def_del_scenario']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.verify_def_del(
            cmd_runner=cmd_runner,
            def_del_scenario=self.def_del_scenario,
            receiver_names=self.receiver_names,
            sender_names=self.sender_names,
            waiter_names=self.waiter_names,
            resumer_names=self.resumer_names,
            del_names=self.del_names,
            add_names=self.add_names,
            deleter_names=self.deleter_names,
            adder_names=self.adder_names
        )


########################################################################
# VerifyInRegistry
########################################################################
# class VerifyInRegistry(ConfigCmd):
#     """Verify that threads are in the registry."""
#     def __init__(self,
#                  cmd_runners: Iterable,
#                  exp_in_registry_names: Iterable) -> None:
#         """Initialize the instance.
#
#         Args:
#             cmd_runners: thread names that will execute the command
#             exp_in_registry_names: thread names expected to be in the
#                 registry
#         """
#         super().__init__(cmd_runners=cmd_runners)
#         self.specified_args = locals()  # used for __repr__
#
#         self.exp_in_registry_names = get_set(exp_in_registry_names)
#
#         self.arg_list += ['exp_in_registry_names']
#
#     def run_process(self, cmd_runner: str) -> None:
#         """Run the command.
#
#         Args:
#             cmd_runner: name of thread running the command
#         """
#         self.config_ver.verify_in_registry(
#             cmd_runner=cmd_runner,
#             exp_in_registry_names=self.exp_in_registry_names)


########################################################################
# VerifyInRegistryNot
########################################################################
# class VerifyInRegistryNot(ConfigCmd):
#     """Verify that threads are not in the registry."""
#     def __init__(self,
#                  cmd_runners: Iterable,
#                  exp_not_in_registry_names: Iterable) -> None:
#         """Initialize the instance.
#
#         Args:
#             cmd_runners: thread names that will execute the command
#             exp_not_in_registry_names: thread names expected to not be
#                 in the registry
#         """
#         super().__init__(cmd_runners=cmd_runners)
#         self.specified_args = locals()  # used for __repr__
#
#         self.exp_not_in_registry_names = get_set(exp_not_in_registry_names)
#
#         self.arg_list += ['exp_not_in_registry_names']
#
#     def run_process(self, cmd_runner: str) -> None:
#         """Run the command.
#
#         Args:
#             cmd_runner: name of thread running the command
#         """
#         self.config_ver.verify_in_registry_not(
#             cmd_runner=cmd_runner,
#             exp_not_in_registry_names=self.exp_not_in_registry_names)


########################################################################
# VerifyRegistered
########################################################################
# class VerifyRegistered(ConfigCmd):
#     """Verify that threads are in the registered state."""
#     def __init__(self,
#                  cmd_runners: Iterable,
#                  exp_registered_names: Iterable) -> None:
#         """Initialize the instance.
#
#         Args:
#             cmd_runners: thread names that will execute the command
#             exp_registered_names: thread names expected to be in
#                 registered state
#         """
#         super().__init__(cmd_runners=cmd_runners)
#         self.specified_args = locals()  # used for __repr__
#
#         self.exp_registered_names = get_set(exp_registered_names)
#
#         self.arg_list += ['exp_registered_names']
#
#     def run_process(self, cmd_runner: str) -> None:
#         """Run the command.
#
#         Args:
#             cmd_runner: name of thread running the command
#         """
#         self.config_ver.verify_is_registered(
#             cmd_runner=cmd_runner,
#             exp_registered_names=self.exp_registered_names)


########################################################################
# VerifyPaired
########################################################################
# class VerifyPaired(ConfigCmd):
#     """Verify that threads are paired."""
#     def __init__(self,
#                  cmd_runners: Iterable,
#                  exp_paired_names: Iterable) -> None:
#         """Initialize the instance.
#
#         Args:
#             cmd_runners: thread names that will execute the command
#             exp_paired_names: thread names expected to be paired
#         """
#         super().__init__(cmd_runners=cmd_runners)
#         self.specified_args = locals()  # used for __repr__
#
#         self.exp_paired_names = get_set(exp_paired_names)
#
#         self.arg_list += ['exp_paired_names']
#
#     def run_process(self, cmd_runner: str) -> None:
#         """Run the command.
#
#         Args:
#             cmd_runner: name of thread running the command
#         """
#         self.config_ver.verify_paired(
#             cmd_runner=cmd_runner,
#             exp_paired_names=self.exp_paired_names)


########################################################################
# VerifyPairedHalf
########################################################################
# class VerifyPairedHalf(ConfigCmd):
#     """Verify that only one thread is in a pair array status block."""
#     def __init__(self,
#                  cmd_runners: Iterable,
#                  removed_names: Iterable,
#                  exp_half_paired_names: Iterable) -> None:
#         """Initialize the instance.
#
#         Args:
#             cmd_runners: thread names that will execute the command
#             removed_names: threads names that are no longer in the pair
#             exp_half_paired_names: thread names expected to be a single
#                 entry in the pair array
#         """
#         super().__init__(cmd_runners=cmd_runners)
#         self.specified_args = locals()  # used for __repr__
#
#         self.removed_names = get_set(removed_names)
#
#         self.exp_half_paired_names = get_set(exp_half_paired_names)
#
#         self.arg_list += ['removed_names',
#                           'exp_half_paired_names']
#
#     def run_process(self, cmd_runner: str) -> None:
#         """Run the command.
#
#         Args:
#             cmd_runner: name of thread running the command
#         """
#         self.config_ver.verify_paired_half(
#             cmd_runner=cmd_runner,
#             removed_names=self.removed_names,
#             exp_half_paired_names=self.exp_half_paired_names)


########################################################################
# VerifyPairedNot
########################################################################
# class VerifyPairedNot(ConfigCmd):
#     """Verify that threads are not paired."""
#     def __init__(self,
#                  cmd_runners: Iterable,
#                  exp_not_paired_names: Iterable) -> None:
#         """Initialize the instance.
#
#         Args:
#             cmd_runners: thread names that will execute the command
#             exp_not_paired_names: thread names expected to be not paired
#         """
#         super().__init__(cmd_runners=cmd_runners)
#         self.specified_args = locals()  # used for __repr__
#
#         self.exp_not_paired_names = get_set(exp_not_paired_names)
#
#         self.arg_list += ['exp_not_paired_names']
#
#     def run_process(self, cmd_runner: str) -> None:
#         """Run the command.
#
#         Args:
#             cmd_runner: name of thread running the command
#         """
#         self.config_ver.verify_paired_not(
#             cmd_runner=cmd_runner,
#             exp_not_paired_names=self.exp_not_paired_names)


########################################################################
# VerifyState
########################################################################
# class VerifyState(ConfigCmd):
#     """Verify the thread state."""
#     def __init__(self,
#                  cmd_runners: Iterable,
#                  check_state_names: Iterable,
#                  expected_state: st.ThreadState
#                  ) -> None:
#         """Initialize the instance.
#
#         Args:
#             cmd_runners: thread names that will execute the command
#             check_state_names: thread names to verify state
#             expected_state: expected state
#         """
#         super().__init__(cmd_runners=cmd_runners)
#         self.specified_args = locals()  # used for __repr__
#
#         self.check_state_names = get_set(check_state_names)
#
#         self.expected_state = expected_state
#
#         self.arg_list += ['check_state_names',
#                           'expected_state']
#
#     def run_process(self, cmd_runner: str) -> None:
#         """Run the command.
#
#         Args:
#             cmd_runner: name of thread running the command
#         """
#         verify_state_data: VerifyStateData = VerifyStateData(
#             cmd_runner=cmd_runner,
#             check_state_names=self.check_state_names,
#             expected_state=self.expected_state)
#
#         self.config_ver.create_snapshot_data(verify_name='verify_state',
#                                              verify_idx=self.serial_num,
#                                              verify_data=verify_state_data)


########################################################################
# Wait
########################################################################
class Wait(ConfigCmd):
    """Do smart_wait."""
    def __init__(self,
                 cmd_runners: Iterable,
                 resumers: Iterable,
                 exp_resumers: Iterable,
                 resumer_count: Optional[int] = None,
                 stopped_remotes: Optional[Iterable] = None,
                 conflict_remotes: Optional[Iterable] = None,
                 deadlock_remotes: Optional[Iterable] = None,
                 log_msg: Optional[str] = None) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            resumers: thread names that will resume
            exp_resumers: thread names that the wait is expected to be
                resumed by
            resumer_count: specification for smart_wait for how many
                resumes are needed to satisfy the smart_wait
            stopped_remotes: thread names that are stopped
            conflict_remotes: thread names that cause deadlock
            deadlock_remotes: thread names that cause deadlock
            log_msg: log message for the smart_resume
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.resumers = get_set(resumers)
        self.exp_resumers = get_set(exp_resumers)

        self.stopped_remotes = get_set(stopped_remotes)

        self.conflict_remotes = get_set(conflict_remotes)

        self.deadlock_remotes = get_set(deadlock_remotes)

        self.resumer_count = resumer_count

        self.log_msg = log_msg

        self.arg_list += ['resumers',
                          'exp_resumers',
                          'resumer_count',
                          'stopped_remotes',
                          'conflict_remotes',
                          'deadlock_remotes']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_wait(
            cmd_runner=cmd_runner,
            resumers=self.resumers,
            exp_resumers=self.exp_resumers,
            timeout=0,
            timeout_remotes=set(),
            stopped_remotes=self.stopped_remotes,
            conflict_remotes=self.conflict_remotes,
            deadlock_remotes=self.deadlock_remotes,
            timeout_type=TimeoutType.TimeoutNone,
            resumer_count=self.resumer_count,
            log_msg=self.log_msg)


########################################################################
# WaitTimeoutFalse
########################################################################
class WaitTimeoutFalse(Wait):
    """Do smart_wait with timeout false."""
    def __init__(self,
                 cmd_runners: Iterable,
                 resumers: Iterable,
                 exp_resumers: Iterable,
                 timeout: IntOrFloat,
                 resumer_count: Optional[int] = None,
                 stopped_remotes: Optional[Iterable] = None,
                 conflict_remotes: Optional[Iterable] = None,
                 deadlock_remotes: Optional[Iterable] = None,
                 log_msg: Optional[str] = None) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            resumers: thread names that will do the smart_resume
            exp_resumers: thread names that the wait is expected to be
                resumed by
            timeout: value for smart_wait
            resumer_count: specification for smart_wait for how many
                resumes are needed to satisfy the smart_wait
            stopped_remotes: thread names that are stopped
            conflict_remotes: thread names that are deadlocked
            deadlock_remotes: thread names that are deadlocked
            log_msg: log message for smart_wait
        """
        super().__init__(cmd_runners=cmd_runners,
                         resumers=resumers,
                         exp_resumers=exp_resumers,
                         stopped_remotes=stopped_remotes,
                         resumer_count=resumer_count,
                         conflict_remotes=conflict_remotes,
                         deadlock_remotes=deadlock_remotes,
                         log_msg=log_msg)
        self.specified_args = locals()  # used for __repr__

        self.timeout = timeout

        self.arg_list += ['timeout']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_wait(
            cmd_runner=cmd_runner,
            resumers=self.resumers,
            exp_resumers=self.exp_resumers,
            timeout=self.timeout,
            timeout_remotes=set(),
            stopped_remotes=self.stopped_remotes,
            conflict_remotes=self.conflict_remotes,
            deadlock_remotes=self.deadlock_remotes,
            timeout_type=TimeoutType.TimeoutFalse,
            resumer_count=self.resumer_count,
            log_msg=self.log_msg)


########################################################################
# WaitTimeoutTrue
########################################################################
class WaitTimeoutTrue(WaitTimeoutFalse):
    """Do smart_wait with timeout true."""
    def __init__(self,
                 cmd_runners: Iterable,
                 resumers: Iterable,
                 exp_resumers: Iterable,
                 timeout: IntOrFloat,
                 timeout_remotes: Iterable,
                 resumer_count: Optional[int] = None,
                 stopped_remotes: Optional[Iterable] = None,
                 conflict_remotes: Optional[Iterable] = None,
                 deadlock_remotes: Optional[Iterable] = None,
                 log_msg: Optional[str] = None
                 ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            resumers: thread names that will do the smart_resume
            exp_resumers: thread names that the wait is expected to be
                resumed by
            timeout: value for smart_wait
            timeout_remotes: thread names that cause a timeout
            resumer_count: specification for smart_wait for how many
                resumes are needed to satisfy the smart_wait
            stopped_remotes: thread names that are stopped
            conflict_remotes: thread names that are deadlocked
            deadlock_remotes: thread names that are deadlocked
            log_msg: log message for smart_wait
        """
        super().__init__(cmd_runners=cmd_runners,
                         resumers=resumers,
                         exp_resumers=exp_resumers,
                         stopped_remotes=stopped_remotes,
                         resumer_count=resumer_count,
                         conflict_remotes=conflict_remotes,
                         deadlock_remotes=deadlock_remotes,
                         timeout=timeout,
                         log_msg=log_msg)
        self.specified_args = locals()  # used for __repr__

        self.timeout_remotes = get_set(timeout_remotes)

        self.arg_list += ['timeout_remotes']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.handle_wait(
            cmd_runner=cmd_runner,
            resumers=self.resumers,
            exp_resumers=self.exp_resumers,
            timeout=self.timeout,
            timeout_remotes=self.timeout_remotes,
            stopped_remotes=self.stopped_remotes,
            conflict_remotes=self.conflict_remotes,
            deadlock_remotes=self.deadlock_remotes,
            timeout_type=TimeoutType.TimeoutTrue,
            resumer_count=self.resumer_count,
            log_msg=self.log_msg)


########################################################################
# WaitForCondition
########################################################################
class WaitForCondition(ConfigCmd):
    """Wait for receive message timeouts."""
    def __init__(self,
                 cmd_runners: Iterable,
                 check_rtn: Callable[..., bool],
                 check_args: Any) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            check_rtn: routine that will do the check
            check_args: the arguments for the check_rtn

        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__
        self.check_rtn = check_rtn
        self.check_args = check_args

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        start_time = time.time()
        while not self.check_rtn(cmd_runner=cmd_runner,
                                 check_args=self.check_args):
            time.sleep(0.1)
            if start_time + 30 < time.time():
                raise CmdTimedOut('WaitForCondition timed out')


########################################################################
# WaitForRecvTimeouts
########################################################################
class WaitForRecvTimeouts(ConfigCmd):
    """Wait for receive message timeouts."""
    def __init__(self,
                 cmd_runners: Iterable) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command

        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.wait_for_recv_msg_timeouts(cmd_runner=cmd_runner)


########################################################################
# WaitForRequestTimeouts
########################################################################
class WaitForRequestTimeouts(ConfigCmd):
    """Wait for request timeouts command."""
    def __init__(self,
                 cmd_runners: Iterable,
                 actor_names: Iterable,
                 timeout_names: Iterable,
                 use_work_remotes: bool = False,
                 as_subset: bool = False
                 ) -> None:
        """Initialize the instance.

        Args:
            cmd_runners: thread names that will execute the command
            actor_names: thread names that are cmd runners waiting for a
                timeout or timeout condition
            timeout_names: thread names that are expected to cause
                timeout by not responding or by not being alive
            use_work_remotes: if True, compare against work_remotes,
                else pk_remotes
            as_subset: if True, the wait is satisfied when the
                timeout_names are a subset of the pk_remotes
        """
        super().__init__(cmd_runners=cmd_runners)
        self.specified_args = locals()  # used for __repr__

        self.actor_names = get_set(actor_names)

        self.timeout_names = get_set(timeout_names)

        self.use_work_remotes = use_work_remotes

        self.as_subset = as_subset

        self.arg_list += ['actor_names',
                          'timeout_names',
                          'use_work_remotes',
                          'as_subset']

    def run_process(self, cmd_runner: str) -> None:
        """Run the command.

        Args:
            cmd_runner: name of thread running the command
        """
        self.config_ver.wait_for_request_timeouts(
            cmd_runner=cmd_runner,
            actor_names=self.actor_names,
            timeout_names=self.timeout_names,
            use_work_remotes=self.use_work_remotes,
            as_subset=self.as_subset)


# ###############################################################################
# # Cmd Constants
# ###############################################################################
# Cmd = Enum('Cmd', 'Wait Wait_TOT Wait_TOF Wait_Clear Resume Sync Exit '
#                   'Next_Action')
#
# ###############################################################################
# # Action
# ###############################################################################
# Action = Enum('Action',
#               'MainWait '
#               'MainSync MainSync_TOT MainSync_TOF '
#               'MainResume MainResume_TOT MainResume_TOF '
#               'ThreadWait ThreadWait_TOT ThreadWait_TOF '
#               'ThreadResume ')
#
# ###############################################################################
# # action_arg fixtures
# ###############################################################################
# action_arg_list = [Action.MainWait,
#                    Action.MainSync,
#                    Action.MainSync_TOT,
#                    Action.MainSync_TOF,
#                    Action.MainResume,
#                    Action.MainResume_TOT,
#                    Action.MainResume_TOF,
#                    Action.ThreadWait,
#                    Action.ThreadWait_TOT,
#                    Action.ThreadWait_TOF,
#                    Action.ThreadResume]
#
# action_arg_list1 = [Action.MainWait
#                     # Action.MainResume,
#                     # Action.MainResume_TOT,
#                     # Action.MainResume_TOF,
#                     # Action.ThreadWait,
#                     # Action.ThreadWait_TOT,
#                     # Action.ThreadWait_TOF,
#                     # Action.ThreadResume
#                     ]
#
# action_arg_list2 = [  # Action.MainWait,
#                     # Action.MainResume,
#                     # Action.MainResume_TOT,
#                     Action.MainResume_TOF
#                     # Action.ThreadWait,
#                     # Action.ThreadWait_TOT,
#                     # Action.ThreadWait_TOF,
#                     # Action.ThreadResume
#                     ]
#
#
# @pytest.fixture(params=action_arg_list)  # type: ignore
# def action_arg1(request: Any) -> Any:
#     """Using different reply messages.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return request.param
#
#
# @pytest.fixture(params=action_arg_list)  # type: ignore
# def action_arg2(request: Any) -> Any:
#     """Using different reply messages.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return request.param


###############################################################################
# num_auto_start_arg
###############################################################################
@pytest.fixture(params=num_auto_start_arg_list)  # type: ignore
def num_auto_start_arg(request: Any) -> int:
    """Number of threads to auto start.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# num_manual_start_arg
###############################################################################
@pytest.fixture(params=num_manual_start_arg_list)  # type: ignore
def num_manual_start_arg(request: Any) -> int:
    """Number of threads to manually start.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# num_unreg_arg
###############################################################################
@pytest.fixture(params=num_unreg_arg_list)  # type: ignore
def num_unreg_arg(request: Any) -> int:
    """Number of threads to be unregistered for smart_start test.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# num_alive_arg
###############################################################################
@pytest.fixture(params=num_alive_arg_list)  # type: ignore
def num_alive_arg(request: Any) -> int:
    """Number of threads to be alive for smart_start test.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# num_stopped_arg
###############################################################################
@pytest.fixture(params=num_stopped_arg_list)  # type: ignore
def num_stopped_arg(request: Any) -> int:
    """Number of threads to be stopped for smart_start test.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# log_level_arg
###############################################################################
@pytest.fixture(params=log_level_arg_list)  # type: ignore
def log_level_arg(request: Any) -> int:
    """Type of deferred delete to do.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


# ###############################################################################
# # def_del_scenario_arg
# ###############################################################################
# @pytest.fixture(params=def_del_scenario_arg_list)  # type: ignore
# def def_del_scenario_arg(request: Any) -> DefDelScenario:
#     """Type of deferred delete to do.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(DefDelScenario, request.param)


###############################################################################
# conflict_deadlock_1_arg
###############################################################################
@pytest.fixture(params=conflict_deadlock_arg_list)  # type: ignore
def conflict_deadlock_1_arg(request: Any) -> ConflictDeadlockScenario:
    """Type of deferred delete to do.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(ConflictDeadlockScenario, request.param)


###############################################################################
# conflict_deadlock_2_arg
###############################################################################
@pytest.fixture(params=conflict_deadlock_arg_list2)  # type: ignore
def conflict_deadlock_2_arg(request: Any) -> ConflictDeadlockScenario:
    """Type of deferred delete to do.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(ConflictDeadlockScenario, request.param)


###############################################################################
# conflict_deadlock_3_arg
###############################################################################
@pytest.fixture(params=conflict_deadlock_arg_list3)  # type: ignore
def conflict_deadlock_3_arg(request: Any) -> ConflictDeadlockScenario:
    """Type of deferred delete to do.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(ConflictDeadlockScenario, request.param)


###############################################################################
# random_seed_arg
###############################################################################
random_seed_arg_list = [1, 2, 3]


@pytest.fixture(params=random_seed_arg_list)  # type: ignore
def random_seed_arg(request: Any) -> int:
    """Using different random seeds.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return request.param


###############################################################################
# num_threads_arg
###############################################################################
num_threads_arg_list = [3, 8, 16]


@pytest.fixture(params=num_threads_arg_list)  # type: ignore
def num_threads_arg(request: Any) -> int:
    """Number of threads to create.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return request.param


###############################################################################
# num_registered_1_arg
###############################################################################
@pytest.fixture(params=num_registered_1_arg_list)  # type: ignore
def num_registered_1_arg(request: Any) -> int:
    """Number of threads to configur as registered.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# num_active_1_arg
###############################################################################
@pytest.fixture(params=num_active_1_arg_list)  # type: ignore
def num_active_1_arg(request: Any) -> int:
    """Number of threads to configur as registered.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# num_stopped_1_arg
###############################################################################
@pytest.fixture(params=num_stopped_1_arg_list)  # type: ignore
def num_stopped_1_arg(request: Any) -> int:
    """Number of threads to configur as registered.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# num_registered_2_arg
###############################################################################
@pytest.fixture(params=num_registered_2_arg_list)  # type: ignore
def num_registered_2_arg(request: Any) -> int:
    """Number of threads to configur as registered.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# num_active_2_arg
###############################################################################
@pytest.fixture(params=num_active_2_arg_list)  # type: ignore
def num_active_2_arg(request: Any) -> int:
    """Number of threads to configur as registered.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# num_stopped_2_arg
###############################################################################
@pytest.fixture(params=num_stopped_2_arg_list)  # type: ignore
def num_stopped_2_arg(request: Any) -> int:
    """Number of threads to configur as registered.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# commander_config_arg
###############################################################################
@pytest.fixture(params=commander_config_arg_list)  # type: ignore
def commander_config_arg(request: Any) -> AppConfig:
    """Type of smart_send timeout to test.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(AppConfig, request.param)


###############################################################################
# timeout_type_arg
###############################################################################
@pytest.fixture(params=timeout_type_arg_list)  # type: ignore
def timeout_type_arg(request: Any) -> TimeoutType:
    """Type of smart_send timeout to test.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(TimeoutType, request.param)


###############################################################################
# num_senders_arg
###############################################################################
@pytest.fixture(params=num_senders_arg_list)  # type: ignore
def num_senders_arg(request: Any) -> int:
    """Number of threads to send msg.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# req0_arg
###############################################################################
@pytest.fixture(params=req0_arg_list)  # type: ignore
def req0_arg(request: Any) -> SmartRequestType:
    """State of sender when smart_recv is to be issued.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(SmartRequestType, request.param)


###############################################################################
# req1_arg
###############################################################################
@pytest.fixture(params=req1_arg_list)  # type: ignore
def req1_arg(request: Any) -> SmartRequestType:
    """State of sender when smart_recv is to be issued.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(SmartRequestType, request.param)


###############################################################################
# req0_when_req1_state_arg
###############################################################################
@pytest.fixture(params=req0_when_req1_state_arg_list)  # type: ignore
def req0_when_req1_state_arg(request: Any) -> tuple[st.ThreadState, int]:
    """State of sender when smart_recv is to be issued.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(tuple[st.ThreadState, int], request.param)


###############################################################################
# req0_when_req1_lap_arg
###############################################################################
@pytest.fixture(params=req0_when_req1_lap_arg_list)  # type: ignore
def req0_when_req1_lap_arg(request: Any) -> int:
    """Lap of sender when smart_recv is to be issued.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# req1_lap_arg
###############################################################################
@pytest.fixture(params=req1_lap_arg_list)  # type: ignore
def req1_lap_arg_arg(request: Any) -> int:
    """Lap of sender when smart_recv is to be issued.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# recv_msg_state_arg
###############################################################################
@pytest.fixture(params=recv_msg_state_arg_list)  # type: ignore
def recv_msg_state_arg(request: Any) -> tuple[st.ThreadState, int]:
    """State of sender when smart_recv is to be issued.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(tuple[st.ThreadState, int], request.param)


###############################################################################
# send_msg_state_arg
###############################################################################
# @pytest.fixture(params=send_msg_state_arg_list)  # type: ignore
# def send_msg_state_arg(request: Any) -> tuple[st.ThreadState, int]:
#     """State of sender when smart_recv is to be issued.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(tuple[st.ThreadState, int], request.param)


###############################################################################
# recv_msg_lap_arg
###############################################################################
@pytest.fixture(params=recv_msg_lap_arg_list)  # type: ignore
def recv_msg_lap_arg(request: Any) -> int:
    """Lap of sender when smart_recv is to be issued.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# send_msg_lap_arg
###############################################################################
@pytest.fixture(params=send_msg_lap_arg_list)  # type: ignore
def send_msg_lap_arg(request: Any) -> int:
    """Lap of sender when smart_recv is to be issued.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# send_resume_arg
###############################################################################
@pytest.fixture(params=send_resume_arg_list)  # type: ignore
def send_resume_arg(request: Any) -> str:
    """Specifies whether send or resume is to be tested.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(str, request.param)


###############################################################################
# wait_state_arg
###############################################################################
@pytest.fixture(params=wait_state_arg_list)  # type: ignore
def wait_state_arg(request: Any) -> st.ThreadState:
    """State of sender when smart_recv is to be issued.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(st.ThreadState, request.param)


###############################################################################
# recv_msg_lap_arg
###############################################################################
@pytest.fixture(params=wait_lap_arg_list)  # type: ignore
def wait_lap_arg(request: Any) -> int:
    """Lap of sender when smart_recv is to be issued.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# resume_lap_arg
###############################################################################
@pytest.fixture(params=resume_lap_arg_list)  # type: ignore
def resume_lap_arg(request: Any) -> int:
    """Lap of sender when smart_recv is to be issued.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# num_receivers_arg
###############################################################################
@pytest.fixture(params=num_receivers_arg_list)  # type: ignore
def num_receivers_arg(request: Any) -> int:
    """Number of threads to receive msgs.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# num_active_no_delay_senders_arg
###############################################################################
@pytest.fixture(params=num_active_no_delay_senders_arg_list)  # type: ignore
def num_active_no_delay_senders_arg(request: Any) -> int:
    """Number of threads to send msg immediately.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# num_active_delay_senders_arg
###############################################################################
@pytest.fixture(params=num_active_delay_senders_arg_list)  # type: ignore
def num_active_delay_senders_arg(request: Any) -> int:
    """Number of threads to send msg after a delay.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# num_senders_exit_before_arg
###############################################################################
@pytest.fixture(params=num_send_exit_senders_arg_list)  # type: ignore
def num_send_exit_senders_arg(request: Any) -> int:
    """Number of threads to send msg and then exit.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


########################################################################
# num_senders_exit_before_arg
########################################################################
@pytest.fixture(params=num_nosend_exit_senders_arg_list)  # type: ignore
def num_nosend_exit_senders_arg(request: Any) -> int:
    """Number of threads to exit and send msg after create (resurrect).

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# num_unreg_senders_arg
###############################################################################
@pytest.fixture(params=num_unreg_senders_arg_list)  # type: ignore
def num_unreg_senders_arg(request: Any) -> int:
    """Number of threads to be unregistered and send msg after create.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# num_reg_senders_arg
###############################################################################
@pytest.fixture(params=num_reg_senders_arg_list)  # type: ignore
def num_reg_senders_arg(request: Any) -> int:
    """Number of threads to be registered and send msg after start.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# num_active_targets_arg
###############################################################################
@pytest.fixture(params=num_active_targets_arg_list)  # type: ignore
def num_active_targets_arg(request: Any) -> int:
    """Number of threads to be active at time of send.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# num_registered_targets_arg
###############################################################################
@pytest.fixture(params=num_registered_targets_arg_list)  # type: ignore
def num_registered_targets_arg(request: Any) -> int:
    """Number of threads to be registered at time of send.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


########################################################################
# num_exit_timeouts_arg
########################################################################
@pytest.fixture(params=num_exit_timeouts_arg_list)  # type: ignore
def num_exit_timeouts_arg(request: Any) -> int:
    """Number of threads to exit before msg is sent.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


########################################################################
# num_unreg_timeouts_arg
########################################################################
@pytest.fixture(params=num_unreg_timeouts_arg_list)  # type: ignore
def num_unreg_timeouts_arg(request: Any) -> int:
    """Number of threads to be unregistered at time of send.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


########################################################################
# num_full_q_timeouts_arg
########################################################################
@pytest.fixture(params=num_full_q_timeouts_arg_list)  # type: ignore
def num_full_q_timeouts_arg(request: Any) -> int:
    """Number of threads to have full queue at time of send.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# recv_msg_after_join_arg
###############################################################################
recv_msg_after_join_arg_list = [1, 2, 3]


@pytest.fixture(params=recv_msg_after_join_arg_list)  # type: ignore
def recv_msg_after_join_arg(request: Any) -> int:
    """Which threads should exit before alpha recvs msg.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return request.param


###############################################################################
# timeout_arg fixtures
###############################################################################
timeout_arg_list = [None, 'TO_False', 'TO_True']


@pytest.fixture(params=timeout_arg_list)  # type: ignore
def timeout_arg1(request: Any) -> Any:
    """Using different requests.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return request.param


@pytest.fixture(params=timeout_arg_list)  # type: ignore
def timeout_arg2(request: Any) -> Any:
    """Using different requests.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return request.param


# ###############################################################################
# # num_resumers_arg
# ###############################################################################
# @pytest.fixture(params=num_resumers_arg_list)  # type: ignore
# def num_resumers_arg(request: Any) -> int:
#     """Number of threads the do resumes.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
#
# ###############################################################################
# # num_start_before_arg
# ###############################################################################
# @pytest.fixture(params=num_start_before_arg_list)  # type: ignore
# def num_start_before_arg(request: Any) -> int:
#     """Number of threads the do resumes.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
#
# ###############################################################################
# # num_unreg_before_arg
# ###############################################################################
# @pytest.fixture(params=num_unreg_before_arg_list)  # type: ignore
# def num_unreg_before_arg(request: Any) -> int:
#     """Number of threads the do resumes.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
#
# ###############################################################################
# # num_stop_before_arg
# ###############################################################################
# @pytest.fixture(params=num_stop_before_arg_list)  # type: ignore
# def num_stop_before_arg(request: Any) -> int:
#     """Number of threads the do resumes.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
#
# ###############################################################################
# # num_started_after_arg
# ###############################################################################
# @pytest.fixture(params=num_started_after_arg_list)  # type: ignore
# def num_started_after_arg(request: Any) -> int:
#     """Number of threads the do resumes.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
#
# ###############################################################################
# # num_started_delay_arg
# ###############################################################################
# @pytest.fixture(params=num_started_delay_arg_list)  # type: ignore
# def num_started_delay_arg(request: Any) -> int:
#     """Number of threads the do resumes.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
#
# ###############################################################################
# # num_unreg_after_arg
# ###############################################################################
# @pytest.fixture(params=num_unreg_after_arg_list)  # type: ignore
# def num_unreg_after_arg(request: Any) -> int:
#     """Number of threads the do resumes.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
#
# ###############################################################################
# # num_stop_after_ok_arg
# ###############################################################################
# @pytest.fixture(params=num_stop_after_ok_arg_list)  # type: ignore
# def num_stop_after_ok_arg(request: Any) -> int:
#     """Number of threads the do resumes.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
#
# ###############################################################################
# # num_stop_after_err_arg
# ###############################################################################
# @pytest.fixture(params=num_stop_after_err_arg_list)  # type: ignore
# def num_stop_after_err_arg(request: Any) -> int:
#     """Number of threads the do resumes.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
# ###############################################################################
# # num_active_arg
# ###############################################################################
# @pytest.fixture(params=num_active_arg_list)  # type: ignore
# def num_active_arg(request: Any) -> int:
#     """Number of active threads.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
#
# ###############################################################################
# # num_registered_before_arg
# ###############################################################################
# @pytest.fixture(params=num_registered_before_arg_list)  # type: ignore
# def num_registered_before_arg(request: Any) -> int:
#     """Number opf registered threads.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
#
# ###############################################################################
# # num_registered_after_arg
# ###############################################################################
# @pytest.fixture(params=num_registered_after_arg_list)  # type: ignore
# def num_registered_after_arg(request: Any) -> int:
#     """Number opf registered threads.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
#
# ###############################################################################
# # num_unreg_no_delay_arg
# ###############################################################################
# @pytest.fixture(params=num_unreg_no_delay_arg_list)  # type: ignore
# def num_unreg_no_delay_arg(request: Any) -> int:
#     """Number unregistered threads quickly created and started.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
# ###############################################################################
# # num_unreg_delay_arg
# ###############################################################################
# @pytest.fixture(params=num_unreg_delay_arg_list)  # type: ignore
# def num_unreg_delay_arg(request: Any) -> int:
#     """Number unregistered threads slowly created and started.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
#
# ###############################################################################
# # num_stopped_no_delay_arg
# ###############################################################################
# @pytest.fixture(params=num_stopped_no_delay_arg_list)  # type: ignore
# def num_stopped_no_delay_arg(request: Any) -> int:
#     """Number stopped threads.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
#
# ###############################################################################
# # num_stopped_delay_arg
# ###############################################################################
# @pytest.fixture(params=num_stopped_delay_arg_list)  # type: ignore
# def num_stopped_delay_arg(request: Any) -> int:
#     """Number stopped threads quickly joined, created, and started.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)


########################################################################
# num_waiters_arg
########################################################################
@pytest.fixture(params=num_waiters_arg_list)  # type: ignore
def num_waiters_arg(request: Any) -> int:
    """Number stopped threads quickly joined, created, and started.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


########################################################################
# num_syncers_arg
########################################################################
@pytest.fixture(params=num_syncers_arg_list)  # type: ignore
def num_syncers_arg(request: Any) -> int:
    """Number stopped threads quickly joined, created, and started.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


########################################################################
# num_stopped_syncers_arg
########################################################################
@pytest.fixture(params=num_stopped_syncers_arg_list)  # type: ignore
def num_stopped_syncers_arg(request: Any) -> int:
    """Number stopped threads quickly joined, created, and started.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


########################################################################
# num_timeout_syncers_arg
########################################################################
@pytest.fixture(params=num_timeout_syncers_arg_list)  # type: ignore
def num_timeout_syncers_arg(request: Any) -> int:
    """Number stopped threads quickly joined, created, and started.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


########################################################################
# num_actors_arg
########################################################################
@pytest.fixture(params=num_actors_arg_list)  # type: ignore
def num_actors_arg(request: Any) -> int:
    """Number stopped threads quickly joined, created, and started.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


########################################################################
# num_cd_actors_arg
########################################################################
@pytest.fixture(params=num_cd_actors_arg_list)  # type: ignore
def num_cd_actors_arg(request: Any) -> int:
    """Number stopped threads quickly joined, created, and started.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


########################################################################
# actor_1_arg
########################################################################
@pytest.fixture(params=actor_1_arg_list)  # type: ignore
def actor_1_arg(request: Any) -> Actors:
    """Type of actor tpo perfom the cmd.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(Actors, request.param)


########################################################################
# num_actor_1_arg
########################################################################
@pytest.fixture(params=num_actor_1_arg_list)  # type: ignore
def num_actor_1_arg(request: Any) -> int:
    """Number of actors for actor style 1.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


########################################################################
# actor_2_arg
########################################################################
@pytest.fixture(params=actor_2_arg_list)  # type: ignore
def actor_2_arg(request: Any) -> Actors:
    """Type of actor tpo perfom the cmd.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(Actors, request.param)


########################################################################
# num_actor_2_arg
########################################################################
@pytest.fixture(params=num_actor_2_arg_list)  # type: ignore
def num_actor_2_arg(request: Any) -> int:
    """Number of actors for actor style 1.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


########################################################################
# actor_3_arg
########################################################################
@pytest.fixture(params=actor_3_arg_list)  # type: ignore
def actor_3_arg(request: Any) -> Actors:
    """Type of actor tpo perfom the cmd.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(Actors, request.param)


########################################################################
# num_actor_3_arg
########################################################################
@pytest.fixture(params=num_actor_3_arg_list)  # type: ignore
def num_actor_3_arg(request: Any) -> int:
    """Number of actors for actor style 1.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


# ########################################################################
# # num_active_no_delay_resumers_arg
# ########################################################################
# @pytest.fixture(params=num_active_no_delay_resumers_arg_list)  # type: ignore
# def num_active_no_delay_resumers_arg(request: Any) -> int:
#     """Number stopped threads quickly joined, created, and started.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
#
# ########################################################################
# # num_active_delay_resumers_arg
# ########################################################################
# @pytest.fixture(params=num_active_delay_resumers_arg_list)  # type: ignore
# def num_active_delay_resumers_arg(request: Any) -> int:
#     """Number stopped threads quickly joined, created, and started.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
#
# ########################################################################
# # num_resume_exit_arg
# ########################################################################
# @pytest.fixture(params=num_resume_exit_arg_list)  # type: ignore
# def num_resume_exit_arg(request: Any) -> int:
#     """Number stopped threads quickly joined, created, and started.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
#
# ########################################################################
# # num_noresume_exit_arg
# ########################################################################
# @pytest.fixture(params=num_noresume_exit_arg_list)  # type: ignore
# def num_noresume_exit_arg(request: Any) -> int:
#     """Number stopped threads quickly joined, created, and started.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
#
# ########################################################################
# # num_unreg_resumers_arg
# ########################################################################
# @pytest.fixture(params=num_unreg_resumers_arg_list)  # type: ignore
# def num_unreg_resumers_arg(request: Any) -> int:
#     """Number stopped threads quickly joined, created, and started.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)
#
#
# ########################################################################
# # num_reg_resumers_arg
# ########################################################################
# @pytest.fixture(params=num_reg_resumers_arg_list)  # type: ignore
# def num_reg_resumers_arg(request: Any) -> int:
#     """Number stopped threads quickly joined, created, and started.
#
#     Args:
#         request: special fixture that returns the fixture params
#
#     Returns:
#         The params values are returned one at a time
#     """
#     return cast(int, request.param)


###############################################################################
# code fixtures
###############################################################################
code_arg_list = [None, 42]


@pytest.fixture(params=code_arg_list)  # type: ignore
def code_arg1(request: Any) -> Any:
    """Using different codes.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


@pytest.fixture(params=code_arg_list)  # type: ignore
def code_arg2(request: Any) -> Any:
    """Using different codes.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# log_msg fixtures
###############################################################################
log_msg_arg_list = [None, 'log msg1']


@pytest.fixture(params=log_msg_arg_list)  # type: ignore
def log_msg_arg1(request: Any) -> Any:
    """Using different log messages.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


@pytest.fixture(params=log_msg_arg_list)  # type: ignore
def log_msg_arg2(request: Any) -> Any:
    """Using different log messages.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(int, request.param)


###############################################################################
# log_enabled fixtures
###############################################################################
log_enabled_list = [True, False]


@pytest.fixture(params=log_enabled_list)  # type: ignore
def log_enabled_arg(request: Any) -> bool:
    """Using different log messages.

    Args:
        request: special fixture that returns the fixture params

    Returns:
        The params values are returned one at a time
    """
    return cast(bool, request.param)


########################################################################
# F1CreateItem
########################################################################
@dataclass
class F1CreateItem:
    """Class that has infor for f1 create."""
    name: str
    auto_start: bool
    target_rtn: Callable[..., Any]
    app_config: AppConfig = AppConfig.ScriptStyle


########################################################################
# TestSmartThreadLogMsgs class
########################################################################
@dataclass
class ThreadTracker:
    """Class that tracks each thread."""
    thread: Optional[st.SmartThread]
    is_alive: bool
    exiting: bool
    is_auto_started: bool
    is_TargetThread: bool
    exp_init_is_alive: bool
    thread_create: st.ThreadCreate
    exp_init_thread_state: st.ThreadState
    auto_start_decision: AutoStartDecision
    st_state: st.ThreadState
    found_del_pairs: dict[tuple[str, str, str], int]
    stopped_by: str = ''


@dataclass
class ThreadPairStatus:
    """Class that keeps pair status."""
    reset_ops_count: bool
    pending_request: bool = False
    pending_msg_count: int = 0
    pending_wait: bool = False
    pending_sync: bool = False


@dataclass
class MonitorAddItem:
    """Class keeps track of threads to add, start, delete, unreg."""
    cmd_runner: str
    thread_alive: bool
    auto_start: bool
    is_ThreadTarget: bool
    expected_state: st.ThreadState


@dataclass
class UpaItem:
    """Update pair_array item."""
    upa_cmd_runner: str
    upa_type: str
    upa_target: str
    upa_def_del_name: str
    upa_process: str


@dataclass
class MonitorEventItem:
    """Class keeps track of threads to add, start, delete, unreg."""
    client_event: threading.Event
    targets: set[str]
    deferred_post_needed: bool = False


hour_match = '([01][0-9]|20|21|22|23)'
min_sec_match = '[0-5][0-9]'
micro_sec_match = '[0-9]{6,6}'
time_match = (fr'{hour_match}:{min_sec_match}:{min_sec_match}\.'
              f'{micro_sec_match}')

list_of_thread_states = ('(ThreadState.Unregistered'
                         '|ThreadState.Initializing'
                         '|ThreadState.Registered'
                         '|ThreadState.Starting'
                         '|ThreadState.Alive'
                         '|ThreadState.Stopped)')

list_of_smart_requests = ('(smart_init'
                          '|smart_start'
                          '|smart_unreg'
                          '|smart_join'
                          '|smart_send'
                          '|smart_recv'
                          '|smart_wait'
                          '|smart_resume'
                          '|smart_sync)')

list_of_sub_processes = ('(_register'
                         '|_clean_registry'
                         '|_clean_pair_array'
                         '|_add_to_pair_array)')


########################################################################
# LogSearchItem
########################################################################
class LogSearchItem(ABC):
    """Input to search log msgs."""
    def __init__(self,
                 search_str: str,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            search_str: regex style search string
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        self.search_pattern = re.compile(search_str)
        self.config_ver: "ConfigVerifier" = config_ver
        self.found_log_msg = found_log_msg
        self.found_log_idx = found_log_idx

    @abstractmethod
    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int) -> "LogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            LogFoundItem containing found message and index
        """
        pass

    @abstractmethod
    def run_process(self) -> None:
        """Run the process to handle the log message."""
        pass


########################################################################
# RequestEntryExitLogSearchItem
########################################################################
class RequestEntryExitLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(f"{list_of_smart_requests} (entry|exit): "
                        r"requestor: [a-z0-9_]+, targets: \[([a-z0-9_]*|,|'| )*\]"),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int
                           ) -> "RequestEntryExitLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return RequestEntryExitLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        request_name = split_msg[0]
        entry_exit = split_msg[1][0:-1]  # remove colon
        cmd_runner = split_msg[3][0:-1]  # remove comma
        target_msg = self.found_log_msg.split('[')[1].split(']')[0].split(', ')

        targets: list[str] = []
        for item in target_msg:
            targets.append(item[1:-1])

        if not targets:
            targets = ['']

        self.config_ver.handle_request_entry_exit_log_msg(
            cmd_runner=cmd_runner,
            request_name=request_name,
            entry_exit=entry_exit,
            targets=targets,
            log_msg=self.found_log_msg)


########################################################################
# SubProcessEntryExitLogSearchItem
########################################################################
class SubProcessEntryExitLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(f"{list_of_smart_requests} {list_of_sub_processes} "
                        "(entry|exit): cmd_runner: [a-z0-9_]+(, target: [a-z0-9_]+)*"),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int
                           ) -> "SubProcessEntryExitLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return SubProcessEntryExitLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        request_name = split_msg[0]
        subprocess_name = split_msg[1]
        entry_exit = split_msg[2][0:-1]  # remove trailing colon
        cmd_runner = split_msg[4]
        if split_msg[-2] == 'target:':
            cmd_runner = cmd_runner[0:-1]  # remove trailing comma
        target = split_msg[-1]

        if subprocess_name == '_clean_registry':
            self.config_ver.last_clean_reg_msg_idx = self.found_log_idx

        self.config_ver.handle_subprocess_entry_exit_log_msg(
            cmd_runner=cmd_runner,
            request_name=request_name,
            subprocess_name=subprocess_name,
            entry_exit=entry_exit,
            target=target,
            log_msg=self.found_log_msg)


########################################################################
# SetStateLogSearchItem
########################################################################
class SetStateLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=('[a-z0-9_]+ set state for thread [a-z0-9_]+ from '
                        f'{list_of_thread_states} to {list_of_thread_states}'),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int) -> "SetStateLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SetStateLogSearchItem containing found message and index
        """
        return SetStateLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[0]
        target_name = split_msg[5]
        from_state_str = split_msg[7]
        to_state_str = split_msg[9]

        from_state = eval('st.' + from_state_str)
        to_state = eval('st.' + to_state_str)

        self.config_ver.handle_set_state_log_msg(cmd_runner=cmd_runner,
                                                 target=target_name,
                                                 from_state=from_state,
                                                 to_state=to_state,
                                                 log_msg=self.found_log_msg)


########################################################################
# InitCompleteLogSearchItem
########################################################################
class InitCompleteLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        list_of_thread_creates = ('(ThreadCreate.Current'
                                  '|ThreadCreate.Target'
                                  '|ThreadCreate.Thread)')

        list_of_auto_start_texts = ('(auto_start obviated'
                                    '|auto_start will proceed'
                                    '|auto_start not requested)')
        super().__init__(
            search_str=('[a-z0-9_]+ completed initialization of [a-z0-9_]+: '
                        f'{list_of_thread_creates}, '
                        f'{list_of_thread_states}, '
                        f'{list_of_auto_start_texts}.'),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int) -> "InitCompleteLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            InitCompleteLogSearchItem containing found message and index
        """
        return InitCompleteLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[0]
        target_name = split_msg[4][0:-1]
        create_text = split_msg[5][0:-1]
        state_text = split_msg[6][0:-1]

        thread_create = eval('st.' + create_text)
        thread_state = eval('st.' + state_text)

        if (init_complete_text_units[AutoStartDecision.auto_start_obviated]
                in self.found_log_msg):
            auto_start = AutoStartDecision.auto_start_obviated
        elif (init_complete_text_units[AutoStartDecision.auto_start_yes]
                in self.found_log_msg):
            auto_start = AutoStartDecision.auto_start_yes
        elif (init_complete_text_units[AutoStartDecision.auto_start_no]
                in self.found_log_msg):
            auto_start = AutoStartDecision.auto_start_no
        else:
            raise InvalidInputDetected(
                'InitCompleteLogSearchItem encountered log msg with '
                f'unknown auto_start text: {self.found_log_msg}')

        pe = self.config_ver.pending_events[cmd_runner]

        comp_key: InitCompKey = (target_name,
                                 thread_create,
                                 thread_state,
                                 auto_start)

        if pe[PE.init_comp_msg][comp_key] <= 0:
            raise UnexpectedEvent(
                f'InitCompleteLogSearchItem using {comp_key=} encountered '
                f'unexpected log message: {self.found_log_msg}')

        pe[PE.init_comp_msg][comp_key] -= 1

        self.config_ver.add_log_msg(re.escape(self.found_log_msg),
                                    log_level=logging.INFO)


########################################################################
# F1AppExitLogSearchItem
########################################################################
class F1AppExitLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        list_of_thread_apps = (r'(OuterF1ThreadApp.run\(\)'
                               '|outer_f1)')
        super().__init__(
            # search_str=r'OuterF1ThreadApp.run\(\) exit: [a-z0-9_]+',
            search_str=f'{list_of_thread_apps} exit: [a-z0-9_]+',
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int) -> "F1AppExitLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            F1AppExitLogSearchItem containing found message and index
        """
        return F1AppExitLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        target = split_msg[2]

        self.config_ver.expected_registered[target].is_alive = False

        self.config_ver.last_thread_stop_msg_idx[target] = self.found_log_idx

        # self.config_ver.log_test_msg(
        #     f'F1AppExitLogSearchItem set {target} is_alive to False')

        # self.config_ver.add_log_msg(re.escape(self.found_log_msg))


########################################################################
# AlreadyUnregLogSearchItem
########################################################################
class AlreadyUnregLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=('[a-z0-9_]+ determined that thread [a-z0-9_]+ is already in '
                        'state ThreadState.Unregistered'),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int) -> "AlreadyUnregLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            AlreadyUnregLogSearchItem containing found message and index
        """
        return AlreadyUnregLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[0]
        target = split_msg[4]

        pe = self.config_ver.pending_events[cmd_runner]
        unreg_key: AlreadyUnregKey = (cmd_runner, target)
        if pe[PE.already_unreg_msg][unreg_key] <= 0:
            raise UnexpectedEvent(
                f'AlreadyUnregLogSearchItem using {unreg_key=} encountered '
                f'unexpected log message: {self.found_log_msg}')

        pe[PE.already_unreg_msg][unreg_key] -= 1

        self.config_ver.add_log_msg(re.escape(self.found_log_msg))


########################################################################
# AddRegEntryLogSearchItem
########################################################################
class AddRegEntryLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(f'[a-z0-9_]+ added [a-z0-9_]+ to SmartThread registry at UTC '
                        f'{time_match}'),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int) -> "AddRegEntryLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            AddRegEntryLogSearchItem containing found message and index
        """
        return AddRegEntryLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        self.config_ver.handle_add_reg_log_msg(
            cmd_runner=split_msg[0],
            target=split_msg[2],
            log_msg=self.found_log_msg)


########################################################################
# AddPairArrayEntryLogSearchItem
########################################################################
class AddPairArrayEntryLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=("[a-z0-9_]+ added "
                        r"PairKey\(name0='[a-z0-9_]+', name1='[a-z0-9_]+'\) to the "
                        "_pair_array"),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int
                           ) -> "AddPairArrayEntryLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            AddPairArrayEntryLogSearchItem containing found message and index
        """
        return AddPairArrayEntryLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[0]
        name_0 = split_msg[2][15:-2]  # lose left paren, comma, quotes
        name_1 = split_msg[3][7:-2]  # lose right paren, quotes
        pair_key: st.PairKey = st.PairKey(name_0, name_1)
        self.config_ver.handle_add_pair_array_log_msg(
            cmd_runner=cmd_runner,
            pair_key=pair_key,
            log_msg=self.found_log_msg)


########################################################################
# AddStatusBlockEntryLogSearchItem
########################################################################
class AddStatusBlockEntryLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=("[a-z0-9_]+ added status_blocks entry for "
                        r"PairKey\(name0='[a-z0-9_]+', name1='[a-z0-9_]+'\), "
                        "name = [a-z0-9_]+"),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int
                           ) -> "AddStatusBlockEntryLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            AddStatusBlockEntryLogSearchItem containing found message and index
        """
        return AddStatusBlockEntryLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[0]
        name_0 = split_msg[5][15:-2]  # lose left paren, comma, quotes
        name_1 = split_msg[6][7:-3]  # lose right paren, quotes
        target = split_msg[9]
        pair_key: st.PairKey = st.PairKey(name_0, name_1)
        self.config_ver.handle_add_status_block_log_msg(
            cmd_runner=cmd_runner,
            pair_key=pair_key,
            target=target,log_msg=self.found_log_msg)


########################################################################
# UpdatePairArrayUtcLogSearchItem
########################################################################
class UpdatePairArrayUtcLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=f'[a-z0-9_]+ updated _pair_array at UTC {time_match}',
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int
                           ) -> "UpdatePairArrayUtcLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            UpdatePairArrayUtcLogSearchItem containing found message and index
        """
        return UpdatePairArrayUtcLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        cmd_runner = self.found_log_msg.split(maxsplit=1)[0]

        pe = self.config_ver.pending_events[cmd_runner]
        if pe[PE.update_pair_array_utc_msg] <= 0:
            raise UnexpectedEvent(
                'UpdatePairArrayUtcLogSearchItem encountered unexpected '
                f'log message: {self.found_log_msg}')

        pe[PE.update_pair_array_utc_msg] -= 1

        self.config_ver.add_log_msg(re.escape(self.found_log_msg))


########################################################################
# RegistryStatusLogSearchItem
########################################################################
class RegistryStatusLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=('name=[a-z0-9_]+, is_alive=(True|False), '
                        f'state={list_of_thread_states}, smart_thread='),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int
                           ) -> "RegistryStatusLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            RegistryStatusLogSearchItem containing found message and index
        """
        return RegistryStatusLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        target = split_msg[0][5:-1]
        is_alive = eval(split_msg[1][9:-1])
        state = eval('st.' + split_msg[2][6:-1])

        if self.config_ver.pending_events[
                target][PE.status_msg][(is_alive, state)] <= 0:
            if (not is_alive
                    and (self.config_ver.last_clean_reg_msg_idx
                         < self.config_ver.last_thread_stop_msg_idx[target])):
                if self.config_ver.pending_events[
                        target][PE.status_msg][
                        (True, st.ThreadState.Alive)] <= 0:
                    raise UnexpectedEvent(
                        f'RegistryStatusLogSearchItem 1 using '
                        f'{(True, st.ThreadState.Alive)} encountered '
                        f'unexpected log message: {self.found_log_msg}')
                else:
                    self.config_ver.pending_events[
                        target][PE.status_msg][
                        (True, st.ThreadState.Alive)] -= 1
            else:
                raise UnexpectedEvent(
                    f'RegistryStatusLogSearchItem 2 using {(is_alive, state)} '
                    f'encountered unexpected log message: '
                    f'{self.found_log_msg}')

        else:
            self.config_ver.pending_events[
                target][PE.status_msg][(is_alive, state)] -= 1

        self.config_ver.add_log_msg(re.escape(self.found_log_msg))


########################################################################
# RemRegEntryLogSearchItem
########################################################################
class RemRegEntryLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=("[a-z0-9_]+ removed [a-z0-9_]+ from registry for "
                        f"request {list_of_smart_requests}"),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int) -> "RemRegEntryLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            RemRegEntryLogSearchItem containing found message and index
        """
        return RemRegEntryLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[0]
        rem_name = split_msg[2]
        process = split_msg[7]

        self.config_ver.handle_rem_reg_log_msg(cmd_runner=cmd_runner,
                                               rem_name=rem_name,
                                               process=process,
                                               log_msg=self.found_log_msg)


########################################################################
# DidCleanRegLogSearchItem
########################################################################
class DidCleanRegLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(f"[a-z0-9_]+ did cleanup of registry at UTC {time_match}, "
                        r"deleted \[('[a-z0-9_]+'|, )+\]"),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int) -> "DidCleanRegLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            DidCleanRegLogSearchItem containing found message and index
        """
        return DidCleanRegLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[0]
        target_msg = self.found_log_msg.split('[')[1].split(']')[0].split(', ')

        targets: list[str] = []
        for item in target_msg:
            targets.append(item[1:-1])

        self.config_ver.handle_did_clean_reg_log_msg(
            cmd_runner=cmd_runner,
            targets=targets,
            log_msg=self.found_log_msg)


########################################################################
# RemStatusBlockEntryLogSearchItem
########################################################################
class RemStatusBlockEntryLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        list_of_extras = ('(, with non-empty msg_q'
                          '|, with wait event set'
                          '|, with sync event set)*')
        super().__init__(
            search_str=("[a-z0-9_]+ removed status_blocks entry for "
                        r"PairKey\(name0='[a-z0-9_]+', name1='[a-z0-9_]+'\), "
                        f"name = [a-z0-9_]+{list_of_extras}"),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int
                           ) -> "RemStatusBlockEntryLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return RemStatusBlockEntryLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[0]
        name_0 = split_msg[5][15:-2]  # lose left paren, comma, quotes
        name_1 = split_msg[6][7:-3]  # lose right paren, quotes
        rem_name = split_msg[9]

        pair_key: st.PairKey = st.PairKey(name_0, name_1)

        pending_msg = pending_wait = pending_sync = False
        if ', with non-empty msg_q' in self.found_log_msg:
            pending_msg = True
        if ', with wait event set' in self.found_log_msg:
            pending_wait = True
        if ', with sync event set' in self.found_log_msg:
            pending_sync = True

        if pending_msg or pending_wait or pending_sync:
            rem_name = rem_name[0:-1]

        pe = self.config_ver.pending_events[cmd_runner]

        def_del_reasons: DefDelReasons = DefDelReasons(
            pending_request=False,
            pending_msg=pending_msg,
            pending_wait=pending_wait,
            pending_sync=pending_sync)

        rem_sb_key: RemSbKey = (rem_name,
                                pair_key,
                                def_del_reasons)
        # self.config_ver.log_test_msg(
        #     'RemStatusBlockEntryLogSearchItem about to check '
        #     f'{pe[PE.rem_status_block_msg][rem_sb_key]=} for '
        #     f'{cmd_runner=}, {rem_sb_key=}'
        # )
        if pe[PE.rem_status_block_msg][rem_sb_key] <= 0:
            self.config_ver.log_test_msg(
                f'RemStatusBlockEntryLogSearchItem using {rem_sb_key=} '
                'encountered unexpected '
                f'log msg: {self.found_log_msg}')
            raise UnexpectedEvent(
                f'RemStatusBlockEntryLogSearchItem using {rem_sb_key=} '
                f'encountered unexpected log msg: {self.found_log_msg}')

        pe[PE.rem_status_block_msg][rem_sb_key] -= 1

        if pe[PE.notify_rem_status_block_msg][rem_sb_key] > 0:
            pe[PE.notify_rem_status_block_msg][rem_sb_key] -= 1

        # self.config_ver.log_test_msg(
        #     'RemStatusBlockEntryLogSearchItem decremented: new value: '
        #     f'{pe[PE.rem_status_block_msg][rem_sb_key]=} for '
        #     f'{cmd_runner=}, {rem_sb_key=}'
        # )

        self.config_ver.add_log_msg(re.escape(self.found_log_msg),
                                    log_level=logging.DEBUG)


########################################################################
# RemStatusBlockEntryDefLogSearchItem
########################################################################
class RemStatusBlockEntryDefLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str="[a-z0-9_]+ removal deferred for status_blocks entry "
                       r"for PairKey\(name0='[a-z0-9_]+', name1='[a-z0-9_]+'\), "
                       "name = [a-z0-9_]+, reasons: ",
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int
                           ) -> "RemStatusBlockEntryDefLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return RemStatusBlockEntryDefLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[0]
        name_0 = split_msg[7][15:-2]  # lose left paren, comma, quotes
        name_1 = split_msg[8][7:-3]  # lose right paren, quotes
        rem_name = split_msg[11][0:-1]

        pair_key: st.PairKey = st.PairKey(name_0, name_1)

        pending_request = pending_msg = pending_wait = pending_sync = False
        idx = -1
        while split_msg[idx] != 'reasons:':
            if split_msg[idx] in ('set', 'set,'):
                if split_msg[idx-2] == 'sync':
                    pending_sync = True
                    idx -= 3
                elif split_msg[idx-2] == 'wait':
                    pending_wait = True
                    idx -= 3
            elif split_msg[idx] in ('msg_q', 'msg_q,'):
                pending_msg = True
                idx -= 2
            elif split_msg[idx] in ('request', 'request,'):
                pending_request = True
                idx -= 2

        pe = self.config_ver.pending_events[cmd_runner]
        def_del_reasons: DefDelReasons = DefDelReasons(
            pending_request=pending_request,
            pending_msg=pending_msg,
            pending_wait=pending_wait,
            pending_sync=pending_sync)

        rem_sb_key: RemSbKey = (rem_name,
                                pair_key,
                                def_del_reasons)

        if pe[PE.rem_status_block_def_msg][rem_sb_key] <= 0:
            raise UnexpectedEvent(
                f'RemStatusBlockEntryDefLogSearchItem using {rem_sb_key=} '
                f'encountered unexpected log msg: {self.found_log_msg}')

        pe[PE.rem_status_block_def_msg][rem_sb_key] -= 1

        if pe[PE.notify_rem_status_block_def_msg][rem_sb_key] > 0:
            pe[PE.notify_rem_status_block_def_msg][rem_sb_key] -= 1

        self.config_ver.add_log_msg(re.escape(self.found_log_msg),
                                    log_level=logging.DEBUG)


########################################################################
# RemPairArrayEntryLogSearchItem
########################################################################
class RemPairArrayEntryLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=("[a-z0-9_]+ removed _pair_array entry for "
                        r"PairKey\(name0='[a-z0-9_]+', name1='[a-z0-9_]+'\)"),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int
                           ) -> "RemPairArrayEntryLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            RemPairArrayEntryLogSearchItem containing found message and index
        """
        return RemPairArrayEntryLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[0]
        name_0 = split_msg[5][15:-2]  # lose left paren, comma, quotes
        name_1 = split_msg[6][7:-2]  # lose right paren, quotes
        pair_key: st.PairKey = st.PairKey(name_0, name_1)

        pe = self.config_ver.pending_events[cmd_runner]
        rem_pae_key: RemPaeKey = (cmd_runner, pair_key)

        if pe[PE.rem_pair_array_entry_msg][rem_pae_key] <= 0:
            raise UnexpectedEvent(
                f'RemPairArrayEntryLogSearchItem using {rem_pae_key=}'
                'encountered unexpected '
                f'log message: {self.found_log_msg}')

        pe[PE.rem_pair_array_entry_msg][rem_pae_key] -= 1

        self.config_ver.add_log_msg(re.escape(self.found_log_msg))


########################################################################
# DidCleanPairArrayUtcLogSearchItem
########################################################################
class DidCleanPairArrayUtcLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=('[a-z0-9_]+ did cleanup of _pair_array at UTC '
                        f'{time_match}'),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int
                           ) -> "DidCleanPairArrayUtcLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            DidCleanPairArrayUtcLogSearchItem containing found message and index
        """
        return DidCleanPairArrayUtcLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        cmd_runner = self.found_log_msg.split(maxsplit=1)[0]

        pe = self.config_ver.pending_events[cmd_runner]
        # self.config_ver.log_test_msg(
        #     'DidCleanPairArrayUtcLogSearchItem for '
        #     f'{cmd_runner=} checking '
        #     f'{pe[PE.did_cleanup_pair_array_utc_msg]=}')
        if pe[PE.did_cleanup_pair_array_utc_msg] <= 0:
            raise UnexpectedEvent(
                'DidCleanPairArrayUtcLogSearchItem encountered unexpected '
                f'log message: {self.found_log_msg}')

        pe[PE.did_cleanup_pair_array_utc_msg] -= 1

        self.config_ver.add_log_msg(re.escape(self.found_log_msg))


########################################################################
# RequestAckLogSearchItem
########################################################################
class RequestAckLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        phrases = {
            'smart_send': 'smart_send sent message to',
            'smart_recv': 'smart_recv received msg from',
            'smart_wait': 'smart_wait resumed by',
            'smart_resume': 'smart_resume resumed',
            'smart_sync': 'smart_sync achieved with'
        }
        list_of_acks = ('(smart_send sent message to'
                        '|smart_recv received msg from'
                        '|smart_wait resumed by'
                        '|smart_resume resumed'
                        '|smart_sync set event for'
                        '|smart_sync backout reset local sync_event for'
                        '|smart_sync backout reset remote sync_event for'
                        '|smart_sync achieved with)')
        super().__init__(
            search_str=f"[a-z0-9_]+ {list_of_acks} [a-z0-9_]+",
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int
                           ) -> "RequestAckLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return RequestAckLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[0]
        request = split_msg[1]
        action = split_msg[2]
        remote = split_msg[-1]

        pe = self.config_ver.pending_events[cmd_runner]

        ack_key: AckKey = (remote, request)

        if request == 'smart_send':
            self.config_ver.set_msg_pending_count(receiver=remote,
                                                  sender=cmd_runner,
                                                  pending_msg_adj=1)
        elif request == 'smart_recv':
            self.config_ver.set_msg_pending_count(receiver=cmd_runner,
                                                  sender=remote,
                                                  pending_msg_adj=0)
        elif request == 'smart_wait':
            self.config_ver.set_wait_pending_flag(waiter=cmd_runner,
                                                  resumer=remote,
                                                  pending_wait_flag=False)
        elif request == 'smart_resume':
            self.config_ver.set_wait_pending_flag(waiter=remote,
                                                  resumer=cmd_runner,
                                                  pending_wait_flag=True)
        elif request == 'smart_sync':
            if action == 'set':
                ack_key = (remote, 'smart_sync_set')
                self.config_ver.set_sync_pending_flag(waiter=remote,
                                                      resumer=cmd_runner,
                                                      pending_sync_flag=True)
            elif action == 'achieved':
                ack_key = (remote, 'smart_sync_achieved')
                self.config_ver.set_sync_pending_flag(waiter=cmd_runner,
                                                      resumer=remote,
                                                      pending_sync_flag=False)
            elif action == 'backout':
                if split_msg[4] == 'local':
                    ack_key = (remote, 'smart_sync_backout_local')
                    self.config_ver.set_sync_pending_flag(
                        waiter=cmd_runner,
                        resumer=remote,
                        pending_sync_flag=False)
                else:
                    ack_key = (remote, 'smart_sync_backout_remote')
                    self.config_ver.set_sync_pending_flag(
                        waiter=remote,
                        resumer=cmd_runner,
                        pending_sync_flag=False)

        if not (request == 'smart_sync' and action == 'set'):
            self.config_ver.set_request_pending_flag(
                cmd_runner=cmd_runner,
                targets={remote},
                pending_request_flag=False)

        if pe[PE.ack_msg][ack_key] <= 0:
            raise UnexpectedEvent(
                f'RequestAckLogSearchItem using {ack_key=} detected '
                f'unexpected log msg: {self.found_log_msg}'
            )

        pe[PE.ack_msg][ack_key] -= 1

        self.config_ver.add_log_msg(re.escape(self.found_log_msg),
                                    log_level=logging.INFO)


########################################################################
# RequestRefreshLogSearchItem
########################################################################
class RequestRefreshLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(f"[a-z0-9_]+ {list_of_smart_requests} calling "
                        fr"refresh, remaining remotes: \["),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int
                           ) -> "RequestRefreshLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return RequestRefreshLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[0]
        request = split_msg[1]
        target_msg = self.found_log_msg.split('[')[1].split(']')[0]

        targets: set[str] = set()
        if target_msg:
            split_targets = target_msg.split()
            for idx in range(0, len(split_targets), 4):
                remote = split_targets[idx+2][8:-2]
                targets |= {remote}

        self.config_ver.handle_request_refresh_log_msg(
            cmd_runner=cmd_runner,
            request=request,
            targets=targets,
            log_msg=self.found_log_msg)

        self.config_ver.add_log_msg(re.escape(self.found_log_msg),
                                    log_level=logging.DEBUG)


########################################################################
# UnregJoinSuccessLogSearchItem
########################################################################
class UnregJoinSuccessLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=(f"[a-z0-9_]+ did successful (smart_unreg|smart_join) "
                        r"of \[([a-z0-9_]*|,|'| )*\]"),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int
                           ) -> "UnregJoinSuccessLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return UnregJoinSuccessLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[0]
        request = split_msg[3]
        target_msg = self.found_log_msg.split('[')[1].split(']')[0].split(', ')

        targets: list[str] = []
        for item in target_msg:
            targets.append(item[1:-1])

        pe = self.config_ver.pending_events[cmd_runner]

        uj_key: UnregJoinSuccessKey = (request, targets[0])

        if pe[PE.unreg_join_success_msg][uj_key] <= 0:
            raise UnexpectedEvent(
                f'UnregJoinSuccessLogSearchItem using {uj_key=} detected '
                f'unexpected log msg: {self.found_log_msg}'
            )

        pe[PE.unreg_join_success_msg][uj_key] -= 1

        self.config_ver.add_log_msg(re.escape(self.found_log_msg),
                                    log_level=logging.INFO)


########################################################################
# JoinWaitingLogSearchItem
########################################################################
class JoinWaitingLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str=("[a-z0-9_]+ smart_join "
                        r"completed targets: \[('[a-z0-9_]+'|, )*\], "
                        r"pending targets: \[('[a-z0-9_]+'|, )*\]"),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int
                           ) -> "JoinWaitingLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return JoinWaitingLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[0]
        left_bracket_split_msg = self.found_log_msg.split('[')
        comp_targ_msg = left_bracket_split_msg[1].split(']')[0].split(', ')

        comp_targets: list[str] = []
        for item in comp_targ_msg:
            comp_targets.append(item[1:-1])

        pend_targets: list[str] = []
        if left_bracket_split_msg[2] != ']':
            pend_targ_msg = left_bracket_split_msg[2].split(']')[0].split(', ')
            for item in pend_targ_msg:
                pend_targets.append(item[1:-1])

        pe = self.config_ver.pending_events[cmd_runner]

        prog_key: JoinProgKey = (len(comp_targets), len(pend_targets))

        if pe[PE.join_progress_msg][prog_key] <= 0:
            raise UnexpectedEvent(
                f'JoinWaitingLogSearchItem using {prog_key=} detected '
                f'unexpected log msg: {self.found_log_msg}'
            )

        pe[PE.join_progress_msg][prog_key] -= 1

        self.config_ver.add_log_msg(re.escape(self.found_log_msg),
                                    log_level=logging.INFO)


########################################################################
# StoppedLogSearchItem
########################################################################
class StoppedLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str='[a-z0-9_]+ has been stopped by [a-z0-9_]+',
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int) -> "StoppedLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            StoppedLogSearchItem containing found message and index
        """
        return StoppedLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()

        self.config_ver.handle_stopped_log_msg(
            cmd_runner=split_msg[5],
            stopped_name=split_msg[0],
            log_idx=self.found_log_idx)


########################################################################
# CmdWaitingLogSearchItem
########################################################################
class CmdWaitingLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        list_of_waiting_methods = ('(create_commander_thread'
                                   '|create_f1_thread'
                                   '|handle_join'
                                   '|handle_recv'
                                   '|handle_recv_tof'
                                   '|handle_recv_tot'
                                   '|handle_resume'
                                   '|handle_start'
                                   '|handle_sync'
                                   '|handle_wait'
                                   '|handle_unregister)')
        super().__init__(
            search_str=(f"cmd_runner='[a-z0-9_]+' {list_of_waiting_methods} "
                        "waiting for monitor"),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int
                           ) -> "CmdWaitingLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            CmdWaitingLogSearchItem containing found message and index
        """
        return CmdWaitingLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[0].split(sep='=')[1]
        cmd_runner = cmd_runner[1:-1]

        self.config_ver.handle_cmd_waiting_log_msg(
            cmd_runner=cmd_runner)


########################################################################
# DebugLogSearchItem
########################################################################
class DebugLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str='TestDebug [a-z0-9_]+ ',
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int
                           ) -> "DebugLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return DebugLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        self.config_ver.add_log_msg(re.escape(self.found_log_msg),
                                    log_level=logging.DEBUG)


########################################################################
# CRunnerRaisesLogSearchItem
########################################################################
class CRunnerRaisesLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        list_of_errors = ('(SmartThreadRemoteThreadNotAlive'
                          '|SmartThreadRequestTimedOut)')
        super().__init__(
            search_str=(f"[a-z0-9_]+ raising {list_of_errors} while processing "
                        f"a {list_of_smart_requests} request with "
                        r"targets \[([a-z0-9_]*|,|'| )*\]"),
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int
                           ) -> "CRunnerRaisesLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return CRunnerRaisesLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        cmd_runner = split_msg[0]
        target_msg = self.found_log_msg.split('[')[1].split(']')[0].split(', ')

        targets: set[str] = set()
        for item in target_msg:
            targets |= {item[1:-1]}

        self.config_ver.set_request_pending_flag(cmd_runner=cmd_runner,
                                                 targets=targets,
                                                 pending_request_flag=False)

        pe = self.config_ver.pending_events[cmd_runner]
        pe[PE.current_request] = StartRequest(
            req_type=st.ReqType.NoReq,
            targets=set(),
            unreg_remotes=set(),
            not_registered_remotes=set(),
            timeout_remotes=set(),
            stopped_remotes=set(),
            deadlock_remotes=set(),
            eligible_targets=set(),
            completed_targets=set(),
            first_round_completed=set(),
            stopped_target_threads=set(),
            exp_senders=set(),
            exp_resumers=set())

        # self.config_ver.add_log_msg(re.escape(self.found_log_msg),
        #                             log_level=logging.ERROR)

        # self.config_ver.log_test_msg(f'request msg parse {handle_name=}, '
        #                              f'{cmd_runner=}')

        # self.config_ver.handle_request_exit_log_msg(
        #     cmd_runner=cmd_runner)
        # self.config_ver.log_test_msg('request_pending reset for '
        #                              f'{cmd_runner=} raises error')

########################################################################
# MonDelLogSearchItem
########################################################################
# class MonDelLogSearchItem(LogSearchItem):
#     """Input to search log msgs."""
#
#     def __init__(self,
#                  config_ver: "ConfigVerifier",
#                  found_log_msg: str = '',
#                  found_log_idx: int = 0,
#                  ) -> None:
#         """Initialize the LogItem.
#
#         Args:
#             config_ver: configuration verifier
#             found_log_msg: log msg that was found
#             found_log_idx: index in the log where message was found
#         """
#         super().__init__(
#             search_str='monitor found del keys',
#             config_ver=config_ver,
#             found_log_msg=found_log_msg,
#             found_log_idx=found_log_idx
#         )
#
#     def get_found_log_item(self,
#                            found_log_msg: str,
#                            found_log_idx: int
#                            ) -> "MonDelLogSearchItem":
#         """Return a found log item.
#
#         Args:
#             found_log_msg: log msg that was found
#             found_log_idx: index in the log where message was found
#
#         Returns:
#             SyncResumedLogSearchItem containing found message and index
#         """
#         return MonDelLogSearchItem(
#             found_log_msg=found_log_msg,
#             found_log_idx=found_log_idx,
#             config_ver=self.config_ver)
#
#     def run_process(self):
#         """Run the process to handle the log message."""
#         split_msg = self.found_log_msg.split()
#         cmd_runner = split_msg[-1]
#         target_msg = self.found_log_msg.split('[')[1].split(']')[0].split(', ')
#
#         targets: list[str] = []
#         for item in target_msg:
#             targets.append(item[1:-1])
#
#         # self.config_ver.log_test_msg(f'request msg parse {cmd_runner=}, '
#         #                              f'{target=}')
#
#         # self.config_ver.handle_request_exit_log_msg(
#         #     cmd_runner=cmd_runner,
#         #     targets=targets)
#
#         self.config_ver.log_test_msg('request_pending reset for '
#                                      f'{cmd_runner=} via mon del '
#                                      f'{targets=}')


########################################################################
# MonitorCheckpointLogSearchItem
########################################################################
class MonitorCheckpointLogSearchItem(LogSearchItem):
    """Input to search log msgs."""

    def __init__(self,
                 config_ver: "ConfigVerifier",
                 found_log_msg: str = '',
                 found_log_idx: int = 0,
                 ) -> None:
        """Initialize the LogItem.

        Args:
            config_ver: configuration verifier
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found
        """
        super().__init__(
            search_str='Monitor Checkpoint: [a-z_]+ [0-9]+',
            config_ver=config_ver,
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx
        )

    def get_found_log_item(self,
                           found_log_msg: str,
                           found_log_idx: int
                           ) -> "MonitorCheckpointLogSearchItem":
        """Return a found log item.

        Args:
            found_log_msg: log msg that was found
            found_log_idx: index in the log where message was found

        Returns:
            SyncResumedLogSearchItem containing found message and index
        """
        return MonitorCheckpointLogSearchItem(
            found_log_msg=found_log_msg,
            found_log_idx=found_log_idx,
            config_ver=self.config_ver)

    def run_process(self):
        """Run the process to handle the log message."""
        split_msg = self.found_log_msg.split()
        verify_name = split_msg[2]
        verify_idx = split_msg[3]

        call_stm = f'self.config_ver.{verify_name}(verify_idx={verify_idx})'

        eval(call_stm)

        if verify_name == 'verify_config':
            self.config_ver.verify_config_complete_event.set()
        elif verify_name == 'check_pending_events':
            self.config_ver.check_pending_events_complete_event.set()


LogSearchItems: TypeAlias = Union[
    RequestEntryExitLogSearchItem,
    SubProcessEntryExitLogSearchItem,
    RegistryStatusLogSearchItem,
    AddPairArrayEntryLogSearchItem,
    AddStatusBlockEntryLogSearchItem,
    DidCleanPairArrayUtcLogSearchItem,
    UpdatePairArrayUtcLogSearchItem,
    AddRegEntryLogSearchItem,
    RemRegEntryLogSearchItem,
    RemPairArrayEntryLogSearchItem,
    DidCleanRegLogSearchItem,
    SetStateLogSearchItem,
    InitCompleteLogSearchItem,
    F1AppExitLogSearchItem,
    AlreadyUnregLogSearchItem,
    RequestAckLogSearchItem,
    RequestRefreshLogSearchItem,
    UnregJoinSuccessLogSearchItem,
    JoinWaitingLogSearchItem,
    StoppedLogSearchItem,
    CmdWaitingLogSearchItem,
    DebugLogSearchItem,
    RemStatusBlockEntryLogSearchItem,
    RemStatusBlockEntryDefLogSearchItem,
    CRunnerRaisesLogSearchItem,
    MonitorCheckpointLogSearchItem]


########################################################################
# MockGetTargetState
########################################################################
TargetsDict: TypeAlias = dict[str, dict[str, tuple[st.ThreadState,
                                                   st.ThreadState]]]


class MockGetTargetState:
    """Tracks targets whose state is to be reported differently."""
    targets: ClassVar[TargetsDict] = {}
    config_ver: ClassVar["ConfigVerifier"]

    def __init__(self,
                 targets: TargetsDict,
                 config_ver: "ConfigVerifier") -> None:
        """Initialize the mock target state.

        Args:
            targets: dictionary of targets
            config_ver: instance of ConfigurationVerifier
        """
        MockGetTargetState.targets = targets
        MockGetTargetState.config_ver = config_ver

    ####################################################################
    # mock_get_target_state
    ####################################################################
    def mock_get_target_state(self,
                              pk_remote: st.PairKeyRemote
                              ) -> st.ThreadState:
        """Get the status of a thread that is the target of a request.

        Args:
            pk_remote: contains target thread info

        Returns:
            The thread status

        Notes:
            Must be called holding the registry lock either shared or
            exclusive
        """
        # MockGetTargetState.config_ver.log_test_msg(
        #     f'mock_get_target_state entered by {self=} with '
        #     f'{MockGetTargetState.targets=}')

        ret_state = st.ThreadState.Unregistered
        if pk_remote.remote not in st.SmartThread._registry:
            if pk_remote.create_time != 0.0:
                ret_state = st.ThreadState.Stopped
            else:
                ret_state = st.ThreadState.Unregistered

        else:
            # MockGetTargetState.config_ver.log_test_msg(
            #     f'mock {self.name} for {pk_remote.remote=} with '
            #     f'{st.SmartThread._registry[pk_remote.remote].thread
            #     .is_alive()=} '
            #     f'{st.SmartThread._registry[pk_remote.remote].st_state=}')
            if (not st.SmartThread._registry[
                pk_remote.remote].thread.is_alive()
                    and st.SmartThread._registry[
                        pk_remote.remote].st_state == st.ThreadState.Alive):
                ret_state = st.ThreadState.Stopped

            elif (pk_remote.pair_key in st.SmartThread._pair_array
                    and pk_remote.remote in st.SmartThread._pair_array[
                        pk_remote.pair_key].status_blocks
                    and st.SmartThread._pair_array[
                        pk_remote.pair_key].status_blocks[
                        pk_remote.remote].create_time
                  != pk_remote.create_time):
                ret_state = st.ThreadState.Stopped

            elif (not st.SmartThread._registry[
                pk_remote.remote].thread.is_alive()
                    and st.SmartThread._registry[
                        pk_remote.remote].st_state == st.ThreadState.Alive):
                ret_state = st.ThreadState.Stopped

            else:
                ret_state = st.SmartThread._registry[pk_remote.remote].st_state

        if self.name in MockGetTargetState.targets:
            if pk_remote.remote in MockGetTargetState.targets[self.name]:
                if ret_state == MockGetTargetState.targets[
                        self.name][pk_remote.remote][0]:
                    old_ret_state = ret_state
                    ret_state = MockGetTargetState.targets[
                        self.name][pk_remote.remote][1]
                    MockGetTargetState.config_ver.log_test_msg(
                        f'mock {self.name} changed state for '
                        f'{pk_remote.remote=} '
                        f'from {old_ret_state= } to {ret_state=}')

        # MockGetTargetState.config_ver.log_test_msg(
        #     f'mock {self.name} returning for {pk_remote.remote=} '
        #     f'with {ret_state=}')
        return ret_state


@dataclass
class PaLogMsgsFound:
    """Pair array log message info."""
    entered_rpa: bool
    removed_sb_entry: list[tuple[str, str]]
    removed_pa_entry: list[tuple[str, str]]
    updated_pa: bool

# class TransitionType(Enum):
#     Unreg = auto()
#     Init = auto()
#     Start = auto()
#     Reg = auto()
#     Alive = auto()
#     Stop = auto()


@dataclass
class StartRequest:
    targets: set[str] = field(default_factory=set)
    unreg_remotes: set[str] = field(default_factory=set)
    not_registered_remotes: set[str] = field(default_factory=set)
    timeout_remotes: set[str] = field(default_factory=set)
    stopped_remotes: set[str] = field(default_factory=set)
    deadlock_remotes: set[str] = field(default_factory=set)
    eligible_targets: set[str] = field(default_factory=set)
    completed_targets: set[str] = field(default_factory=set)
    first_round_completed: set[str] = field(default_factory=set)
    stopped_target_threads: set[str] = field(default_factory=set)
    exp_senders: set[str] = field(default_factory=set)
    exp_resumers: set[str] = field(default_factory=set)
    exp_receivers: set[str] = field(default_factory=set)
    exp_resumed_targets: set[str] = field(default_factory=set)
    timeout_type: TimeoutType = TimeoutType.TimeoutNone
    req_type: st.ReqType = st.ReqType.NoReq



@dataclass
class PendingEvent:
    """Pending event class."""
    start_request: deque[StartRequest]
    current_request: StartRequest
    num_targets_remaining: int
    request_msg: dict[RequestKey, int]
    subprocess_msg: dict[SubProcessKey, int]
    set_state_msg: dict[SetStateKey, int]
    status_msg: dict[tuple[bool, st.ThreadState], int]
    rem_reg_msg: dict[RemRegKey, int]
    did_clean_reg_msg: int
    update_pair_array_utc_msg: int
    did_cleanup_pair_array_utc_msg: int
    rem_reg_targets: deque[list[str]]
    add_reg_msg: dict[AddRegKey, int]
    add_pair_array_msg: dict[AddPaKey, int]
    add_status_block_msg: dict[AddStatusBlockKey, int]
    rem_status_block_msg: dict[RemSbKey, int]
    rem_status_block_def_msg: dict[RemSbKey, int]
    rem_pair_array_entry_msg: dict[RemPaeKey, int]
    notify_rem_status_block_msg: dict[RemSbKey, int]
    notify_rem_status_block_def_msg: dict[RemSbKey, int]
    ack_msg: dict[AckKey, int]


class PE(Enum):
    start_request = auto()
    current_request = auto()
    save_current_request = auto()
    num_targets_remaining = auto()
    request_msg = auto()
    subprocess_msg = auto()
    set_state_msg = auto()
    status_msg = auto()
    rem_reg_msg = auto()
    did_clean_reg_msg = auto()
    update_pair_array_utc_msg = auto()
    did_cleanup_pair_array_utc_msg = auto()
    rem_reg_targets = auto()
    add_reg_msg = auto()
    add_pair_array_msg = auto()
    add_status_block_msg = auto()
    rem_status_block_msg = auto()
    rem_status_block_def_msg = auto()
    rem_pair_array_entry_msg = auto()
    notify_rem_status_block_msg = auto()
    notify_rem_status_block_def_msg = auto()
    ack_msg = auto()
    confirm_stop_msg = auto()
    already_unreg_msg = auto()
    unreg_join_success_msg = auto()
    join_progress_msg = auto()
    init_comp_msg = auto()
    calling_refresh_msg = auto()


class ConfigVerifier:
    """Class that tracks and verifies the SmartThread configuration."""

    def __init__(self,
                 commander_name: str,
                 log_ver: LogVer,
                 caplog_to_use: pytest.CaptureFixture[str],
                 msgs: Msgs,
                 max_msgs: Optional[int] = 10) -> None:
        """Initialize the ConfigVerifier.

        Args:
            commander_name: name of the thread running the commands
            log_ver: the log verifier to track and verify log msgs
            caplog_to_use: pytest fixture to capture log messages
            msgs: Msgs class instance used to communicate with threads
            max_msgs: max message for the SmartThread msg_q

        """
        self.specified_args = locals()  # used for __repr__, see below
        self.commander_name = commander_name
        self.commander_thread_config_built = False
        # self.cmd_thread_alive = False
        # self.cmd_thread_auto_start = False
        self.create_commander_event: threading.Event = threading.Event()

        self.monitor_thread = threading.Thread(target=self.monitor)
        self.monitor_exit = False
        self.monitor_bail = False

        self.cmd_suite: deque[ConfigCmd] = deque()
        self.cmd_serial_num: int = 0
        self.completed_cmds: dict[str, list[int]] = defaultdict(list)
        self.f1_process_cmds: dict[str, bool] = {}
        self.thread_names: list[str] = [
            'alpha', 'beta', 'charlie', 'delta',
            'echo', 'fox', 'george', 'henry',
            'ida', 'jack', 'king', 'love',
            'mary', 'nancy', 'oscar', 'peter',
            'queen', 'roger', 'sam', 'tom',
            'uncle', 'victor', 'wanda', 'xander'
        ]
        self.unregistered_names: set[str] = set(self.thread_names)
        self.registered_names: set[str] = set()
        self.active_names: set[str] = set()
        self.thread_target_names: set[str] = set()
        self.stopped_remotes: set[str] = set()
        self.expected_registered: dict[str, ThreadTracker] = {}
        self.expected_pairs: dict[tuple[str, str],
                                  dict[str, ThreadPairStatus]] = {}
        self.log_ver = log_ver
        self.caplog_to_use = caplog_to_use
        self.msgs = msgs
        self.ops_lock = threading.RLock()
        # self.commander_thread: Optional[st.SmartThread] = None
        self.all_threads: dict[str, st.SmartThread] = {}
        self.max_msgs = max_msgs

        self.expected_num_recv_timeouts: int = 0

        # self.del_def_pairs_count: dict[
        #     tuple[str, str, str], int] = defaultdict(int)
        # self.del_def_pairs_msg_count: dict[
        #     tuple[str, str, str], int] = defaultdict(int)
        # self.del_def_pairs_msg_ind_count: dict[
        #     tuple[str, str, str, str], int] = defaultdict(int)

        self.del_deferred_list: list[tuple[tuple[str, str], str]] = []

        # self.found_utc_log_msgs: dict[tuple[str, str], int]= defaultdict(int)
        self.found_update_pair_array_log_msgs: dict[str, int] = defaultdict(
            int)
        # self.recv_msg_event_items: dict[str, MonitorEventItem] = {}
        # self.join_event_items: dict[str, MonitorEventItem] = {}
        # self.unreg_event_items: dict[str, MonitorEventItem] = {}
        # self.started_event_items: dict[str, MonitorEventItem] = {}
        self.stopped_event_items: dict[str, MonitorEventItem] = {}
        self.cmd_waiting_event_items: dict[str, threading.Event] = {}
        self.request_pending_pair_keys: dict[str, list[st.PairKey]] = {}

        self.stopping_names: list[str] = []

        self.recently_stopped: dict[str, int] = defaultdict(int)

        self.log_start_idx: int = 0
        self.log_search_items: tuple[LogSearchItems, ...] = (
            RequestEntryExitLogSearchItem(config_ver=self),
            SubProcessEntryExitLogSearchItem(config_ver=self),
            RegistryStatusLogSearchItem(config_ver=self),
            AddPairArrayEntryLogSearchItem(config_ver=self),
            AddStatusBlockEntryLogSearchItem(config_ver=self),
            DidCleanPairArrayUtcLogSearchItem(config_ver=self),
            UpdatePairArrayUtcLogSearchItem(config_ver=self),
            AddRegEntryLogSearchItem(config_ver=self),
            RemRegEntryLogSearchItem(config_ver=self),
            RemPairArrayEntryLogSearchItem(config_ver=self),
            DidCleanRegLogSearchItem(config_ver=self),
            SetStateLogSearchItem(config_ver=self),
            InitCompleteLogSearchItem(config_ver=self),
            F1AppExitLogSearchItem(config_ver=self),
            AlreadyUnregLogSearchItem(config_ver=self),
            RequestAckLogSearchItem(config_ver=self),
            RequestRefreshLogSearchItem(config_ver=self),
            UnregJoinSuccessLogSearchItem(config_ver=self),
            JoinWaitingLogSearchItem(config_ver=self),
            StoppedLogSearchItem(config_ver=self),
            CmdWaitingLogSearchItem(config_ver=self),
            DebugLogSearchItem(config_ver=self),
            RemStatusBlockEntryLogSearchItem(config_ver=self),
            RemStatusBlockEntryDefLogSearchItem(config_ver=self),
            CRunnerRaisesLogSearchItem(config_ver=self),
            MonitorCheckpointLogSearchItem(config_ver=self)
        )
        self.last_update_pair_array_log_msg: str = ''

        self.log_found_items: deque[LogSearchItem] = deque()

        self.pending_events: dict[str, PendEvents] = {}
        self.setup_pending_events()

        self.snap_shot_data: dict[int, SnapShotDataItem] = {}

        self.allow_log_test_msg = True

        self.last_clean_reg_msg_idx: int = 0
        self.last_thread_stop_msg_idx: dict[str, int] = defaultdict(int)

        self.monitor_event: threading.Event = threading.Event()
        self.monitor_condition: threading.Condition = threading.Condition()
        self.monitor_pause: bool = False
        self.check_pending_events_complete_event: threading.Event = (
            threading.Event())
        self.verify_config_complete_event: threading.Event = (
            threading.Event())
        self.monitor_thread.start()

    ####################################################################
    # __repr__
    ####################################################################
    def __repr__(self) -> str:
        """Return a representation of the class.

        Returns:
            The representation as how the class is instantiated

        """
        if TYPE_CHECKING:
            __class__: Type[ConfigVerifier]  # noqa: F842
        classname = self.__class__.__name__
        parms = ""
        comma = ''

        for key, item in self.specified_args.items():
            if item:  # if not None
                if key in ('log_ver',):
                    if type(item) is str:
                        parms += comma + f"{key}='{item}'"
                    else:
                        parms += comma + f"{key}={item}"
                    comma = ', '  # after first item, now need comma

        return f'{classname}({parms})'

    ####################################################################
    # setup_pending_events
    ####################################################################
    def setup_pending_events(self):
        """Setup the pending events for all threads."""
        self.pending_events = {}
        for name in self.thread_names:
            self.pending_events[name] = {}
        for name in self.thread_names:
            self.pending_events[name][PE.start_request] = deque()
            self.pending_events[name][PE.current_request] = StartRequest(
                req_type=st.ReqType.NoReq,
                targets=set(),
                unreg_remotes=set(),
                not_registered_remotes=set(),
                timeout_remotes=set(),
                stopped_remotes=set(),
                deadlock_remotes=set(),
                eligible_targets=set(),
                completed_targets=set(),
                first_round_completed=set(),
                stopped_target_threads=set(),
                exp_senders=set(),
                exp_resumers=set()
            )
            self.pending_events[name][PE.save_current_request] = StartRequest(
                req_type=st.ReqType.NoReq,
                targets=set(),
                unreg_remotes=set(),
                not_registered_remotes=set(),
                timeout_remotes=set(),
                stopped_remotes=set(),
                deadlock_remotes=set(),
                eligible_targets=set(),
                completed_targets=set(),
                first_round_completed=set(),
                stopped_target_threads=set(),
                exp_senders=set(),
                exp_resumers=set()
            )
            self.pending_events[name][PE.num_targets_remaining] = 0
            self.pending_events[name][PE.request_msg] = defaultdict(int)
            self.pending_events[name][PE.subprocess_msg] = defaultdict(int)
            self.pending_events[name][PE.set_state_msg] = defaultdict(int)
            self.pending_events[name][PE.status_msg] = defaultdict(int)
            self.pending_events[name][PE.rem_reg_msg] = defaultdict(int)
            self.pending_events[name][PE.did_clean_reg_msg] = 0
            self.pending_events[name][PE.update_pair_array_utc_msg] = 0
            self.pending_events[name][PE.did_cleanup_pair_array_utc_msg] = 0
            self.pending_events[name][PE.rem_reg_targets] = deque()
            self.pending_events[name][PE.add_reg_msg] = defaultdict(int)
            self.pending_events[name][PE.add_pair_array_msg] = defaultdict(int)
            self.pending_events[name][
                PE.add_status_block_msg] = defaultdict(int)
            self.pending_events[name][
                PE.rem_status_block_msg] = defaultdict(int)
            self.pending_events[name][
                PE.rem_status_block_def_msg] = defaultdict(int)
            self.pending_events[name][
                PE.rem_pair_array_entry_msg] = defaultdict(int)
            self.pending_events[name][
                PE.notify_rem_status_block_msg] = defaultdict(int)
            self.pending_events[name][
                PE.notify_rem_status_block_def_msg] = defaultdict(int)
            self.pending_events[name][PE.ack_msg] = defaultdict(int)
            self.pending_events[name][
                PE.confirm_stop_msg] = defaultdict(int)
            self.pending_events[name][
                PE.already_unreg_msg] = defaultdict(int)
            self.pending_events[name][
                PE.unreg_join_success_msg] = defaultdict(int)
            self.pending_events[name][PE.join_progress_msg] = defaultdict(int)
            self.pending_events[name][PE.init_comp_msg] = defaultdict(int)
            self.pending_events[name][
                PE.calling_refresh_msg] = defaultdict(int)

    ####################################################################
    # monitor
    ####################################################################
    def monitor(self):
        """Gather log messages and call handlers."""
        self.log_test_msg('monitor entered')

        while not self.monitor_exit:
            self.monitor_event.wait(timeout=0.25)
            self.monitor_event.clear()

            if self.monitor_pause:
                continue
            if self.monitor_bail:
                break

            while self.get_log_msgs():
                while self.log_found_items:
                    found_log_item = self.log_found_items.popleft()

                    # log the log msg being processed but mangle it a
                    # little so we don't find it again and get into a
                    # loop here
                    found_msg = found_log_item.found_log_msg
                    if 'TestDebug' not in found_msg:
                        semi_msg = found_msg.replace(' ', ';', 3)
                        self.log_test_msg(
                            f'monitor processing msg: {semi_msg}')

                    found_log_item.run_process()
                    # self.log_test_msg(f'monitor completed msg: {semi_msg}')

            with self.monitor_condition:
                self.monitor_condition.notify_all()

    ####################################################################
    # set_request_pending_flag
    ####################################################################
    def set_request_pending_flag(self,
                                 cmd_runner: str,
                                 targets: set[str],
                                 pending_request_flag: bool) -> None:
        """Set or reset request pending flags.

        Args:
            cmd_runner: thread name doing the set or reset
            targets: thread names that are targets of request
            pending_request_flag: specifies value to set for request

        """
        # self.log_test_msg(f'set_request_pending_flag entry: {cmd_runner=}, '
        #                   f'{targets=}, {pending_request_flag=}')
        for target in targets:
            pair_key = st.SmartThread._get_pair_key(cmd_runner, target)
            if pair_key not in self.expected_pairs:
                continue

            pae = self.expected_pairs[pair_key]

            cb = pae[cmd_runner]
            self.log_test_msg(f'set_request_pending_flag {cmd_runner=}, '
                              f'{pair_key=}, {target=}, updating from '
                              f'{cb.pending_request=} to '
                              f'{pending_request_flag=}')
            cb.pending_request = pending_request_flag

    ####################################################################
    # set_msg_pending_count
    ####################################################################
    def set_msg_pending_count(self,
                              receiver: str,
                              sender: str,
                              pending_msg_adj: int) -> None:
        """Set or reset one or more pending flags.

        Args:
            receiver: thread name whose msg count is to be adj
            sender: thread name that sent the msg
            pending_msg_adj: specifies value to add or subtract for msg
                count

        """
        pair_key = st.SmartThread._get_pair_key(receiver, sender)
        if pair_key not in self.expected_pairs:
            raise InvalidConfigurationDetected(
                f'set_msg_pending_count detected that for {receiver=}, '
                f'{sender=}: {pair_key=} is not in the '
                f'{self.expected_pairs=}'
            )

        pae = self.expected_pairs[pair_key]

        if receiver not in pae:
            raise InvalidConfigurationDetected(
                f'set_msg_pending_count detected that for {sender=}, '
                f'{pair_key=}: {receiver=} is not in the {pae=}'
            )

        cb = pae[receiver]
        if pending_msg_adj == 0:
            new_msg_count = 0
        else:
            new_msg_count = cb.pending_msg_count + pending_msg_adj
        self.log_test_msg(f'set_msg_pending_count {receiver=}, '
                          f'{pair_key=}, {sender=}, updating from '
                          f'{cb.pending_msg_count=} to '
                          f'{new_msg_count=}')
        cb.pending_msg_count = new_msg_count

    ####################################################################
    # set_wait_pending_flag
    ####################################################################
    def set_wait_pending_flag(self,
                              waiter: str,
                              resumer: str,
                              pending_wait_flag: bool) -> None:
        """Set or reset one or more pending flags.

        Args:
            waiter: thread name whose wait flag is to be set
            resumer: thread name that set the wait event
            pending_wait_flag: specifies True or False to set the flag

        """
        pair_key = st.SmartThread._get_pair_key(waiter, resumer)
        if pair_key not in self.expected_pairs:
            raise InvalidConfigurationDetected(
                f'set_wait_pending_flag detected that for {waiter=}, '
                f'{resumer=}: {pair_key=} is not in the '
                f'{self.expected_pairs=}'
            )

        pae = self.expected_pairs[pair_key]

        if waiter not in pae:
            raise InvalidConfigurationDetected(
                f'set_wait_pending_flag detected that for {resumer=}, '
                f'{pair_key=}: {waiter=} is not in the {pae=}'
            )

        cb = pae[waiter]

        self.log_test_msg(f'set_wait_pending_flag {waiter=}, '
                          f'{pair_key=}, {resumer=}, updating from '
                          f'{cb.pending_wait=} to '
                          f'{pending_wait_flag=}')
        cb.pending_wait = pending_wait_flag

    ####################################################################
    # set_sync_pending_flag
    ####################################################################
    def set_sync_pending_flag(self,
                              waiter: str,
                              resumer: str,
                              pending_sync_flag: bool) -> None:
        """Set or reset one or more pending flags.

        Args:
            waiter: thread name whose wait flag is to be set
            resumer: thread name that set the wait event
            pending_sync_flag: specifies True or False to set the flag

        """
        pair_key = st.SmartThread._get_pair_key(waiter, resumer)
        if pair_key not in self.expected_pairs:
            raise InvalidConfigurationDetected(
                f'set_sync_pending_flag detected that for {waiter=}, '
                f'{resumer=}: {pair_key=} is not in the '
                f'{self.expected_pairs=}'
            )

        pae = self.expected_pairs[pair_key]

        if waiter not in pae:
            raise InvalidConfigurationDetected(
                f'set_sync_pending_flag detected that for {resumer=}, '
                f'{pair_key=}: {waiter=} is not in the {pae=}'
            )

        cb = pae[waiter]

        self.log_test_msg(f'set_sync_pending_flag {waiter=}, '
                          f'{pair_key=}, {resumer=}, updating from '
                          f'{cb.pending_sync=} to '
                          f'{pending_sync_flag=}')
        cb.pending_sync = pending_sync_flag

    ####################################################################
    # abort_all_f1_threads
    ####################################################################
    def abort_all_f1_threads(self):
        """Abort all threads before raising an error."""
        self.log_test_msg('abort_all_f1_threads entry')
        for name, thread in self.all_threads.items():
            # self.log_test_msg(f'abort_all_f1_threads looking at {name=}')
            if name == self.commander_name:
                continue
            self.add_log_msg(f'aborting f1_thread {name}, '
                             f'thread.is_alive(): {thread.thread.is_alive()}.')
            if thread.thread.is_alive():
                exit_cmd = ExitThread(cmd_runners=name,
                                      stopped_by=self.commander_name)
                self.add_cmd_info(exit_cmd)
                self.msgs.queue_msg(name, exit_cmd)
        self.monitor_bail = True
        self.monitor_exit = True
        self.monitor_event.set()
        # self.log_test_msg('abort_all_f1_threads about to join1')
        # self.log_test_msg(f'abort_all_f1_threads '
        #                   f'{threading.current_thread()=}')
        # self.log_test_msg(f'abort_all_f1_threads '
        #                   f'{self.monitor_thread=}')
        if threading.current_thread() is not self.monitor_thread:
            # self.log_test_msg('abort_all_f1_threads about to join2')
            self.monitor_thread.join()
        self.log_test_msg('abort_all_f1_threads exit')

    ####################################################################
    # add_cmd
    ####################################################################
    def add_cmd(self,
                cmd: ConfigCmd) -> int:
        """Add a command to the deque.

        Args:
            cmd: command to add

        Returns:
            the serial number for the command

        """
        serial_num = self.add_cmd_info(cmd=cmd, frame_num=2)
        self.cmd_suite.append(cmd)
        return serial_num

    ####################################################################
    # add_cmd_info
    ####################################################################
    def add_cmd_info(self,
                     cmd: ConfigCmd,
                     frame_num: int = 1) -> int:
        """Add a command to the deque.

        Args:
            cmd: command to add
            frame_num: how many frames back to go for line number

        Returns:
            the serial number for the command
        """
        self.cmd_serial_num += 1
        cmd.serial_num = self.cmd_serial_num

        frame = _getframe(frame_num)
        caller_info = get_caller_info(frame)
        cmd.line_num = caller_info.line_num
        cmd.config_ver = self
        del frame

        return self.cmd_serial_num

    ####################################################################
    # add_log_msg
    ####################################################################
    def add_log_msg(self,
                    new_log_msg: str,
                    log_level: Optional[int] = logging.DEBUG) -> None:
        """Add log message to log_ver for SmartThread logger.

        Args:
            new_log_msg: msg to add to log_ver
            log_level: the logging severity level to use
        """
        self.log_ver.add_msg(
            log_name='scottbrian_paratools.smart_thread',
            log_level=log_level,
            log_msg=new_log_msg)

    ####################################################################
    # build_cd_normal_sync_suite
    ####################################################################
    def build_cd_normal_sync_suite(
            self,
            actor_names: list[str]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            actor_names: names of threads that will do the sync

        """
        sync_serial_num = self.add_cmd(
            Sync(cmd_runners=actor_names,
                 targets=set(actor_names),
                 log_msg='cd normal sync test'))
        self.add_cmd(
            ConfirmResponse(cmd_runners=[self.commander_name],
                            confirm_cmd='Sync',
                            confirm_serial_num=sync_serial_num,
                            confirmers=list(actor_names)))

    ####################################################################
    # build_cd_normal_resume_wait_suite
    ####################################################################
    def build_cd_normal_resume_wait_suite(
            self,
            actor_names: list[str]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            actor_names: names of threads that will do the sync

        """
        mid_point = len(actor_names)//2
        resumers = actor_names[0:mid_point]
        waiters = actor_names[mid_point:]
        resume_serial_num = self.add_cmd(
            Resume(cmd_runners=resumers,
                   targets=waiters,
                   exp_resumed_targets=waiters,
                   stopped_remotes=[],
                   log_msg='cd normal resume wait test'))
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd='Resume',
                confirm_serial_num=resume_serial_num,
                confirmers=resumers))
        wait_serial_num = self.add_cmd(
            Wait(cmd_runners=waiters,
                 resumers=resumers,
                 stopped_remotes=set(),
                 log_msg='cd normal resume wait test'))
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd='Wait',
                confirm_serial_num=wait_serial_num,
                confirmers=waiters))

    ####################################################################
    # build_cd_resume_sync_sync_wait_suite
    ####################################################################
    def build_cd_resume_sync_sync_wait_suite(
            self,
            actor_names: list[str]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            actor_names: names of threads that will do the sync

        """
        mid_point = len(actor_names) // 2
        resumers = actor_names[0:mid_point]
        waiters = actor_names[mid_point:]
        resume_serial_num = self.add_cmd(
            Resume(cmd_runners=resumers,
                   targets=waiters,
                   exp_resumed_targets=waiters,
                   stopped_remotes=[],
                   log_msg='cd resume sync sync wait test'))
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd='Resume',
                confirm_serial_num=resume_serial_num,
                confirmers=resumers))
        sync_serial_num = self.add_cmd(
            Sync(cmd_runners=actor_names,
                 targets=set(actor_names),
                 log_msg='cd resume sync sync wait test'))
        self.add_cmd(
            ConfirmResponse(cmd_runners=[self.commander_name],
                            confirm_cmd='Sync',
                            confirm_serial_num=sync_serial_num,
                            confirmers=actor_names))
        wait_serial_num = self.add_cmd(
            Wait(cmd_runners=waiters,
                 resumers=resumers,
                 stopped_remotes=set(),
                 log_msg='cd resume sync sync wait test'))
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd='Wait',
                confirm_serial_num=wait_serial_num,
                confirmers=waiters))

    ####################################################################
    # build_cd_sync_conflict_suite
    ####################################################################
    def build_cd_sync_conflict_suite(
            self,
            actor_names: list[str]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            actor_names: names of threads that will do the sync

        """
        mid_point = len(actor_names) // 2
        syncers = actor_names[0:mid_point]
        waiters = actor_names[mid_point:]

        sync_serial_num = self.add_cmd(
            Sync(cmd_runners=syncers,
                 targets=set(actor_names),
                 conflict_remotes=set(waiters),
                 log_msg='cd resume sync conflict test'))

        self.add_cmd(
            WaitForRequestTimeouts(
                cmd_runners=self.commander_name,
                actor_names=syncers,
                timeout_names=waiters))

        wait_serial_num = self.add_cmd(
            Wait(cmd_runners=waiters,
                 resumers=syncers,
                 stopped_remotes=set(),
                 conflict_remotes=set(syncers),
                 log_msg='cd resume sync conflict test'))

        self.add_cmd(
            ConfirmResponse(cmd_runners=[self.commander_name],
                            confirm_cmd='Sync',
                            confirm_serial_num=sync_serial_num,
                            confirmers=syncers))

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd='Wait',
                confirm_serial_num=wait_serial_num,
                confirmers=waiters))

    ####################################################################
    # build_cd_wait_deadlock_suite
    ####################################################################
    def build_cd_wait_deadlock_suite(
            self,
            actor_names: list[str]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            actor_names: names of threads that will do the sync

        """
        mid_point = len(actor_names) // 2
        waiters1 = actor_names[0:mid_point]
        waiters2 = actor_names[mid_point:]

        wait_serial_num_1 = self.add_cmd(
            Wait(cmd_runners=waiters1,
                 resumers=waiters2,
                 stopped_remotes=set(),
                 deadlock_remotes=set(waiters2),
                 log_msg='cd wait deadlock test'))

        wait_serial_num_2 = self.add_cmd(
            Wait(cmd_runners=waiters2,
                 resumers=waiters1,
                 stopped_remotes=set(),
                 deadlock_remotes=set(waiters1),
                 log_msg='cd wait deadlock test'))

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd='Wait',
                confirm_serial_num=wait_serial_num_1,
                confirmers=waiters1))

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd='Wait',
                confirm_serial_num=wait_serial_num_2,
                confirmers=waiters2))

    ####################################################################
    # build_conf_dead_scenario_suite
    ####################################################################
    def build_conf_dead_scenario_suite(
            self,
            scenario_list: list[ConflictDeadlockScenario],
            num_cd_actors: int) -> None:
        """Build ConfigCmd items for sync scenarios.

        Args:
            scenario_list: scenario 1, 2, and 3
            num_cd_actors: number of syncers, resumers, and waiters

        """
        actions: dict[ConflictDeadlockScenario, Callable[..., None]] = {
            ConflictDeadlockScenario.NormalSync:
                self.build_cd_normal_sync_suite,
            ConflictDeadlockScenario.NormalResumeWait:
                self.build_cd_normal_resume_wait_suite,
            ConflictDeadlockScenario.ResumeSyncSyncWait:
                self.build_cd_resume_sync_sync_wait_suite,
            ConflictDeadlockScenario.SyncConflict:
                self.build_cd_sync_conflict_suite,
            ConflictDeadlockScenario.WaitDeadlock:
                self.build_cd_wait_deadlock_suite,
        }
        # Make sure we have enough threads
        assert num_cd_actors <= len(self.unregistered_names)

        self.build_config(
            cmd_runner=self.commander_name,
            num_active=num_cd_actors + 1)

        self.log_name_groups()

        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose actor_names
        ################################################################
        actor_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_cd_actors,
            update_collection=True,
            var_name_for_log='actor_names')

        for scenario in scenario_list:
            actions[scenario](actor_names=actor_names)

    ####################################################################
    # build_config
    ####################################################################
    def build_config(self,
                     cmd_runner: str,
                     num_registered: Optional[int] = 0,
                     num_active: Optional[int] = 1,
                     num_stopped: Optional[int] = 0
                     ) -> None:
        """Add ConfigCmd items to the queue.

        Args:
            cmd_runner: thread running the command
            num_registered: number of threads that need to be
                registered but not yet started (meaning state is
                Registered)
            num_active: number of threads that need to be active
                (meaning state is Active)
            num_stopped: number of threads that need to have exited but
                not yet joined (meaning state is Stopped)

        Note: the number of registered, active, and stopped must not
            exceed the number of thread_names

        """
        assert (num_registered
                + num_active
                + num_stopped) <= len(self.thread_names)
        assert num_active >= 1  # always need at least 1 for commander

        # if not self.commander_thread_config_built:
        #     self.build_create_suite(commander_name=self.commander_name)
        #     self.commander_thread_config_built = True
        #     # num_active -= 1  # one less active thread to create

        num_adjust_registered = len(self.registered_names) - num_registered
        num_adjust_active = len(self.active_names) - num_active
        num_adjust_stopped = len(self.stopped_remotes) - num_stopped

        num_create_auto_start = 0
        num_create_no_start = 0
        num_reg_to_unreg = 0
        num_reg_to_start = 0
        num_active_to_exit = 0
        num_stopped_to_join = 0
        num_active_to_join = 0

        # determine how many to start for active and stopped
        if num_adjust_registered > 0:  # if surplus of registered
            num_adjust_act_stop = num_adjust_active + num_adjust_stopped
            if num_adjust_act_stop < 0:  # if shortage
                num_reg_to_start = min(num_adjust_registered,
                                       -num_adjust_act_stop)
                num_adjust_registered -= num_reg_to_start
                num_adjust_active += num_reg_to_start

            if num_adjust_registered > 0:  # if still surplus
                num_reg_to_unreg = num_adjust_registered
                num_adjust_registered = 0
        elif num_adjust_registered < 0:
            num_create_no_start = -num_adjust_registered
            num_adjust_registered = 0

        if num_adjust_active > 0:  # if surplus
            if num_adjust_stopped < 0:  # need more
                num_active_to_exit = min(num_adjust_active,
                                         -num_adjust_stopped)
                num_adjust_active -= num_active_to_exit
                num_adjust_stopped += num_active_to_exit

            if num_adjust_active > 0:  # if still surplus
                num_active_to_exit += num_adjust_active
                num_active_to_join = num_adjust_active
                num_adjust_active = 0
        elif num_adjust_active < 0:  # if need more
            num_create_auto_start += -num_adjust_active
            num_adjust_active = 0

        if num_adjust_stopped > 0:  # if surplus
            num_stopped_to_join += num_adjust_stopped
            num_adjust_stopped = 0
        elif num_adjust_stopped < 0:  # if we need more
            num_create_auto_start += -num_adjust_stopped
            num_active_to_exit += -num_adjust_stopped
            num_adjust_stopped = 0

        # start by reducing surpluses
        if num_reg_to_unreg > 0:
            self.build_unreg_suite_num(num_to_unreg=num_reg_to_unreg)

        if num_stopped_to_join > 0:
            self.build_join_suite_num(
                cmd_runners=cmd_runner,
                num_to_join=num_stopped_to_join)

        # create threads with no_start
        if num_create_no_start > 0:
            self.build_f1_create_suite_num(
                    num_to_create=num_create_no_start,
                    auto_start=False)

        # start registered so we have actives to exit if need be
        if num_reg_to_start > 0:
            self.build_start_suite_num(num_to_start=num_reg_to_start)

        # create threads with auto_start
        if num_create_auto_start > 0:
            self.build_f1_create_suite_num(
                num_to_create=num_create_auto_start,
                auto_start=True)

        # Now that we have actives, do any needed exits
        if num_active_to_exit > 0:
            self.build_exit_suite_num(
                num_to_exit=num_active_to_exit)

        # Finally, join the stopped threads as needed
        if num_active_to_join > 0:
            self.build_join_suite_num(
                cmd_runners=cmd_runner,
                num_to_join=num_active_to_join)

        # verify the counts
        self.add_cmd(VerifyCounts(cmd_runners=cmd_runner,
                                  exp_num_registered=num_registered,
                                  exp_num_active=num_active,
                                  exp_num_stopped=num_stopped))

    ####################################################################
    # create_config
    ####################################################################
    def create_config(self,
                      unreg_names: Optional[Iterable] = None,
                      reg_names: Optional[Iterable] = None,
                      active_names: Optional[Iterable] = None,
                      stopped_names: Optional[Iterable] = None,
                      ) -> None:
        """Add ConfigCmd items to the queue to create a config.

        Args:
            unreg_names: thread names to be in the unreg pool
            reg_names: thread names to be in the registered pool
            active_names: thread names to be in the active pool
            stopped_names: thread names to be in the stopped pool

        """
        self.thread_names: list[str] = ['alpha']
        if unreg_names:
            self.thread_names.extend(unreg_names)

        if reg_names:
            self.thread_names.extend(reg_names)
        if active_names:
            self.thread_names.extend(active_names)
        if stopped_names:
            self.thread_names.extend(stopped_names)

        self.unregistered_names: set[str] = set(self.thread_names)
        self.setup_pending_events()

        if reg_names:
            names: list[str] = sorted(reg_names)
            f1_create_items: list[F1CreateItem] = []
            for idx, name in enumerate(names):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(F1CreateItem(name=name,
                                                    auto_start=False,
                                                    target_rtn=outer_f1,
                                                    app_config=app_config))

            self.build_create_suite(f1_create_items=f1_create_items,
                                    validate_config=True)

        if active_names:
            names: list[str] = sorted(active_names)
            f1_create_items: list[F1CreateItem] = []
            for idx, name in enumerate(names):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(F1CreateItem(name=name,
                                                    auto_start=True,
                                                    target_rtn=outer_f1,
                                                    app_config=app_config))

            self.build_create_suite(f1_create_items=f1_create_items,
                                    validate_config=True)

        if stopped_names:
            names: list[str] = sorted(stopped_names)
            f1_create_items: list[F1CreateItem] = []
            for idx, name in enumerate(names):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(F1CreateItem(name=name,
                                                    auto_start=True,
                                                    target_rtn=outer_f1,
                                                    app_config=app_config))

            self.build_create_suite(f1_create_items=f1_create_items,
                                    validate_config=True)

            self.build_exit_suite(cmd_runner=self.commander_name,
                                  names=names)

    ####################################################################
    # build_config_build_suite
    ####################################################################
    def build_config_build_suite(self,
                                 num_registered_1: int,
                                 num_active_1: int,
                                 num_stopped_1: int,
                                 num_registered_2: int,
                                 num_active_2: int,
                                 num_stopped_2: int
                                 ) -> None:
        """Return a list of ConfigCmd items for config build.

        Args:
            num_registered_1: number of threads to initially build as
                registered
            num_active_1: number of threads to initially build as
                active
            num_stopped_1: number of threads to initially build as
                stopped
            num_registered_2: number of threads to reconfigure as
                registered
            num_active_2: number of threads to reconfigure as active
            num_stopped_2: number of threads to reconfigure as stopped

        """
        self.build_config(
            cmd_runner=self.commander_name,
            num_registered=num_registered_1,
            num_active=num_active_1,
            num_stopped=num_stopped_1)
        self.build_config(
            cmd_runner=self.commander_name,
            num_registered=num_registered_2,
            num_active=num_active_2,
            num_stopped=num_stopped_2)

    ####################################################################
    # build_create_suite
    ####################################################################
    def build_create_suite(
            self,
            cmd_runner: Optional[str] = None,
            commander_name: Optional[str] = None,
            commander_auto_start: Optional[bool] = True,
            f1_create_items: Optional[list[F1CreateItem]] = None,
            validate_config: Optional[bool] = True
            ) -> None:
        """Return a list of ConfigCmd items for a create.

        Args:
            cmd_runner: name of thread to do the creates
            commander_name: specifies that a commander thread is to be
                created with this name
            commander_auto_start: specifies whether to start the
                commander thread during create
            f1_create_items: contain f1_names to create
            validate_config: indicates whether to do config validation

        """
        if commander_name:
            self.commander_name = commander_name
        if cmd_runner:
            cmd_runner_to_use = cmd_runner
        else:
            cmd_runner_to_use = self.commander_name

        if f1_create_items:
            f1_names: list[str] = []
            f1_auto_start_names: list[str] = []
            f1_auto_items: list[F1CreateItem] = []
            f1_no_start_names: list[str] = []
            f1_no_start_items: list[F1CreateItem] = []
            for f1_create_item in f1_create_items:
                f1_names.append(f1_create_item.name)
                if f1_create_item.auto_start:
                    f1_auto_start_names.append(f1_create_item.name)
                    f1_auto_items.append(f1_create_item)
                else:
                    f1_no_start_names.append(f1_create_item.name)
                    f1_no_start_items.append(f1_create_item)
                if f1_create_item.app_config == AppConfig.ScriptStyle:
                    self.thread_target_names |= {f1_create_item.name}
            if not set(f1_names).issubset(self.unregistered_names):
                self.abort_all_f1_threads()
                raise InvalidInputDetected(f'Input names {f1_names} not a '
                                           f'subset of unregistered names '
                                           f'{self.unregistered_names}')
            self.unregistered_names -= set(f1_names)
            if f1_auto_items:
                self.add_cmd(
                    CreateF1AutoStart(cmd_runners=cmd_runner_to_use,
                                      f1_create_items=f1_auto_items))

                self.active_names |= set(f1_auto_start_names)
            elif f1_no_start_items:
                self.add_cmd(
                    CreateF1NoStart(cmd_runners=cmd_runner_to_use,
                                    f1_create_items=f1_no_start_items))
                self.registered_names |= set(f1_no_start_names)

        if self.registered_names:
            self.add_cmd(VerifyConfig(
                cmd_runners=cmd_runner_to_use,
                verify_type=VerifyType.VerifyRegisteredState,
                names_to_check=self.registered_names.copy()))

        if self.active_names:
            # self.add_cmd(VerifyActive(
            #     cmd_runners=cmd_runner_to_use,
            #     exp_active_names=list(self.active_names)))
            self.add_cmd(VerifyConfig(
                cmd_runners=cmd_runner_to_use,
                verify_type=VerifyType.VerifyAliveState,
                names_to_check=self.active_names.copy()))

        if validate_config:
            # self.add_cmd(ValidateConfig(cmd_runners=cmd_runner_to_use))
            self.add_cmd(VerifyConfig(
                cmd_runners=cmd_runner_to_use,
                verify_type=VerifyType.VerifyStructures))

    ####################################################################
    # build_exit_suite
    ####################################################################
    def build_exit_suite(self,
                         cmd_runner: str,
                         names: Iterable,
                         validate_config: bool = True,
                         reset_ops_count: bool = False
                         ) -> None:
        """Add ConfigCmd items for an exit.

        Args:
            cmd_runner: name of thread that will do the cmd
            names: names of threads to exit
            validate_config: specifies whether to validate the
                configuration
            reset_ops_count: specifies that the pending_ops_count is to
                be set to zero

        """
        names = get_set(names)
        if not names.issubset(self.active_names):
            self.abort_all_f1_threads()
            raise InvalidInputDetected(f'Input names {names} not a subset '
                                       f'of active names {self.active_names}')
        active_names = list(self.active_names - names)

        if names:
            self.add_cmd(StopThread(cmd_runners=cmd_runner,
                                    stop_names=names,
                                    reset_ops_count=reset_ops_count))
            if validate_config:
                self.add_cmd(Pause(cmd_runners=cmd_runner,
                                   pause_seconds=.2))
                # self.add_cmd(VerifyAliveNot(cmd_runners=cmd_runner,
                #                             exp_not_alive_names=names))
                self.add_cmd(VerifyConfig(
                    cmd_runners=cmd_runner,
                    verify_type=VerifyType.VerifyNotAlive,
                    names_to_check=names))
                # self.add_cmd(VerifyState(
                #     cmd_runners=cmd_runner,
                #     check_state_names=names,
                #     expected_state=st.ThreadState.Alive))
                stopped_state_names: list[str] = []
                alive_state_names: list[str] = []
                # for name in names:
                #     if name in self.thread_target_names:
                #         stopped_state_names.append(name)
                #     else:
                #         alive_state_names.append(name)
                # if stopped_state_names:
                #     self.add_cmd(VerifyConfig(
                #         cmd_runners=cmd_runner,
                #         verify_type=VerifyType.VerifyState,
                #         names_to_check=stopped_state_names,
                #         state_to_check=st.ThreadState.Stopped))
                # if alive_state_names:
                self.add_cmd(VerifyConfig(
                    cmd_runners=cmd_runner,
                    verify_type=VerifyType.VerifyState,
                    names_to_check=names,
                    state_to_check=st.ThreadState.Alive))
        if active_names and validate_config:
            # self.add_cmd(VerifyAlive(cmd_runners=cmd_runner,
            #                          exp_alive_names=active_names))
            self.add_cmd(VerifyConfig(cmd_runners=cmd_runner,
                                      verify_type=VerifyType.VerifyAlive,
                                      names_to_check=active_names))
            # self.add_cmd(VerifyState(
            #     cmd_runners=cmd_runner,
            #     check_state_names=active_names,
            #     expected_state=st.ThreadState.Alive))
            self.add_cmd(VerifyConfig(cmd_runners=cmd_runner,
                                      verify_type=VerifyType.VerifyState,
                                      names_to_check=active_names,
                                      state_to_check=st.ThreadState.Alive))

        if validate_config:
            # self.add_cmd(ValidateConfig(cmd_runners=cmd_runner))
            self.add_cmd(VerifyConfig(
                cmd_runners=cmd_runner,
                verify_type=VerifyType.VerifyStructures))

        self.active_names -= names
        self.stopped_remotes |= names

    ####################################################################
    # build_exit_suite_num
    ####################################################################
    def build_exit_suite_num(self,
                             num_to_exit: int) -> None:
        """Return a list of ConfigCmd items for smart_unreg.

        Args:
            num_to_exit: number of threads to exit

        """
        assert num_to_exit > 0
        if (len(self.active_names) - 1) < num_to_exit:
            self.abort_all_f1_threads()
            raise InvalidInputDetected(f'Input num_to_exit {num_to_exit} '
                                       f'is greater than the number of '
                                       f'registered threads '
                                       f'{len(self.active_names)}')

        names: list[str] = list(
            random.sample(sorted(self.active_names - {self.commander_name}),
                          num_to_exit))

        return self.build_exit_suite(cmd_runner=self.commander_name,
                                     names=names)

    ####################################################################
    # build_f1_create_suite_num
    ####################################################################
    def build_f1_create_suite_num(self,
                                  num_to_create: int,
                                  auto_start: Optional[bool] = True,
                                  validate_config: Optional[bool] = True
                                  ) -> None:
        """Return a list of ConfigCmd items for a create.

        Args:
            num_to_create: number of f1 threads to create
            auto_start: indicates whether to use auto_start
            validate_config: indicates whether to do config validation

        """
        assert num_to_create > 0
        if len(self.unregistered_names) < num_to_create:
            self.abort_all_f1_threads()
            raise InvalidInputDetected(
                f'Input num_to_create {num_to_create} '
                f'is greater than the number of '
                f'unregistered threads '
                f'{len(self.unregistered_names)}')

        names: list[str] = list(
            random.sample(sorted(self.unregistered_names), num_to_create))
        f1_create_items: list[F1CreateItem] = []
        for idx, name in enumerate(names):
            if idx % 2:
                app_config = AppConfig.ScriptStyle
            else:
                app_config = AppConfig.RemoteThreadApp

            f1_create_items.append(F1CreateItem(name=name,
                                                auto_start=auto_start,
                                                target_rtn=outer_f1,
                                                app_config=app_config))

        self.build_create_suite(f1_create_items=f1_create_items,
                                validate_config=validate_config)

    ####################################################################
    # build_join_suite
    ####################################################################
    def build_join_suite(self,
                         cmd_runners: Iterable,
                         join_target_names: Iterable,
                         validate_config: Optional[bool] = True
                         ) -> None:
        """Return a list of ConfigCmd items for join.

        Args:
            cmd_runners: list of names to do the join
            join_target_names: the threads that are to be joined
            validate_config: specifies whether to validate the config
                after the join is done

        """
        cmd_runners = get_set(cmd_runners)
        join_target_names = get_set(join_target_names)

        if not join_target_names.issubset(self.stopped_remotes):
            self.abort_all_f1_threads()
            raise InvalidInputDetected(f'Input {join_target_names} is not a '
                                       'subset of inactive names '
                                       f'{self.stopped_remotes}')

        if join_target_names:
            self.add_cmd(Join(
                cmd_runners=cmd_runners,
                join_names=join_target_names))
            # self.add_cmd(VerifyInRegistryNot(
            #     cmd_runners=cmd_runners,
            #     exp_not_in_registry_names=join_target_names))
            self.add_cmd(VerifyConfig(
                cmd_runners=cmd_runners,
                verify_type=VerifyType.VerifyNotInRegistry,
                names_to_check=join_target_names))

            # self.add_cmd(VerifyPairedNot(
            #     cmd_runners=cmd_runners,
            #     exp_not_paired_names=join_target_names))
            self.add_cmd(VerifyConfig(
                cmd_runners=cmd_runners,
                verify_type=VerifyType.VerifyNotPaired,
                names_to_check=join_target_names))

        if validate_config:
            # self.add_cmd(ValidateConfig(cmd_runners=cmd_runners))
            self.add_cmd(VerifyConfig(
                cmd_runners=cmd_runners,
                verify_type=VerifyType.VerifyStructures))

        self.unregistered_names |= join_target_names
        self.stopped_remotes -= join_target_names

    ####################################################################
    # build_join_suite
    ####################################################################
    def build_join_suite_num(self,
                             cmd_runners: Iterable,
                             num_to_join: int) -> None:
        """Return a list of ConfigCmd items for join.

        Args:
            cmd_runners: threads running the command
            num_to_join: number of threads to join

        """
        assert num_to_join > 0
        if len(self.stopped_remotes) < num_to_join:
            self.abort_all_f1_threads()
            raise InvalidInputDetected(f'Input num_to_join {num_to_join} '
                                       f'is greater than the number of '
                                       f'stopped threads '
                                       f'{len(self.stopped_remotes)}')

        names: list[str] = list(
            random.sample(sorted(self.stopped_remotes), num_to_join))

        self.build_join_suite(
            cmd_runners=cmd_runners,
            join_target_names=names)

    ####################################################################
    # build_join_timeout_suite
    ####################################################################
    def build_join_timeout_suite(
            self,
            timeout_type: TimeoutType,
            num_active_no_target: int,
            num_no_delay_exit: int,
            num_delay_exit: int,
            num_delay_unreg: int,
            num_no_delay_reg: int,
            num_delay_reg: int) -> None:
        """Return a list of ConfigCmd items for a create.

        Args:
            timeout_type: specifies TimeoutNone, TimeoutFalse,
                or TimeoutTrue
            num_active_no_target: number of threads that should be
                active and stay active during the join as non-targets
            num_no_delay_exit: number of threads that should be active
                and targeted for join, and then exited immediately to
                allow the join to succeed
            num_delay_exit: number of threads that should be active and
                targeted for join, and then be exited after a short
                delay to allow a TimeoutFalse join to succeed, and a
                long delay to cause a TimeoutTrue join to
                timeout and a TimeoutNone to eventually succeed
            num_delay_unreg: number of threads that should be
                unregistered and targeted for join. These will cause the
                already unregistered log message and will be considered
                as successfully joined in the smart_join completion
                message. They will be eventually started to show that
                they are unaffected by the smart_join once they are
                recognized as already unregistered.
            num_no_delay_reg: number of threads that should be
                registered and targeted for join, and then be
                be immediately started and exited to allow the
                join to succeed
            num_delay_reg: number of threads that should be registered
                and targeted for join, and then be started and exited
                after a short delay to allow a TimeoutFalse join to
                succeed, and a long delay to cause a TimeoutTrue join to
                timeout and a TimeoutNone to eventually succeed

        """
        # Make sure we have enough threads
        assert 1 < (num_active_no_target
                    + num_no_delay_exit
                    + num_delay_exit
                    + num_delay_unreg
                    + num_no_delay_reg
                    + num_delay_reg) <= len(self.unregistered_names)

        if (timeout_type == TimeoutType.TimeoutFalse
                or timeout_type == TimeoutType.TimeoutTrue):
            assert (num_delay_exit
                    + num_delay_reg) > 0

        assert num_active_no_target > 0

        num_registered_needed = (
                num_no_delay_reg
                + num_delay_reg)

        num_active_needed = (
                num_active_no_target
                + num_no_delay_exit
                + num_delay_exit
                + 1)

        timeout_time = (((num_no_delay_exit
                        + num_no_delay_reg) * 0.3)
                        + ((num_delay_exit
                           + num_delay_reg) * 1.5))

        if timeout_type == TimeoutType.TimeoutNone:
            pause_time = 0.5
        elif timeout_type == TimeoutType.TimeoutFalse:
            pause_time = 0.5
            timeout_time += (pause_time * 4)  # prevent timeout
        else:  # timeout True
            pause_time = timeout_time + 1  # force timeout

        self.build_config(
            cmd_runner=self.commander_name,
            num_registered=num_registered_needed,
            num_active=num_active_needed)

        self.log_name_groups()

        unregistered_names_copy = self.unregistered_names.copy()
        registered_names_copy = self.registered_names.copy()
        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose receiver_names
        ################################################################
        active_no_target_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_active_no_target,
            update_collection=True,
            var_name_for_log='active_no_target_names')

        ################################################################
        # choose active_no_delay_sender_names
        ################################################################
        no_delay_exit_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_no_delay_exit,
            update_collection=True,
            var_name_for_log='no_delay_exit_names')

        ################################################################
        # choose active_delay_sender_names
        ################################################################
        delay_exit_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_delay_exit,
            update_collection=True,
            var_name_for_log='delay_exit_names')

        ################################################################
        # choose delay_unreg_names
        ################################################################
        delay_unreg_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_delay_unreg,
            update_collection=True,
            var_name_for_log='delay_unreg_names')

        ################################################################
        # choose unreg_sender_names
        ################################################################
        no_delay_reg_names = self.choose_names(
            name_collection=registered_names_copy,
            num_names_needed=num_no_delay_reg,
            update_collection=True,
            var_name_for_log='no_delay_reg_names')

        ################################################################
        # choose reg_sender_names
        ################################################################
        delay_reg_names = self.choose_names(
            name_collection=registered_names_copy,
            num_names_needed=num_delay_reg,
            update_collection=True,
            var_name_for_log='delay_reg_names')

        ################################################################
        # start by doing the recv_msgs, one for each sender
        ################################################################
        all_target_names: list[str] = (no_delay_exit_names
                                       + delay_exit_names
                                       + delay_unreg_names
                                       + no_delay_reg_names
                                       + delay_reg_names)

        all_timeout_names: list[str] = (delay_exit_names
                                        + delay_reg_names)

        if len(all_target_names) % 2 == 0:
            log_msg = f'join log test: {get_ptime()}'
        else:
            log_msg = None

        ################################################################
        # start the join
        ################################################################
        if timeout_type == TimeoutType.TimeoutNone:
            confirm_cmd_to_use = 'Join'
            join_serial_num = self.add_cmd(
                Join(cmd_runners=active_no_target_names[0],
                     join_names=all_target_names,
                     unreg_names=delay_unreg_names,
                     log_msg=log_msg))
        elif timeout_type == TimeoutType.TimeoutFalse:
            confirm_cmd_to_use = 'JoinTimeoutFalse'
            join_serial_num = self.add_cmd(
                JoinTimeoutFalse(cmd_runners=active_no_target_names[0],
                                 join_names=all_target_names,
                                 unreg_names=delay_unreg_names,
                                 timeout=timeout_time,
                                 log_msg=log_msg))
        else:  # TimeoutType.TimeoutTrue
            confirm_cmd_to_use = 'JoinTimeoutTrue'
            join_serial_num = self.add_cmd(
                JoinTimeoutTrue(cmd_runners=active_no_target_names[0],
                                join_names=all_target_names,
                                unreg_names=delay_unreg_names,
                                timeout=timeout_time,
                                timeout_names=all_timeout_names,
                                log_msg=log_msg))

        ################################################################
        # handle no_delay_exit_names
        ################################################################
        if no_delay_exit_names:
            self.build_exit_suite(cmd_runner=self.commander_name,
                                  names=no_delay_exit_names,
                                  validate_config=False)

        ################################################################
        # handle no_delay_reg_names
        ################################################################
        if no_delay_reg_names:
            self.build_start_suite(start_names=no_delay_reg_names,
                                   validate_config=False)
            self.build_exit_suite(cmd_runner=self.commander_name,
                                  names=no_delay_reg_names,
                                  validate_config=False)

        ################################################################
        # make sure smart_join is in loop waiting for timeout names
        ################################################################
        if (timeout_type != TimeoutType.TimeoutNone
                and all_timeout_names):
            self.add_cmd(
                WaitForRequestTimeouts(
                    cmd_runners=self.commander_name,
                    actor_names=active_no_target_names[0],
                    timeout_names=all_timeout_names,
                    use_work_remotes=True,
                    as_subset=True))

        ################################################################
        # pause for short or long delay
        ################################################################
        self.add_cmd(
            Pause(cmd_runners=self.commander_name,
                  pause_seconds=pause_time))

        ################################################################
        # make sure smart_join sees the timeout_names as pending
        ################################################################
        if (timeout_type != TimeoutType.TimeoutNone
                and all_timeout_names):
            self.add_cmd(
                WaitForRequestTimeouts(
                    cmd_runners=self.commander_name,
                    actor_names=active_no_target_names[0],
                    timeout_names=all_timeout_names,
                    use_work_remotes=True,
                    as_subset=True))

        ################################################################
        # handle delay_exit_names
        ################################################################
        if delay_exit_names:
            self.build_exit_suite(cmd_runner=self.commander_name,
                                  names=delay_exit_names,
                                  validate_config=False)

        ################################################################
        # handle delay_reg_names
        ################################################################
        if delay_reg_names:
            self.build_start_suite(start_names=delay_reg_names,
                                   validate_config=False)
            self.add_cmd(VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyAliveState,
                names_to_check=delay_reg_names))

            self.build_exit_suite(cmd_runner=self.commander_name,
                                  names=delay_reg_names,
                                  validate_config=False)

        ################################################################
        # handle delay_unreg_names
        ################################################################
        if delay_unreg_names:
            f1_create_items: list[F1CreateItem] = []
            for idx, name in enumerate(delay_unreg_names):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(F1CreateItem(name=name,
                                                    auto_start=True,
                                                    target_rtn=outer_f1,
                                                    app_config=app_config))

            self.build_create_suite(f1_create_items=f1_create_items,
                                    validate_config=False)
            self.build_exit_suite(cmd_runner=self.commander_name,
                                  names=delay_unreg_names,
                                  validate_config=False)

        ################################################################
        # finally, confirm the smart_recv is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd=confirm_cmd_to_use,
                confirm_serial_num=join_serial_num,
                confirmers=active_no_target_names[0]))

        if delay_unreg_names:
            self.add_cmd(VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStoppedState,
                names_to_check=delay_unreg_names))

    ####################################################################
    # build_msg_suite
    ####################################################################
    def build_msg_suite(self,
                        from_names: list[str],
                        to_names: list[str]) -> None:
        """Return a list of ConfigCmd items for msgs.

        Args:
            from_names: names of threads that send
            to_names: names of threads that receive

        """
        msgs_to_send = SendRecvMsgs(
            sender_names=from_names,
            receiver_names=to_names,
            num_msgs=1,
            send_type=SendType.ToRemotes)

        self.add_cmd(
            SendMsg(cmd_runners=from_names,
                    receivers=to_names,
                    msgs_to_send=msgs_to_send,
                    msg_idx=0))

        self.add_cmd(
            RecvMsg(cmd_runners=to_names,
                    senders=from_names,
                    exp_senders=from_names,
                    exp_msgs=msgs_to_send))

    ####################################################################
    # build_pending_sans_sync_scenario
    ####################################################################
    def build_pending_sans_sync_scenario(
            self,
            request_type: st.ReqType,
            pending_request_tf: bool,
            pending_msg_count: int,
            pending_wait_tf: bool) -> None:
        """Return a list of ConfigCmd items for a create.

        Args:
            request_type: request type that is to get the pending
                flags set on it
            pending_request_tf: if True, pending_request flag is to be
                set
            pending_msg_count: number of msgs to be placed on the
                pending thread
            pending_wait_tf: if True, pending_wait flag is to be set

        Notes:
            There are two test cases dealing with the pending flags:
            test_pending_sans_sync_scenario:
                this will test combinations for:
                    pending_request: True, False
                    pending_msg: count of 0, 1, 2
                    pending_wait: True, False
                using requests:
                    smart_send
                    smart_recv
                    smart_wait
                    smart_resume

            test_pending_sync_only_scenario:
                this will test combinations for:
                    pending_request: True
                    pending_msg: count of 0, 1, 2
                    pending_wait: True, False
                    pending_sync: True, False
                using requests:
                    smart_sync

            The reason for having two different test cases is that
            pending_sync can only be set with smart_sync, and
            only with pending_request also set.
        """
        pending_names = ['pending_0']
        remote_names = ['remote_0']
        locker_names = ['locker_0', 'locker_1', 'locker_2']
        joiner_names = ['joiner_0']

        active_names: list[str] = (
                pending_names
                + remote_names
                + locker_names
                + joiner_names)

        self.create_config(active_names=active_names)

        self.log_name_groups()

        lock_positions: list[str] = []
        pend_req_serial_num: int = 0
        join_serial_num: int = 0

        ################################################################
        # verify all flags off
        ################################################################
        exp_pending_flags = PendingFlags()
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyPendingFlags,
            names_to_check=pending_names,
            aux_names=remote_names,
            exp_pending_flags=exp_pending_flags,
            obtain_reg_lock=False))

        ################################################################
        # handle pending_msg_count
        ################################################################
        msgs_remote_to_pending = SendRecvMsgs(
            sender_names=remote_names,
            receiver_names=pending_names,
            num_msgs=max(1, pending_msg_count),
            send_type=SendType.ToRemotes)

        for idx in range(pending_msg_count):
            send_msg_serial_num = self.add_cmd(SendMsg(
                cmd_runners=remote_names,
                receivers=pending_names,
                msgs_to_send=msgs_remote_to_pending,
                msg_idx=idx,
                send_type=SendType.ToRemotes))
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd='SendMsg',
                    confirm_serial_num=send_msg_serial_num,
                    confirmers=remote_names))

        exp_pending_flags = PendingFlags(pending_msgs=pending_msg_count)
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyPendingFlags,
            names_to_check=pending_names,
            aux_names=remote_names,
            exp_pending_flags=exp_pending_flags,
            obtain_reg_lock=False))

        ################################################################
        # handle pending_wait
        ################################################################
        if pending_wait_tf:
            resume_serial_num = self.add_cmd(Resume(
                cmd_runners=remote_names,
                targets=pending_names,
                exp_resumed_targets=pending_names))
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd='Resume',
                    confirm_serial_num=resume_serial_num,
                    confirmers=remote_names))

        exp_pending_flags = PendingFlags(pending_msgs=pending_msg_count,
                                         pending_wait=pending_wait_tf)
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyPendingFlags,
            names_to_check=pending_names,
            aux_names=remote_names,
            exp_pending_flags=exp_pending_flags,
            obtain_reg_lock=False))

        if pending_request_tf:
            ############################################################
            # start of by getting lock_0
            # locks held:
            # before: none
            # after : lock_0
            ############################################################
            obtain_lock_serial_num_0 = self.add_cmd(
                LockObtain(cmd_runners=locker_names[0]))
            lock_positions.append(locker_names[0])

            # we can confirm only this first lock obtain
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='LockObtain',
                    confirm_serial_num=obtain_lock_serial_num_0,
                    confirmers=locker_names[0]))

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ############################################################
            # smart_req will get behind lock_0 in request_setup
            # locks held:
            # before: lock_0
            # after : lock_0|smart_req
            ############################################################
            stopped_remotes = set()
            if request_type == st.ReqType.Smart_send:
                stopped_remotes = remote_names[0]
                msgs_pending_to_remote = SendRecvMsgs(
                    sender_names=pending_names,
                    receiver_names=remote_names,
                    num_msgs=1,
                    send_type=SendType.ToRemotes)
                pend_req_serial_num = self.add_cmd(
                    SendMsg(cmd_runners=pending_names[0],
                            receivers=remote_names[0],
                            msgs_to_send=msgs_pending_to_remote,
                            msg_idx=0,
                            stopped_remotes=stopped_remotes))
            elif request_type == st.ReqType.Smart_recv:

                if pending_msg_count == 0:
                    stopped_remotes = remote_names[0]
                    exp_senders: set[str] = set()
                else:
                    exp_senders: set[str] = {remote_names[0]}
                pend_req_serial_num = self.add_cmd(
                    RecvMsg(cmd_runners=pending_names[0],
                            senders=remote_names[0],
                            exp_msgs=msgs_remote_to_pending,
                            exp_senders=exp_senders,
                            stopped_remotes=stopped_remotes))
            elif request_type == st.ReqType.Smart_wait:
                if not pending_wait_tf:
                    stopped_remotes = remote_names[0]
                    exp_resumers: set[str] = set()
                else:
                    exp_resumers: set[str] = {remote_names[0]}
                pend_req_serial_num = self.add_cmd(
                    Wait(cmd_runners=pending_names[0],
                         resumers=remote_names[0],
                         exp_resumers=exp_resumers,
                         stopped_remotes=stopped_remotes))
            elif request_type == st.ReqType.Smart_resume:
                stopped_remotes = remote_names[0]
                pend_req_serial_num = self.add_cmd(
                    Resume(cmd_runners=pending_names[0],
                           targets=remote_names[0],
                           exp_resumed_targets=remote_names[0],
                           stopped_remotes=stopped_remotes))
            else:
                raise InvalidInputDetected(
                    'build_pending_sans_sync_scenario detected invalid '
                    f'input with {request_type=}')

            lock_positions.append(pending_names[0])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            pe = self.pending_events[pending_names[0]]
            if request_type == st.ReqType.Smart_recv:
                if not pending_wait_tf:
                    ref_key: CallRefKey = 'smart_recv'
                    pe[PE.calling_refresh_msg][ref_key] += 1
            elif request_type == st.ReqType.Smart_wait:
                if pending_msg_count == 0:
                    ref_key: CallRefKey = 'smart_wait'
                    pe[PE.calling_refresh_msg][ref_key] += 1
            else:
                if (pending_msg_count == 0
                        and not pending_wait_tf):
                    ref_key: CallRefKey = request_type.value
                    pe[PE.calling_refresh_msg][ref_key] += 1

            ############################################################
            # locker_1 gets behind the smart_req
            # locks held:
            # before: lock_0|smart_req
            # after : lock_0|smart_req|lock_1
            ############################################################
            self.add_cmd(
                LockObtain(cmd_runners=locker_names[1]))
            lock_positions.append(locker_names[1])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ################################################################
            # smart_join gets behind lock_1
            # locks held:
            # before: lock_0|smart_req|lock_1
            # after : lock_0|smart_req|lock_1|smart_join
            ################################################################
            join_serial_num = self.add_cmd(
                Join(cmd_runners=joiner_names[0],
                     join_names=remote_names[0]))
            lock_positions.append(joiner_names[0])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ################################################################
            # locker_2 gets behind the smart_join
            # locks held:
            # before: lock_0|smart_req|lock_1|smart_join
            # after : lock_0|smart_req|lock_1|smart_join|lock_2
            ################################################################
            self.add_cmd(
                LockObtain(cmd_runners=locker_names[2]))
            lock_positions.append(locker_names[2])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ################################################################
            # release lock_0 to allow smart_wait to do request_set_up
            # to get pending_request set, and then wait behind lock_2
            # before going into request loop
            # locks held:
            # before: lock_0|smart_req|lock_1|smart_join|lock_2
            # after : lock_1|smart_join|lock_2|smart_req
            ################################################################
            self.add_cmd(
                LockRelease(cmd_runners=locker_names[0]))
            lock_positions.remove(locker_names[0])
            # releasing lock 0 will allow the smart_wait to do request_setup
            # and then get behind lock_2
            lock_positions.remove(pending_names[0])
            lock_positions.append(pending_names[0])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

        ################################################################
        # verify results
        ################################################################
        exp_pending_flags = PendingFlags(pending_request=pending_request_tf,
                                         pending_msgs=pending_msg_count,
                                         pending_wait=pending_wait_tf,
                                         pending_sync=False)
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyPendingFlags,
            names_to_check=pending_names,
            aux_names=remote_names,
            exp_pending_flags=exp_pending_flags,
            obtain_reg_lock=False))

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyStructures,
            obtain_reg_lock=False))

        self.build_exit_suite(cmd_runner=self.commander_name,
                              names=remote_names,
                              validate_config=False)

        if pending_request_tf:
            ############################################################
            # release lock_1 to allow smart_join to remove remotes
            # locks held:
            # before: lock_1|smart_join|lock_2|smart_req
            # after : lock_2|smart_req
            ############################################################
            self.add_cmd(
                LockRelease(cmd_runners=locker_names[1]))
            lock_positions.remove(locker_names[1])
            # releasing lock 1 will allow the smart_join to complete
            lock_positions.remove(joiner_names[0])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))
        else:
            ############################################################
            # do smart_join, no locks to deal with
            ############################################################
            join_serial_num = self.add_cmd(
                Join(cmd_runners=joiner_names[0],
                     join_names=remote_names[0]))

        ################################################################
        # verify results
        ################################################################
        exp_pending_flags = PendingFlags(
            pending_request=pending_request_tf,
            pending_msgs=pending_msg_count,
            pending_wait=pending_wait_tf,
            pending_sync=False)

        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyPendingFlags,
            names_to_check=pending_names,
            aux_names=remote_names,
            exp_pending_flags=exp_pending_flags,
            obtain_reg_lock=False))

        pe = self.pending_events[joiner_names[0]]

        pair_key = st.SmartThread._get_pair_key(pending_names[0],
                                                remote_names[0])

        pending_msg_tf: bool = False
        if pending_msg_count > 0:
            pending_msg_tf = True
        if (pending_request_tf
                or pending_msg_tf
                or pending_wait_tf):
            def_del_reasons: DefDelReasons = DefDelReasons(
                pending_request=pending_request_tf,
                pending_msg=pending_msg_tf,
                pending_wait=pending_wait_tf,
                pending_sync=False)

            rem_sb_key: RemSbKey = (pending_names[0],
                                    pair_key,
                                    def_del_reasons)

            pe[PE.notify_rem_status_block_def_msg][rem_sb_key] += 1

        if lock_positions:  # if we still hold lock_2
            ############################################################
            # release lock_2 to allow smart_req to complete
            # locks held:
            # before: lock_2|smart_req
            # after:  None
            ############################################################
            self.add_cmd(
                LockRelease(cmd_runners=locker_names[2]))
            lock_positions.remove(locker_names[2])
            # releasing lock 1 will allow the smart_unreg complete
            lock_positions.remove(pending_names[0])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

        ################################################################
        # confirm the wait is done
        ################################################################
        if pend_req_serial_num:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd='Wait',
                    confirm_serial_num=pend_req_serial_num,
                    confirmers=pending_names))

        ################################################################
        # confirm the join is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd='Unregister',
                confirm_serial_num=join_serial_num,
                confirmers=joiner_names))
        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyStructures,
            obtain_reg_lock=False))

    ####################################################################
    # build_pending_sync_only_scenarios
    ####################################################################
    def build_pending_sync_only_scenarios(
            self,
            pending_msg_count: int,
            pending_wait_tf: bool,
            pending_sync_tf: bool) -> None:
        """Return a list of ConfigCmd items for a create.

        Args:
            pending_msg_count: number of msgs to be placed on the
                pending thread
            pending_wait_tf: if True, pending_wait flag is to be set
            pending_sync_tf: if True, pending_sync flag is to be set

        Notes:
            There are two test cases dealing with the pending flags:
            test_pending_sans_sync_scenario:
                this will test combinations for:
                    pending_request: True, False
                    pending_msg: count of 0, 1, 2
                    pending_wait: True, False
                using requests:
                    smart_send
                    smart_recv
                    smart_wait
                    smart_resume

            test_pending_sync_only_scenario:
                this will test combinations for:
                    pending_request: True
                    pending_msg: count of 0, 1, 2
                    pending_wait: True, False
                    pending_sync: True, False
                using requests:
                    smart_sync

            The reason for having two different test cases is that
            pending_sync can only be set with smart_sync, and
            only with pending_request also set.
        """
        pending_names = ['pending_0']
        remote_names = ['remote_0']
        locker_names = ['locker_0', 'locker_1', 'locker_2',
                        'locker_3', 'locker_4']
        joiner_names = ['joiner_0']

        active_names: list[str] = (
                pending_names
                + remote_names
                + locker_names
                + joiner_names)

        self.create_config(active_names=active_names)

        self.log_name_groups()

        lock_positions: list[str] = []
        pend_req_serial_num: int = 0
        join_serial_num: int = 0

        ################################################################
        # verify all flags off
        ################################################################
        exp_pending_flags = PendingFlags()
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyPendingFlags,
            names_to_check=pending_names,
            aux_names=remote_names,
            exp_pending_flags=exp_pending_flags,
            obtain_reg_lock=False))

        ################################################################
        # handle pending_msg_count
        ################################################################
        msgs_remote_to_pending = SendRecvMsgs(
            sender_names=remote_names,
            receiver_names=pending_names,
            num_msgs=max(1, pending_msg_count),
            send_type=SendType.ToRemotes)

        for idx in range(pending_msg_count):
            send_msg_serial_num = self.add_cmd(SendMsg(
                cmd_runners=remote_names,
                receivers=pending_names,
                msgs_to_send=msgs_remote_to_pending,
                msg_idx=idx,
                send_type=SendType.ToRemotes))
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd='SendMsg',
                    confirm_serial_num=send_msg_serial_num,
                    confirmers=remote_names))

        exp_pending_flags = PendingFlags(pending_msgs=pending_msg_count)
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyPendingFlags,
            names_to_check=pending_names,
            aux_names=remote_names,
            exp_pending_flags=exp_pending_flags,
            obtain_reg_lock=False))

        ################################################################
        # handle pending_wait
        ################################################################
        if pending_wait_tf:
            resume_serial_num = self.add_cmd(Resume(
                cmd_runners=remote_names,
                targets=pending_names,
                exp_resumed_targets=pending_names,))
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd='Resume',
                    confirm_serial_num=resume_serial_num,
                    confirmers=remote_names))

        exp_pending_flags = PendingFlags(pending_msgs=pending_msg_count,
                                         pending_wait=pending_wait_tf)
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyPendingFlags,
            names_to_check=pending_names,
            aux_names=remote_names,
            exp_pending_flags=exp_pending_flags,
            obtain_reg_lock=False))

        ################################################################
        # start of by getting lock_0
        # locks held:
        # before: none
        # after : lock_0
        ################################################################
        obtain_lock_serial_num_0 = self.add_cmd(
            LockObtain(cmd_runners=locker_names[0]))
        lock_positions.append(locker_names[0])

        # we can confirm only this first lock obtain
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd='LockObtain',
                confirm_serial_num=obtain_lock_serial_num_0,
                confirmers=locker_names[0]))

        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # pend_sync will get behind lock_0 in request_setup
        # locks held:
        # before: lock_0
        # after : lock_0|pend_sync
        ################################################################
        if pending_sync_tf:
            stopped_remotes = set()
        else:
            stopped_remotes = remote_names[0]
        pend_req_serial_num = self.add_cmd(
            Sync(cmd_runners=pending_names[0],
                 targets=remote_names[0],
                 stopped_remotes=stopped_remotes))

        lock_positions.append(pending_names[0])

        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        if (pending_msg_count == 0
                and not pending_wait_tf):
            pe = self.pending_events[pending_names[0]]
            ref_key: CallRefKey = 'smart_sync'

            pe[PE.calling_refresh_msg][ref_key] += 1

        ################################################################
        # locker_1 gets behind the pend_sync
        # locks held:
        # before: lock_0|pend_sync
        # after : lock_0|pend_sync|lock_1
        ################################################################
        self.add_cmd(
            LockObtain(cmd_runners=locker_names[1]))
        lock_positions.append(locker_names[1])

        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ############################################################
        # handle sync case part 1
        ############################################################
        if pending_sync_tf:
            ############################################################
            # remote_sync gets behind lock_1
            # locks held:
            # before: lock_0|pend_sync|lock_1
            # after : lock_0|pend_sync|lock_1|remote_sync
            ############################################################
            self.add_cmd(Sync(
                cmd_runners=remote_names[0],
                targets=pending_names[0],
                stopped_remotes=set()))
            lock_positions.append(remote_names[0])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ############################################################
            # locker_4 gets behind remote_sync
            # locks held:
            # before: lock_0|pend_sync|lock_1|remote_sync
            # after : lock_0|pend_sync|lock_1|remote_sync|lock_4
            ############################################################
            self.add_cmd(
                LockObtain(cmd_runners=locker_names[4]))
            lock_positions.append(locker_names[4])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ############################################################
            # release lock_0 to get pend_sync to set its pending_request
            # and then get behind lock_2 just before starting request
            # loop
            # locks held:
            # before: lock_0|pend_sync|lock_1|remote_sync|lock_4
            # after : lock_1|remote_sync|lock_4|pend_sync
            ############################################################
            self.add_cmd(
                LockRelease(cmd_runners=locker_names[0]))
            lock_positions.remove(locker_names[0])
            lock_positions.remove(pending_names[0])

            lock_positions.append(pending_names[0])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ############################################################
            # locker_3 gets behind pend_sync to block remote_sync
            # locks held:
            # before: lock_1|remote_sync|lock_4|pend_sync
            # after : lock_1|remote_sync|lock_4|pend_sync|lock_3
            ############################################################
            self.add_cmd(
                LockObtain(cmd_runners=locker_names[3]))
            lock_positions.append(locker_names[3])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ############################################################
            # release lock_1 to get remote_sync to set its
            # pending_request and then get behind lock_2 just before
            # starting request loop
            # locks held:
            # before: lock_1|remote_sync|lock_4|pend_sync|lock_3
            # after : lock_4|pend_sync|lock_3|remote_sync
            ############################################################
            self.add_cmd(
                LockRelease(cmd_runners=locker_names[1]))
            lock_positions.remove(locker_names[1])
            lock_positions.remove(remote_names[0])

            lock_positions.append(remote_names[0])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ############################################################
            # locker_1 gets behind remote_sync
            # locks held:
            # before: lock_4|pend_sync|lock_3|remote_sync
            # after : lock_4|pend_sync|lock_3|remote_sync|lock_1
            ############################################################
            self.add_cmd(
                LockObtain(cmd_runners=locker_names[1]))
            lock_positions.append(locker_names[1])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))
            ############################################################
            # smart_join gets behind lock_1
            # locks held:
            # before: lock_4|pend_sync|lock_3|remote_sync|lock_1
            # after : lock_4|pend_sync|lock_3|remote_sync|lock_1
            #         |smart_join
            ############################################################
            join_serial_num = self.add_cmd(
                Join(cmd_runners=joiner_names[0],
                     join_names=remote_names[0]))
            lock_positions.append(joiner_names[0])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ############################################################
            # locker_2 gets behind smart_join to block pend_sync
            # locks held:
            # before: lock_4|pend_sync|lock_3|remote_sync|lock_1
            #         |smart_join
            # after : lock_4|pend_sync|lock_3|remote_sync|lock_1
            #         |smart_join|lock_2
            ############################################################
            self.add_cmd(
                LockObtain(cmd_runners=locker_names[2]))
            lock_positions.append(locker_names[2])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ############################################################
            # release lock_4 to get pend_sync to set sync flag for
            # remote_sync and then get behind lock_2 (because its sync
            # flag is not yet set by remote_sync)
            # locks held:
            # before: lock_4|pend_sync|lock_3|remote_sync|lock_1
            #         |smart_join|lock_2
            # after : lock_3|remote_sync|lock_1|smart_join|lock_2
            #         |pend_sync
            ############################################################
            self.add_cmd(
                LockRelease(cmd_runners=locker_names[4]))
            lock_positions.remove(locker_names[4])
            lock_positions.remove(pending_names[0])

            lock_positions.append(pending_names[0])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ############################################################
            # release lock_3 to allow remote_sync to set sync flag for
            # pend_sync and complete the request
            # locks held:
            # before: lock_3|remote_sync|lock_1|smart_join|lock_2
            #         |pend_sync
            # after : lock_1|smart_join|lock_2|pend_sync
            ############################################################
            self.add_cmd(
                LockRelease(cmd_runners=locker_names[3]))
            lock_positions.remove(locker_names[3])
            lock_positions.remove(remote_names[0])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))
        else:
            ############################################################
            # smart_join gets behind lock_1
            # locks held:
            # before: lock_0|pend_sync|lock_1
            # after : lock_0|pend_sync|lock_1|smart_join
            ############################################################
            join_serial_num = self.add_cmd(
                Join(cmd_runners=joiner_names[0],
                     join_names=remote_names[0]))
            lock_positions.append(joiner_names[0])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ################################################################
            # locker_2 gets behind the smart_join
            # before: lock_0|pend_sync|lock_1|smart_join
            # after : lock_0|pend_sync|lock_1|smart_join|lock_2
            ################################################################
            self.add_cmd(
                LockObtain(cmd_runners=locker_names[2]))
            lock_positions.append(locker_names[2])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ################################################################
            # release lock_0 to allow pend_sync to do request_set_up
            # to get pending_request set, and then wait behind lock_2
            # before going into request loop
            # before: lock_0|pend_sync|lock_1|smart_join|lock_2
            # after : lock_1|smart_join|lock_2|pend_sync
            ################################################################
            self.add_cmd(
                LockRelease(cmd_runners=locker_names[0]))
            lock_positions.remove(locker_names[0])
            lock_positions.remove(pending_names[0])

            lock_positions.append(pending_names[0])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

        ################################################################
        # verify results
        ################################################################
        exp_pending_flags = PendingFlags(pending_request=True,
                                         pending_msgs=pending_msg_count,
                                         pending_wait=pending_wait_tf,
                                         pending_sync=pending_sync_tf)
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyPendingFlags,
            names_to_check=pending_names,
            aux_names=remote_names,
            exp_pending_flags=exp_pending_flags,
            obtain_reg_lock=False))

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyStructures,
            obtain_reg_lock=False))

        self.build_exit_suite(cmd_runner=self.commander_name,
                              names=remote_names,
                              validate_config=False)

        ############################################################
        # release lock_1 to allow smart_join to remove remotes
        # before: lock_1|smart_join|lock_2|pend_sync
        # after : lock_2|pend_sync
        ############################################################
        self.add_cmd(
            LockRelease(cmd_runners=locker_names[1]))
        lock_positions.remove(locker_names[1])
        # releasing lock 1 will allow the smart_join to complete
        lock_positions.remove(joiner_names[0])

        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # verify results
        ################################################################
        exp_pending_flags = PendingFlags(
            pending_request=True,
            pending_msgs=pending_msg_count,
            pending_wait=pending_wait_tf,
            pending_sync=pending_sync_tf)
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyPendingFlags,
            names_to_check=pending_names,
            aux_names=remote_names,
            exp_pending_flags=exp_pending_flags,
            obtain_reg_lock=False))

        pe = self.pending_events[joiner_names[0]]

        pair_key = st.SmartThread._get_pair_key(pending_names[0],
                                                remote_names[0])

        pending_msg_tf: bool = False
        if pending_msg_count > 0:
            pending_msg_tf = True
        def_del_reasons: DefDelReasons = DefDelReasons(
            pending_request=True,
            pending_msg=pending_msg_tf,
            pending_wait=pending_wait_tf,
            pending_sync=pending_sync_tf)

        rem_sb_key: RemSbKey = (pending_names[0],
                                pair_key,
                                def_del_reasons)

        pe[PE.notify_rem_status_block_def_msg][rem_sb_key] += 1

        if lock_positions:  # if we still hold lock_2
            ############################################################
            # release lock_2 to allow pend_sync to complete
            # before: lock_2|pend_sync
            # after : none
            ############################################################
            self.add_cmd(
                LockRelease(cmd_runners=locker_names[2]))
            lock_positions.remove(locker_names[2])
            lock_positions.remove(pending_names[0])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

        ################################################################
        # confirm the pend_sync is done
        ################################################################
        if pend_req_serial_num:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd='Wait',
                    confirm_serial_num=pend_req_serial_num,
                    confirmers=pending_names))

        ################################################################
        # confirm the join is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd='Join',
                confirm_serial_num=join_serial_num,
                confirmers=joiner_names))

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyStructures,
            obtain_reg_lock=True))

    ####################################################################
    # build_remove_reasons_scenarios
    ####################################################################
    def build_remove_reasons_scenarios(
            self,
            pending_msg_count: int,
            pending_wait_tf: bool,
            pending_sync_tf: bool) -> None:
        """Return a list of ConfigCmd items for a create.

        Args:
            pending_msg_count: number of msgs to be placed on the
                pending thread
            pending_wait_tf: if True, pending_wait flag is to be set
            pending_sync_tf: if True, pending_sync flag is to be set

        """
        pending_names = ['pending_0']
        remote_names = ['remote_0']
        locker_names = ['locker_0', 'locker_1', 'locker_2']
        joiner_names = ['joiner_0']

        active_names: list[str] = (
                pending_names
                + remote_names
                + locker_names
                + joiner_names)

        self.create_config(active_names=active_names)

        self.log_name_groups()

        pending_name = pending_names[0]
        remote_name = remote_names[0]
        joiner_name = joiner_names[0]

        lock_positions: list[str] = []
        pend_req_serial_num: int = 0
        join_serial_num: int = 0

        ################################################################
        # verify all flags off
        ################################################################
        exp_pending_flags = PendingFlags()
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyPendingFlags,
            names_to_check=pending_name,
            aux_names=remote_name,
            exp_pending_flags=exp_pending_flags,
            obtain_reg_lock=False))

        ################################################################
        # handle pending_msg_count
        ################################################################
        msgs_remote_to_pending = SendRecvMsgs(
            sender_names=remote_name,
            receiver_names=pending_name,
            num_msgs=max(1, pending_msg_count),
            send_type=SendType.ToRemotes)

        for idx in range(pending_msg_count):
            send_msg_serial_num = self.add_cmd(SendMsg(
                cmd_runners=remote_name,
                receivers=pending_name,
                msgs_to_send=msgs_remote_to_pending,
                msg_idx=idx,
                send_type=SendType.ToRemotes))
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd='SendMsg',
                    confirm_serial_num=send_msg_serial_num,
                    confirmers=remote_name))

        exp_pending_flags = PendingFlags(pending_msgs=pending_msg_count)
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyPendingFlags,
            names_to_check=pending_name,
            aux_names=remote_name,
            exp_pending_flags=exp_pending_flags,
            obtain_reg_lock=False))

        ################################################################
        # handle pending_wait
        ################################################################
        if pending_wait_tf:
            resume_serial_num = self.add_cmd(Resume(
                cmd_runners=remote_name,
                exp_resumed_targets=remote_name,
                targets=pending_name))
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd='Resume',
                    confirm_serial_num=resume_serial_num,
                    confirmers=remote_name))

        exp_pending_flags = PendingFlags(pending_msgs=pending_msg_count,
                                         pending_wait=pending_wait_tf)
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyPendingFlags,
            names_to_check=pending_name,
            aux_names=remote_name,
            exp_pending_flags=exp_pending_flags,
            obtain_reg_lock=False))

        ################################################################
        # handle pending_sync
        ################################################################
        sync_serial_num = 0
        if pending_sync_tf:
            ############################################################
            # start of by getting lock_0
            # locks held:
            # before: none
            # after : lock_0
            ############################################################
            obtain_lock_serial_num_0 = self.add_cmd(
                LockObtain(cmd_runners=locker_names[0]))
            lock_positions.append(locker_names[0])

            # we can confirm only this first lock obtain
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='LockObtain',
                    confirm_serial_num=obtain_lock_serial_num_0,
                    confirmers=locker_names[0]))

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ############################################################
            # remote smart_sync will get behind lock_0 in request_setup
            # locks held:
            # before: lock_0
            # after : lock_0|smart_sync
            ############################################################
            sync_serial_num = self.add_cmd(Sync(
                cmd_runners=remote_name,
                targets=pending_name,
                stopped_remotes=pending_name))

            lock_positions.append(remote_name)

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            # Normally, handle_request_smart_sync_entry will set up the
            # ack msg when the target is not included in the set of
            # stopped_remotes. In this case, we know the sync flag will
            # be set for the pending_name, but we include it in the set
            # of stopped_remotes. So, we need to set up the ack msg
            # here.
            pe = self.pending_events[remote_name]

            ack_key: AckKey = (pending_name, 'smart_sync_set')

            pe[PE.ack_msg][ack_key] += 1

            # smart_sync will eventually see that it was delete deferred
            # while it was behind the lock when pending_name was joined.
            # So, we need to indicate that the smart_sync will do a
            # refresh.

            pe = self.pending_events[remote_name]
            ref_key: CallRefKey = 'smart_sync'
            pe[PE.calling_refresh_msg][ref_key] += 1

            ############################################################
            # lock_1 gets behind the smart_sync
            # locks held:
            # before: lock_0|smart_sync
            # after : lock_0|smart_sync|lock_1
            ############################################################
            self.add_cmd(
                LockObtain(cmd_runners=locker_names[1]))
            lock_positions.append(locker_names[1])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ############################################################
            # release lock_0 to allow smart_sync to do request_set_up
            # to get pending_request set, and then wait behind lock_1
            # before going into request loop
            # locks held:
            # before: lock_0|smart_sync|lock_1
            # after : lock_1|smart_sync
            ############################################################
            self.add_cmd(
                LockRelease(cmd_runners=locker_names[0]))
            lock_positions.remove(locker_names[0])
            lock_positions.remove(remote_name)
            lock_positions.append(remote_name)

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ############################################################
            # lock_0 gets behind the smart_sync
            # locks held:
            # before: lock_1|smart_sync
            # after : lock_1|smart_sync|lock_0
            ############################################################
            self.add_cmd(
                LockObtain(cmd_runners=locker_names[0]))
            lock_positions.append(locker_names[0])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ############################################################
            # smart_join gets behind lock_0
            # locks held:
            # before: lock_1|smart_sync|lock_0
            # after : lock_1|smart_sync|lock_0|smart_join
            ############################################################
            join_serial_num = self.add_cmd(
                Join(cmd_runners=joiner_name,
                     join_names=pending_name))
            lock_positions.append(joiner_name)

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ############################################################
            # lock_2 gets behind the smart_join
            # locks held:
            # before: lock_1|smart_sync|lock_0|smart_join
            # after : lock_1|smart_sync|lock_0|smart_join|lock_2
            ############################################################
            self.add_cmd(
                LockObtain(cmd_runners=locker_names[2]))
            lock_positions.append(locker_names[2])

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ############################################################
            # release lock_1 to allow smart_sync to set the sync flag in
            # pending_name and then get behind lock_2
            # locks held:
            # before: lock_1|smart_sync|lock_0|smart_join|lock_2
            # after : lock_0|smart_join|lock_2|smart_sync
            ############################################################
            self.add_cmd(
                LockRelease(cmd_runners=locker_names[1]))
            lock_positions.remove(locker_names[1])
            lock_positions.remove(remote_name)

            lock_positions.append(remote_name)

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))


            pair_key = st.SmartThread._get_pair_key(remote_name,
                                                    pending_name)
            check_pend_arg: CheckPendArg = (pending_name, pair_key)
            self.add_cmd(WaitForCondition(
                cmd_runners=self.commander_name,
                check_rtn=self.check_sync_event_set,
                check_args=check_pend_arg))

        ################################################################
        # verify the pending flags are as expected before we do the join
        ################################################################
        exp_pending_flags = PendingFlags(pending_msgs=pending_msg_count,
                                         pending_wait=pending_wait_tf,
                                         pending_sync=pending_sync_tf)
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyPendingFlags,
            names_to_check=pending_name,
            aux_names=remote_name,
            exp_pending_flags=exp_pending_flags,
            obtain_reg_lock=False))

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyStructures,
            obtain_reg_lock=False))

        ################################################################
        # remove the pending thread
        ################################################################
        self.build_exit_suite(cmd_runner=self.commander_name,
                              names=pending_name,
                              validate_config=False)

        if pending_sync_tf:
            ############################################################
            # release lock_0 to allow smart_join to remove remotes
            # locks held:
            # before: lock_0|smart_join|lock_2|smart_sync
            # after : lock_2|smart_sync
            ############################################################
            self.add_cmd(
                LockRelease(cmd_runners=locker_names[0]))
            lock_positions.remove(locker_names[0])
            lock_positions.remove(joiner_name)

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))
            ############################################################
            # release lock_2 to allow smart_sync to complete
            # locks held:
            # before: lock_2|smart_sync
            # after : none
            ############################################################
            self.add_cmd(
                LockRelease(cmd_runners=locker_names[2]))
            lock_positions.remove(locker_names[2])
            lock_positions.remove(remote_name)

            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd='Sync',
                    confirm_serial_num=sync_serial_num,
                    confirmers=remote_name))
        else:
            ############################################################
            # do smart_join, no locks to deal with
            ############################################################
            join_serial_num = self.add_cmd(
                Join(cmd_runners=joiner_name,
                     join_names=pending_name))

        pe = self.pending_events[joiner_name]

        pair_key = st.SmartThread._get_pair_key(pending_name,
                                                remote_name)

        pending_msg_tf: bool = False
        if pending_msg_count > 0:
            pending_msg_tf = True

        def_del_reasons: DefDelReasons = DefDelReasons(
            pending_request=False,
            pending_msg=pending_msg_tf,
            pending_wait=pending_wait_tf,
            pending_sync=pending_sync_tf)

        rem_sb_key: RemSbKey = (pending_name,
                                pair_key,
                                def_del_reasons)

        pe[PE.notify_rem_status_block_msg][rem_sb_key] += 1

        ################################################################
        # confirm the join is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd='Join',
                confirm_serial_num=join_serial_num,
                confirmers=joiner_names))

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyStructures,
            obtain_reg_lock=True))

    ####################################################################
    # build_backout_sync_remote_scenario
    ####################################################################
    def build_backout_sync_remote_scenario(self) -> None:
        """Return a list of ConfigCmd items for a create."""
        pending_names = ['pending_0']
        remote_names = ['remote_0']
        locker_names = ['locker_0', 'locker_1', 'locker_2']
        joiner_names = ['joiner_0']

        active_names: list[str] = (
                pending_names
                + remote_names
                # + locker_names
                + joiner_names)

        self.create_config(active_names=active_names)

        self.log_name_groups()

        pending_name = pending_names[0]
        remote_name = remote_names[0]
        joiner_name = joiner_names[0]

        lock_positions: list[str] = []
        pend_req_serial_num: int = 0
        join_serial_num: int = 0

        ################################################################
        # verify all flags off
        ################################################################
        exp_pending_flags = PendingFlags()
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyPendingFlags,
            names_to_check=pending_name,
            aux_names=remote_name,
            exp_pending_flags=exp_pending_flags,
            obtain_reg_lock=False))

        ################################################################
        # issue the sync to set sync_event for pending_name
        ################################################################
        sync_serial_num = self.add_cmd(Sync(
            cmd_runners=remote_name,
            targets=pending_name,
            stopped_remotes=pending_name))

        # Normally, handle_request_smart_sync_entry will set up the
        # ack msg when the target is not included in the set of
        # stopped_remotes. In this case, we know the sync flag will
        # be set for the pending_name, but we include it in the set
        # of stopped_remotes. So, we need to set up the ack msg
        # here.
        pe = self.pending_events[remote_name]

        ack_key: AckKey = (pending_name, 'smart_sync_set')

        pe[PE.ack_msg][ack_key] += 1

        ################################################################
        # wait for the pending_sync flag to be set in mock structures
        ################################################################
        pair_key = st.SmartThread._get_pair_key(remote_name,
                                                pending_name)
        check_pend_arg: CheckPendArg = (pending_name, pair_key)
        self.add_cmd(WaitForCondition(
            cmd_runners=self.commander_name,
            check_rtn=self.check_sync_event_set,
            check_args=check_pend_arg))

        ################################################################
        # verify the pending flags are as expected before we do the join
        ################################################################
        exp_pending_flags = PendingFlags(pending_sync=True)
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyPendingFlags,
            names_to_check=pending_name,
            aux_names=remote_name,
            exp_pending_flags=exp_pending_flags,
            obtain_reg_lock=False))

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyStructures,
            obtain_reg_lock=False))

        ################################################################
        # remove the pending thread to cause the backout
        ################################################################
        self.build_exit_suite(cmd_runner=self.commander_name,
                              names=pending_name,
                              validate_config=False)

        pe = self.pending_events[remote_name]

        ack_key: AckKey = (pending_name, 'smart_sync_backout_remote')

        pe[PE.ack_msg][ack_key] += 1

        ################################################################
        # confirm the sync is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd='Sync',
                confirm_serial_num=sync_serial_num,
                confirmers=remote_name))

        ################################################################
        # do smart_join
        ################################################################
        join_serial_num = self.add_cmd(
            Join(cmd_runners=joiner_name,
                 join_names=pending_name))

        pe = self.pending_events[joiner_name]

        pair_key = st.SmartThread._get_pair_key(pending_name,
                                                remote_name)

        # we expect no reasons
        def_del_reasons: DefDelReasons = DefDelReasons()

        rem_sb_key: RemSbKey = (pending_name,
                                pair_key,
                                def_del_reasons)

        pe[PE.notify_rem_status_block_msg][rem_sb_key] += 1

        ################################################################
        # confirm the join is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd='Join',
                confirm_serial_num=join_serial_num,
                confirmers=joiner_names))

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyStructures,
            obtain_reg_lock=True))

    ####################################################################
    # build_backout_sync_local_scenario
    ####################################################################
    def build_backout_sync_local_scenario(self) -> None:
        """Return a list of ConfigCmd items for a create."""
        pending_names = ['pending_0']
        remote_names = ['remote_0']
        locker_names = ['locker_0', 'locker_1', 'locker_2']
        joiner_names = ['joiner_0']

        active_names: list[str] = (
                pending_names
                + remote_names
                + locker_names
                + joiner_names)

        self.create_config(active_names=active_names)

        self.log_name_groups()

        pending_name = pending_names[0]
        remote_name = remote_names[0]
        joiner_name = joiner_names[0]

        lock_positions: list[str] = []
        pend_req_serial_num: int = 0
        join_serial_num: int = 0

        ################################################################
        # verify all flags off
        ################################################################
        exp_pending_flags = PendingFlags()
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyPendingFlags,
            names_to_check=pending_name,
            aux_names=remote_name,
            exp_pending_flags=exp_pending_flags,
            obtain_reg_lock=False))

        ################################################################
        # start of by getting lock_0
        # locks held:
        # before: none
        # after : lock_0
        ################################################################
        obtain_lock_serial_num_0 = self.add_cmd(
            LockObtain(cmd_runners=locker_names[0]))
        lock_positions.append(locker_names[0])

        # we can confirm only this first lock obtain
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd='LockObtain',
                confirm_serial_num=obtain_lock_serial_num_0,
                confirmers=locker_names[0]))

        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # remote_sync will get behind lock_0 in request_setup
        # locks held:
        # before: lock_0
        # after : lock_0|remote_sync
        ################################################################
        remote_sync_serial_num = self.add_cmd(
            SyncTimeoutTrue(
                cmd_runners=remote_name,
                targets=pending_name,
                timeout=1,
                timeout_remotes=pending_name))

        lock_positions.append(remote_name)

        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # lock_1 gets behind remote_sync
        # locks held:
        # before: lock_0|remote_sync
        # after : lock_0|remote_sync|lock_1
        ################################################################
        self.add_cmd(
            LockObtain(cmd_runners=locker_names[1]))
        lock_positions.append(locker_names[1])

        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # release lock_0 to allow remote_sync to do request_set_up and
        # then wait behind lock_1 just before going into request loop
        # locks held:
        # before: lock_0|remote_sync|lock_1
        # after : lock_1|remote_sync
        ############################################################
        self.add_cmd(
            LockRelease(cmd_runners=locker_names[0]))
        lock_positions.remove(locker_names[0])
        lock_positions.remove(remote_name)
        lock_positions.append(remote_name)

        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # lock_0 gets behind remote_sync
        # locks held:
        # before: lock_1|remote_sync
        # after : lock_1|remote_sync|lock_0
        ################################################################
        self.add_cmd(
            LockObtain(cmd_runners=locker_names[0]))
        lock_positions.append(locker_names[0])

        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # pend_sync will get behind lock_0 in request_setup
        # locks held:
        # before: lock_1|remote_sync|lock_0
        # after : lock_1|remote_sync|lock_0|pend_sync
        ################################################################
        pend_sync_serial_num = self.add_cmd(
            Sync(cmd_runners=pending_name,
                 targets=remote_name))

        lock_positions.append(pending_name)

        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # lock_2 gets behind pend_sync
        # locks held:
        # before: lock_1|remote_sync|lock_0|pend_sync
        # after : lock_1|remote_sync|lock_0|pend_sync|lock_2
        ################################################################
        self.add_cmd(
            LockObtain(cmd_runners=locker_names[2]))
        lock_positions.append(locker_names[2])

        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))
        ################################################################
        # release lock_1 to allow remote_sync to enter the request loop
        # and set the pending_name sync flag, and then get behind lock_0
        # locks held:
        # before: lock_1|remote_sync|lock_0|pend_sync|lock_2
        # after : lock_0|pend_sync|lock_2|remote_sync
        ############################################################
        self.add_cmd(
            LockRelease(cmd_runners=locker_names[1]))
        lock_positions.remove(locker_names[1])
        lock_positions.remove(remote_name)
        lock_positions.append(remote_name)

        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # lock_1 gets behind remote_sync
        # locks held:
        # before: lock_0|pend_sync|lock_2|remote_sync
        # after : lock_0|pend_sync|lock_2|remote_sync|lock_1
        ################################################################
        self.add_cmd(
            LockObtain(cmd_runners=locker_names[1]))
        lock_positions.append(locker_names[1])

        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # release lock_0 to allow pend_sync to do setup and then wait
        # behind lock_1 just before entering request loop
        # locks held:
        # before: lock_0|pend_sync|lock_2|remote_sync|lock_1
        # after : lock_2|remote_sync|lock_1|pend_sync
        ############################################################
        self.add_cmd(
            LockRelease(cmd_runners=locker_names[0]))
        lock_positions.remove(locker_names[0])
        lock_positions.remove(pending_name)
        lock_positions.append(pending_name)

        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # lock_0 gets behind pend_sync
        # locks held:
        # before: lock_2|remote_sync|lock_1|pend_sync
        # after : lock_2|remote_sync|lock_1|pend_sync|lock_0
        ################################################################
        self.add_cmd(
            LockObtain(cmd_runners=locker_names[0]))
        lock_positions.append(locker_names[0])

        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # pause for 1.5 seconds to cause remote_sync to timeout
        ################################################################
        self.add_cmd(Pause(
            cmd_runners=self.commander_name,
            pause_seconds=1.5))

        ################################################################
        # release lock_2 to allow remote_sync to enter the request loop
        # and see no progress from the pending_name, and then
        # timeout and get behind lock_0 just before sync backout
        # locks held:
        # before: lock_2|remote_sync|lock_1|pend_sync|lock_0
        # after : lock_1|pend_sync|lock_0|remote_sync
        ############################################################
        self.add_cmd(
            LockRelease(cmd_runners=locker_names[2]))
        lock_positions.remove(locker_names[2])
        lock_positions.remove(remote_name)
        lock_positions.append(remote_name)

        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # release lock_1 to allow pend_sync to enter the request loop
        # and set sync event for remote_sync and see that its sync event
        # is set and complete the sync request
        # locks held:
        # before: lock_1|pend_sync|lock_0|remote_sync
        # after : lock_0|remote_sync
        ############################################################
        self.add_cmd(
            LockRelease(cmd_runners=locker_names[1]))
        lock_positions.remove(locker_names[1])
        lock_positions.remove(pending_name)

        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # release lock_0 to allow remote_sync to enter the backout
        # routine to reset its sync event flag
        # locks held:
        # before: lock_0|remote_sync
        # after : none
        ############################################################
        self.add_cmd(
            LockRelease(cmd_runners=locker_names[0]))
        lock_positions.remove(locker_names[0])
        lock_positions.remove(remote_name)

        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # Normally, handle_request_smart_sync_entry will set up the
        # ack msg when the target is not included in the set of
        # stopped_remotes or timeout_remotes. In this case, we know the
        # sync flag will be set for the pending_name, but we include it
        # in the set of timeout_remotes. So, we need to set up the ack
        # msg here.
        ################################################################
        pe = self.pending_events[remote_name]

        ack_key: AckKey = (pending_name, 'smart_sync_set')

        pe[PE.ack_msg][ack_key] += 1

        ################################################################
        # We also need to set the ack message for the backout.
        ################################################################
        ack_key: AckKey = (pending_name, 'smart_sync_backout_local')

        pe[PE.ack_msg][ack_key] += 1

        ################################################################
        # wait for the pending_sync flag to be set in mock structures
        ################################################################
        # pair_key = st.SmartThread._get_pair_key(remote_name,
        #                                         pending_name)
        # check_pend_arg: CheckPendArg = (pending_name, pair_key)
        # self.add_cmd(WaitForCondition(
        #     cmd_runners=self.commander_name,
        #     check_rtn=self.check_sync_event_set,
        #     check_args=check_pend_arg))

        ################################################################
        # verify the pending flags are as expected
        ################################################################
        exp_pending_flags = PendingFlags()
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyPendingFlags,
            names_to_check=pending_name,
            aux_names=remote_name,
            exp_pending_flags=exp_pending_flags,
            obtain_reg_lock=False))

        exp_pending_flags = PendingFlags()
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyPendingFlags,
            names_to_check=remote_name,
            aux_names=pending_name,
            exp_pending_flags=exp_pending_flags,
            obtain_reg_lock=False))

        ################################################################
        # confirm the remote_sync is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd='SyncTimeoutTrue',
                confirm_serial_num=remote_sync_serial_num,
                confirmers=remote_name))

        ################################################################
        # confirm the pend_sync is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd='Sync',
                confirm_serial_num=pend_sync_serial_num,
                confirmers=pending_name))

        ################################################################
        # verify config structures
        ################################################################
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyStructures,
            obtain_reg_lock=True))

    ####################################################################
    # check_pending_events
    ####################################################################
    def check_sync_event_set(self,
                             cmd_runner: str,
                             check_args: CheckPendArg) -> bool:
        """Check that the sync event is set in the target.

        Args:
            cmd_runner: thread name doing the check
            check_args: target name and pair_key to be checked
        """
        self.log_test_msg(f'check_sync_event_set entry: {cmd_runner=} '
                          f'{check_args=}')
        target = check_args[0]
        pair_key = check_args[1]
        if target not in self.expected_registered:
            raise InvalidConfigurationDetected(
                f'check_sync_event_set {target=} not in expected_registered')

        if pair_key not in self.expected_pairs:
            raise InvalidConfigurationDetected(
                f'check_sync_event_set {pair_key=} not in expected_pairs')

        if target not in self.expected_pairs[pair_key]:
            raise InvalidConfigurationDetected(
                f'check_sync_event_set {target=} not in expected_pairs'
                f'with {pair_key=}')

        if self.expected_pairs[pair_key][target].pending_sync:
            return True

        return False

    ####################################################################
    # check_pending_events
    ####################################################################
    def check_pending_events(self,
                             verify_idx: int) -> None:
        """Check pending events are clear.

        Args:
            verify_idx: contains verify index to snapshot data
        """
        incomplete_items: dict[str, dict[PE, Any]] = {}
        for cmd_runner, pend_events in self.pending_events.items():
            for event_name, item in pend_events.items():
                if isinstance(item, defaultdict):
                    for key, item2 in item.items():
                        if item2 != 0:
                            if cmd_runner not in incomplete_items:
                                incomplete_items[cmd_runner] = {}
                            if event_name not in incomplete_items[
                                    cmd_runner]:
                                incomplete_items[cmd_runner][
                                    event_name] = {}
                            incomplete_items[cmd_runner][event_name][
                                key] = item2
                elif isinstance(item, int):
                    if item != 0:
                        if cmd_runner not in incomplete_items:
                            incomplete_items[cmd_runner] = {}
                        incomplete_items[cmd_runner][event_name] = item
                elif isinstance(item, deque):
                    if len(item) != 0:
                        if cmd_runner not in incomplete_items:
                            incomplete_items[cmd_runner] = {}
                        incomplete_items[cmd_runner][event_name] = item
                elif isinstance(item, StartRequest):
                    if item.req_type != st.ReqType.NoReq:
                        if cmd_runner not in incomplete_items:
                            incomplete_items[cmd_runner] = {}
                        incomplete_items[cmd_runner][event_name] = item
                else:
                    self.abort_all_f1_threads()
                    raise UnrecognizedEvent(
                        'check_pending_events does not recognize'
                        f'event {event_name=}, {item=}')

        if incomplete_items:
            for cmd_runner, item in incomplete_items.items():
                self.log_test_msg(f'incomplete_item: {cmd_runner=}, {item=}')
            self.abort_all_f1_threads()
            raise RemainingPendingEvents(
                'check_pending_events detected that there are remaining '
                f'pending items:\n {incomplete_items=}')

    ####################################################################
    # build_def_del_pending_scenario
    ####################################################################
    def build_def_del_pending_scenario(
            self,
            name_0_pend: DefDelReasons,
            name_1_pend: DefDelReasons,
            name_2_pend: DefDelReasons
    ) -> None:
        """Return a list of ConfigCmd items for a deferred delete.

        Args:
            name_0_pend: reasons for name 0
            name_1_pend: reasons for name 1
            name_2_pend: reasons for name 2

        """
        num_receivers = 2
        num_senders = 1

        num_waiters = 2
        num_resumers = 1

        num_syncers = 2

        num_dels = 1
        num_adds = 1

        num_deleters = 1
        num_adders = 1

        num_lockers = 5

        num_active_needed = (num_receivers
                             + num_senders
                             + num_waiters
                             + num_resumers
                             + num_syncers
                             + num_dels
                             + num_deleters
                             + num_adders
                             + num_lockers
                             + 1)  # plus 1 for the commander
        self.build_config(
            cmd_runner=self.commander_name,
            num_active=num_active_needed)

        self.log_name_groups()

        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose receiver_names
        ################################################################
        receiver_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_receivers,
            update_collection=True,
            var_name_for_log='receiver_names')

        ################################################################
        # choose sender_names
        ################################################################
        sender_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_senders,
            update_collection=True,
            var_name_for_log='sender_names')

        ################################################################
        # choose waiter_names
        ################################################################
        waiter_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_waiters,
            update_collection=True,
            var_name_for_log='waiter_names')

        ################################################################
        # choose resumer_names
        ################################################################
        resumer_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_resumers,
            update_collection=True,
            var_name_for_log='resumer_names')

        ################################################################
        # choose syncer_names
        ################################################################
        # syncer_names = self.choose_names(
        #     name_collection=active_names_copy,
        #     num_names_needed=num_syncers,
        #     update_collection=True,
        #     var_name_for_log='syncer_names')

        ################################################################
        # choose del_names
        ################################################################
        del_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_dels,
            update_collection=True,
            var_name_for_log='del_names')

        ################################################################
        # choose add_names
        ################################################################
        unregistered_names_copy = self.unregistered_names.copy()
        add_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_adds,
            update_collection=True,
            var_name_for_log='add_names')

        ################################################################
        # choose deleter_names
        ################################################################
        deleter_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_deleters,
            update_collection=True,
            var_name_for_log='deleter_names')

        ################################################################
        # choose adder_names
        ################################################################
        adder_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_adders,
            update_collection=True,
            var_name_for_log='adder_names')

        ################################################################
        # choose locker_names
        ################################################################
        locker_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_lockers,
            update_collection=True,
            var_name_for_log='locker_names')

        ################################################################
        # msgs to send
        ################################################################

        ################################################################
        # tracking vars for locks
        ################################################################
        lock_positions: list[str] = []
        first_cmd_lock_pos: str = ''
        second_cmd_lock_pos: str = ''

        ################################################################
        # Categorize the request types
        ################################################################
        single_request = False
        double_request = False
        del_add_request = False

        cmd_0_name: str = ''
        cmd_0_confirmer: str = ''
        cmd_0_serial_num: int = 0
        recv_0_name: str = ''
        wait_0_name: str = ''

        cmd_1_name: str = ''
        cmd_1_confirmer: str = ''
        cmd_1_serial_num: int = 0
        recv_1_name: str = ''
        wait_1_name: str = ''

        receivers: list[str] = []
        waiters: list[str] = []

        if (def_del_scenario == DefDelScenario.NormalRecv
                or def_del_scenario == DefDelScenario.ResurrectionRecv
                or def_del_scenario == DefDelScenario.NormalWait
                or def_del_scenario == DefDelScenario.ResurrectionWait):
            single_request = True

        if (def_del_scenario == DefDelScenario.Recv0Recv1
                or def_del_scenario == DefDelScenario.Recv1Recv0
                or def_del_scenario == DefDelScenario.WaitRecv
                or def_del_scenario == DefDelScenario.Wait0Wait1
                or def_del_scenario == DefDelScenario.Wait1Wait0
                or def_del_scenario == DefDelScenario.RecvWait):
            double_request = True

        if (def_del_scenario == DefDelScenario.RecvDel
                or def_del_scenario == DefDelScenario.WaitDel
                or def_del_scenario == DefDelScenario.RecvAdd
                or def_del_scenario == DefDelScenario.WaitAdd):
            del_add_request = True

        ################################################################
        # Determine whether first request is smart_recv or wait
        ################################################################
        if (def_del_scenario == DefDelScenario.NormalRecv
                or def_del_scenario == DefDelScenario.ResurrectionRecv
                or def_del_scenario == DefDelScenario.Recv0Recv1
                or def_del_scenario == DefDelScenario.Recv1Recv0
                or def_del_scenario == DefDelScenario.RecvWait
                # or def_del_scenario == DefDelScenario.WaitRecv
                or def_del_scenario == DefDelScenario.RecvDel
                or def_del_scenario == DefDelScenario.RecvAdd):
            cmd_0_name = 'RecvMsg'
            recv_0_name = receiver_names[0]
            cmd_0_confirmer = recv_0_name
            receivers.append(recv_0_name)

        elif (def_del_scenario == DefDelScenario.NormalWait
                or def_del_scenario == DefDelScenario.ResurrectionWait
                or def_del_scenario == DefDelScenario.Wait0Wait1
                or def_del_scenario == DefDelScenario.Wait1Wait0
                # or def_del_scenario == DefDelScenario.RecvWait
                or def_del_scenario == DefDelScenario.WaitRecv
                or def_del_scenario == DefDelScenario.WaitDel
                or def_del_scenario == DefDelScenario.WaitAdd):

            cmd_0_name = 'Wait'
            wait_0_name = waiter_names[0]
            cmd_0_confirmer = wait_0_name
            waiters.append(wait_0_name)

        ################################################################
        # Determine whether second request (if one) is smart_recv or wait
        ################################################################
        if (def_del_scenario == DefDelScenario.Recv0Recv1
                or def_del_scenario == DefDelScenario.Recv1Recv0
                or def_del_scenario == DefDelScenario.WaitRecv):
            if def_del_scenario == DefDelScenario.WaitRecv:
                recv_1_name = receiver_names[0]
            else:
                recv_1_name = receiver_names[1]
            cmd_1_name = 'RecvMsg'
            receivers.append(recv_1_name)

        elif (def_del_scenario == DefDelScenario.Wait0Wait1
                or def_del_scenario == DefDelScenario.Wait1Wait0
                or def_del_scenario == DefDelScenario.RecvWait):

            if def_del_scenario == DefDelScenario.RecvWait:
                wait_1_name = waiter_names[0]
            else:
                wait_1_name = waiter_names[1]
            cmd_1_name = 'Wait'
            waiters.append(wait_1_name)

        exiters: list[str] = []
        if (def_del_scenario == DefDelScenario.RecvDel
                or def_del_scenario == DefDelScenario.WaitDel):
            exiters.append(del_names[0])

        adders: list[str] = []
        if (def_del_scenario == DefDelScenario.RecvAdd
                or def_del_scenario == DefDelScenario.WaitAdd):
            adders.append(add_names[0])

        exit_names: list[str] = []
        if receivers:
            ############################################################
            # send a msg that will sit on the smart_recv msg_q (1 or 2)
            ############################################################
            exit_names.append(sender_names[0])

            sender_msgs = SendRecvMsgs(
                sender_names=sender_names,
                receiver_names=receivers,
                num_msgs=1,
                send_type=SendType.ToRemotes)
            send_msg_serial_num_0 = self.add_cmd(
                SendMsg(cmd_runners=sender_names[0],
                        receivers=receivers,
                        msgs_to_send=sender_msgs,
                        msg_idx=0))
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='SendMsg',
                    confirm_serial_num=send_msg_serial_num_0,
                    confirmers=sender_names[0]))
        if waiters:
            ############################################################
            # resume that will set wait bit
            ############################################################
            exit_names.append(resumer_names[0])
            resume_serial_num_0 = self.add_cmd(
                Resume(cmd_runners=resumer_names[0],
                       targets=waiters,
                       exp_resumed_targets=waiters,
                       stopped_remotes=[]))
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='Resume',
                    confirm_serial_num=resume_serial_num_0,
                    confirmers=resumer_names[0]))

        if (def_del_scenario != DefDelScenario.NormalRecv
                and def_del_scenario != DefDelScenario.NormalWait):
            ############################################################
            # exit the sender to create a half paired case
            ############################################################
            self.build_exit_suite(
                cmd_runner=self.commander_name,
                names=exit_names,
                validate_config=False)
            self.build_join_suite(
                cmd_runners=self.commander_name,
                join_target_names=exit_names,
                validate_config=False)

            if (def_del_scenario == DefDelScenario.ResurrectionRecv
                    or def_del_scenario == DefDelScenario.ResurrectionWait):
                ########################################################
                # resurrect the sender
                ########################################################
                f1_create_items: list[F1CreateItem] = []
                for idx, name in enumerate(exit_names):
                    if idx % 2:
                        app_config = AppConfig.ScriptStyle
                    else:
                        app_config = AppConfig.RemoteThreadApp

                    f1_create_items.append(F1CreateItem(name=name,
                                                        auto_start=True,
                                                        target_rtn=outer_f1,
                                                        app_config=app_config))
                self.build_create_suite(
                    f1_create_items=f1_create_items,
                    validate_config=False)

        ################################################################
        # For scenarios that have a second request, get lock 0 to keep
        # the first smart_recv/wait progressing beyond the lock obtain in
        # _request_setup where the pk_remotes list is built.
        ################################################################
        if not single_request:
            obtain_lock_serial_num_0 = self.add_cmd(
                LockObtain(cmd_runners=locker_names[0]))
            lock_positions.append(locker_names[0])

            # we can confirm only this first lock obtain
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='LockObtain',
                    confirm_serial_num=obtain_lock_serial_num_0,
                    confirmers=locker_names[0]))

            ############################################################
            # verify locks held: lock_0
            ############################################################
            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))
        ################################################################
        # do the first recv or wait
        ################################################################
        if cmd_0_name == 'RecvMsg':
            cmd_0_serial_num = self.add_cmd(
                RecvMsg(cmd_runners=recv_0_name,
                        senders=sender_names[0],
                        exp_senders=sender_names[0],
                        exp_msgs=sender_msgs,
                        log_msg='def_del_recv_test_0'))
            if not single_request:
                first_cmd_lock_pos = recv_0_name
                lock_positions.append(recv_0_name)
        else:  # must be wait
            cmd_0_serial_num = self.add_cmd(
                Wait(cmd_runners=wait_0_name,
                     resumers=resumer_names[0],
                     stopped_remotes=set(),
                     log_msg='def_del_wait_test_0'))
            if not single_request:
                first_cmd_lock_pos = wait_0_name
                lock_positions.append(wait_0_name)

        ################################################################
        # Note: in the lock verify comments, the 'a', 'b', 'c', or 'd'
        # chars appended to request_0 and request_1 indicate where the
        # request is positioned along the path:
        # 'a' means behind the lock in _request_setup where the
        # pk_remotes list is built
        # 'b' means behind the lock in _request_loop
        # 'c' means behind the lock in _request_loop before doing a
        # refresh pair_array
        # 'd' means the lock in _cmd_loop (e.g., for del or add)
        ################################################################
        ############################################################
        # verify locks held:
        # For 1 request scenarios: no locks held
        # For all others: lock_0|request_0a
        ############################################################
        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # Get lock 1 to keep the second smart_recv/wait progressing beyond
        # the lock obtain in _request_setup where the pk_remotes list
        # is built.
        ################################################################
        if not single_request:
            self.add_cmd(
                LockObtain(cmd_runners=locker_names[1]))
            lock_positions.append(locker_names[1])

        ################################################################
        # verify locks held:
        # For 1 request scenarios: no locks held
        # For all others: lock_0|request_0a|lock_1
        ################################################################
        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))
        ################################################################
        # From this point on we will split the scenarios into separate
        # build paths to simplify the lock manipulations
        ################################################################
        if double_request:
            if cmd_1_name == 'RecvMsg':
                cmd_1_confirmer = recv_1_name
                cmd_1_serial_num = self.add_cmd(
                    RecvMsg(cmd_runners=recv_1_name,
                            senders=sender_names[0],
                            exp_senders=sender_names[0],
                            exp_msgs=sender_msgs,
                            log_msg='def_del_recv_test_1'))
                second_cmd_lock_pos = recv_1_name
                lock_positions.append(recv_1_name)
            else:  # must be wait
                cmd_1_confirmer = wait_1_name
                cmd_1_serial_num = self.add_cmd(
                    Wait(cmd_runners=wait_1_name,
                         resumers=resumer_names[0],
                         stopped_remotes=set(),
                         log_msg='def_del_wait_test_1'))
                second_cmd_lock_pos = wait_1_name
                lock_positions.append(wait_1_name)
            ############################################################
            # complete the build in part a
            ############################################################
            self.build_def_del_suite_part_a(
                def_del_scenario=def_del_scenario,
                lock_positions=lock_positions,
                first_cmd_lock_pos=first_cmd_lock_pos,
                second_cmd_lock_pos=second_cmd_lock_pos,
                locker_names=locker_names)
        elif del_add_request:
            ############################################################
            # for del and add, we need to progress request_0 from a to b
            ############################################################
            ############################################################
            # release lock_0
            ############################################################
            self.add_cmd(
                LockRelease(cmd_runners=locker_names[0]))
            lock_positions.remove(locker_names[0])
            # releasing lock 0 will allow the first recv/wait to go and
            # then get behind lock 2
            lock_positions.remove(first_cmd_lock_pos)
            lock_positions.append(first_cmd_lock_pos)
            ############################################################
            # verify locks held: lock_1|request_0b
            ############################################################
            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ############################################################
            # do the del or add request
            ############################################################
            if (def_del_scenario == DefDelScenario.RecvDel
                    or def_del_scenario == DefDelScenario.WaitDel):
                self.build_exit_suite(
                    cmd_runner=deleter_names[0],
                    names=[del_names[0]],
                    validate_config=False)
                self.build_join_suite(
                    cmd_runners=deleter_names[0],
                    join_target_names=[del_names[0]],
                    validate_config=False)
                second_cmd_lock_pos = deleter_names[0]
                lock_positions.append(deleter_names[0])
            else:  # must be add
                f1_create_items: list[F1CreateItem] = [
                    F1CreateItem(
                        name=add_names[0],
                        auto_start=True,
                        target_rtn=outer_f1,
                        app_config=AppConfig.ScriptStyle)]
                self.build_create_suite(
                    cmd_runner=adder_names[0],
                    f1_create_items=f1_create_items,
                    validate_config=False)
                second_cmd_lock_pos = adder_names[0]
                lock_positions.append(adder_names[0])
            ############################################################
            # verify locks held: lock_1|request_0b|request_1b
            ############################################################
            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))
            ############################################################
            # complete the build in part b
            ############################################################
            self.build_def_del_suite_part_b(
                lock_positions=lock_positions,
                first_cmd_lock_pos=first_cmd_lock_pos,
                second_cmd_lock_pos=second_cmd_lock_pos,
                locker_names=locker_names)

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd=cmd_0_name,
                confirm_serial_num=cmd_0_serial_num,
                confirmers=cmd_0_confirmer))

        if cmd_1_name:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd=cmd_1_name,
                    confirm_serial_num=cmd_1_serial_num,
                    confirmers=cmd_1_confirmer))

        ################################################################
        # verify no locks held
        ################################################################
        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=[]))

        ################################################################
        # check results
        ################################################################
        self.add_cmd(
            VerifyDefDel(
                cmd_runners=self.commander_name,
                def_del_scenario=def_del_scenario,
                receiver_names=receiver_names,
                sender_names=sender_names,
                waiter_names=waiter_names,
                resumer_names=resumer_names,
                del_names=del_names,
                add_names=add_names,
                deleter_names=deleter_names,
                adder_names=adder_names))

    ####################################################################
    # build_def_del_suite
    ####################################################################
    def build_def_del_suite(
            self,
            def_del_scenario: DefDelScenario) -> None:
        """Return a list of ConfigCmd items for a deferred delete.

        Args:
            def_del_scenario: specifies type of test to do

        """
        num_receivers = 2
        num_senders = 1

        num_waiters = 2
        num_resumers = 1

        num_syncers = 2

        num_dels = 1
        num_adds = 1

        num_deleters = 1
        num_adders = 1

        num_lockers = 5

        num_active_needed = (num_receivers
                             + num_senders
                             + num_waiters
                             + num_resumers
                             + num_syncers
                             + num_dels
                             + num_deleters
                             + num_adders
                             + num_lockers
                             + 1)  # plus 1 for the commander
        self.build_config(
            cmd_runner=self.commander_name,
            num_active=num_active_needed)

        self.log_name_groups()

        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose receiver_names
        ################################################################
        receiver_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_receivers,
            update_collection=True,
            var_name_for_log='receiver_names')

        ################################################################
        # choose sender_names
        ################################################################
        sender_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_senders,
            update_collection=True,
            var_name_for_log='sender_names')

        ################################################################
        # choose waiter_names
        ################################################################
        waiter_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_waiters,
            update_collection=True,
            var_name_for_log='waiter_names')

        ################################################################
        # choose resumer_names
        ################################################################
        resumer_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_resumers,
            update_collection=True,
            var_name_for_log='resumer_names')

        ################################################################
        # choose syncer_names
        ################################################################
        # syncer_names = self.choose_names(
        #     name_collection=active_names_copy,
        #     num_names_needed=num_syncers,
        #     update_collection=True,
        #     var_name_for_log='syncer_names')

        ################################################################
        # choose del_names
        ################################################################
        del_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_dels,
            update_collection=True,
            var_name_for_log='del_names')

        ################################################################
        # choose add_names
        ################################################################
        unregistered_names_copy = self.unregistered_names.copy()
        add_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_adds,
            update_collection=True,
            var_name_for_log='add_names')

        ################################################################
        # choose deleter_names
        ################################################################
        deleter_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_deleters,
            update_collection=True,
            var_name_for_log='deleter_names')

        ################################################################
        # choose adder_names
        ################################################################
        adder_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_adders,
            update_collection=True,
            var_name_for_log='adder_names')

        ################################################################
        # choose locker_names
        ################################################################
        locker_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_lockers,
            update_collection=True,
            var_name_for_log='locker_names')

        ################################################################
        # msgs to send
        ################################################################

        ################################################################
        # tracking vars for locks
        ################################################################
        lock_positions: list[str] = []
        first_cmd_lock_pos: str = ''
        second_cmd_lock_pos: str = ''

        ################################################################
        # Categorize the request types
        ################################################################
        single_request = False
        double_request = False
        del_add_request = False

        cmd_0_name: str = ''
        cmd_0_smart_name = ''
        cmd_0_confirmer: str = ''
        cmd_0_serial_num: int = 0
        recv_0_name: str = ''
        wait_0_name: str = ''

        cmd_1_name: str = ''
        cmd_1_smart_name = ''
        cmd_1_confirmer: str = ''
        cmd_1_serial_num: int = 0
        recv_1_name: str = ''
        wait_1_name: str = ''

        receivers: list[str] = []
        waiters: list[str] = []

        if (def_del_scenario == DefDelScenario.NormalRecv
                or def_del_scenario == DefDelScenario.ResurrectionRecv
                or def_del_scenario == DefDelScenario.NormalWait
                or def_del_scenario == DefDelScenario.ResurrectionWait):
            single_request = True

        if (def_del_scenario == DefDelScenario.Recv0Recv1
                or def_del_scenario == DefDelScenario.Recv1Recv0
                or def_del_scenario == DefDelScenario.WaitRecv
                or def_del_scenario == DefDelScenario.Wait0Wait1
                or def_del_scenario == DefDelScenario.Wait1Wait0
                or def_del_scenario == DefDelScenario.RecvWait):
            double_request = True

        if (def_del_scenario == DefDelScenario.RecvDel
                or def_del_scenario == DefDelScenario.WaitDel
                or def_del_scenario == DefDelScenario.RecvAdd
                or def_del_scenario == DefDelScenario.WaitAdd):
            del_add_request = True

        ################################################################
        # Determine whether first request is smart_recv or wait
        ################################################################
        if (def_del_scenario == DefDelScenario.NormalRecv
                or def_del_scenario == DefDelScenario.ResurrectionRecv
                or def_del_scenario == DefDelScenario.Recv0Recv1
                or def_del_scenario == DefDelScenario.Recv1Recv0
                or def_del_scenario == DefDelScenario.RecvWait
                # or def_del_scenario == DefDelScenario.WaitRecv
                or def_del_scenario == DefDelScenario.RecvDel
                or def_del_scenario == DefDelScenario.RecvAdd):
            cmd_0_name = 'RecvMsg'
            cmd_0_smart_name = 'smart_recv'
            recv_0_name = receiver_names[0]
            cmd_0_confirmer = recv_0_name
            receivers.append(recv_0_name)

        elif (def_del_scenario == DefDelScenario.NormalWait
                or def_del_scenario == DefDelScenario.ResurrectionWait
                or def_del_scenario == DefDelScenario.Wait0Wait1
                or def_del_scenario == DefDelScenario.Wait1Wait0
                # or def_del_scenario == DefDelScenario.RecvWait
                or def_del_scenario == DefDelScenario.WaitRecv
                or def_del_scenario == DefDelScenario.WaitDel
                or def_del_scenario == DefDelScenario.WaitAdd):

            cmd_0_name = 'Wait'
            cmd_0_smart_name = 'smart_wait'
            wait_0_name = waiter_names[0]
            cmd_0_confirmer = wait_0_name
            waiters.append(wait_0_name)

        ################################################################
        # Determine whether second request (if one) is smart_recv or wait
        ################################################################
        if (def_del_scenario == DefDelScenario.Recv0Recv1
                or def_del_scenario == DefDelScenario.Recv1Recv0
                or def_del_scenario == DefDelScenario.WaitRecv):
            if def_del_scenario == DefDelScenario.WaitRecv:
                recv_1_name = receiver_names[0]
            else:
                recv_1_name = receiver_names[1]
            cmd_1_name = 'RecvMsg'
            cmd_1_smart_name = 'smart_recv'
            receivers.append(recv_1_name)

        elif (def_del_scenario == DefDelScenario.Wait0Wait1
                or def_del_scenario == DefDelScenario.Wait1Wait0
                or def_del_scenario == DefDelScenario.RecvWait):

            if def_del_scenario == DefDelScenario.RecvWait:
                wait_1_name = waiter_names[0]
            else:
                wait_1_name = waiter_names[1]
            cmd_1_name = 'Wait'
            cmd_1_smart_name = 'smart_wait'
            waiters.append(wait_1_name)

        exiters: list[str] = []
        if (def_del_scenario == DefDelScenario.RecvDel
                or def_del_scenario == DefDelScenario.WaitDel):
            exiters.append(del_names[0])

        adders: list[str] = []
        if (def_del_scenario == DefDelScenario.RecvAdd
                or def_del_scenario == DefDelScenario.WaitAdd):
            adders.append(add_names[0])

        exit_names: list[str] = []
        if receivers:
            ############################################################
            # send a msg that will sit on the smart_recv msg_q (1 or 2)
            ############################################################
            exit_names.append(sender_names[0])

            sender_msgs = SendRecvMsgs(
                sender_names=sender_names,
                receiver_names=receivers,
                num_msgs=1,
                send_type=SendType.ToRemotes)
            send_msg_serial_num_0 = self.add_cmd(
                SendMsg(cmd_runners=sender_names[0],
                        receivers=receivers,
                        msgs_to_send=sender_msgs,
                        msg_idx=0))
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='SendMsg',
                    confirm_serial_num=send_msg_serial_num_0,
                    confirmers=sender_names[0]))
        if waiters:
            ############################################################
            # resume that will set wait bit
            ############################################################
            exit_names.append(resumer_names[0])
            resume_serial_num_0 = self.add_cmd(
                Resume(cmd_runners=resumer_names[0],
                       targets=waiters,
                       exp_resumed_targets=waiters,
                       stopped_remotes=[]))
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='Resume',
                    confirm_serial_num=resume_serial_num_0,
                    confirmers=resumer_names[0]))

        if (def_del_scenario != DefDelScenario.NormalRecv
                and def_del_scenario != DefDelScenario.NormalWait):
            ############################################################
            # exit the sender to create a half paired case
            ############################################################
            self.build_exit_suite(
                cmd_runner=self.commander_name,
                names=exit_names,
                validate_config=False)
            self.build_join_suite(
                cmd_runners=self.commander_name,
                join_target_names=exit_names,
                validate_config=False)

            if (def_del_scenario == DefDelScenario.ResurrectionRecv
                    or def_del_scenario == DefDelScenario.ResurrectionWait):
                ########################################################
                # resurrect the sender
                ########################################################
                f1_create_items: list[F1CreateItem] = []
                for idx, name in enumerate(exit_names):
                    if idx % 2:
                        app_config = AppConfig.ScriptStyle
                    else:
                        app_config = AppConfig.RemoteThreadApp

                    f1_create_items.append(F1CreateItem(name=name,
                                                        auto_start=True,
                                                        target_rtn=outer_f1,
                                                        app_config=app_config))
                self.build_create_suite(
                    f1_create_items=f1_create_items,
                    validate_config=False)

        ################################################################
        # For scenarios that have a second request, get lock 0 to keep
        # the first smart_recv/wait progressing beyond the lock obtain in
        # _request_setup where the pk_remotes list is built.
        ################################################################
        if not single_request:
            obtain_lock_serial_num_0 = self.add_cmd(
                LockObtain(cmd_runners=locker_names[0]))
            lock_positions.append(locker_names[0])

            # we can confirm only this first lock obtain
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='LockObtain',
                    confirm_serial_num=obtain_lock_serial_num_0,
                    confirmers=locker_names[0]))

            ############################################################
            # verify locks held: lock_0
            ############################################################
            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))
        ################################################################
        # do the first recv or wait
        ################################################################
        if cmd_0_name == 'RecvMsg':
            cmd_0_serial_num = self.add_cmd(
                RecvMsg(cmd_runners=recv_0_name,
                        senders=sender_names[0],
                        exp_msgs=sender_msgs,
                        exp_senders=sender_names[0],
                        log_msg='def_del_recv_test_0'))
            if not single_request:
                first_cmd_lock_pos = recv_0_name
                lock_positions.append(recv_0_name)

        else:  # must be wait
            cmd_0_serial_num = self.add_cmd(
                Wait(cmd_runners=wait_0_name,
                     resumers=resumer_names[0],
                     exp_resumers=resumer_names[0],
                     stopped_remotes=set(),
                     log_msg='def_del_wait_test_0'))
            if not single_request:
                first_cmd_lock_pos = wait_0_name
                lock_positions.append(wait_0_name)

        ################################################################
        # Note: in the lock verify comments, the 'a', 'b', 'c', or 'd'
        # chars appended to request_0 and request_1 indicate where the
        # request is positioned along the path:
        # 'a' means behind the lock in _request_setup where the
        # pk_remotes list is built
        # 'b' means behind the lock in _request_loop
        # 'c' means behind the lock in _request_loop before doing a
        # refresh pair_array
        # 'd' means the lock in _cmd_loop (e.g., for del or add)
        ################################################################
        ################################################################
        # verify locks held:
        # For 1 request scenarios: no locks held
        # For all others: lock_0|request_0a
        ################################################################
        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # Get lock 1 to keep the second smart_recv/wait progressing
        # beyond the lock obtain in _request_setup where the pk_remotes
        # list is built.
        ################################################################
        if not single_request:
            self.add_cmd(
                LockObtain(cmd_runners=locker_names[1]))
            lock_positions.append(locker_names[1])

        ################################################################
        # verify locks held:
        # For 1 request scenarios: no locks held
        # For all others: lock_0|request_0a|lock_1
        ################################################################
        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))
        ################################################################
        # From this point on we will split the scenarios into separate
        # build paths to simplify the lock manipulations
        ################################################################
        if double_request:
            if cmd_1_name == 'RecvMsg':
                cmd_1_confirmer = recv_1_name
                cmd_1_serial_num = self.add_cmd(
                    RecvMsg(cmd_runners=recv_1_name,
                            senders=sender_names[0],
                            exp_senders=sender_names[0],
                            exp_msgs=sender_msgs,
                            log_msg='def_del_recv_test_1'))
                second_cmd_lock_pos = recv_1_name
                lock_positions.append(recv_1_name)

            else:  # must be wait
                cmd_1_confirmer = wait_1_name
                cmd_1_serial_num = self.add_cmd(
                    Wait(cmd_runners=wait_1_name,
                         resumers=resumer_names[0],
                         exp_resumers=resumer_names[0],
                         stopped_remotes=set(),
                         log_msg='def_del_wait_test_1'))
                second_cmd_lock_pos = wait_1_name
                lock_positions.append(wait_1_name)

            ############################################################
            # complete the build in part a
            ############################################################
            self.build_def_del_suite_part_a(
                def_del_scenario=def_del_scenario,
                lock_positions=lock_positions,
                first_cmd_lock_pos=first_cmd_lock_pos,
                second_cmd_lock_pos=second_cmd_lock_pos,
                locker_names=locker_names)
        elif del_add_request:
            ############################################################
            # for del and add, we need to progress request_0 from a to b
            ############################################################
            ############################################################
            # release lock_0
            ############################################################
            self.add_cmd(
                LockRelease(cmd_runners=locker_names[0]))
            lock_positions.remove(locker_names[0])
            # releasing lock 0 will allow the first recv/wait to go and
            # then get behind lock 2
            lock_positions.remove(first_cmd_lock_pos)
            lock_positions.append(first_cmd_lock_pos)
            ############################################################
            # verify locks held: lock_1|request_0b
            ############################################################
            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

            ############################################################
            # do the del or add request
            ############################################################
            if (def_del_scenario == DefDelScenario.RecvDel
                    or def_del_scenario == DefDelScenario.WaitDel):
                self.build_exit_suite(
                    cmd_runner=deleter_names[0],
                    names=[del_names[0]],
                    validate_config=False)
                self.build_join_suite(
                    cmd_runners=deleter_names[0],
                    join_target_names=[del_names[0]],
                    validate_config=False)
                second_cmd_lock_pos = deleter_names[0]
                lock_positions.append(deleter_names[0])
            else:  # must be add
                f1_create_items: list[F1CreateItem] = [
                    F1CreateItem(
                        name=add_names[0],
                        auto_start=True,
                        target_rtn=outer_f1,
                        app_config=AppConfig.ScriptStyle)]
                self.build_create_suite(
                    cmd_runner=adder_names[0],
                    f1_create_items=f1_create_items,
                    validate_config=False)
                second_cmd_lock_pos = adder_names[0]
                lock_positions.append(adder_names[0])
            ############################################################
            # verify locks held: lock_1|request_0b|request_1b
            ############################################################
            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))
            ############################################################
            # complete the build in part b
            ############################################################
            self.build_def_del_suite_part_b(
                lock_positions=lock_positions,
                first_cmd_lock_pos=first_cmd_lock_pos,
                second_cmd_lock_pos=second_cmd_lock_pos,
                locker_names=locker_names)

        ################################################################
        # handle expected refresh call
        ################################################################
        if (def_del_scenario != DefDelScenario.NormalRecv
                and def_del_scenario != DefDelScenario.NormalWait
                and def_del_scenario != DefDelScenario.ResurrectionRecv
                and def_del_scenario != DefDelScenario.ResurrectionWait):
            pe = self.pending_events[cmd_0_confirmer]
            ref_key: CallRefKey = cmd_0_smart_name

            pe[PE.calling_refresh_msg][ref_key] += 1

            if double_request:
                pe = self.pending_events[cmd_1_confirmer]
                ref_key: CallRefKey = cmd_1_smart_name

                pe[PE.calling_refresh_msg][ref_key] += 1

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd=cmd_0_name,
                confirm_serial_num=cmd_0_serial_num,
                confirmers=cmd_0_confirmer))

        if cmd_1_name:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd=cmd_1_name,
                    confirm_serial_num=cmd_1_serial_num,
                    confirmers=cmd_1_confirmer))

        ################################################################
        # verify no locks held
        ################################################################
        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=[]))

        ################################################################
        # check results
        ################################################################
        self.add_cmd(
            VerifyDefDel(
                cmd_runners=self.commander_name,
                def_del_scenario=def_del_scenario,
                receiver_names=receiver_names,
                sender_names=sender_names,
                waiter_names=waiter_names,
                resumer_names=resumer_names,
                del_names=del_names,
                add_names=add_names,
                deleter_names=deleter_names,
                adder_names=adder_names))

    ####################################################################
    # build_def_del_suite_part_a
    ####################################################################
    def build_def_del_suite_part_a(
            self,
            def_del_scenario: DefDelScenario,
            lock_positions: list[str],
            first_cmd_lock_pos: str,
            second_cmd_lock_pos: str,
            locker_names: list[str]) -> None:
        """Add ConfigCmd items for a deferred delete.

        Args:
            def_del_scenario: specifies type of test to do
            lock_positions: ordered list of requests waiting on lock
            first_cmd_lock_pos: either recv or wait as request_0
            second_cmd_lock_pos: either recv or wait as request_1
            locker_names: list of thread names that obtain the lock

        """
        ################################################################
        # Upon entry, both requests have been made and are both sitting
        # behind the first lock in _request_setup
        ################################################################

        ################################################################
        # verify locks held: lock_0|request_0a|lock_1|request_1a
        ################################################################
        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # Get lock 2 to keep the first smart_recv/wait progressing
        # beyond the lock obtain in _request_loop.
        ################################################################
        self.add_cmd(
            LockObtain(cmd_runners=locker_names[2]))
        lock_positions.append(locker_names[2])

        ################################################################
        # verify locks held: lock_0|request_0a|lock_1|request_1a|lock_2
        ################################################################
        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # release lock 0 to allow first smart_recv/wait to progress
        # to the lock obtain in _request_loop
        ################################################################
        self.add_cmd(
            LockRelease(cmd_runners=locker_names[0]))
        lock_positions.remove(locker_names[0])
        # releasing lock 0 will allow the first recv/wait to go and then
        # get behind lock 2
        lock_positions.remove(first_cmd_lock_pos)
        lock_positions.append(first_cmd_lock_pos)

        ################################################################
        # verify locks held: lock_1|request_1a|lock_2|request_0b
        ################################################################
        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # get lock 3 to keep second smart_recv/wait behind first
        ################################################################
        self.add_cmd(
            LockObtain(cmd_runners=locker_names[3]))
        lock_positions.append(locker_names[3])

        ################################################################
        # verify locks held: lock_1|request_1a|lock_2|request_0b|lock_3
        ################################################################
        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # release lock 1 to allow second smart_recv/wait to progress.
        # For smart_recv/wait, to the lock obtain in _request_loop.
        ################################################################
        self.add_cmd(
            LockRelease(cmd_runners=locker_names[1]))
        lock_positions.remove(locker_names[1])

        lock_positions.remove(second_cmd_lock_pos)
        lock_positions.append(second_cmd_lock_pos)

        ################################################################
        # verify locks held: lock_2|request_0b|lock_3|request_1b
        ################################################################
        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # get lock 4 to freeze first and second smart_recv/wait just
        # before the refresh so we can swap lock positions (if needed)
        ################################################################
        self.add_cmd(
            LockObtain(cmd_runners=locker_names[4]))
        lock_positions.append(locker_names[4])

        ################################################################
        # verify locks held: lock_2|request_0b|lock_3|request_1b|lock_4
        ################################################################
        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # release lock_2 to allow first smart_recv/wait to go
        ################################################################
        release_lock_serial_num_2 = self.add_cmd(
            LockRelease(cmd_runners=locker_names[2]))
        lock_positions.remove(locker_names[2])

        # releasing lock_2 will allow the first recv/wait to go
        lock_positions.remove(first_cmd_lock_pos)

        # the first recv/wait will now get behind the last lock, but
        # only for those cases that involve the deferred delete which
        # this routine handles
        lock_positions.append(first_cmd_lock_pos)

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd='LockRelease',
                confirm_serial_num=release_lock_serial_num_2,
                confirmers=locker_names[2]))

        ################################################################
        # verify locks held: lock_3|request_1b|lock_4|request_0c
        ################################################################
        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # release lock_3 to allow second smart_recv/wait to go
        ################################################################
        release_lock_serial_num_3 = self.add_cmd(
            LockRelease(cmd_runners=locker_names[3]))
        lock_positions.remove(locker_names[3])

        # releasing the second lock will allow the second recv/wait to
        # go and then get the lock exclusive behind the last lock waiter
        lock_positions.remove(second_cmd_lock_pos)

        # recv, wait will get behind the 3rd lock
        lock_positions.append(second_cmd_lock_pos)

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd='LockRelease',
                confirm_serial_num=release_lock_serial_num_3,
                confirmers=locker_names[3]))

        ################################################################
        # verify locks held: lock_4|request_0c|request_1c
        ################################################################
        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # At this point we will have the first cmd behind lock_4 and
        # the second cmd behind the first cmd. We now need to swap the
        # lock positions for some scenarios.
        ################################################################
        if (def_del_scenario == DefDelScenario.Recv1Recv0
                or def_del_scenario == DefDelScenario.Wait1Wait0):
            lock_pos_1 = lock_positions[1]
            lock_positions[1] = lock_positions[2]
            lock_positions[2] = lock_pos_1

            assert lock_positions[0] == locker_names[4]
            assert lock_positions[1] == second_cmd_lock_pos
            assert lock_positions[2] == first_cmd_lock_pos

            self.add_cmd(
                LockSwap(cmd_runners=self.commander_name,
                         new_positions=lock_positions.copy()))

            ############################################################
            # verify locks held: lock_4|request_1c|request_0c
            ############################################################
            self.add_cmd(
                LockVerify(cmd_runners=self.commander_name,
                           exp_positions=lock_positions.copy()))

        ################################################################
        # release lock_4 to allow both smart_recv/wait to refresh
        ################################################################
        release_lock_serial_num_4 = self.add_cmd(
            LockRelease(cmd_runners=locker_names[4]))
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd='LockRelease',
                confirm_serial_num=release_lock_serial_num_4,
                confirmers=locker_names[4]))

        lock_positions.remove(locker_names[4])
        lock_positions.remove(first_cmd_lock_pos)
        lock_positions.remove(second_cmd_lock_pos)

        ################################################################
        # verify locks held: no locks held
        ################################################################
        assert not lock_positions
        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

    ####################################################################
    # build_def_del_suite_part_b
    ####################################################################
    def build_def_del_suite_part_b(
            self,
            lock_positions: list[str],
            first_cmd_lock_pos: str,
            second_cmd_lock_pos: str,
            locker_names: list[str]) -> None:
        """Add ConfigCmd items for a deferred delete.

        Args:
            lock_positions: ordered list of requests waiting on lock
            first_cmd_lock_pos: either recv or wait as request_0
            second_cmd_lock_pos: either add or del as request_1
            locker_names: list of thread names that obtain the lock

        """
        ################################################################
        # Upon entry, both requests have been made with request_0
        # sitting behind the lock in _request_loop and request_1 (the
        # add or del) sitting behind the lock in _cmd_loop
        ################################################################

        ################################################################
        # verify locks held: lock_1|request_0b|request_1b
        ################################################################
        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

        ################################################################
        # release lock 1 to allow request_0 to progress to doing the
        # refresh which means the del or add request will proceed and
        # do the refresh ahead of request_0
        ################################################################
        release_lock_serial_num_1 = self.add_cmd(
            LockRelease(cmd_runners=locker_names[1]))

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd='LockRelease',
                confirm_serial_num=release_lock_serial_num_1,
                confirmers=locker_names[1]))

        lock_positions.remove(locker_names[1])
        lock_positions.remove(first_cmd_lock_pos)
        lock_positions.remove(second_cmd_lock_pos)

        ################################################################
        # verify locks held: no locks held
        ################################################################
        assert not lock_positions
        self.add_cmd(
            LockVerify(cmd_runners=self.commander_name,
                       exp_positions=lock_positions.copy()))

    ####################################################################
    # build_recv_msg_suite
    ####################################################################
    def build_recv_msg_suite(
            self,
            timeout_type: TimeoutType,
            recv_msg_state: tuple[st.ThreadState, int],
            recv_msg_lap: int,
            send_msg_lap: int) -> None:
        """Add cmds to run scenario.

        Args:
            timeout_type: specifies whether the smart_recv should
                be coded with timeout, and whether it be False or True
            recv_msg_state: sender state when smart_recv is to be issued
            recv_msg_lap: lap 0 or 1 when the smart_recv is to be issued
            send_msg_lap: lap 0 or 1 when the smart_send is to be issued

        """
        # Make sure we have enough threads. Each of the scenarios will
        # require one thread for the commander, one thread for the
        # sender, and one thread for the receiver, for a total of three.
        assert 3 <= len(self.unregistered_names)

        self.build_config(
            cmd_runner=self.commander_name,
            num_active=2)  # one for commander and one for receiver

        self.log_name_groups()

        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose receiver_names
        ################################################################
        receiver_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=1,
            update_collection=True,
            var_name_for_log='receiver_names')

        ################################################################
        # choose sender_names
        ################################################################
        sender_names = self.choose_names(
            name_collection=self.unregistered_names,
            num_names_needed=1,
            update_collection=False,
            var_name_for_log='sender_names')

        log_msg = f'smart_recv log test: {get_ptime()}'

        ################################################################
        # setup the messages to send
        ################################################################
        receiver_name = receiver_names[0]
        sender_name = sender_names[0]

        sender_msgs = SendRecvMsgs(
            sender_names=sender_name,
            receiver_names=receiver_name,
            num_msgs=1,
            send_type=SendType.ToRemotes)
        confirm_cmd_to_use = 'RecvMsg'
        recv_msg_serial_num = 0
        ################################################################
        # lap loop
        ################################################################
        current_state = st.ThreadState.Unregistered
        reg_iteration = 0
        for lap in range(2):
            ############################################################
            # start loop to advance sender through the config states
            ############################################################
            for state in (
                    st.ThreadState.Unregistered,
                    st.ThreadState.Registered,
                    st.ThreadState.Unregistered,
                    st.ThreadState.Registered,
                    st.ThreadState.Alive,
                    st.ThreadState.Stopped):
                state_iteration = 0
                ########################################################
                # do join to make sender unregistered
                ########################################################
                if state == st.ThreadState.Unregistered:
                    if current_state == st.ThreadState.Registered:
                        self.add_cmd(Unregister(
                            cmd_runners='alpha',
                            unregister_targets=sender_name))
                        state_iteration = 1
                    elif current_state == st.ThreadState.Stopped:
                        self.build_join_suite(
                            cmd_runners=self.commander_name,
                            join_target_names=sender_name,
                            validate_config=False)
                    current_state = st.ThreadState.Unregistered
                ########################################################
                # do create to make sender registered
                ########################################################
                elif state == st.ThreadState.Registered:
                    state_iteration = reg_iteration % 2
                    reg_iteration += 1
                    self.build_create_suite(
                        f1_create_items=[
                            F1CreateItem(name=sender_name,
                                         auto_start=False,
                                         target_rtn=outer_f1,
                                         app_config=AppConfig.ScriptStyle)],
                        validate_config=False)
                    current_state = st.ThreadState.Registered
                ########################################################
                # do start to make sender alive
                ########################################################
                elif state == st.ThreadState.Alive:
                    self.build_start_suite(
                        start_names=sender_name,
                        validate_config=False)
                    if (send_msg_lap == lap
                            and timeout_type != TimeoutType.TimeoutTrue):
                        self.add_cmd(
                            SendMsg(cmd_runners=sender_name,
                                    receivers=receiver_name,
                                    msgs_to_send=sender_msgs,
                                    msg_idx=0))
                    current_state = st.ThreadState.Alive
                ########################################################
                # do stop to make sender stopped
                ########################################################
                else:  # state == st.ThreadState.Stopped:
                    self.build_exit_suite(
                        cmd_runner=self.commander_name,
                        names=sender_name,
                        validate_config=False)
                    current_state = st.ThreadState.Stopped
                ########################################################
                # issue smart_recv
                ########################################################
                pause_time = 0
                if (recv_msg_state[0] == state
                        and recv_msg_state[1] == state_iteration
                        and recv_msg_lap == lap):
                    stopped_remotes = set()
                    if ((lap == 0 and send_msg_lap == 1)
                            or timeout_type == TimeoutType.TimeoutTrue):
                        stopped_remotes = {sender_name}
                        pause_time = 1
                    if timeout_type == TimeoutType.TimeoutNone:
                        recv_msg_serial_num = self.add_cmd(
                            RecvMsg(cmd_runners=receiver_name,
                                    senders=sender_name,
                                    exp_senders=sender_name,
                                    exp_msgs=sender_msgs,
                                    stopped_remotes=stopped_remotes,
                                    log_msg=log_msg))
                    elif timeout_type == TimeoutType.TimeoutFalse:
                        timeout_time = 6
                        confirm_cmd_to_use = 'RecvMsgTimeoutFalse'
                        recv_msg_serial_num = self.add_cmd(
                            RecvMsgTimeoutFalse(
                                cmd_runners=receiver_name,
                                senders=sender_name,
                                exp_senders=sender_name,
                                exp_msgs=sender_msgs,
                                timeout=timeout_time,
                                stopped_remotes=stopped_remotes,
                                log_msg=log_msg))

                    else:  # TimeoutType.TimeoutTrue
                        timeout_time = 0.5
                        pause_time = 1  # ensure timeout
                        if state != st.ThreadState.Stopped:
                            stopped_remotes = set()
                            self.set_recv_timeout(num_timeouts=1)

                        confirm_cmd_to_use = 'RecvMsgTimeoutTrue'
                        recv_msg_serial_num = self.add_cmd(
                            RecvMsgTimeoutTrue(
                                cmd_runners=receiver_name,
                                senders=sender_name,
                                exp_msgs=sender_msgs,
                                timeout=timeout_time,
                                timeout_names=sender_name,
                                stopped_remotes=stopped_remotes,
                                log_msg=log_msg))
                    if pause_time > 0:
                        self.add_cmd(
                            Pause(cmd_runners=self.commander_name,
                                  pause_seconds=pause_time))
        ################################################################
        # finally, confirm the smart_recv is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd=confirm_cmd_to_use,
                confirm_serial_num=recv_msg_serial_num,
                confirmers=receiver_names))

    ####################################################################
    # build_recv_msg_timeout_suite
    ####################################################################
    def build_recv_msg_timeout_suite(
            self,
            timeout_type: TimeoutType,
            num_receivers: int,
            num_active_no_delay_senders: int,
            num_active_delay_senders: int,
            num_send_exit_senders: int,
            num_nosend_exit_senders: int,
            num_unreg_senders: int,
            num_reg_senders: int) -> None:
        """Return a list of ConfigCmd items for a msg timeout.

        Args:
            timeout_type: specifies whether the smart_recv should
                be coded with timeout and whether the smart_recv should
                succeed or fail with a timeout
            num_receivers: number of threads that will do the
                smart_recv
            num_active_no_delay_senders: number of threads that are
                active and will do the smart_send immediately
            num_active_delay_senders: number of threads that are active
                and will do the smart_send after a delay
            num_send_exit_senders: number of threads that are active
                and will do the smart_send and then exit
            num_nosend_exit_senders: number of threads that are
                active and will not do the smart_send and then exit
            num_unreg_senders: number of threads that are
                unregistered and will be created and started and then
                do the smart_send
            num_reg_senders: number of threads that are registered
                and will be started and then do the smart_send

        """
        # Make sure we have enough threads
        assert (num_receivers
                + num_active_no_delay_senders
                + num_active_delay_senders
                + num_send_exit_senders
                + num_nosend_exit_senders
                + num_unreg_senders
                + num_reg_senders) <= len(self.unregistered_names)

        assert num_receivers > 0

        assert (num_active_no_delay_senders
                + num_active_delay_senders
                + num_send_exit_senders
                + num_nosend_exit_senders
                + num_unreg_senders
                + num_reg_senders) > 0

        if (timeout_type == TimeoutType.TimeoutFalse
                or timeout_type == TimeoutType.TimeoutTrue):
            assert (num_active_delay_senders
                    + num_nosend_exit_senders
                    + num_unreg_senders
                    + num_reg_senders) > 0

        num_active_needed = (
                num_receivers
                + num_active_no_delay_senders
                + num_active_delay_senders
                + num_send_exit_senders
                + num_nosend_exit_senders
                + 1)

        timeout_time = ((num_active_no_delay_senders * 0.1)
                        + (num_active_delay_senders * 0.1)
                        + (num_send_exit_senders * 0.1)
                        + (num_nosend_exit_senders * 0.5)
                        + (num_unreg_senders * 0.5)
                        + (num_reg_senders * 0.2))

        if timeout_type == TimeoutType.TimeoutNone:
            pause_time = 0.5
        elif timeout_type == TimeoutType.TimeoutFalse:
            pause_time = 0.5
            timeout_time += (pause_time * 2)  # prevent timeout
        else:  # timeout True
            pause_time = timeout_time + 1  # force timeout

        self.build_config(
            cmd_runner=self.commander_name,
            num_registered=num_reg_senders,
            num_active=num_active_needed)

        self.log_name_groups()

        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose receiver_names
        ################################################################
        receiver_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_receivers,
            update_collection=True,
            var_name_for_log='receiver_names')

        ################################################################
        # choose active_no_delay_sender_names
        ################################################################
        active_no_delay_sender_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_active_no_delay_senders,
            update_collection=True,
            var_name_for_log='active_no_delay_sender_names')

        ################################################################
        # choose active_delay_sender_names
        ################################################################
        active_delay_sender_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_active_delay_senders,
            update_collection=True,
            var_name_for_log='active_delay_sender_names')

        ################################################################
        # choose send_exit_sender_names
        ################################################################
        send_exit_sender_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_send_exit_senders,
            update_collection=True,
            var_name_for_log='send_exit_sender_names')

        ################################################################
        # choose nosend_exit_sender_names
        ################################################################
        nosend_exit_sender_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_nosend_exit_senders,
            update_collection=True,
            var_name_for_log='nosend_exit_sender_names')

        ################################################################
        # choose unreg_sender_names
        ################################################################
        unreg_sender_names = self.choose_names(
            name_collection=self.unregistered_names,
            num_names_needed=num_unreg_senders,
            update_collection=False,
            var_name_for_log='unreg_sender_names')

        ################################################################
        # choose reg_sender_names
        ################################################################
        reg_sender_names = self.choose_names(
            name_collection=self.registered_names,
            num_names_needed=num_reg_senders,
            update_collection=False,
            var_name_for_log='reg_sender_names')

        ################################################################
        # start by doing the recv_msgs, one for each sender
        ################################################################
        all_sender_names: list[str] = (active_no_delay_sender_names
                                       + active_delay_sender_names
                                       + send_exit_sender_names
                                       + nosend_exit_sender_names
                                       + unreg_sender_names
                                       + reg_sender_names)

        all_timeout_names: list[str] = (active_delay_sender_names
                                        + send_exit_sender_names
                                        + nosend_exit_sender_names
                                        + unreg_sender_names
                                        + reg_sender_names)

        self.set_recv_timeout(
            num_timeouts=len(all_timeout_names) * num_receivers)

        if len(all_sender_names) % 2 == 0:
            log_msg = f'smart_recv log test: {get_ptime()}'
        else:
            log_msg = None

        ################################################################
        # setup the messages to send
        ################################################################
        sender_msgs = SendRecvMsgs(
            sender_names=all_sender_names,
            receiver_names=receiver_names,
            num_msgs=1,
            send_type=SendType.ToRemotes)

        if timeout_type == TimeoutType.TimeoutNone:
            confirm_cmd_to_use = 'RecvMsg'
            recv_msg_serial_num = self.add_cmd(
                RecvMsg(cmd_runners=receiver_names,
                        senders=all_sender_names,
                        exp_senders=all_sender_names,
                        exp_msgs=sender_msgs,
                        log_msg=log_msg))
        elif timeout_type == TimeoutType.TimeoutFalse:
            confirm_cmd_to_use = 'RecvMsgTimeoutFalse'
            recv_msg_serial_num = self.add_cmd(
                RecvMsgTimeoutFalse(
                    cmd_runners=receiver_names,
                    senders=all_sender_names,
                    exp_senders=all_sender_names,
                    exp_msgs=sender_msgs,
                    timeout=2,
                    log_msg=log_msg))

        else:  # TimeoutType.TimeoutTrue
            confirm_cmd_to_use = 'RecvMsgTimeoutTrue'
            recv_msg_serial_num = self.add_cmd(
                RecvMsgTimeoutTrue(
                    cmd_runners=receiver_names,
                    senders=all_sender_names,
                    exp_msgs=sender_msgs,
                    timeout=2,
                    timeout_names=all_timeout_names,
                    log_msg=log_msg))

        ################################################################
        # do smart_send from active_no_delay_senders
        ################################################################
        if active_no_delay_sender_names:
            self.add_cmd(
                SendMsg(cmd_runners=active_no_delay_sender_names,
                        receivers=receiver_names,
                        msgs_to_send=sender_msgs,
                        msg_idx=0))

        self.add_cmd(
            Pause(cmd_runners=self.commander_name,
                  pause_seconds=pause_time))
        if timeout_type == TimeoutType.TimeoutTrue:
            self.add_cmd(WaitForRecvTimeouts(cmd_runners=self.commander_name))

        ################################################################
        # do smart_send from active_delay_senders
        ################################################################
        if active_delay_sender_names:
            self.add_cmd(
                SendMsg(cmd_runners=active_delay_sender_names,
                        receivers=receiver_names,
                        msgs_to_send=sender_msgs,
                        msg_idx=0))

        ################################################################
        # do smart_send from send_exit_senders and then exit
        ################################################################
        if send_exit_sender_names:
            self.add_cmd(
                SendMsg(cmd_runners=send_exit_sender_names,
                        receivers=receiver_names,
                        msgs_to_send=sender_msgs,
                        msg_idx=0))

            self.build_exit_suite(
                cmd_runner=self.commander_name,
                names=send_exit_sender_names,
                validate_config=False)
            self.build_join_suite(
                cmd_runners=self.commander_name,
                join_target_names=send_exit_sender_names,
                validate_config=False)

        ################################################################
        # exit the nosend_exit_senders, then resurrect and do smart_send
        ################################################################
        if nosend_exit_sender_names:
            self.build_exit_suite(
                cmd_runner=self.commander_name,
                names=nosend_exit_sender_names,
                validate_config=False)
            self.build_join_suite(
                cmd_runners=self.commander_name,
                join_target_names=nosend_exit_sender_names,
                validate_config=False)
            f1_create_items: list[F1CreateItem] = []
            for idx, name in enumerate(nosend_exit_sender_names):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(F1CreateItem(name=name,
                                                    auto_start=True,
                                                    target_rtn=outer_f1,
                                                    app_config=app_config))
            self.build_create_suite(
                f1_create_items=f1_create_items,
                validate_config=False)
            self.add_cmd(
                SendMsg(cmd_runners=nosend_exit_sender_names,
                        receivers=receiver_names,
                        msgs_to_send=sender_msgs,
                        msg_idx=0))

        ################################################################
        # create and start the unreg_senders, then do smart_send
        ################################################################
        if unreg_sender_names:
            f1_create_items: list[F1CreateItem] = []
            for idx, name in enumerate(unreg_sender_names):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(F1CreateItem(name=name,
                                                    auto_start=True,
                                                    target_rtn=outer_f1,
                                                    app_config=app_config))
            self.build_create_suite(
                f1_create_items=f1_create_items,
                validate_config=False)
            self.add_cmd(
                SendMsg(cmd_runners=unreg_sender_names,
                        receivers=receiver_names,
                        msgs_to_send=sender_msgs,
                        msg_idx=0))

        ################################################################
        # start the reg_senders, then do smart_send
        ################################################################
        if reg_sender_names:
            self.build_start_suite(
                start_names=reg_sender_names,
                validate_config=False)
            self.add_cmd(
                SendMsg(cmd_runners=reg_sender_names,
                        receivers=receiver_names,
                        msgs_to_send=sender_msgs,
                        msg_idx=0))

        ################################################################
        # finally, confirm the smart_recv is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd=confirm_cmd_to_use,
                confirm_serial_num=recv_msg_serial_num,
                confirmers=receiver_names))

    ####################################################################
    # build_wait_scenario_suite
    ####################################################################
    def build_wait_scenario_suite(
            self,
            num_waiters: int,
            num_actors: int,
            actor_list: list[Actors]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            num_waiters: number of threads that will do the wait
            num_actors: number of threads that will do the resume
            actor_list: contains the actors

        """
        actions: dict[Actors, Callable[..., None]] = {
            Actors.ActiveBeforeActor:
                self.build_resume_before_wait_timeout_suite,
            Actors.ActiveAfterActor:
                self.build_resume_after_wait_timeout_suite,
            Actors.ActionExitActor:
                self.build_resume_exit_wait_timeout_suite,
            Actors.ExitActionActor:
                self.build_exit_resume_wait_timeout_suite,
            Actors.UnregActor:
                self.build_unreg_resume_wait_timeout_suite,
            Actors.RegActor:
                self.build_reg_resume_wait_timeout_suite,
        }
        # Make sure we have enough threads
        assert num_waiters > 0
        assert num_actors > 0
        assert (num_waiters + num_actors) <= len(self.unregistered_names)

        # number needed for waiters, actors, and commander
        num_active_threads_needed = num_waiters + num_actors + 1

        self.build_config(
            cmd_runner=self.commander_name,
            num_active=num_active_threads_needed)

        self.log_name_groups()

        active_names_copy = self.active_names - {self.commander_name}

        waiter_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_waiters,
            update_collection=True,
            var_name_for_log='waiter_names')

        actor_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_actors,
            update_collection=True,
            var_name_for_log='actor_names')

        for actor in actor_list:
            actions[actor](waiter_names=waiter_names,
                           actor_names=actor_names)

    ####################################################################
    # build_wait_suite
    ####################################################################
    def build_wait_suite(
            self,
            timeout_type: TimeoutType,
            wait_state: st.ThreadState,
            wait_lap: int,
            resume_lap: int) -> None:
        """Add cmds to run scenario.

        Args:
            timeout_type: specifies whether the smart_recv should
                be coded with timeout, and whether it be False or True
            wait_state: resume state when wait is to be issued
            wait_lap: lap 0 or 1 when the wait is to be issued
            resume_lap: lap 0 or 1 when the resume is to be issued

        """
        # Make sure we have enough threads. Each of the scenarios will
        # require one thread for the commander, one thread for the
        # sender, and one thread for the receiver, for a total of three.
        assert 3 <= len(self.unregistered_names)

        self.build_config(
            cmd_runner=self.commander_name,
            num_active=2)  # one for commander and one for receiver

        self.log_name_groups()

        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose receiver_names
        ################################################################
        waiter_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=1,
            update_collection=True,
            var_name_for_log='waiter_names')

        ################################################################
        # choose sender_names
        ################################################################
        resumer_names = self.choose_names(
            name_collection=self.unregistered_names,
            num_names_needed=1,
            update_collection=False,
            var_name_for_log='resumer_names')

        log_msg = f'wait log test: {get_ptime()}'

        ################################################################
        # setup the names
        ################################################################
        waiter_name = waiter_names[0]
        resumer_name = resumer_names[0]

        confirm_cmd_to_use = 'Wait'
        wait_serial_num = 0
        ################################################################
        # lap loop
        ################################################################
        for lap in range(2):
            ############################################################
            # start loop to advance resumer through the config states
            ############################################################
            for state in (
                    st.ThreadState.Unregistered,
                    st.ThreadState.Registered,
                    st.ThreadState.Alive,
                    st.ThreadState.Stopped):
                ########################################################
                # do join to make resumer unregistered
                ########################################################
                if state == st.ThreadState.Unregistered:
                    if lap == 1:  # resumer already unregistered lap 0
                        self.build_join_suite(
                            cmd_runners=self.commander_name,
                            join_target_names=resumer_name,
                            validate_config=False)

                ########################################################
                # do create to make resumer registered
                ########################################################
                elif state == st.ThreadState.Registered:
                    self.build_create_suite(
                        f1_create_items=[
                            F1CreateItem(name=resumer_name,
                                         auto_start=False,
                                         target_rtn=outer_f1,
                                         app_config=AppConfig.ScriptStyle)],
                        validate_config=False)
                ########################################################
                # do start to make resumer alive
                ########################################################
                elif state == st.ThreadState.Alive:
                    self.build_start_suite(
                        start_names=resumer_name,
                        validate_config=False)
                    if (resume_lap == lap
                            and timeout_type != TimeoutType.TimeoutTrue):
                        self.add_cmd(
                            Resume(cmd_runners=resumer_name,
                                   targets=waiter_name,
                                   exp_resumed_targets=waiter_name,
                                   stopped_remotes=[]))
                ########################################################
                # do stop to make resumer stopped
                ########################################################
                else:  # state == st.ThreadState.Stopped:
                    self.build_exit_suite(
                        cmd_runner=self.commander_name,
                        names=resumer_name,
                        validate_config=False)
                ########################################################
                # issue wait
                ########################################################
                pause_time = 0
                if wait_state == state and wait_lap == lap:
                    stopped_remotes = set()
                    if (wait_lap == 0 and resume_lap == 1
                            and timeout_type != TimeoutType.TimeoutTrue):
                        stopped_remotes = {resumer_name}
                        pause_time = 1
                    if (timeout_type == TimeoutType.TimeoutTrue
                            and wait_state == st.ThreadState.Stopped):
                        stopped_remotes = {resumer_name}
                        pause_time = 1

                    if timeout_type == TimeoutType.TimeoutNone:
                        wait_serial_num = self.add_cmd(
                            Wait(cmd_runners=waiter_name,
                                 resumers=resumer_name,
                                 stopped_remotes=stopped_remotes,
                                 log_msg=log_msg))
                    elif timeout_type == TimeoutType.TimeoutFalse:
                        timeout_time = 6
                        confirm_cmd_to_use = 'WaitTimeoutFalse'
                        wait_serial_num = self.add_cmd(
                            WaitTimeoutFalse(
                                cmd_runners=waiter_name,
                                resumers=resumer_name,
                                timeout=timeout_time,
                                stopped_remotes=stopped_remotes,
                                log_msg=log_msg))

                    else:  # TimeoutType.TimeoutTrue
                        timeout_time = 0.5
                        pause_time = 1  # ensure timeout

                        confirm_cmd_to_use = 'WaitTimeoutTrue'
                        wait_serial_num = self.add_cmd(
                            WaitTimeoutTrue(
                                cmd_runners=waiter_name,
                                resumers=resumer_name,
                                timeout=timeout_time,
                                timeout_remotes=resumer_name,
                                stopped_remotes=stopped_remotes,
                                log_msg=log_msg))
                    if pause_time > 0:
                        self.add_cmd(
                            Pause(cmd_runners=self.commander_name,
                                  pause_seconds=pause_time))
        ################################################################
        # finally, confirm the smart_recv is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd=confirm_cmd_to_use,
                confirm_serial_num=wait_serial_num,
                confirmers=waiter_names))

    ####################################################################
    # powerset
    ####################################################################
    @staticmethod
    def powerset(names: list[str]):
        """Returns a generator powerset of the input list of names.

        Args:
            names: names to use to make a powerset

        """
        # powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)
        return chain.from_iterable(
            combinations(names, r) for r in range(len(names) + 1))

    ####################################################################
    # build_wait_active_suite
    ####################################################################
    def build_resume_before_wait_timeout_suite(
            self,
            waiter_names: list[str],
            actor_names: list[str]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            waiter_names: names of threads that will do the wait
            actor_names: names of threads that will do the resume

        """
        ################################################################
        # Loop to do combinations of resume names, the waiter names that
        # will be resumed - the remaining waiter names will timeout
        ################################################################
        for target_names in self.powerset(waiter_names.copy()):
            timeout_names = waiter_names
            if target_names:
                target_names = list(target_names)
                ########################################################
                # resume the waiters that are expected to succeed
                ########################################################
                resume_cmd_serial_num = self.add_cmd(
                    Resume(cmd_runners=actor_names,
                           targets=target_names,
                           exp_resumed_targets=target_names,
                           stopped_remotes=[]))
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='Resume',
                        confirm_serial_num=resume_cmd_serial_num,
                        confirmers=actor_names))

                timeout_time = 1.5
                wait_serial_num = self.add_cmd(
                    WaitTimeoutFalse(
                        cmd_runners=target_names,
                        resumers=actor_names,
                        stopped_remotes=set(),
                        timeout=timeout_time))

                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='WaitTimeoutFalse',
                        confirm_serial_num=wait_serial_num,
                        confirmers=target_names))

                timeout_names = list(set(waiter_names) - set(target_names))

            if timeout_names:
                ########################################################
                # the timeout_names are expected to timeout since they
                # were not resumed
                ########################################################
                timeout_time = 0.5
                wait_serial_num = self.add_cmd(
                    WaitTimeoutTrue(
                        cmd_runners=timeout_names,
                        resumers=actor_names,
                        stopped_remotes=set(),
                        timeout=timeout_time,
                        timeout_remotes=set(actor_names)))

                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='WaitTimeoutTrue',
                        confirm_serial_num=wait_serial_num,
                        confirmers=timeout_names))

    ####################################################################
    # build_wait_active_suite
    ####################################################################
    def build_resume_after_wait_timeout_suite(
            self,
            waiter_names: list[str],
            actor_names: list[str]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            waiter_names: names of threads that will do the wait
            actor_names: names of threads that will do the resume

        """
        ################################################################
        # Loop to do combinations of resume names, the waiter names that
        # will be resumed - the remaining waiter names will timeout
        ################################################################
        for target_names in self.powerset(waiter_names.copy()):
            timeout_names = waiter_names
            if target_names:
                ########################################################
                # resume the waiters that are expected to succeed
                ########################################################
                timeout_time = 1.5
                wait_serial_num = self.add_cmd(
                    WaitTimeoutFalse(
                        cmd_runners=list(target_names),
                        resumers=actor_names,
                        stopped_remotes=set(),
                        timeout=timeout_time))

                resume_cmd_serial_num = self.add_cmd(
                    Resume(cmd_runners=actor_names,
                           targets=list(target_names),
                           exp_resumed_targets=list(target_names),
                           stopped_remotes=[]))
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='Resume',
                        confirm_serial_num=resume_cmd_serial_num,
                        confirmers=actor_names))

                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='WaitTimeoutFalse',
                        confirm_serial_num=wait_serial_num,
                        confirmers=list(target_names)))

                timeout_names = list(set(waiter_names) - set(target_names))

            if timeout_names:
                ########################################################
                # the timeout_names are expected to timeout since they
                # were not resumed
                ########################################################
                timeout_time = 0.5
                wait_serial_num = self.add_cmd(
                    WaitTimeoutTrue(
                        cmd_runners=timeout_names,
                        resumers=actor_names,
                        stopped_remotes=set(),
                        timeout=timeout_time,
                        timeout_remotes=set(actor_names)))
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='WaitTimeoutTrue',
                        confirm_serial_num=wait_serial_num,
                        confirmers=timeout_names))

    ####################################################################
    # build_wait_active_suite
    ####################################################################
    def build_resume_exit_wait_timeout_suite(
            self,
            waiter_names: list[str],
            actor_names: list[str]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            waiter_names: names of threads that will do the wait
            actor_names: names of threads that will do the resume

        """
        ################################################################
        # Loop to do combinations of resume names, the waiter names that
        # will be resumed - the remaining waiter names will timeout
        ################################################################
        for target_names in self.powerset(waiter_names.copy()):
            timeout_names = waiter_names
            if target_names:
                target_names = list(target_names)
                ########################################################
                # resume the waiters that are expected to succeed
                ########################################################
                resume_cmd_serial_num = self.add_cmd(
                    Resume(cmd_runners=actor_names,
                           targets=target_names,
                           exp_resumed_targets=target_names,
                           stopped_remotes=[]))

                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='Resume',
                        confirm_serial_num=resume_cmd_serial_num,
                        confirmers=actor_names))

                self.build_exit_suite(cmd_runner=self.commander_name,
                                      names=actor_names)
                self.build_join_suite(
                    cmd_runners=self.commander_name,
                    join_target_names=actor_names)

                for resumer_name in actor_names:
                    # self.add_cmd(VerifyPairedHalf(
                    #     cmd_runners=self.commander_name,
                    #     removed_names=resumer_name,
                    #     exp_half_paired_names=target_names))
                    self.add_cmd(VerifyConfig(
                        cmd_runners=self.commander_name,
                        verify_type=VerifyType.VerifyHalfPaired,
                        names_to_check=target_names,
                        aux_names=resumer_name))

                timeout_time = 1.5
                wait_serial_num = self.add_cmd(
                    WaitTimeoutFalse(
                        cmd_runners=target_names,
                        resumers=actor_names,
                        stopped_remotes=set(),
                        timeout=timeout_time))
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='WaitTimeoutFalse',
                        confirm_serial_num=wait_serial_num,
                        confirmers=target_names))

                f1_create_items: list[F1CreateItem] = []
                for idx, name in enumerate(actor_names):
                    if idx % 2:
                        app_config = AppConfig.ScriptStyle
                    else:
                        app_config = AppConfig.RemoteThreadApp

                    f1_create_items.append(F1CreateItem(name=name,
                                                        auto_start=True,
                                                        target_rtn=outer_f1,
                                                        app_config=app_config))
                self.build_create_suite(
                    f1_create_items=f1_create_items,
                    validate_config=False)

                timeout_names = list(set(waiter_names) - set(target_names))

            if timeout_names:
                ########################################################
                # the timeout_names are expected to timeout since they
                # were not resumed
                ########################################################
                timeout_time = 0.5
                wait_serial_num = self.add_cmd(
                    WaitTimeoutTrue(
                        cmd_runners=timeout_names,
                        resumers=actor_names,
                        stopped_remotes=set(),
                        timeout=timeout_time,
                        timeout_remotes=set(actor_names)))
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='WaitTimeoutTrue',
                        confirm_serial_num=wait_serial_num,
                        confirmers=timeout_names))

    ####################################################################
    # build_exit_resume_wait_timeout_suite
    ####################################################################
    def build_exit_resume_wait_timeout_suite(
            self,
            waiter_names: list[str],
            actor_names: list[str]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            waiter_names: names of threads that will do the wait
            actor_names: names of threads that will do the resume

        """
        ################################################################
        # Loop to do combinations of resume names, the waiter names that
        # will be resumed - the remaining waiter names will timeout
        ################################################################
        for target_names in self.powerset(waiter_names.copy()):
            timeout_names = waiter_names

            if len(target_names) % 2:
                stopped_remotes = set(actor_names.copy())
            else:
                stopped_remotes = set()

            if target_names:
                target_names = list(target_names)

                timeout_time = 3.0
                wait_serial_num = self.add_cmd(
                    WaitTimeoutFalse(
                        cmd_runners=target_names,
                        resumers=actor_names,
                        stopped_remotes=stopped_remotes,
                        timeout=timeout_time))

                if stopped_remotes:
                    self.build_exit_suite(cmd_runner=self.commander_name,
                                          names=actor_names)

                    self.add_cmd(
                        ConfirmResponse(
                            cmd_runners=[self.commander_name],
                            confirm_cmd='WaitTimeoutFalse',
                            confirm_serial_num=wait_serial_num,
                            confirmers=target_names))

                    self.build_join_suite(
                        cmd_runners=self.commander_name,
                        join_target_names=actor_names)

                    f1_create_items: list[F1CreateItem] = []
                    for idx, name in enumerate(actor_names):
                        if idx % 2:
                            app_config = AppConfig.ScriptStyle
                        else:
                            app_config = AppConfig.RemoteThreadApp

                        f1_create_items.append(
                            F1CreateItem(name=name,
                                         auto_start=True,
                                         target_rtn=outer_f1,
                                         app_config=app_config))
                    self.build_create_suite(
                        f1_create_items=f1_create_items,
                        validate_config=False)

                if not stopped_remotes:
                    ########################################################
                    # resume the waiters that are expected to succeed
                    ########################################################
                    resume_cmd_serial_num = self.add_cmd(
                        Resume(cmd_runners=actor_names,
                               targets=target_names,
                               exp_resumed_targets=target_names,
                               stopped_remotes=[]))

                    self.add_cmd(
                        ConfirmResponse(
                            cmd_runners=[self.commander_name],
                            confirm_cmd='Resume',
                            confirm_serial_num=resume_cmd_serial_num,
                            confirmers=actor_names))

                    self.add_cmd(
                        ConfirmResponse(
                            cmd_runners=[self.commander_name],
                            confirm_cmd='WaitTimeoutFalse',
                            confirm_serial_num=wait_serial_num,
                            confirmers=target_names))

                timeout_names = list(set(waiter_names) - set(target_names))

            if timeout_names:
                ########################################################
                # the timeout_names are expected to timeout since they
                # were not resumed
                ########################################################
                if len(timeout_names) % 2:
                    stopped_remotes = set(actor_names.copy())
                    self.build_exit_suite(cmd_runner=self.commander_name,
                                          names=actor_names)
                else:
                    stopped_remotes = set()

                timeout_time = 0.5
                wait_serial_num = self.add_cmd(
                    WaitTimeoutTrue(
                        cmd_runners=timeout_names,
                        resumers=actor_names,
                        stopped_remotes=stopped_remotes,
                        timeout=timeout_time,
                        timeout_remotes=set(actor_names)))
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='WaitTimeoutTrue',
                        confirm_serial_num=wait_serial_num,
                        confirmers=timeout_names))
                if stopped_remotes:
                    self.build_join_suite(
                        cmd_runners=self.commander_name,
                        join_target_names=actor_names)

                    f1_create_items: list[F1CreateItem] = []
                    for idx, name in enumerate(actor_names):
                        if idx % 2:
                            app_config = AppConfig.ScriptStyle
                        else:
                            app_config = AppConfig.RemoteThreadApp

                        f1_create_items.append(
                            F1CreateItem(name=name,
                                         auto_start=True,
                                         target_rtn=outer_f1,
                                         app_config=app_config))
                    self.build_create_suite(
                        f1_create_items=f1_create_items,
                        validate_config=False)

    ####################################################################
    # build_wait_active_suite
    ####################################################################
    def build_unreg_resume_wait_timeout_suite(
            self,
            waiter_names: list[str],
            actor_names: list[str]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            waiter_names: names of threads that will do the wait
            actor_names: names of threads that will do the resume

        """
        ################################################################
        # Loop to do combinations of resume names, the waiter names that
        # will be resumed - the remaining waiter names will timeout
        ################################################################
        for target_names in self.powerset(waiter_names.copy()):
            if target_names:
                target_names = list(target_names)

                ########################################################
                # get actors into unreg state
                ########################################################
                self.build_exit_suite(cmd_runner=self.commander_name,
                                      names=actor_names)
                self.build_join_suite(
                    cmd_runners=self.commander_name,
                    join_target_names=actor_names)

                ########################################################
                # do the wait
                ########################################################
                wait_serial_num = self.add_cmd(
                    Wait(
                        cmd_runners=target_names,
                        resumers=actor_names,
                        stopped_remotes=set()))

                ########################################################
                # get actors into active state
                ########################################################
                f1_create_items: list[F1CreateItem] = []
                for idx, name in enumerate(actor_names):
                    if idx % 2:
                        app_config = AppConfig.ScriptStyle
                    else:
                        app_config = AppConfig.RemoteThreadApp

                    f1_create_items.append(F1CreateItem(name=name,
                                                        auto_start=True,
                                                        target_rtn=outer_f1,
                                                        app_config=app_config))
                self.build_create_suite(
                    f1_create_items=f1_create_items,
                    validate_config=False)

                ########################################################
                # resume the waiters
                ########################################################
                resume_cmd_serial_num = self.add_cmd(
                    Resume(cmd_runners=actor_names,
                           targets=target_names,
                           exp_resumed_targets=target_names,
                           stopped_remotes=[]))

                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='Resume',
                        confirm_serial_num=resume_cmd_serial_num,
                        confirmers=actor_names))

                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='Wait',
                        confirm_serial_num=wait_serial_num,
                        confirmers=target_names))

    ####################################################################
    # build_wait_active_suite
    ####################################################################
    def build_reg_resume_wait_timeout_suite(
            self,
            waiter_names: list[str],
            actor_names: list[str]) -> None:
        """Adds cmds to the cmd queue.

        Args:
            waiter_names: names of threads that will do the wait
            actor_names: names of threads that will do the resume

        """
        ################################################################
        # Loop to do combinations of resume names, the waiter names that
        # will be resumed - the remaining waiter names will timeout
        ################################################################
        for target_names in self.powerset(waiter_names.copy()):
            if target_names:
                target_names = list(target_names)

                ########################################################
                # get actors into reg state
                ########################################################
                self.build_exit_suite(cmd_runner=self.commander_name,
                                      names=actor_names)
                self.build_join_suite(
                    cmd_runners=self.commander_name,
                    join_target_names=actor_names)

                f1_create_items: list[F1CreateItem] = []
                for idx, name in enumerate(actor_names):
                    if idx % 2:
                        app_config = AppConfig.ScriptStyle
                    else:
                        app_config = AppConfig.RemoteThreadApp

                    f1_create_items.append(F1CreateItem(name=name,
                                                        auto_start=False,
                                                        target_rtn=outer_f1,
                                                        app_config=app_config))
                self.build_create_suite(
                    f1_create_items=f1_create_items,
                    validate_config=False)

                ########################################################
                # do the wait
                ########################################################
                wait_serial_num = self.add_cmd(
                    Wait(
                        cmd_runners=target_names,
                        resumers=actor_names,
                        stopped_remotes=set()))

                ########################################################
                # get actors into active state
                ########################################################
                self.build_start_suite(start_names=actor_names)

                ########################################################
                # resume the waiters
                ########################################################
                resume_cmd_serial_num = self.add_cmd(
                    Resume(cmd_runners=actor_names,
                           targets=target_names,
                           exp_resumed_targets=target_names,
                           stopped_remotes=[]))

                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='Resume',
                        confirm_serial_num=resume_cmd_serial_num,
                        confirmers=actor_names))

                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='Wait',
                        confirm_serial_num=wait_serial_num,
                        confirmers=target_names))

    ####################################################################
    # test_resume_scenarios
    ####################################################################
    def build_resume_scenarios(
            self,
            num_resumers: int,
            num_start_before: int,
            num_unreg_before: int,
            num_stop_before: int,
            num_unreg_after: int,
            num_stop_after_ok: int,
            num_stop_after_err: int
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_resumers: number of threads doing resumes
            num_start_before: number of target threads that will
                be started and issue a wait before the resume is done,
                and should succeed
            num_unreg_before: number of target threads that will be
                registered and then unregistered before the resume, and
                then started after the resume, and should succeed
            num_stop_before: number of target threads that will
                be started and then stopped (but not joined) before the
                resume, and should result in a not alive error
            num_unreg_after: number of target threads that will be
                unregistered after the resume, and should cause an error
            num_stop_after_ok: number of target threads that will
                be started after the resume is issued, and will stay
                alive long enough for the resume to set the wait_event,
                and will then be stopped and joined, and should result
                in success
            num_stop_after_err: number of target threads that will
                be started after the resume is issued, and will quickly
                be stopped and joined before the resume has a chance to
                see that is is alive to sety the wait_event, and should
                result in a not alive error

        """
        # Make sure we have enough threads
        total_arg_counts = (
                num_resumers
                + num_start_before
                + num_unreg_before
                + num_stop_before
                + num_unreg_after
                + num_stop_after_ok
                + num_stop_after_err)
        assert total_arg_counts <= len(self.unregistered_names)

        assert num_resumers > 0

        num_active_needed = (num_resumers + 1)  # plus 1 for commander

        self.build_config(
            cmd_runner=self.commander_name,
            num_active=num_active_needed,
        )

        self.log_name_groups()

        # remove commander
        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose resumer_names
        ################################################################
        resumer_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_resumers,
            update_collection=True,
            var_name_for_log='resumer_names')

        ################################################################
        # choose start_before_names
        ################################################################
        unregistered_names_copy = self.unregistered_names.copy()
        start_before_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_start_before,
            update_collection=True,
            var_name_for_log='start_before_names')

        ################################################################
        # choose unreg_before_names
        ################################################################
        unreg_before_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_unreg_before,
            update_collection=True,
            var_name_for_log='unreg_before_names')

        ################################################################
        # choose stop_before_names
        ################################################################
        stop_before_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_stop_before,
            update_collection=True,
            var_name_for_log='stop_before_names')

        ################################################################
        # choose unreg_after_names
        ################################################################
        unreg_after_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_unreg_after,
            update_collection=True,
            var_name_for_log='unreg_after_names')

        ################################################################
        # choose stop_after_ok_names
        ################################################################
        stop_after_ok_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_stop_after_ok,
            update_collection=True,
            var_name_for_log='stop_after_ok_names')

        ################################################################
        # choose stop_after_ok_names
        ################################################################
        stop_after_err_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_stop_after_err,
            update_collection=True,
            var_name_for_log='stop_after_err_names')

        all_targets: list[str] = (start_before_names
                                  + unreg_before_names
                                  + stop_before_names
                                  + unreg_after_names
                                  + stop_after_ok_names
                                  + stop_after_err_names)

        after_targets: list[str] = (unreg_before_names
                                    + unreg_after_names
                                    + stop_after_ok_names
                                    + stop_after_err_names)

        ################################################################
        # monkeypatch for SmartThread._get_target_state
        ################################################################
        a_target_mock_dict = {}
        if stop_after_err_names:
            for resumer_name in resumer_names:
                a_sub_dict = {}
                for stop_name in stop_after_err_names:
                    a_sub_dict[stop_name] = (st.ThreadState.Alive,
                                             st.ThreadState.Registered)
                a_target_mock_dict[resumer_name] = a_sub_dict

        # a_mock_get_target_state = MockGetTargetState(
        #     targets=a_target_mock_dict,
        #     config_ver=self)

        resume_serial_num_2 = 0

        wait_confirms: list[ConfirmResponse] = []
        for idx, waiter in enumerate(roundrobin(start_before_names,
                                     unreg_before_names,
                                     stop_before_names)):
            if idx % 2:
                app_config = AppConfig.ScriptStyle
            else:
                app_config = AppConfig.RemoteThreadApp

            if waiter in start_before_names:
                self.build_create_suite(
                    f1_create_items=[F1CreateItem(name=waiter,
                                                  auto_start=True,
                                                  target_rtn=outer_f1,
                                                  app_config=app_config)],
                    validate_config=False)
                wait_serial_num = self.add_cmd(
                    Wait(cmd_runners=waiter,
                         resumers=resumer_names,
                         stopped_remotes=set()))
                wait_confirms.append(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='Wait',
                        confirm_serial_num=wait_serial_num,
                        confirmers=waiter))
            elif waiter in unreg_before_names:
                self.build_create_suite(
                    f1_create_items=[F1CreateItem(name=waiter,
                                                  auto_start=False,
                                                  target_rtn=outer_f1,
                                                  app_config=app_config)],
                    validate_config=False)
                self.build_unreg_suite(names=waiter)
            elif waiter in stop_before_names:
                self.build_create_suite(
                    f1_create_items=[F1CreateItem(name=waiter,
                                                  auto_start=True,
                                                  target_rtn=outer_f1,
                                                  app_config=app_config)],
                    validate_config=False)
                # stop now, join later
                self.build_exit_suite(
                    cmd_runner=self.commander_name,
                    names=waiter,
                    validate_config=False)
            else:
                raise IncorrectDataDetected('build_resume_scenarios '
                                            f'{waiter=} not found in '
                                            f'{start_before_names=} nor '
                                            f'{unreg_before_names=} nor '
                                            f'{stop_before_names=}')

        ################################################################
        # wait for wait to be running and waiting to be resumed
        ################################################################
        if start_before_names:
            self.add_cmd(WaitForRequestTimeouts(
                cmd_runners=self.commander_name,
                actor_names=start_before_names,
                timeout_names=resumer_names))
        ################################################################
        # issue smart_resume
        ################################################################
        if stop_before_names:
            stopped_remotes = stop_before_names
        else:
            stopped_remotes = (unreg_after_names
                               + stop_after_err_names)

        resume_serial_num_1 = self.add_cmd(
            Resume(cmd_runners=resumer_names,
                   targets=all_targets,
                   exp_resumed_targets=all_targets,
                   stopped_remotes=stopped_remotes))

        ################################################################
        # confirm response now if we should have raised error for
        # stopped remotes
        ################################################################
        if stop_before_names:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='Resume',
                    confirm_serial_num=resume_serial_num_1,
                    confirmers=resumer_names))
            ############################################################
            # we need this resume for the after resume waits when the
            # first resume ends early because of stopped remotes
            ############################################################
            if after_targets:
                stopped_remotes = (unreg_after_names
                                   + stop_after_err_names)
                resume_serial_num_2 = self.add_cmd(
                    Resume(cmd_runners=resumer_names,
                           targets=after_targets,
                           exp_resumed_targets=after_targets,
                           stopped_remotes=stopped_remotes))

        ################################################################
        # Create and start unreg_before and stop_after_ok and issue the
        # wait. Note unreg_before is used both before and after the
        # resume
        ################################################################
        for idx, waiter in enumerate(roundrobin(unreg_before_names,
                                                stop_after_ok_names)):
            if idx % 2:
                app_config = AppConfig.ScriptStyle
            else:
                app_config = AppConfig.RemoteThreadApp

            self.build_create_suite(
                f1_create_items=[F1CreateItem(name=waiter,
                                              auto_start=True,
                                              target_rtn=outer_f1,
                                              app_config=app_config)],
                validate_config=False)
            wait_serial_num = self.add_cmd(
                Wait(cmd_runners=waiter,
                     resumers=resumer_names,
                     stopped_remotes=set()))
            wait_confirms.append(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='Wait',
                    confirm_serial_num=wait_serial_num,
                    confirmers=waiter))

        ################################################################
        # build unreg_after and stop_after_err
        ################################################################
        for idx, waiter in enumerate(roundrobin(unreg_after_names,
                                                stop_after_err_names)):
            if idx % 2:
                app_config = AppConfig.ScriptStyle
            else:
                app_config = AppConfig.RemoteThreadApp

            if waiter in unreg_after_names:
                self.build_create_suite(
                    f1_create_items=[F1CreateItem(name=waiter,
                                                  auto_start=False,
                                                  target_rtn=outer_f1,
                                                  app_config=app_config)],
                    validate_config=False)
                self.build_unreg_suite(names=waiter)
            elif waiter in stop_after_err_names:
                self.build_create_suite(
                    f1_create_items=[F1CreateItem(name=waiter,
                                                  auto_start=True,
                                                  target_rtn=outer_f1,
                                                  app_config=app_config)],
                    validate_config=False)
                self.build_exit_suite(
                    cmd_runner=self.commander_name,
                    names=waiter,
                    validate_config=False)
                self.build_join_suite(
                    cmd_runners=self.commander_name,
                    join_target_names=waiter,
                    validate_config=False)
            else:
                raise IncorrectDataDetected('build_resume_scenarios '
                                            f'{waiter=} not found in '
                                            f'{unreg_after_names=} nor '
                                            f'{stop_after_err_names=}')

        ####################################################
        # confirm the resumes
        ####################################################
        if not stop_before_names:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='Resume',
                    confirm_serial_num=resume_serial_num_1,
                    confirmers=resumer_names))
        elif after_targets:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='Resume',
                    confirm_serial_num=resume_serial_num_2,
                    confirmers=resumer_names))

        for confirm in wait_confirms:
            self.add_cmd(confirm)

    ####################################################################
    # test_resume_scenarios
    ####################################################################
    def build_wait_scenarios(
            self,
            num_waiters: int,
            num_start_before: int,
            num_unreg_before: int,
            num_stop_before: int,
            num_unreg_after: int,
            num_stop_after_ok: int,
            num_stop_after_err: int
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_waiters: number of threads doing resumes
            num_start_before: number of target threads that will
                be started and issue a wait before the resume is done,
                and should succeed
            num_unreg_before: number of target threads that will be
                registered and then unregistered before the resume, and
                then started after the resume, and should succeed
            num_stop_before: number of target threads that will
                be started and then stopped (but not joined) before the
                resume, and should result in a not alive error
            num_unreg_after: number of target threads that will be
                unregistered after the resume, and should cause an error
            num_stop_after_ok: number of target threads that will
                be started after the resume is issued, and will stay
                alive long enough for the resume to set the wait_event,
                and will then be stopped and joined, and should result
                in success
            num_stop_after_err: number of target threads that will
                be started after the resume is issued, and will quickly
                be stopped and joined before the resume has a chance to
                see that is is alive to sety the wait_event, and should
                result in a not alive error

        """
        # Make sure we have enough threads
        total_arg_counts = (
                num_waiters
                + num_start_before
                + num_unreg_before
                + num_stop_before
                + num_unreg_after
                + num_stop_after_ok
                + num_stop_after_err)
        assert total_arg_counts <= len(self.unregistered_names)

        assert num_waiters > 0

        num_active_needed = (num_waiters + 1)  # plus 1 for commander

        self.build_config(
            cmd_runner=self.commander_name,
            num_active=num_active_needed,
        )

        self.log_name_groups()

        # remove commander
        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose waiter_names
        ################################################################
        waiter_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_waiters,
            update_collection=True,
            var_name_for_log='waiter_names')

        ################################################################
        # choose start_before_names
        ################################################################
        unregistered_names_copy = self.unregistered_names.copy()
        start_before_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_start_before,
            update_collection=True,
            var_name_for_log='start_before_names')

        ################################################################
        # choose unreg_before_names
        ################################################################
        unreg_before_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_unreg_before,
            update_collection=True,
            var_name_for_log='unreg_before_names')

        ################################################################
        # choose stop_before_names
        ################################################################
        stop_before_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_stop_before,
            update_collection=True,
            var_name_for_log='stop_before_names')

        ################################################################
        # choose unreg_after_names
        ################################################################
        unreg_after_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_unreg_after,
            update_collection=True,
            var_name_for_log='unreg_after_names')

        ################################################################
        # choose stop_after_ok_names
        ################################################################
        stop_after_ok_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_stop_after_ok,
            update_collection=True,
            var_name_for_log='stop_after_ok_names')

        ################################################################
        # choose stop_after_ok_names
        ################################################################
        stop_after_err_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_stop_after_err,
            update_collection=True,
            var_name_for_log='stop_after_err_names')

        all_targets: list[str] = (start_before_names
                                  + unreg_before_names
                                  + stop_before_names
                                  + unreg_after_names
                                  + stop_after_ok_names
                                  + stop_after_err_names)

        after_targets: list[str] = (unreg_before_names
                                    + unreg_after_names
                                    + stop_after_ok_names
                                    + stop_after_err_names)

        ################################################################
        # monkeypatch for SmartThread._get_target_state
        ################################################################
        a_target_mock_dict = {}
        if stop_after_err_names:
            for waiter_name in waiter_names:
                a_sub_dict = {}
                for stop_name in stop_after_err_names:
                    a_sub_dict[stop_name] = (st.ThreadState.Alive,
                                             st.ThreadState.Registered)
                a_target_mock_dict[waiter_name] = a_sub_dict

        # a_mock_get_target_state = MockGetTargetState(
        #     targets=a_target_mock_dict,
        #     config_ver=self)

        wait_serial_num_2 = 0

        resume_confirms_before: list[ConfirmResponse] = []
        resume_confirms_after: list[ConfirmResponse] = []

        for idx, resumer in enumerate(roundrobin(start_before_names,
                                      unreg_before_names,
                                      stop_before_names)):
            if idx % 2:
                app_config = AppConfig.ScriptStyle
            else:
                app_config = AppConfig.RemoteThreadApp

            if resumer in start_before_names:
                self.build_create_suite(
                    f1_create_items=[F1CreateItem(name=resumer,
                                                  auto_start=True,
                                                  target_rtn=outer_f1,
                                                  app_config=app_config)],
                    validate_config=False)
                resume_serial_num = self.add_cmd(
                    Resume(cmd_runners=resumer,
                           targets=waiter_names,
                           exp_resumed_targets=waiter_names,
                           stopped_remotes=set()))
                resume_confirms_before.append(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='Resume',
                        confirm_serial_num=resume_serial_num,
                        confirmers=resumer))
            elif resumer in unreg_before_names:
                self.build_create_suite(
                    f1_create_items=[F1CreateItem(name=resumer,
                                                  auto_start=False,
                                                  target_rtn=outer_f1,
                                                  app_config=app_config)],
                    validate_config=False)
                self.build_unreg_suite(names=resumer,
                                       validate_config=False)
            elif resumer in stop_before_names:
                self.build_create_suite(
                    f1_create_items=[F1CreateItem(name=resumer,
                                                  auto_start=True,
                                                  target_rtn=outer_f1,
                                                  app_config=app_config)],
                    validate_config=False)
                # stop now, join later
                self.build_exit_suite(
                    cmd_runner=self.commander_name,
                    names=resumer,
                    validate_config=False)
            else:
                raise IncorrectDataDetected('build_resume_scenarios '
                                            f'{resumer=} not found in '
                                            f'{start_before_names=} nor '
                                            f'{unreg_before_names=} nor '
                                            f'{stop_before_names=}')

        ################################################################
        # confirm the before resumes
        ################################################################
        for confirm in resume_confirms_before:
            self.add_cmd(confirm)
        ################################################################
        # issue smart_wait
        ################################################################
        if stop_before_names:
            stopped_remotes = (stop_before_names
                               + unreg_before_names
                               + unreg_after_names
                               + stop_after_ok_names
                               + stop_after_err_names)
        else:
            stopped_remotes = (unreg_after_names
                               + stop_after_err_names)

        wait_serial_num_1 = self.add_cmd(
            Wait(cmd_runners=waiter_names,
                 resumers=all_targets,
                 stopped_remotes=stopped_remotes))

        ################################################################
        # confirm response now if we should have raised error for
        # stopped remotes
        ################################################################
        if stop_before_names:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='Wait',
                    confirm_serial_num=wait_serial_num_1,
                    confirmers=waiter_names))
            ############################################################
            # we need this wait for the after wait resumes when the
            # first wait ends early because of stopped remotes
            ############################################################
            if after_targets:
                stopped_remotes = (unreg_after_names
                                   + stop_after_err_names)
                wait_serial_num_2 = self.add_cmd(
                    Wait(cmd_runners=waiter_names,
                         resumers=after_targets,
                         stopped_remotes=stopped_remotes))

        ################################################################
        # Create and start unreg_before and stop_after_ok and issue the
        # resume. Note unreg_before is used both before and after the
        # wait
        ################################################################
        for idx, resumer in enumerate(roundrobin(unreg_before_names,
                                                 stop_after_ok_names)):
            if idx % 2:
                app_config = AppConfig.ScriptStyle
            else:
                app_config = AppConfig.RemoteThreadApp

            self.build_create_suite(
                f1_create_items=[F1CreateItem(name=resumer,
                                              auto_start=True,
                                              target_rtn=outer_f1,
                                              app_config=app_config)],
                validate_config=False)
            resume_serial_num = self.add_cmd(
                Resume(cmd_runners=resumer,
                       targets=waiter_names,
                       exp_resumed_targets=waiter_names,
                       stopped_remotes=set()))
            resume_confirms_after.append(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='Resume',
                    confirm_serial_num=resume_serial_num,
                    confirmers=resumer))

        ################################################################
        # build unreg_after and stop_after_err
        ################################################################
        for idx, resumer in enumerate(roundrobin(unreg_after_names,
                                                 stop_after_err_names)):
            if idx % 2:
                app_config = AppConfig.ScriptStyle
            else:
                app_config = AppConfig.RemoteThreadApp

            if resumer in unreg_after_names:
                self.build_create_suite(
                    f1_create_items=[F1CreateItem(name=resumer,
                                                  auto_start=False,
                                                  target_rtn=outer_f1,
                                                  app_config=app_config)],
                    validate_config=False)
                self.build_unreg_suite(names=resumer,
                                       validate_config=False)
            elif resumer in stop_after_err_names:
                self.build_create_suite(
                    f1_create_items=[F1CreateItem(name=resumer,
                                                  auto_start=True,
                                                  target_rtn=outer_f1,
                                                  app_config=app_config)],
                    validate_config=False)
                self.build_exit_suite(
                    cmd_runner=self.commander_name,
                    names=resumer,
                    validate_config=False)
                self.build_join_suite(
                    cmd_runners=self.commander_name,
                    join_target_names=resumer,
                    validate_config=False)
            else:
                raise IncorrectDataDetected('build_resume_scenarios '
                                            f'{resumer=} not found in '
                                            f'{unreg_after_names=} nor '
                                            f'{stop_after_err_names=}')

        ####################################################
        # confirm the waits
        ####################################################
        if not stop_before_names:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='Wait',
                    confirm_serial_num=wait_serial_num_1,
                    confirmers=waiter_names))
        elif after_targets:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='Wait',
                    confirm_serial_num=wait_serial_num_2,
                    confirmers=waiter_names))

        for confirm in resume_confirms_after:
            self.add_cmd(confirm)

    ####################################################################
    # build_resume_timeout_suite
    ####################################################################
    def build_resume_timeout_suite(self,
                                   timeout_type: TimeoutType,
                                   num_resumers: int,
                                   num_active: int,
                                   num_registered_before: int,
                                   num_registered_after: int,
                                   num_unreg_no_delay: int,
                                   num_unreg_delay: int,
                                   num_stopped_no_delay: int,
                                   num_stopped_delay: int
                                   ) -> None:
        """Add ConfigCmd items for smart_resume timeout scenarios.

        Args:
            timeout_type: specifies whether to issue the send_cmd with
                timeout, and is so whether the send_cmd should timeout
                or, by starting exited threads in time, not timeout
            num_resumers: number of threads doing resumes
            num_active: number threads active that will wait before the
                resume is done. This is the most expected use case. No
                resume timeout should occur for active targets.
            num_registered_before: number threads registered that will
                be started and then wait before the resume is issued.
                This case provides a variation by having a configuration
                change occur while the active targets are waiting. No
                resume timeout should occur for registered_before
                targets.
            num_registered_after: number threads registered that are
                started and wait after the resume is issued. This case
                provides a variation of a resume target being not alive
                when the resume is issued, and then a configuration
                change while the resume is running and the resume sees
                that the target is now alive. There is no significant
                delay between the resume and the start to expect the
                registered_after targets to cause a timeout.
            num_unreg_no_delay: number threads unregistered before the
                resume is done, and are then created and started within
                the allowed timeout
            num_unreg_delay: number threads unregistered before the
                resume is done, and are then created and started after
                the allowed timeout
            num_stopped_no_delay: number of threads stopped before the
                resume and are resurrected before a timeout
            num_stopped_delay: number of threads stopped before
                the resume and are resurrected after a timeout

        """
        # Make sure we have enough threads
        assert (num_resumers
                + num_active
                + num_registered_before
                + num_registered_after
                + num_unreg_no_delay
                + num_unreg_delay
                + num_stopped_no_delay
                + num_stopped_delay) <= len(self.unregistered_names)

        assert num_resumers > 0

        num_active_needed = (
                num_resumers
                + num_active
                + 1)  # plus 1 for commander

        timeout_time = ((num_active * 0.16)
                        + (num_registered_before * 0.16)
                        + (num_registered_after * 0.16)
                        + (num_unreg_no_delay * 0.32)
                        + (num_unreg_delay * 0.16)
                        + (num_stopped_no_delay * 0.32)
                        + (num_stopped_delay * 0.16))

        pause_time = 0.5
        if timeout_type == TimeoutType.TimeoutFalse:
            timeout_time *= 4  # prevent timeout
            pause_time = timeout_time * 0.10
        elif timeout_type == TimeoutType.TimeoutTrue:
            # timeout_time *= 0.5  # force timeout
            pause_time = timeout_time * 2

        self.build_config(
            cmd_runner=self.commander_name,
            num_registered=num_registered_before + num_registered_after,
            num_active=num_active_needed,
            num_stopped=num_stopped_no_delay + num_stopped_delay
        )

        self.log_name_groups()

        # remove commander
        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose resumer_names
        ################################################################
        resumer_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_resumers,
            update_collection=True,
            var_name_for_log='resumer_names')

        ################################################################
        # choose active_target_names
        ################################################################
        active_target_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_active,
            update_collection=True,
            var_name_for_log='active_target_names')

        ################################################################
        # choose registered_names_before
        ################################################################
        registered_names_copy = self.registered_names.copy()
        registered_names_before = self.choose_names(
            name_collection=registered_names_copy,
            num_names_needed=num_registered_before,
            update_collection=True,
            var_name_for_log='registered_names_before')

        ################################################################
        # choose registered_names_after
        ################################################################
        registered_names_after = self.choose_names(
            name_collection=registered_names_copy,
            num_names_needed=num_registered_after,
            update_collection=True,
            var_name_for_log='registered_names_after')

        ################################################################
        # choose unreg_no_delay_names
        ################################################################
        unregistered_names_copy = self.unregistered_names.copy()
        unreg_no_delay_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_unreg_no_delay,
            update_collection=True,
            var_name_for_log='unreg_no_delay_names')

        ################################################################
        # choose unreg_delay_names
        ################################################################
        unreg_delay_names = self.choose_names(
            name_collection=unregistered_names_copy,
            num_names_needed=num_unreg_delay,
            update_collection=True,
            var_name_for_log='unreg_delay_names')

        ################################################################
        # choose stopped_no_delay_targets
        ################################################################
        stopped_remotes_copy = self.stopped_remotes.copy()
        stopped_no_delay_targets = self.choose_names(
            name_collection=stopped_remotes_copy,
            num_names_needed=num_stopped_no_delay,
            update_collection=True,
            var_name_for_log='stopped_no_delay_targets')

        ################################################################
        # choose stopped_delay_targets
        ################################################################
        stopped_delay_targets = self.choose_names(
            name_collection=stopped_remotes_copy,
            num_names_needed=num_stopped_delay,
            update_collection=True,
            var_name_for_log='stopped_delay_targets')

        all_targets: list[str] = (active_target_names
                                  + registered_names_before
                                  + registered_names_after
                                  + unreg_no_delay_names
                                  + unreg_delay_names
                                  + stopped_no_delay_targets
                                  + stopped_delay_targets)

        # timeout_names = unreg_delay_names  + stopped_delay_targets
        timeout_names = unreg_delay_names + registered_names_after

        # if len(all_targets) % 2:
        #     error_stopped_target = True
        #     stopped_remotes = stopped_no_delay_targets
        #     + stopped_delay_targets
        # else:
        #     error_stopped_target = False
        #     stopped_remotes = stopped_delay_targets
        stopped_remotes = stopped_no_delay_targets + stopped_delay_targets
        ################################################################
        # issue smart_wait for active_target_names
        ################################################################
        if active_target_names:
            wait_active_target_serial_num = self.add_cmd(
                Wait(cmd_runners=active_target_names,
                     resumers=resumer_names,
                     stopped_remotes=set()))

        ################################################################
        # start registered_names_before issue smart_wait
        # This provides a variation where a configuration change (start)
        # is done while the above wait for active targets is in progress
        ################################################################
        if registered_names_before:
            self.build_start_suite(start_names=registered_names_before)
            wait_reg_before_target_serial_num = self.add_cmd(
                Wait(cmd_runners=registered_names_before,
                     resumers=resumer_names,
                     stopped_remotes=set()))

        ################################################################
        # issue smart_resume
        ################################################################
        if timeout_type == TimeoutType.TimeoutNone:
            resume_to_confirm = 'Resume'
            resume_serial_num = self.add_cmd(
                Resume(cmd_runners=resumer_names,
                       targets=all_targets,
                       exp_resumed_targets=all_targets,
                       stopped_remotes=stopped_remotes))
        elif timeout_type == TimeoutType.TimeoutFalse:
            resume_to_confirm = 'ResumeTimeoutFalse'
            resume_serial_num = self.add_cmd(
                ResumeTimeoutFalse(
                    cmd_runners=resumer_names,
                    targets=all_targets,
                    exp_resumed_targets=all_targets,
                    stopped_remotes=stopped_remotes,
                    timeout=timeout_time))
        else:
            resume_to_confirm = 'ResumeTimeoutTrue'
            exp_resumed_targets = (set(all_targets)
                                   - set(stopped_remotes)
                                   - set(timeout_names))
            resume_serial_num = self.add_cmd(
                ResumeTimeoutTrue(
                    cmd_runners=resumer_names,
                    targets=all_targets,
                    exp_resumed_targets=exp_resumed_targets,
                    stopped_remotes=stopped_remotes,
                    timeout=timeout_time,
                    timeout_names=timeout_names))

        ################################################################
        # prevent stopped_no_delay from getting started too soon
        ################################################################
        # if error_stopped_target and stopped_remotes:
        if stopped_remotes:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd=resume_to_confirm,
                    confirm_serial_num=resume_serial_num,
                    confirmers=resumer_names))
        ################################################################
        # create and start unreg_no_delay_names and build smart_wait
        ################################################################
        if unreg_no_delay_names:
            f1_create_items: list[F1CreateItem] = []
            for idx, name in enumerate(unreg_no_delay_names):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(F1CreateItem(name=name,
                                                    auto_start=True,
                                                    target_rtn=outer_f1,
                                                    app_config=app_config))
            self.build_create_suite(
                f1_create_items=f1_create_items,
                validate_config=False)

            wait_unreg_no_delay_serial_num = self.add_cmd(
                Wait(cmd_runners=unreg_no_delay_names,
                     resumers=resumer_names,
                     stopped_remotes=set()))

        ################################################################
        # build stopped_no_delay_targets smart_wait
        ################################################################
        if stopped_no_delay_targets:
            self.build_join_suite(
                cmd_runners=self.commander_name,
                join_target_names=stopped_no_delay_targets)

            for stopped_no_delay_name in stopped_no_delay_targets:
                # self.add_cmd(VerifyPairedNot(
                #     cmd_runners=self.commander_name,
                #     exp_not_paired_names=stopped_no_delay_name))
                self.add_cmd(VerifyConfig(
                    cmd_runners=self.commander_name,
                    verify_type=VerifyType.VerifyNotPaired,
                    names_to_check=stopped_no_delay_name))

            f1_create_items: list[F1CreateItem] = []
            for idx, name in enumerate(stopped_no_delay_targets):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(F1CreateItem(name=name,
                                                    auto_start=True,
                                                    target_rtn=outer_f1,
                                                    app_config=app_config))
            self.build_create_suite(
                f1_create_items=f1_create_items,
                validate_config=False)

            wait_stopped_no_delay_serial_num = self.add_cmd(
                Wait(cmd_runners=stopped_no_delay_targets,
                     resumers=resumer_names,
                     stopped_remotes=set()))

        ################################################################
        # wait for resume timeouts to be known
        ################################################################
        # if not (error_stopped_target and stopped_remotes):
        if not stopped_remotes:
            self.add_cmd(WaitForRequestTimeouts(
                cmd_runners=self.commander_name,
                actor_names=resumer_names,
                timeout_names=timeout_names))

        self.add_cmd(Pause(
            cmd_runners='alpha',
            pause_seconds=pause_time))

        ################################################################
        # start registered_names_after and issue smart_wait
        ################################################################
        if registered_names_after:
            self.build_start_suite(start_names=registered_names_after)
            wait_reg_after_target_serial_num = self.add_cmd(
                Wait(cmd_runners=registered_names_after,
                     resumers=resumer_names,
                     stopped_remotes=set()))

        ################################################################
        # build unreg_delay_names smart_wait
        ################################################################
        if unreg_delay_names:
            f1_create_items: list[F1CreateItem] = []
            for idx, name in enumerate(unreg_delay_names):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(F1CreateItem(name=name,
                                                    auto_start=False,
                                                    target_rtn=outer_f1,
                                                    app_config=app_config))
            self.build_create_suite(
                f1_create_items=f1_create_items,
                validate_config=False)

        ################################################################
        # build stopped_delay_targets smart_wait
        ################################################################
        if stopped_delay_targets:
            self.build_join_suite(
                cmd_runners=self.commander_name,
                join_target_names=stopped_delay_targets)

            for stopped_delay_name in stopped_delay_targets:
                # self.add_cmd(VerifyPairedNot(
                #     cmd_runners=self.commander_name,
                #     exp_not_paired_names=stopped_delay_name))
                self.add_cmd(VerifyConfig(
                    cmd_runners=self.commander_name,
                    verify_type=VerifyType.VerifyNotPaired,
                    names_to_check=stopped_delay_name))

            f1_create_items: list[F1CreateItem] = []
            for idx, name in enumerate(stopped_delay_targets):
                if idx % 2:
                    app_config = AppConfig.ScriptStyle
                else:
                    app_config = AppConfig.RemoteThreadApp

                f1_create_items.append(F1CreateItem(name=name,
                                                    auto_start=False,
                                                    target_rtn=outer_f1,
                                                    app_config=app_config))
            self.build_create_suite(
                f1_create_items=f1_create_items,
                validate_config=False)

            self.build_start_suite(start_names=stopped_delay_targets)
            wait_stopped_delay_serial_num = self.add_cmd(
                Wait(cmd_runners=stopped_delay_targets,
                     resumers=resumer_names,
                     stopped_remotes=set()))

        ################################################################
        # build unreg_delay_names smart_wait
        ################################################################
        if unreg_delay_names:
            self.build_start_suite(start_names=unreg_delay_names)
            wait_unreg_delay_serial_num = self.add_cmd(
                Wait(cmd_runners=unreg_delay_names,
                     resumers=resumer_names,
                     stopped_remotes=set()))

        ####################################################
        # confirm the active target waits
        ####################################################
        if active_target_names:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='Wait',
                    confirm_serial_num=wait_active_target_serial_num,
                    confirmers=active_target_names))

        ####################################################
        # confirm the registered target waits
        ####################################################
        if registered_names_before:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='Wait',
                    confirm_serial_num=wait_reg_before_target_serial_num,
                    confirmers=registered_names_before))

        ####################################################
        # confirm the registered target waits
        ####################################################
        if registered_names_after:
            if (timeout_type == TimeoutType.TimeoutTrue
                    or stopped_remotes):
                self.add_cmd(
                    ConfirmResponseNot(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='Wait',
                        confirm_serial_num=wait_reg_after_target_serial_num,
                        confirmers=registered_names_after))

                resume_serial_num2 = self.add_cmd(
                    ResumeTimeoutFalse(
                        cmd_runners=resumer_names,
                        targets=registered_names_after,
                        exp_resumed_targets=registered_names_after,
                        stopped_remotes=[],
                        timeout=0.5))
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='ResumeTimeoutFalse',
                        confirm_serial_num=resume_serial_num2,
                        confirmers=resumer_names))
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='Wait',
                    confirm_serial_num=wait_reg_after_target_serial_num,
                    confirmers=registered_names_after))

        ####################################################
        # confirm the unreg_no_delay_names
        ####################################################
        if unreg_no_delay_names:
            # if error_stopped_target and stopped_remotes:
            if stopped_remotes:
                self.add_cmd(
                    ConfirmResponseNot(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='Wait',
                        confirm_serial_num=wait_unreg_no_delay_serial_num,
                        confirmers=unreg_no_delay_names))

                resume_serial_num2 = self.add_cmd(
                    ResumeTimeoutFalse(
                        cmd_runners=resumer_names,
                        targets=unreg_no_delay_names,
                        exp_resumed_targets=unreg_no_delay_names,
                        stopped_remotes=[],
                        timeout=0.5))
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='ResumeTimeoutFalse',
                        confirm_serial_num=resume_serial_num2,
                        confirmers=resumer_names))
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='Wait',
                    confirm_serial_num=wait_unreg_no_delay_serial_num,
                    confirmers=unreg_no_delay_names))
        ####################################################
        # confirm the unreg_delay_names
        ####################################################
        if unreg_delay_names:
            if (timeout_type == TimeoutType.TimeoutTrue
                    # or (error_stopped_target and stopped_remotes)):
                    or stopped_remotes):
                self.add_cmd(
                    ConfirmResponseNot(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='Wait',
                        confirm_serial_num=wait_unreg_delay_serial_num,
                        confirmers=unreg_delay_names))

                resume_serial_num2 = self.add_cmd(
                    ResumeTimeoutFalse(
                        cmd_runners=resumer_names,
                        targets=unreg_delay_names,
                        exp_resumed_targets=unreg_delay_names,
                        stopped_remotes=[],
                        timeout=0.5))
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='ResumeTimeoutFalse',
                        confirm_serial_num=resume_serial_num2,
                        confirmers=resumer_names))
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='Wait',
                    confirm_serial_num=wait_unreg_delay_serial_num,
                    confirmers=unreg_delay_names))
        ####################################################
        # confirm the stopped_no_delay_targets
        ####################################################
        if stopped_no_delay_targets:
            # if error_stopped_target and stopped_remotes:
            if stopped_remotes:
                self.add_cmd(
                    ConfirmResponseNot(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='Wait',
                        confirm_serial_num=wait_stopped_no_delay_serial_num,
                        confirmers=stopped_no_delay_targets))

                resume_serial_num2 = self.add_cmd(
                    ResumeTimeoutFalse(
                        cmd_runners=resumer_names,
                        targets=stopped_no_delay_targets,
                        exp_resumed_targets=stopped_no_delay_targets,
                        stopped_remotes=[],
                        timeout=0.5))
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='ResumeTimeoutFalse',
                        confirm_serial_num=resume_serial_num2,
                        confirmers=resumer_names))
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='Wait',
                    confirm_serial_num=wait_stopped_no_delay_serial_num,
                    confirmers=stopped_no_delay_targets))

        ####################################################
        # confirm the stopped_remotes
        ####################################################
        if stopped_delay_targets:
            if (timeout_type == TimeoutType.TimeoutTrue
                    # or (error_stopped_target and stopped_remotes)):
                    or stopped_remotes):
                self.add_cmd(
                    ConfirmResponseNot(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='Wait',
                        confirm_serial_num=wait_stopped_delay_serial_num,
                        confirmers=stopped_delay_targets))

                resume_serial_num2 = self.add_cmd(
                    ResumeTimeoutFalse(
                        cmd_runners=resumer_names,
                        targets=stopped_delay_targets,
                        exp_resumed_targets=stopped_delay_targets,
                        stopped_remotes=[],
                        timeout=0.5))
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=[self.commander_name],
                        confirm_cmd='ResumeTimeoutFalse',
                        confirm_serial_num=resume_serial_num2,
                        confirmers=resumer_names))
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd='Wait',
                    confirm_serial_num=wait_stopped_delay_serial_num,
                    confirmers=stopped_delay_targets))

        ####################################################
        # confirm the resumer_names
        ####################################################
        # if not (error_stopped_target and stopped_remotes):
        if not stopped_remotes:
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=[self.commander_name],
                    confirm_cmd=resume_to_confirm,
                    confirm_serial_num=resume_serial_num,
                    confirmers=resumer_names))

    ####################################################################
    # build_send_rotate_state_scenario
    ####################################################################
    def build_send_rotate_state_scenario(
            self,
            timeout_type: TimeoutType,
            send_msg_state: tuple[st.ThreadState, int],
            send_msg_lap: int,
            recv_msg_lap: int,
            send_resume: str = 'send') -> None:
        """Add cmds to run scenario.

        Args:
            timeout_type: specifies whether the smart_recv should
                be coded with timeout, and whether it be False or True
            send_msg_state: receiver state when smart_send is to be issued
            send_msg_lap: lap 0 or 1 when the smart_send is to be issued
            recv_msg_lap: lap 0 or 1 when the smart_recv is to be issued
            send_resume: 'send' or 'resume'

        """
        # Make sure we have enough threads. Each of the scenarios will
        # require one thread for the commander, one thread for the
        # sender, and one thread for the receiver, for a total of three.
        assert 3 <= len(self.unregistered_names)

        self.build_config(
            cmd_runner=self.commander_name,
            num_active=2)  # one for commander and two for senders
        self.log_name_groups()

        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose receiver_names
        ################################################################
        sender_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=1,
            update_collection=True,
            var_name_for_log='sender_names')

        ################################################################
        # choose receiver_names
        ################################################################
        receiver_names = self.choose_names(
            name_collection=self.unregistered_names,
            num_names_needed=1,
            update_collection=False,
            var_name_for_log='receiver_names')

        log_msg = f'smart_send log test: {get_ptime()}'

        ################################################################
        # setup the messages to send
        ################################################################
        receiver_name = receiver_names[0]
        sender_name = sender_names[0]

        sender_msgs = SendRecvMsgs(
            sender_names=sender_name,
            receiver_names=receiver_name,
            num_msgs=1,
            send_type=SendType.ToRemotes)

        receiver_msgs = SendRecvMsgs(
            sender_names=receiver_name,
            receiver_names=sender_name,
            num_msgs=1,
            send_type=SendType.ToRemotes)

        confirm_cmd_to_use = 'SendMsg'
        send_msg_serial_num = 0

        recv_msg_ok = False
        reset_ops_count = False

        stopped_remotes = set()

        if (send_msg_state[0] == st.ThreadState.Unregistered
                and send_msg_state[1] == 0):
            if timeout_type != TimeoutType.TimeoutTrue:
                stopped_remotes = {receiver_name}

        if (send_msg_state[0] == st.ThreadState.Registered
                and send_msg_state[1] == 0):
            if timeout_type != TimeoutType.TimeoutTrue:
                stopped_remotes = {receiver_name}
                # if send_msg_lap == recv_msg_lap:
                #     # recv_msg_ok = True
                #     stopped_remotes = {receiver_name}
                # else:
                #     if (send_resume == 'sync'
                #             or send_resume == 'sync_send'):
                #         if send_msg_lap < recv_msg_lap:
                #             stopped_remotes = {receiver_name}
                #         elif send_msg_lap > recv_msg_lap:
                #             timeout_type = TimeoutType.TimeoutTrue
                #     else:
                #         reset_ops_count = True

        # if (send_msg_state[0] == st.ThreadState.Unregistered
        #         and send_msg_state[1] == 1):
        #     if timeout_type != TimeoutType.TimeoutTrue:
        #         if send_msg_lap == recv_msg_lap:
        #             recv_msg_ok = True
        #         else:
        #             stopped_remotes = {receiver_name}

        if (send_msg_state[0] == st.ThreadState.Registered
                and send_msg_state[1] == 1):
            if timeout_type != TimeoutType.TimeoutTrue:
                if send_msg_lap == recv_msg_lap:
                    recv_msg_ok = True
                elif (send_resume == 'sync'
                        or send_resume == 'sync_send'):
                    if send_msg_lap < recv_msg_lap:
                        stopped_remotes = {receiver_name}
                    elif send_msg_lap > recv_msg_lap:
                        timeout_type = TimeoutType.TimeoutTrue
                elif send_msg_lap > recv_msg_lap:
                    stopped_remotes = {receiver_name}

        if (send_msg_state[0] == st.ThreadState.Unregistered
                and send_msg_state[1] == 1):
            if timeout_type != TimeoutType.TimeoutTrue:
                if send_msg_lap == recv_msg_lap:
                    recv_msg_ok = True
                else:
                    if (send_resume == 'sync'
                            or send_resume == 'sync_send'):
                        if send_msg_lap < recv_msg_lap:
                            stopped_remotes = {receiver_name}
                        elif send_msg_lap > recv_msg_lap:
                            timeout_type = TimeoutType.TimeoutTrue
                    else:
                        reset_ops_count = True

        if send_msg_state[0] == st.ThreadState.Alive:
            if timeout_type != TimeoutType.TimeoutTrue:
                if send_msg_lap == recv_msg_lap:
                    recv_msg_ok = True
                else:
                    stopped_remotes = {receiver_name}

        # if (send_msg_state[0] == st.ThreadState.Registered
        #         or send_msg_state[0] == st.ThreadState.Alive):
        #     if timeout_type == TimeoutType.TimeoutTrue:
        #         timeout_type = TimeoutType.TimeoutNone
        #
        #     if send_msg_lap == recv_msg_lap:
        #         recv_msg_ok = True
        #     else:
        #         if (send_resume == 'sync'
        #                 or send_resume == 'sync_send'):
        #             if send_msg_lap < recv_msg_lap:
        #                 stopped_remotes = {receiver_name}
        #             elif send_msg_lap > recv_msg_lap:
        #                 timeout_type = TimeoutType.TimeoutTrue
        #         else:
        #             reset_ops_count = True

        if send_msg_state[0] == st.ThreadState.Stopped:
            stopped_remotes = {receiver_name}
            # else:
            #     if send_msg_lap == 1:
            #         timeout_type = TimeoutType.TimeoutTrue
            #     else:
            #         if (send_resume == 'sync'
            #                 or send_resume == 'sync_send'):
            #             if send_msg_lap == recv_msg_lap:
            #                 timeout_type = TimeoutType.TimeoutTrue
            #             else:
            #                 if timeout_type != TimeoutType.TimeoutTrue:
            #                     recv_msg_ok = True
            #         elif (send_msg_lap != recv_msg_lap
            #                 and timeout_type != TimeoutType.TimeoutTrue):
            #             recv_msg_ok = True

        ################################################################
        # lap loop
        ################################################################
        current_state = st.ThreadState.Unregistered
        reg_iteration = 0
        for lap in range(2):
            ############################################################
            # start loop to advance receiver through the config states
            ############################################################
            for state in (
                    st.ThreadState.Unregistered,
                    st.ThreadState.Registered,
                    st.ThreadState.Unregistered,
                    st.ThreadState.Registered,
                    st.ThreadState.Alive,
                    st.ThreadState.Stopped):
                state_iteration = 0
                ########################################################
                # do join to make receiver unregistered
                ########################################################
                if state == st.ThreadState.Unregistered:
                    if current_state == st.ThreadState.Registered:
                        self.add_cmd(Unregister(
                            cmd_runners=self.commander_name,
                            unregister_targets=receiver_name))
                        self.unregistered_names |= {receiver_name}
                        state_iteration = 1
                    elif current_state == st.ThreadState.Stopped:
                        self.build_join_suite(
                            cmd_runners=self.commander_name,
                            join_target_names=receiver_name,
                            validate_config=False)
                    current_state = st.ThreadState.Unregistered
                ########################################################
                # do create to make receiver registered
                ########################################################
                elif state == st.ThreadState.Registered:
                    state_iteration = reg_iteration % 2
                    reg_iteration += 1
                    self.build_create_suite(
                        f1_create_items=[
                            F1CreateItem(name=receiver_name,
                                         auto_start=False,
                                         target_rtn=outer_f1,
                                         app_config=AppConfig.ScriptStyle)],
                        validate_config=False)
                    current_state = st.ThreadState.Registered
                ########################################################
                # do start to make receiver alive
                ########################################################
                elif state == st.ThreadState.Alive:
                    self.build_start_suite(
                        start_names=receiver_name,
                        validate_config=False)

                    if send_resume == 'sync_send':
                        send_msg_serial_num2 = self.add_cmd(
                            SendMsg(
                                cmd_runners=receiver_name,
                                receivers=sender_name,
                                msgs_to_send=receiver_msgs,
                                msg_idx=0,
                                stopped_remotes=set(),
                                log_msg=log_msg))
                        self.add_cmd(
                            ConfirmResponse(
                                cmd_runners=self.commander_name,
                                confirm_cmd='SendMsg',
                                confirm_serial_num=send_msg_serial_num2,
                                confirmers=receiver_name))
                    if recv_msg_lap == lap:
                        if recv_msg_ok:
                            if send_resume == 'send':
                                self.add_cmd(
                                    RecvMsg(cmd_runners=receiver_name,
                                            senders=sender_name,
                                            exp_senders=sender_name,
                                            exp_msgs=sender_msgs))
                            elif send_resume == 'resume':
                                self.add_cmd(
                                    Wait(cmd_runners=receiver_name,
                                         resumers=sender_name))
                            else:
                                self.add_cmd(
                                    Sync(cmd_runners=receiver_name,
                                         targets=sender_name))
                        else:
                            if send_resume == 'send':
                                self.add_cmd(
                                    RecvMsgTimeoutTrue(
                                        cmd_runners=receiver_name,
                                        senders=sender_name,
                                        timeout=0.5,
                                        timeout_names=sender_name,
                                        exp_msgs=sender_msgs))
                            elif send_resume == 'resume':
                                self.add_cmd(
                                    WaitTimeoutTrue(
                                        cmd_runners=receiver_name,
                                        resumers=sender_name,
                                        timeout=0.5,
                                        timeout_remotes=sender_name))
                            else:
                                self.add_cmd(
                                    SyncTimeoutTrue(
                                        cmd_runners=receiver_name,
                                        targets=sender_name,
                                        timeout=0.5,
                                        timeout_remotes=sender_name))
                            self.add_cmd(
                                Pause(cmd_runners=self.commander_name,
                                      pause_seconds=1))
                    current_state = st.ThreadState.Alive
                ########################################################
                # do stop to make receiver stopped
                ########################################################
                else:  # state == st.ThreadState.Stopped:
                    self.build_exit_suite(
                        cmd_runner=self.commander_name,
                        names=receiver_name,
                        validate_config=False,
                        reset_ops_count=reset_ops_count)
                    current_state = st.ThreadState.Stopped
                ########################################################
                # issue smart_send
                ########################################################
                if (send_msg_state[0] == state
                        and send_msg_state[1] == state_iteration
                        and send_msg_lap == lap):
                    pause_time = 1
                    if timeout_type == TimeoutType.TimeoutNone:
                        if send_resume == 'send':
                            confirm_cmd_to_use = 'SendMsg'
                            send_msg_serial_num = self.add_cmd(
                                SendMsg(
                                    cmd_runners=sender_name,
                                    receivers=receiver_name,
                                    msgs_to_send=sender_msgs,
                                    msg_idx=0,
                                    stopped_remotes=stopped_remotes,
                                    log_msg=log_msg))
                        elif send_resume == 'resume':
                            confirm_cmd_to_use = 'Resume'
                            send_msg_serial_num = self.add_cmd(
                                Resume(
                                    cmd_runners=sender_name,
                                    targets=receiver_name,
                                    exp_resumed_targets=receiver_name,
                                    stopped_remotes=stopped_remotes,
                                    log_msg=log_msg))
                        elif (send_resume == 'sync'
                              or send_resume == 'sync_send'):
                            confirm_cmd_to_use = 'Sync'
                            send_msg_serial_num = self.add_cmd(
                                Sync(
                                    cmd_runners=sender_name,
                                    targets=receiver_name,
                                    stopped_remotes=stopped_remotes,
                                    log_msg=log_msg))

                    elif timeout_type == TimeoutType.TimeoutFalse:
                        timeout_time = 6
                        if send_resume == 'send':
                            confirm_cmd_to_use = 'SendMsgTimeoutFalse'
                            send_msg_serial_num = self.add_cmd(
                                SendMsgTimeoutFalse(
                                    cmd_runners=sender_name,
                                    receivers=receiver_name,
                                    msgs_to_send=sender_msgs,
                                    msg_idx=0,
                                    timeout=timeout_time,
                                    stopped_remotes=stopped_remotes,
                                    log_msg=log_msg))
                        elif send_resume == 'resume':
                            confirm_cmd_to_use = 'ResumeTimeoutFalse'
                            send_msg_serial_num = self.add_cmd(
                                ResumeTimeoutFalse(
                                    cmd_runners=sender_name,
                                    targets=receiver_name,
                                    exp_resumed_targets=receiver_name,
                                    timeout=timeout_time,
                                    stopped_remotes=stopped_remotes,
                                    log_msg=log_msg))
                        elif (send_resume == 'sync'
                              or send_resume == 'sync_send'):
                            confirm_cmd_to_use = 'SyncTimeoutFalse'
                            send_msg_serial_num = self.add_cmd(
                                SyncTimeoutFalse(
                                    cmd_runners=sender_name,
                                    targets=receiver_name,
                                    timeout=timeout_time,
                                    stopped_remotes=stopped_remotes,
                                    log_msg=log_msg))
                    else:  # timeout_type == TimeoutType.TimeoutTrue
                        timeout_time = 0.5
                        if send_resume == 'send':
                            confirm_cmd_to_use = 'SendMsgTimeoutTrue'
                            send_msg_serial_num = self.add_cmd(
                                SendMsgTimeoutTrue(
                                    cmd_runners=sender_name,
                                    receivers=receiver_name,
                                    msgs_to_send=sender_msgs,
                                    msg_idx=0,
                                    timeout=timeout_time,
                                    unreg_timeout_names=receiver_name,
                                    fullq_timeout_names=[],
                                    stopped_remotes=stopped_remotes,
                                    log_msg=log_msg))
                        elif send_resume == 'resume':
                            confirm_cmd_to_use = 'ResumeTimeoutTrue'
                            send_msg_serial_num = self.add_cmd(
                                ResumeTimeoutTrue(
                                    cmd_runners=sender_name,
                                    targets=receiver_name,
                                    exp_resumed_targets=set(),
                                    timeout=timeout_time,
                                    timeout_names=receiver_name,
                                    stopped_remotes=stopped_remotes,
                                    log_msg=log_msg))
                        elif (send_resume == 'sync'
                              or send_resume == 'sync_send'):
                            confirm_cmd_to_use = 'SyncTimeoutTrue'
                            send_msg_serial_num = self.add_cmd(
                                SyncTimeoutTrue(
                                    cmd_runners=sender_name,
                                    targets=receiver_name,
                                    timeout=timeout_time,
                                    timeout_remotes=receiver_name,
                                    stopped_remotes=stopped_remotes,
                                    log_msg=log_msg))
                    self.add_cmd(
                        Pause(cmd_runners=self.commander_name,
                              pause_seconds=pause_time))
        ################################################################
        # finally, confirm the smart_recv is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd=confirm_cmd_to_use,
                confirm_serial_num=send_msg_serial_num,
                confirmers=sender_name))

    ####################################################################
    # build_rotate_state_scenario
    ####################################################################
    def build_rotate_state_scenario(
            self,
            timeout_type: TimeoutType,
            req0: SmartRequestType,
            req1: SmartRequestType,
            req0_when_req1_state: tuple[st.ThreadState, int],
            req0_when_req1_lap: int,
            req1_lap: int) -> None:
        """Add cmds to run scenario.

        Args:
            timeout_type: specifies whether the smart_recv should
                be coded with timeout, and whether it be False or True
            req0: the SmartRequest that req0 will make
            req1: the SmartRequest that req1 will make
            req0_when_req1_state: req0 will issue SmartRequest when
                req1 transitions to this state
            req0_when_req1_lap: req0 will issue SmartRequest when
                req1 transitions during this lap
            req1_lap: lap 0 or 1 when req1 SmartRequest is to be
                issued

        """
        # Make sure we have enough threads. Each of the scenarios will
        # require one thread for the commander, one thread for req0,
        # and one thread for req1, for a total of three.
        assert 3 <= len(self.unregistered_names)

        self.build_config(
            cmd_runner=self.commander_name,
            num_active=2)  # one for commander and one for req0
        self.log_name_groups()

        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose receiver_names
        ################################################################
        req0_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=1,
            update_collection=True,
            var_name_for_log='req0_names')

        ################################################################
        # choose receiver_names
        ################################################################
        req1_names = self.choose_names(
            name_collection=self.unregistered_names,
            num_names_needed=1,
            update_collection=False,
            var_name_for_log='req1_names')

        ################################################################
        # setup the messages to send
        ################################################################
        req0_name = req0_names[0]
        req1_name = req1_names[0]

        sender_msgs = SendRecvMsgs(
            sender_names=[req0_name, req1_name],
            receiver_names=[req0_name, req1_name],
            num_msgs=1,
            send_type=SendType.ToRemotes)
        # if req0 == SmartRequestType.SendMsg:
        #     sr_key: SrKeyMsgKey = SrKeyMsgKey(sender=req0_name, receiver=req1_name)
        #     sender_msgs.send_msgs[sr_key] = [f'send test: {req0_name} sending '
        #                                      f'msg at {get_ptime()}']
        # if req1 == SmartRequestType.SendMsg:
        #     sr_key: SrKeyMsgKey = SrKeyMsgKey(sender=req1_name, receiver=req0_name)
        #     sender_msgs.send_msgs[sr_key] = [f'send test: {req1_name} sending '
        #                                      f'msg at {get_ptime()}']

        req0_conflict_remotes: set[str] = set()
        req0_deadlock_remotes: set[str] = set()

        req1_conflict_remotes: set[str] = set()
        req1_deadlock_remotes: set[str] = set()

        req0_specific_args: dict[str, Any] = {
            'sender_msgs': sender_msgs,
            'conflict_remotes': req0_conflict_remotes,
            'deadlock_remotes': req0_deadlock_remotes,
        }

        req1_specific_args: dict[str, Any] = {
            'sender_msgs': sender_msgs,
            'conflict_remotes': req1_conflict_remotes,
            'deadlock_remotes': req1_deadlock_remotes,
        }

        ################################################################
        # request rtns
        ################################################################
        request_build_rtns: dict[SmartRequestType,
                                 Callable[..., RequestConfirmParms]] = {
            SmartRequestType.SendMsg: self.build_send_msg_request,
            SmartRequestType.RecvMsg: self.build_recv_msg_request,
            SmartRequestType.Resume: self.build_resume_request,
            SmartRequestType.Sync: self.build_sync_request,
            SmartRequestType.Wait: self.build_wait_request,
        }

        req0_stopped_remotes = set()
        req1_stopped_remotes = set()
        req1_timeout_type: TimeoutType = TimeoutType.TimeoutNone
        supress_req1 = False

        reset_ops_count = False

        class ReqCategory(Enum):
            Throw = auto()
            Catch = auto()
            Handshake = auto()

        @dataclass
        class ReqFlags:
            req0_category: ReqCategory
            req1_category: ReqCategory
            req_matched: bool
            req_conflict: bool
            req_deadlock: bool

        request_table: dict[
            tuple[SmartRequestType, SmartRequestType], ReqFlags] = {

            (SmartRequestType.SendMsg, SmartRequestType.SendMsg):
                ReqFlags(req0_category=ReqCategory.Throw,
                         req1_category=ReqCategory.Throw,
                         req_matched=False,
                         req_conflict=False,
                         req_deadlock=False),
            (SmartRequestType.SendMsg, SmartRequestType.RecvMsg):
                ReqFlags(req0_category=ReqCategory.Throw,
                         req1_category=ReqCategory.Catch,
                         req_matched=True,
                         req_conflict=False,
                         req_deadlock=False),
            (SmartRequestType.SendMsg, SmartRequestType.Resume):
                ReqFlags(req0_category=ReqCategory.Throw,
                         req1_category=ReqCategory.Throw,
                         req_matched=False,
                         req_conflict=False,
                         req_deadlock=False),
            (SmartRequestType.SendMsg, SmartRequestType.Sync):
                ReqFlags(req0_category=ReqCategory.Throw,
                         req1_category=ReqCategory.Handshake,
                         req_matched=False,
                         req_conflict=False,
                         req_deadlock=False),
            (SmartRequestType.SendMsg, SmartRequestType.Wait):
                ReqFlags(req0_category=ReqCategory.Throw,
                         req1_category=ReqCategory.Catch,
                         req_matched=False,
                         req_conflict=False,
                         req_deadlock=False),

            (SmartRequestType.RecvMsg, SmartRequestType.RecvMsg):
                ReqFlags(req0_category=ReqCategory.Catch,
                         req1_category=ReqCategory.Catch,
                         req_matched=False,
                         req_conflict=False,
                         req_deadlock=False),
            (SmartRequestType.RecvMsg, SmartRequestType.SendMsg):
                ReqFlags(req0_category=ReqCategory.Catch,
                         req1_category=ReqCategory.Throw,
                         req_matched=True,
                         req_conflict=False,
                         req_deadlock=False),
            (SmartRequestType.RecvMsg, SmartRequestType.Resume):
                ReqFlags(req0_category=ReqCategory.Catch,
                         req1_category=ReqCategory.Throw,
                         req_matched=False,
                         req_conflict=False,
                         req_deadlock=False),
            (SmartRequestType.RecvMsg, SmartRequestType.Sync):
                ReqFlags(req0_category=ReqCategory.Catch,
                         req1_category=ReqCategory.Handshake,
                         req_matched=False,
                         req_conflict=False,
                         req_deadlock=False),
            (SmartRequestType.RecvMsg, SmartRequestType.Wait):
                ReqFlags(req0_category=ReqCategory.Catch,
                         req1_category=ReqCategory.Catch,
                         req_matched=False,
                         req_conflict=False,
                         req_deadlock=False),

            (SmartRequestType.Resume, SmartRequestType.SendMsg):
                ReqFlags(req0_category=ReqCategory.Throw,
                         req1_category=ReqCategory.Throw,
                         req_matched=False,
                         req_conflict=False,
                         req_deadlock=False),
            (SmartRequestType.Resume, SmartRequestType.RecvMsg):
                ReqFlags(req0_category=ReqCategory.Throw,
                         req1_category=ReqCategory.Catch,
                         req_matched=False,
                         req_conflict=False,
                         req_deadlock=False),
            (SmartRequestType.Resume, SmartRequestType.Resume):
                ReqFlags(req0_category=ReqCategory.Throw,
                         req1_category=ReqCategory.Throw,
                         req_matched=False,
                         req_conflict=False,
                         req_deadlock=False),
            (SmartRequestType.Resume, SmartRequestType.Sync):
                ReqFlags(req0_category=ReqCategory.Throw,
                         req1_category=ReqCategory.Handshake,
                         req_matched=False,
                         req_conflict=False,
                         req_deadlock=False),
            (SmartRequestType.Resume, SmartRequestType.Wait):
                ReqFlags(req0_category=ReqCategory.Throw,
                         req1_category=ReqCategory.Catch,
                         req_matched=True,
                         req_conflict=False,
                         req_deadlock=False),

            (SmartRequestType.Sync, SmartRequestType.SendMsg):
                ReqFlags(req0_category=ReqCategory.Handshake,
                         req1_category=ReqCategory.Throw,
                         req_matched=False,
                         req_conflict=False,
                         req_deadlock=False),
            (SmartRequestType.Sync, SmartRequestType.RecvMsg):
                ReqFlags(req0_category=ReqCategory.Handshake,
                         req1_category=ReqCategory.Catch,
                         req_matched=False,
                         req_conflict=False,
                         req_deadlock=False),
            (SmartRequestType.Sync, SmartRequestType.Resume):
                ReqFlags(req0_category=ReqCategory.Handshake,
                         req1_category=ReqCategory.Throw,
                         req_matched=False,
                         req_conflict=False,
                         req_deadlock=False),
            (SmartRequestType.Sync, SmartRequestType.Sync):
                ReqFlags(req0_category=ReqCategory.Handshake,
                         req1_category=ReqCategory.Handshake,
                         req_matched=True,
                         req_conflict=False,
                         req_deadlock=False),
            (SmartRequestType.Sync, SmartRequestType.Wait):
                ReqFlags(req0_category=ReqCategory.Handshake,
                         req1_category=ReqCategory.Catch,
                         req_matched=False,
                         req_conflict=True,
                         req_deadlock=False),

            (SmartRequestType.Wait, SmartRequestType.SendMsg):
                ReqFlags(req0_category=ReqCategory.Catch,
                         req1_category=ReqCategory.Throw,
                         req_matched=False,
                         req_conflict=False,
                         req_deadlock=False),
            (SmartRequestType.Wait, SmartRequestType.RecvMsg):
                ReqFlags(req0_category=ReqCategory.Catch,
                         req1_category=ReqCategory.Catch,
                         req_matched=False,
                         req_conflict=False,
                         req_deadlock=False),
            (SmartRequestType.Wait, SmartRequestType.Resume):
                ReqFlags(req0_category=ReqCategory.Catch,
                         req1_category=ReqCategory.Throw,
                         req_matched=True,
                         req_conflict=False,
                         req_deadlock=False),
            (SmartRequestType.Wait, SmartRequestType.Sync):
                ReqFlags(req0_category=ReqCategory.Catch,
                         req1_category=ReqCategory.Handshake,
                         req_matched=False,
                         req_conflict=True,
                         req_deadlock=False),
            (SmartRequestType.Wait, SmartRequestType.Wait):
                ReqFlags(req0_category=ReqCategory.Catch,
                         req1_category=ReqCategory.Catch,
                         req_matched=False,
                         req_conflict=False,
                         req_deadlock=True),
        }

        req_flags = request_table[(req0, req1)]

        self.log_test_msg(f'{req_flags=}')

        if timeout_type == TimeoutType.TimeoutTrue:
            if (req0_when_req1_state[0] == st.ThreadState.Unregistered
                    or req0_when_req1_state[0] == st.ThreadState.Registered):
                if req_flags.req1_category != ReqCategory.Throw:
                    req1_timeout_type = TimeoutType.TimeoutTrue
                else:
                    if req1_lap < req0_when_req1_lap and req_flags.req_matched:
                        supress_req1 = True

            elif req0_when_req1_state[0] == st.ThreadState.Alive:
                if req0_when_req1_lap == req1_lap:
                    if req_flags.req_deadlock:
                        req0_specific_args['deadlock_remotes'] = {req1_name}
                        req1_specific_args['deadlock_remotes'] = {req0_name}
                    elif req_flags.req_conflict:
                        req0_specific_args['conflict_remotes'] = {req1_name}
                        req1_specific_args['conflict_remotes'] = {req0_name}
                    elif req_flags.req0_category == ReqCategory.Throw:
                        timeout_type = TimeoutType.TimeoutNone
                    elif (req_flags.req1_category != ReqCategory.Throw
                          or req_flags.req_matched):
                        supress_req1 = True

                elif req0_when_req1_lap < req1_lap:
                    if req_flags.req0_category == ReqCategory.Throw:
                        timeout_type = TimeoutType.TimeoutNone
                    else:
                        if req_flags.req1_category != ReqCategory.Throw:
                            req1_timeout_type = TimeoutType.TimeoutTrue

                else:  # req1_lap < req0_when_req1_lap
                    if req_flags.req0_category == ReqCategory.Throw:
                        timeout_type = TimeoutType.TimeoutNone
                    else:
                        if req_flags.req_matched:
                            supress_req1 = True
                        elif req_flags.req1_category != ReqCategory.Throw:
                            req1_timeout_type = TimeoutType.TimeoutTrue

        # not an else since we might have cases where timeout_type True
        # was changed to None in the above section
        if timeout_type != TimeoutType.TimeoutTrue:
            if ((req0_when_req1_state[0] == st.ThreadState.Unregistered
                 or req0_when_req1_state[0] == st.ThreadState.Registered)
                    and req0_when_req1_state[1] == 0):
                if req0_when_req1_lap == req1_lap:
                    req0_stopped_remotes = {req1_name}
                    if req_flags.req1_category != ReqCategory.Throw:
                        req1_timeout_type = TimeoutType.TimeoutTrue
                elif req0_when_req1_lap < req1_lap:
                    req0_stopped_remotes = {req1_name}
                    if req_flags.req1_category != ReqCategory.Throw:
                        req1_timeout_type = TimeoutType.TimeoutTrue
                elif req1_lap < req0_when_req1_lap:
                    if req_flags.req1_category != ReqCategory.Throw:
                        req1_timeout_type = TimeoutType.TimeoutTrue
                        req0_stopped_remotes = {req1_name}
                    else:
                        if not req_flags.req_matched:
                            req0_stopped_remotes = {req1_name}

            elif (req0_when_req1_state[0] == st.ThreadState.Unregistered
                  or req0_when_req1_state[0] == st.ThreadState.Registered
                  or req0_when_req1_state[0] == st.ThreadState.Alive):
                if req0_when_req1_lap == req1_lap:
                    if req_flags.req_deadlock:
                        req0_specific_args['deadlock_remotes'] = {req1_name}
                        req1_specific_args['deadlock_remotes'] = {req0_name}
                    elif req_flags.req_conflict:
                        req0_specific_args['conflict_remotes'] = {req1_name}
                        req1_specific_args['conflict_remotes'] = {req0_name}
                    else:
                        if req_flags.req0_category == ReqCategory.Throw:
                            if not req_flags.req_matched:
                                if (req_flags.req1_category !=
                                        ReqCategory.Throw):
                                    req1_timeout_type = TimeoutType.TimeoutTrue
                        else:
                            if not req_flags.req_matched:
                                req0_stopped_remotes = {req1_name}
                                if (req_flags.req1_category
                                        != ReqCategory.Throw):
                                    req1_timeout_type = TimeoutType.TimeoutTrue

                elif req0_when_req1_lap < req1_lap:
                    if req_flags.req0_category == ReqCategory.Throw:
                        if req_flags.req1_category != ReqCategory.Throw:
                            req1_timeout_type = TimeoutType.TimeoutTrue
                    else:
                        req0_stopped_remotes = {req1_name}
                        if req_flags.req1_category != ReqCategory.Throw:
                            req1_timeout_type = TimeoutType.TimeoutTrue

                else:  # req1_lap < req0_when_req1_lap
                    if req_flags.req1_category == ReqCategory.Throw:
                        if not req_flags.req_matched:
                            if req_flags.req0_category != ReqCategory.Throw:
                                req0_stopped_remotes = {req1_name}
                    else:
                        req1_timeout_type = TimeoutType.TimeoutTrue
                        if req_flags.req0_category != ReqCategory.Throw:
                            req0_stopped_remotes = {req1_name}

        if req0_when_req1_state[0] == st.ThreadState.Stopped:
            if req0_when_req1_lap == req1_lap:
                if req_flags.req1_category == ReqCategory.Throw:
                    if not req_flags.req_matched:
                        req0_stopped_remotes = {req1_name}
                    else:
                        if timeout_type == TimeoutType.TimeoutTrue:
                            timeout_type = TimeoutType.TimeoutNone
                else:
                    req1_timeout_type = TimeoutType.TimeoutTrue
                    req0_stopped_remotes = {req1_name}
            elif req0_when_req1_lap < req1_lap:
                req0_stopped_remotes = {req1_name}
                if req_flags.req1_category != ReqCategory.Throw:
                    req1_timeout_type = TimeoutType.TimeoutTrue
            else:  # req1_lap < req0_when_req1_lap
                if req_flags.req1_category == ReqCategory.Throw:
                    if not req_flags.req_matched:
                        req0_stopped_remotes = {req1_name}
                    else:
                        if timeout_type == TimeoutType.TimeoutTrue:
                            timeout_type = TimeoutType.TimeoutNone
                else:
                    # req1_timeout_type = TimeoutType.TimeoutTrue
                    req0_stopped_remotes = {req1_name}

        ################################################################
        # lap loop
        ################################################################
        req0_confirm_parms = RequestConfirmParms(request_name='',
                                                 serial_number=0)
        current_req1_state = st.ThreadState.Unregistered
        reg_iteration = 0
        for lap in range(2):
            ############################################################
            # start loop to advance receiver through the config states
            ############################################################
            for state in (
                    st.ThreadState.Unregistered,
                    st.ThreadState.Registered,
                    st.ThreadState.Unregistered,
                    st.ThreadState.Registered,
                    st.ThreadState.Alive,
                    st.ThreadState.Stopped):
                state_iteration = 0
                ########################################################
                # do join to make receiver unregistered
                ########################################################
                if state == st.ThreadState.Unregistered:
                    if current_req1_state == st.ThreadState.Registered:
                        self.add_cmd(Unregister(
                            cmd_runners=self.commander_name,
                            unregister_targets=req1_name))
                        self.unregistered_names |= {req1_name}
                        state_iteration = 1
                    elif current_req1_state == st.ThreadState.Stopped:
                        # pause to allow req0 to recognize that req1 is
                        # stopped so that it will have time to issue
                        # the raise error log message that the test code
                        # will intercept and use to reset
                        # request_pending in the test code before we
                        # start deleting req1 from the pair_array so
                        # that we determine the correct log messages to
                        # add for log verification
                        if req0_stopped_remotes:
                            self.add_cmd(
                                Pause(cmd_runners=self.commander_name,
                                      pause_seconds=1))
                        self.build_join_suite(
                            cmd_runners=self.commander_name,
                            join_target_names=req1_name,
                            validate_config=False)
                    current_req1_state = st.ThreadState.Unregistered
                ########################################################
                # do create to make receiver registered
                ########################################################
                elif state == st.ThreadState.Registered:
                    state_iteration = reg_iteration % 2
                    reg_iteration += 1
                    self.build_create_suite(
                        f1_create_items=[
                            F1CreateItem(name=req1_name,
                                         auto_start=False,
                                         target_rtn=outer_f1,
                                         app_config=AppConfig.ScriptStyle)],
                        validate_config=False)
                    current_req1_state = st.ThreadState.Registered
                ########################################################
                # do start to make req1 alive
                ########################################################
                elif state == st.ThreadState.Alive:
                    self.build_start_suite(
                        start_names=req1_name,
                        validate_config=False)

                    if req1_lap == lap:
                        if not supress_req1:
                            req1_confirm_parms = request_build_rtns[req1](
                                    timeout_type=req1_timeout_type,
                                    cmd_runner=req1_name,
                                    target=req0_name,
                                    stopped_remotes=req1_stopped_remotes,
                                    request_specific_args=req1_specific_args)
                            self.add_cmd(
                                ConfirmResponse(
                                    cmd_runners=self.commander_name,
                                    confirm_cmd=(
                                        req1_confirm_parms.request_name),
                                    confirm_serial_num=(
                                        req1_confirm_parms.serial_number),
                                    confirmers=req1_name))

                        if supress_req1:  # or not req0_requires_ack:
                            req1_pause_time = 1
                            self.add_cmd(
                                Pause(cmd_runners=self.commander_name,
                                      pause_seconds=req1_pause_time))
                    current_req1_state = st.ThreadState.Alive
                ########################################################
                # do stop to make receiver stopped
                ########################################################
                else:  # state == st.ThreadState.Stopped:
                    self.build_exit_suite(
                        cmd_runner=self.commander_name,
                        names=req1_name,
                        validate_config=False,
                        reset_ops_count=reset_ops_count)
                    current_req1_state = st.ThreadState.Stopped
                ########################################################
                # issue req0
                ########################################################
                if (req0_when_req1_state[0] == state
                        and req0_when_req1_state[1] == state_iteration
                        and req0_when_req1_lap == lap):
                    if timeout_type == TimeoutType.TimeoutTrue:
                        pause_time = 1
                    else:
                        pause_time = 0.5
                    req0_confirm_parms = request_build_rtns[req0](
                        timeout_type=timeout_type,
                        cmd_runner=req0_name,
                        target=req1_name,
                        stopped_remotes=req0_stopped_remotes,
                        request_specific_args=req0_specific_args)

                    self.add_cmd(
                        Pause(cmd_runners=self.commander_name,
                              pause_seconds=pause_time))
        ################################################################
        # finally, confirm req0 is done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=[self.commander_name],
                confirm_cmd=req0_confirm_parms.request_name,
                confirm_serial_num=req0_confirm_parms.serial_number,
                confirmers=req0_name))

    ####################################################################
    # build_send_msg_request
    ####################################################################
    def build_send_msg_request(
            self,
            timeout_type: TimeoutType,
            cmd_runner: str,
            target: str,
            stopped_remotes: set[str],
            request_specific_args: dict[str, Any]) -> RequestConfirmParms:
        """Adds cmds to the cmd queue.

        Args:
            timeout_type: None, False, or True for timeout
            cmd_runner: name of thread that will do the request
            target: name of thread that is the target of the request
            stopped_remotes: names of threads that are expected to be
                detected by the request as stopped
            request_specific_args: specific args for each request

        Returns:
            the name and serial number of the request for confirmation
            purposes

        """
        if timeout_type == TimeoutType.TimeoutNone:
            confirm_request_name = 'SendMsg'
            request_serial_num = self.add_cmd(
                SendMsg(
                    cmd_runners=cmd_runner,
                    receivers=target,
                    msgs_to_send=request_specific_args['sender_msgs'],
                    msg_idx=0,
                    stopped_remotes=stopped_remotes))
        elif timeout_type == TimeoutType.TimeoutFalse:
            confirm_request_name = 'SendMsgTimeoutFalse'
            timeout_time = 6
            request_serial_num = self.add_cmd(
                SendMsgTimeoutFalse(
                    cmd_runners=cmd_runner,
                    receivers=target,
                    msgs_to_send=request_specific_args['sender_msgs'],
                    msg_idx=0,
                    timeout=timeout_time,
                    stopped_remotes=stopped_remotes))
        else:  # timeout_type == TimeoutType.TimeoutTrue
            timeout_time = 0.5
            confirm_request_name = 'SendMsgTimeoutTrue'
            request_serial_num = self.add_cmd(
                SendMsgTimeoutTrue(
                    cmd_runners=cmd_runner,
                    receivers=target,
                    msgs_to_send=request_specific_args['sender_msgs'],
                    msg_idx=0,
                    timeout=timeout_time,
                    unreg_timeout_names=target,
                    fullq_timeout_names=[],
                    stopped_remotes=stopped_remotes))

        return RequestConfirmParms(request_name=confirm_request_name,
                                   serial_number=request_serial_num)

    ####################################################################
    # build_recv_msg_request
    ####################################################################
    def build_recv_msg_request(
            self,
            timeout_type: TimeoutType,
            cmd_runner: str,
            target: str,
            stopped_remotes: set[str],
            request_specific_args: dict[str, Any]) -> RequestConfirmParms:
        """Adds cmds to the cmd queue.

        Args:
            timeout_type: None, False, or True for timeout
            cmd_runner: name of thread that will do the request
            target: name of thread that is the target of the request
            stopped_remotes: names of threads that are expected to be
                detected by the request as stopped
            request_specific_args: specific args for each request

        Returns:
            the name and serial number of the request for confirmation
            purposes

        """
        if timeout_type == TimeoutType.TimeoutNone:
            confirm_request_name = 'RecvMsg'
            request_serial_num = self.add_cmd(
                RecvMsg(
                    cmd_runners=cmd_runner,
                    senders=target,
                    exp_senders=target,
                    exp_msgs=request_specific_args['sender_msgs'],
                    stopped_remotes=stopped_remotes))
        elif timeout_type == TimeoutType.TimeoutFalse:
            confirm_request_name = 'RecvMsgTimeoutFalse'
            timeout_time = 6
            request_serial_num = self.add_cmd(
                RecvMsgTimeoutFalse(
                    cmd_runners=cmd_runner,
                    senders=target,
                    exp_senders=target,
                    exp_msgs=request_specific_args['sender_msgs'],
                    timeout=timeout_time,
                    stopped_remotes=stopped_remotes))
        else:  # timeout_type == TimeoutType.TimeoutTrue
            timeout_time = 0.5
            confirm_request_name = 'RecvMsgTimeoutTrue'
            request_serial_num = self.add_cmd(
                RecvMsgTimeoutTrue(
                    cmd_runners=cmd_runner,
                    senders=target,
                    exp_senders=set(),
                    exp_msgs=request_specific_args['sender_msgs'],
                    timeout=timeout_time,
                    timeout_names=target,
                    stopped_remotes=stopped_remotes))

        return RequestConfirmParms(request_name=confirm_request_name,
                                   serial_number=request_serial_num)

    ####################################################################
    # build_resume_request
    ####################################################################
    def build_resume_request(
            self,
            timeout_type: TimeoutType,
            cmd_runner: str,
            target: str,
            stopped_remotes: set[str],
            request_specific_args: dict[str, Any]) -> RequestConfirmParms:
        """Adds cmds to the cmd queue.

        Args:
            timeout_type: None, False, or True for timeout
            cmd_runner: name of thread that will do the request
            target: name of thread that is the target of the request
            stopped_remotes: names of threads that are expected to be
                detected by the request as stopped
            request_specific_args: specific args for each request

        Returns:
            the name and serial number of the request for confirmation
            purposes

        """
        if timeout_type == TimeoutType.TimeoutNone:
            confirm_request_name = 'Resume'
            request_serial_num = self.add_cmd(
                Resume(
                    cmd_runners=cmd_runner,
                    targets=target,
                    exp_resumed_targets=target,
                    stopped_remotes=stopped_remotes))
        elif timeout_type == TimeoutType.TimeoutFalse:
            confirm_request_name = 'ResumeTimeoutFalse'
            timeout_time = 6
            request_serial_num = self.add_cmd(
                ResumeTimeoutFalse(
                    cmd_runners=cmd_runner,
                    targets=target,
                    exp_resumed_targets=target,
                    timeout=timeout_time,
                    stopped_remotes=stopped_remotes))
        else:  # timeout_type == TimeoutType.TimeoutTrue
            timeout_time = 0.5
            confirm_request_name = 'ResumeTimeoutTrue'
            request_serial_num = self.add_cmd(
                ResumeTimeoutTrue(
                    cmd_runners=cmd_runner,
                    targets=target,
                    exp_resumed_targets=set(),
                    timeout=timeout_time,
                    timeout_names=target,
                    stopped_remotes=stopped_remotes))

        return RequestConfirmParms(request_name=confirm_request_name,
                                   serial_number=request_serial_num)

    ####################################################################
    # build_send_scenario
    ####################################################################
    def build_send_scenario(
            self,
            num_senders: int,
            num_receivers: int,
            num_msgs: int,
            send_type: SendType) -> None:
        """Add cmds to run scenario.

        Args:
            num_senders: number of sender threads
            num_receivers: number of receiver threads
            num_msgs: number of message to send
            send_type: type of send to do

        """
        senders: set[str] = set()
        for idx in range(num_senders):
            senders |= {'sender_' + str(idx)}

        receivers: set[str] = set()
        for idx in range(num_receivers):
            receivers |= {'receiver_' + str(idx)}

        self.create_config(active_names=senders | receivers)

        self.log_name_groups()

        msgs_to_send = SendRecvMsgs(sender_names=senders,
                                    receiver_names=receivers,
                                    num_msgs=num_msgs,
                                    send_type=send_type)

        ############################################################
        # send messages
        ############################################################
        for msg_idx in range(num_msgs):
            send_msg_serial_num = self.add_cmd(SendMsg(
                cmd_runners=senders,
                receivers=receivers,
                msgs_to_send=msgs_to_send,
                msg_idx=msg_idx,
                send_type=send_type))
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd='SendMsg',
                    confirm_serial_num=send_msg_serial_num,
                    confirmers=senders))

        ############################################################
        # receive messages
        ############################################################
        recv_msg_serial_num = self.add_cmd(RecvMsg(
            cmd_runners=receivers,
            senders=senders,
            exp_senders=senders,
            exp_msgs=msgs_to_send))
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd='RecvMsg',
                confirm_serial_num=recv_msg_serial_num,
                confirmers=receivers))

    ####################################################################
    # build_recv_basic_scenario
    ####################################################################
    def build_recv_basic_scenario(
            self,
            num_senders: int,
            num_msgs: int,
            sender_count: int,
            recv_type: RecvType) -> None:
        """Add cmds to run scenario.

        Args:
            num_senders: number of senders
            num_msgs: number of message to send
            sender_count: number of senders needed to satisfy smart_recv
            recv_type: type of recv to do

        """
        senders: set[str] = set()
        for idx in range(num_senders):
            senders |= {'sender_' + str(idx)}

        non_senders: set[str] = set()
        for idx in range(3):
            non_senders |= {'non_sender_' + str(idx)}

        receiver = 'receiver_1'

        self.create_config(
            active_names=senders | non_senders | {receiver})

        self.log_name_groups()

        # build msgs for non_senders since we might have no senders
        msgs_to_send = SendRecvMsgs(sender_names=senders | non_senders,
                                    receiver_names=receiver,
                                    num_msgs=num_msgs)

        recv_senders: set[str] = set()
        if recv_type == RecvType.PartialSenders:
            num_recv_senders = len(senders) // 2
        elif recv_type == RecvType.MatchSenders:
            num_recv_senders = len(senders)
        elif recv_type == RecvType.ExtraSenders:
            num_recv_senders = len(senders)
            recv_senders |= non_senders
        else:  # recv_type == RecvType.UnmatchSenders:
            num_recv_senders = 0
            recv_senders |= non_senders

        for idx, sender_name in enumerate(senders):
            if num_recv_senders <= idx:
                break
            recv_senders |= {sender_name}

        # make sure we have a non-empty set for smart_recv in case
        # num_senders is zero or too small for PartialResumers to get
        # at least 1 sender
        if not recv_senders:
            recv_senders |= non_senders
        exp_senders: set[str] = senders & recv_senders

        recv_sender_count: Optional[int] = None
        if sender_count > 0:  # if we want sender_count
            # make sure we specify a legal value
            recv_sender_count = min(sender_count, len(recv_senders))

        ################################################################
        # send messages
        ################################################################
        if senders:
            for msg_idx in range(num_msgs):
                send_msg_serial_num = self.add_cmd(SendMsg(
                    cmd_runners=senders,
                    receivers=receiver,
                    msgs_to_send=msgs_to_send,
                    msg_idx=msg_idx,
                    send_type=SendType.ToRemotes))
                self.add_cmd(
                    ConfirmResponse(
                        cmd_runners=self.commander_name,
                        confirm_cmd='SendMsg',
                        confirm_serial_num=send_msg_serial_num,
                        confirmers=senders))

        ################################################################
        # receive messages
        ################################################################
        timeout: int = 0
        timeout_remotes: set[str] = (recv_senders - exp_senders)
        if exp_senders:
            if recv_sender_count:
                if len(exp_senders) < recv_sender_count:
                    timeout = 1
            else:
                if recv_senders != exp_senders:
                    timeout = 1
        else:
            timeout = 1

        if timeout == 0:
            recv_msg_serial_num = self.add_cmd(RecvMsg(
                cmd_runners=receiver,
                senders=recv_senders,
                exp_senders=exp_senders,
                sender_count=recv_sender_count,
                exp_msgs=msgs_to_send))
        else:
            recv_msg_serial_num = self.add_cmd(RecvMsgTimeoutTrue(
                cmd_runners=receiver,
                senders=recv_senders,
                exp_senders=set(),
                sender_count=recv_sender_count,
                timeout=1,
                timeout_names=recv_senders,
                exp_msgs=msgs_to_send))
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd='RecvMsg',
                confirm_serial_num=recv_msg_serial_num,
                confirmers=receiver))

    ####################################################################
    # build_resume_basic_scenario
    ####################################################################
    def build_resume_basic_scenario(
            self,
            num_resumers: int,
            num_waiters: int) -> None:
        """Add cmds to run scenario.

        Args:
            num_resumers: number of resumer threads
            num_waiters: number of waiter threads

        """
        resumers: set[str] = set()
        for idx in range(num_resumers):
            resumers |= {'resumer_' + str(idx)}

        waiters: set[str] = set()
        for idx in range(num_waiters):
            waiters |= {'waiter_' + str(idx)}

        self.create_config(active_names=resumers | waiters)

        self.log_name_groups()

        ################################################################
        # resume
        ################################################################
        resume_serial_num = self.add_cmd(Resume(
            cmd_runners=resumers,
            targets=waiters,
            exp_resumed_targets=waiters))

        ################################################################
        # receive messages
        ################################################################
        wait_serial_num = self.add_cmd(Wait(
            cmd_runners=waiters,
            resumers=resumers,
            exp_resumers=resumers))

        ################################################################
        # confirm response
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd='Resume',
                confirm_serial_num=resume_serial_num,
                confirmers=resumers))

        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd='Wait',
                confirm_serial_num=wait_serial_num,
                confirmers=waiters))

    ####################################################################
    # build_wait_basic_scenario
    ####################################################################
    def build_wait_basic_scenario(
            self,
            num_resumers: int,
            resumer_count: int,
            wait_type: RecvType) -> None:
        """Add cmds to run scenario.

        Args:
            num_resumers: number of resumers beyond what is
                required for the wait_type_arg
            resumer_count: resumer_count specification for smart_wait
            wait_type: type of wait to do

        """
        resumers: set[str] = set()
        for idx in range(num_resumers):
            resumers |= {'resume_' + str(idx)}

        non_resumers: set[str] = set()
        for idx in range(3):
            non_resumers |= {'non_resumer_' + str(idx)}

        waiter = 'waiter_1'

        self.create_config(
            active_names=resumers | non_resumers | {waiter})

        self.log_name_groups()

        wait_resumers: set[str] = set()
        if wait_type == WaitType.PartialResumers:
            num_wait_resumers = len(resumers) // 2
        elif wait_type == WaitType.MatchResumers:
            num_wait_resumers = len(resumers)
        elif wait_type == WaitType.ExtraResumers:
            num_wait_resumers = len(resumers)
            wait_resumers |= non_resumers
        else:  # wait_type == WaitType.UnmatchResumers:
            num_wait_resumers = 0
            wait_resumers |= non_resumers

        for idx, resumer_name in enumerate(resumers):
            if num_wait_resumers <= idx:
                break
            wait_resumers |= {resumer_name}

        # make sure we have a non-empty set for smart_wait in case
        # num_resumers is zero or too small for PartialResumers to get
        # at least 1 resumer
        if not wait_resumers:
            wait_resumers |= non_resumers
        exp_resumers: set[str] = resumers & wait_resumers

        wait_resumer_count: Optional[int] = None
        if resumer_count > 0:  # if we want resumer_count
            # make sure we specify a legal value
            wait_resumer_count = min(resumer_count, len(wait_resumers))

        ################################################################
        # resume
        ################################################################
        if resumers:
            resume_serial_num = self.add_cmd(Resume(
                cmd_runners=resumers,
                targets=waiter,
                exp_resumed_targets=waiter))

            ############################################################
            # confirm resumes are done
            ############################################################
            self.add_cmd(
                ConfirmResponse(
                    cmd_runners=self.commander_name,
                    confirm_cmd='Resume',
                    confirm_serial_num=resume_serial_num,
                    confirmers=resumers))

        ################################################################
        # wait
        ################################################################
        timeout: int = 0
        timeout_remotes: set[str] = (wait_resumers - exp_resumers)
        if exp_resumers:
            if wait_resumer_count:
                if len(exp_resumers) < wait_resumer_count:
                    timeout = 1
            else:
                if wait_resumers != exp_resumers:
                    timeout = 1
        else:
            timeout = 1

        if timeout == 0:
            cmd_to_confirm = 'Wait'
            wait_serial_num = self.add_cmd(Wait(
                cmd_runners=waiter,
                resumers=wait_resumers,
                resumer_count=wait_resumer_count,
                exp_resumers=exp_resumers))
        else:
            cmd_to_confirm = 'WaitTimeoutTrue'
            wait_serial_num = self.add_cmd(WaitTimeoutTrue(
                cmd_runners=waiter,
                resumers=wait_resumers,
                resumer_count=wait_resumer_count,
                exp_resumers=exp_resumers,
                timeout=1,
                timeout_remotes=timeout_remotes))

        ################################################################
        # confirm waits are done
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd=cmd_to_confirm,
                confirm_serial_num=wait_serial_num,
                confirmers=waiter))

    ####################################################################
    # build_sync_basic_scenario
    ####################################################################
    def build_sync_basic_scenario(
            self,
            num_syncers: int,
            num_extras: int) -> None:
        """Add cmds to run scenario.

        Args:
            num_syncers: number of threads doing sync
            num_extras: number of extra threads not involved in the
                sync request

        """
        syncers: set[str] = set()
        for idx in range(num_syncers):
            syncers |= {'syncer_' + str(idx)}

        extras: set[str] = set()
        for idx in range(num_extras):
            extras |= {'extra_' + str(idx)}

        self.create_config(active_names=syncers | extras)

        self.log_name_groups()

        ################################################################
        # resume
        ################################################################
        sync_serial_num = self.add_cmd(Sync(
            cmd_runners=syncers,
            targets=syncers))

        ################################################################
        # confirm response
        ################################################################
        self.add_cmd(
            ConfirmResponse(
                cmd_runners=self.commander_name,
                confirm_cmd='Sync',
                confirm_serial_num=sync_serial_num,
                confirmers=syncers))

    ####################################################################
    # build_sync_request
    ####################################################################
    def build_sync_request(
            self,
            timeout_type: TimeoutType,
            cmd_runner: str,
            target: str,
            stopped_remotes: set[str],
            request_specific_args: dict[str, Any]) -> RequestConfirmParms:
        """Adds cmds to the cmd queue.

        Args:
            timeout_type: None, False, or True for timeout
            cmd_runner: name of thread that will do the request
            target: name of thread that is the target of the request
            stopped_remotes: names of threads that are expected to be
                detected by the request as stopped
            request_specific_args: specific args for each request

        Returns:
            the name and serial number of the request for confirmation
            purposes

        """
        if timeout_type == TimeoutType.TimeoutNone:
            confirm_request_name = 'Sync'
            request_serial_num = self.add_cmd(
                Sync(
                    cmd_runners=cmd_runner,
                    targets=target,
                    stopped_remotes=stopped_remotes,
                    conflict_remotes=request_specific_args['conflict_remotes']
                ))
        elif timeout_type == TimeoutType.TimeoutFalse:
            confirm_request_name = 'SyncTimeoutFalse'
            timeout_time = 6
            request_serial_num = self.add_cmd(
                SyncTimeoutFalse(
                    cmd_runners=cmd_runner,
                    targets=target,
                    timeout=timeout_time,
                    stopped_remotes=stopped_remotes,
                    conflict_remotes=request_specific_args['conflict_remotes']
                ))
        else:  # timeout_type == TimeoutType.TimeoutTrue
            timeout_time = 0.5
            confirm_request_name = 'SyncTimeoutTrue'
            request_serial_num = self.add_cmd(
                SyncTimeoutTrue(
                    cmd_runners=cmd_runner,
                    targets=target,
                    timeout=timeout_time,
                    timeout_remotes=target,
                    stopped_remotes=stopped_remotes,
                    conflict_remotes=request_specific_args['conflict_remotes']
                ))

        return RequestConfirmParms(request_name=confirm_request_name,
                                   serial_number=request_serial_num)

    ####################################################################
    # build_wait_request
    ####################################################################
    def build_wait_request(
            self,
            timeout_type: TimeoutType,
            cmd_runner: str,
            target: str,
            stopped_remotes: set[str],
            request_specific_args: dict[str, Any]) -> RequestConfirmParms:
        """Adds cmds to the cmd queue.

        Args:
            timeout_type: None, False, or True for timeout
            cmd_runner: name of thread that will do the request
            target: name of thread that is the target of the request
            stopped_remotes: names of threads that are expected to be
                detected by the request as stopped
            request_specific_args: specific args for each request

        Returns:
            the name and serial number of the request for confirmation
            purposes

        """
        if timeout_type == TimeoutType.TimeoutNone:
            confirm_request_name = 'Wait'
            request_serial_num = self.add_cmd(
                Wait(
                    cmd_runners=cmd_runner,
                    resumers=target,
                    stopped_remotes=stopped_remotes,
                    conflict_remotes=request_specific_args['conflict_remotes'],
                    deadlock_remotes=request_specific_args['deadlock_remotes']
                ))
        elif timeout_type == TimeoutType.TimeoutFalse:
            confirm_request_name = 'WaitTimeoutFalse'
            timeout_time = 6
            request_serial_num = self.add_cmd(
                WaitTimeoutFalse(
                    cmd_runners=cmd_runner,
                    resumers=target,
                    timeout=timeout_time,
                    stopped_remotes=stopped_remotes,
                    conflict_remotes=request_specific_args['conflict_remotes'],
                    deadlock_remotes=request_specific_args['deadlock_remotes']
                ))
        else:  # timeout_type == TimeoutType.TimeoutTrue
            timeout_time = 0.5
            confirm_request_name = 'WaitTimeoutTrue'
            request_serial_num = self.add_cmd(
                WaitTimeoutTrue(
                    cmd_runners=cmd_runner,
                    resumers=target,
                    timeout=timeout_time,
                    timeout_remotes=target,
                    stopped_remotes=stopped_remotes,
                    conflict_remotes=request_specific_args['conflict_remotes'],
                    deadlock_remotes=request_specific_args['deadlock_remotes']
                ))

        return RequestConfirmParms(request_name=confirm_request_name,
                                   serial_number=request_serial_num)

    ####################################################################
    # build_msg_timeout_suite
    ####################################################################
    def build_send_msg_timeout_suite(self,
                                     timeout_type: TimeoutType,
                                     num_senders: Optional[int] = 1,
                                     num_active_targets: Optional[int] = 1,
                                     num_registered_targets: Optional[int] = 0,
                                     num_unreg_timeouts: Optional[int] = 0,
                                     num_exit_timeouts: Optional[int] = 1,
                                     num_full_q_timeouts: Optional[int] = 0
                                     ) -> None:
        """Return a list of ConfigCmd items for a msg timeout.

        Args:
            timeout_type: specifies whether to issue the send_cmd with
                timeout, and is so whether the send_cmd should timeout
                or, by starting exited threads in time, not timeout
            num_senders: specifies number of threads that will send msg
            num_active_targets: specifies number of threads to receive
                the msg,
                including those that are registered only or expected to
                cause the timeout
            num_registered_targets: specifies the number of targets that
                should be registered only (i.e., not yet started)
            num_unreg_timeouts: specifies the number of threads that
                should cause timeout by being unregistered
            num_exit_timeouts: specifies the number of threads that
                should be exited and joined to cause timeout
            num_full_q_timeouts: specifies the number of threads that
                should cause timeout by having a full msg queue

        """
        # Make sure we have enough threads
        assert (num_senders
                + num_active_targets
                + num_registered_targets
                + num_unreg_timeouts
                + num_exit_timeouts
                + num_full_q_timeouts) <= len(self.unregistered_names)

        assert num_senders > 0

        # for the exit timeout case, we send zero msgs for the first
        # thread, then 1 for the second thread, 2 for the third, etc.,
        # so we need to make sure we don't exceed the max number of
        # messages that can be received
        assert num_exit_timeouts < self.max_msgs

        num_active_needed = (
                num_senders
                + num_active_targets
                + num_exit_timeouts
                + num_full_q_timeouts
                + 1)

        timeout_time = ((num_active_targets * 0.16)
                        + (num_registered_targets * 0.16)
                        + (num_unreg_timeouts * 0.50)
                        + (num_exit_timeouts * 0.50)
                        + (num_full_q_timeouts * 0.25 * self.max_msgs))

        if timeout_type == TimeoutType.TimeoutFalse:
            timeout_time *= 2  # prevent timeout
            timeout_time = max(timeout_time, 1)
        elif timeout_type == TimeoutType.TimeoutTrue:
            timeout_time *= 0.5  # force timeout

        self.build_config(
            cmd_runner=self.commander_name,
            num_registered=num_registered_targets,
            num_active=num_active_needed)

        self.log_name_groups()

        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose sender_names
        ################################################################
        sender_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_senders,
            update_collection=True,
            var_name_for_log='sender_names')

        ################################################################
        # choose active_target_names
        ################################################################
        active_target_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_active_targets,
            update_collection=True,
            var_name_for_log='active_target_names')

        ################################################################
        # choose registered_target_names
        ################################################################
        registered_target_names = self.choose_names(
            name_collection=self.registered_names,
            num_names_needed=num_registered_targets,
            update_collection=False,
            var_name_for_log='registered_target_names')

        ################################################################
        # choose unreg_timeout_names
        ################################################################
        unreg_timeout_names = self.choose_names(
            name_collection=self.unregistered_names,
            num_names_needed=num_unreg_timeouts,
            update_collection=False,
            var_name_for_log='unreg_timeout_names')

        ################################################################
        # choose exit_names
        ################################################################
        exit_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_exit_timeouts,
            update_collection=True,
            var_name_for_log='exit_names')

        ################################################################
        # choose full_q_names
        ################################################################
        full_q_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_full_q_timeouts,
            update_collection=True,
            var_name_for_log='full_q_names')

        ################################################################
        # send msgs to senders so we have some on their queues so we
        # can verify partially paired for any threads that are exited
        ################################################################
        ################################################################
        # setup the messages to send
        ################################################################
        all_targets: list[str] = (active_target_names
                                  + registered_target_names
                                  + unreg_timeout_names
                                  + exit_names
                                  + full_q_names)

        sender_msgs = SendRecvMsgs(
            sender_names=sender_names,
            receiver_names=all_targets,
            num_msgs=1,
            send_type=SendType.ToRemotes)

        sender_1_msg_1 = SendRecvMsgs(
            sender_names=exit_names,
            receiver_names=sender_names[1],
            num_msgs=1,
            send_type=SendType.ToRemotes)
        if exit_names and num_senders >= 2:
            for exit_name in exit_names:
                log_msg = f'log test: {get_ptime()}'

                send_msg_serial_num = self.add_cmd(
                    SendMsg(cmd_runners=exit_name,
                            receivers=sender_names[1],
                            msgs_to_send=sender_1_msg_1,
                            msg_idx=0,
                            log_msg=log_msg))

                ########################################################
                # confirm the smart_send
                ########################################################
                self.add_cmd(
                    ConfirmResponse(cmd_runners=self.commander_name,
                                    confirm_cmd='SendMsg',
                                    confirm_serial_num=send_msg_serial_num,
                                    confirmers=[exit_name]))

        sender_2_msg_1 = SendRecvMsgs(
            sender_names=exit_names,
            receiver_names=sender_names[2],
            num_msgs=1,
            send_type=SendType.ToRemotes)

        sender_2_msg_2 = SendRecvMsgs(
            sender_names=exit_names,
            receiver_names=sender_names[2],
            num_msgs=1,
            send_type=SendType.ToRemotes)

        if exit_names and num_senders == 3:
            for exit_name in exit_names:
                send_msg_serial_num = self.add_cmd(
                    SendMsg(cmd_runners=exit_name,
                            receivers=sender_names[2],
                            msgs_to_send=sender_2_msg_1,
                            msg_idx=0))

                ########################################################
                # confirm the smart_send
                ########################################################
                self.add_cmd(
                    ConfirmResponse(cmd_runners=[self.commander_name],
                                    confirm_cmd='SendMsg',
                                    confirm_serial_num=send_msg_serial_num,
                                    confirmers=[exit_name]))

                log_msg = f'log test: {get_ptime()}'

                send_msg_serial_num = self.add_cmd(
                    SendMsg(cmd_runners=exit_name,
                            receivers=sender_names[2],
                            msgs_to_send=sender_2_msg_2,
                            msg_idx=0,
                            log_msg=log_msg))

                ########################################################
                # confirm the smart_send
                ########################################################
                self.add_cmd(
                    ConfirmResponse(cmd_runners=[self.commander_name],
                                    confirm_cmd='SendMsg',
                                    confirm_serial_num=send_msg_serial_num,
                                    confirmers=[exit_name]))

        ################################################################
        # send max msgs if needed
        ################################################################
        if full_q_names:
            for idx in range(self.max_msgs):
                # send from each sender thread to ensure we get
                # exactly max_msgs on each pair between sender and the
                # full_q receivers
                send_msg_serial_num = self.add_cmd(
                    SendMsg(cmd_runners=sender_names,
                            receivers=full_q_names,
                            msgs_to_send=sender_msgs,
                            msg_idx=0))

                ########################################################
                # confirm the smart_send
                ########################################################
                self.add_cmd(
                    ConfirmResponse(cmd_runners=[self.commander_name],
                                    confirm_cmd='SendMsg',
                                    confirm_serial_num=send_msg_serial_num,
                                    confirmers=sender_names))

        ################################################################
        # build exit and join suites for the exit names
        ################################################################
        if exit_names:
            for idx in range(1, num_exit_timeouts):
                # the idea here is to have the first exit_name have zero
                # msgs, the second will have 1 msg, etc, etc, etc...
                for num_msgs in range(idx):
                    log_msg = f'log test: {get_ptime()}'
                    send_msg_serial_num = self.add_cmd(
                        SendMsg(cmd_runners=sender_names,
                                receivers=exit_names[idx],
                                msgs_to_send=sender_msgs,
                                msg_idx=0,
                                log_msg=log_msg))

                    ####################################################
                    # confirm the smart_send
                    ####################################################
                    self.add_cmd(
                        ConfirmResponse(cmd_runners=[self.commander_name],
                                        confirm_cmd='SendMsg',
                                        confirm_serial_num=send_msg_serial_num,
                                        confirmers=sender_names))

            self.build_exit_suite(cmd_runner=self.commander_name,
                                  names=exit_names)
            self.build_join_suite(
                cmd_runners=self.commander_name,
                join_target_names=exit_names)

            for exit_name in exit_names:
                # self.add_cmd(VerifyPairedNot(
                #     cmd_runners=self.commander_name,
                #     exp_not_paired_names=[exit_name, sender_names[0]]))
                self.add_cmd(VerifyConfig(
                    cmd_runners=self.commander_name,
                    verify_type=VerifyType.VerifyNotPaired,
                    names_to_check=[exit_name, sender_names[0]]))

            if num_senders >= 2:
                for exit_name in exit_names:
                    # self.add_cmd(VerifyPairedHalf(
                    #     cmd_runners=self.commander_name,
                    #     removed_names=exit_name,
                    #     exp_half_paired_names=sender_names[1]))
                    self.add_cmd(VerifyConfig(
                        cmd_runners=self.commander_name,
                        verify_type=VerifyType.VerifyHalfPaired,
                        names_to_check=sender_names[1],
                        aux_names=exit_name))

            if num_senders == 3:
                for exit_name in exit_names:
                    # self.add_cmd(VerifyPairedHalf(
                    #     cmd_runners=self.commander_name,
                    #     removed_names=exit_name,
                    #     exp_half_paired_names=sender_names[2]))
                    self.add_cmd(VerifyConfig(
                        cmd_runners=self.commander_name,
                        verify_type=VerifyType.VerifyHalfPaired,
                        names_to_check=sender_names[2],
                        aux_names=exit_name))

        if timeout_type == TimeoutType.TimeoutTrue:
            send_msg_serial_num = self.add_cmd(
                SendMsgTimeoutTrue(
                    cmd_runners=sender_names,
                    receivers=all_targets,
                    msgs_to_send=sender_msgs,
                    msg_idx=0,
                    timeout=timeout_time,
                    unreg_timeout_names=unreg_timeout_names+exit_names,
                    fullq_timeout_names=full_q_names))

            confirm_cmd_to_use = 'SendMsgTimeoutTrue'
            final_recv_names = active_target_names + registered_target_names
        else:
            if timeout_type == TimeoutType.TimeoutFalse:
                send_msg_serial_num = self.add_cmd(
                    SendMsgTimeoutFalse(
                        cmd_runners=sender_names,
                        receivers=all_targets,
                        msgs_to_send=sender_msgs,
                        msg_idx=0,
                        timeout=timeout_time))

                confirm_cmd_to_use = 'SendMsgTimeoutFalse'
            else:
                send_msg_serial_num = self.add_cmd(
                    SendMsg(cmd_runners=sender_names,
                            receivers=all_targets,
                            msgs_to_send=sender_msgs,
                            msg_idx=0))
                confirm_cmd_to_use = 'SendMsg'

            self.add_cmd(WaitForRequestTimeouts(
                cmd_runners=self.commander_name,
                actor_names=sender_names,
                timeout_names=unreg_timeout_names + exit_names))

            # restore config by adding back the exited threads and
            # creating the un_reg threads so smart_send will complete
            # before timing out
            if unreg_timeout_names or exit_names:
                f1_create_items: list[F1CreateItem] = []
                for idx, name in enumerate(unreg_timeout_names + exit_names):
                    if idx % 2:
                        app_config = AppConfig.ScriptStyle
                    else:
                        app_config = AppConfig.RemoteThreadApp

                    f1_create_items.append(F1CreateItem(name=name,
                                                        auto_start=True,
                                                        target_rtn=outer_f1,
                                                        app_config=app_config))
                self.build_create_suite(
                    f1_create_items=f1_create_items,
                    validate_config=False)

            # tell the fullq threads to read the stacked up msgs
            # so that the smart_send will complete
            if full_q_names:
                for idx in range(self.max_msgs):
                    self.add_cmd(
                        RecvMsg(cmd_runners=full_q_names,
                                senders=sender_names,
                                exp_senders=sender_names,
                                exp_msgs=sender_msgs))

            final_recv_names = all_targets

        ################################################################
        # confirm the smart_send
        ################################################################
        self.add_cmd(
            ConfirmResponse(cmd_runners=[self.commander_name],
                            confirm_cmd=confirm_cmd_to_use,
                            confirm_serial_num=send_msg_serial_num,
                            confirmers=sender_names))

        # start any registered threads
        if registered_target_names:
            self.build_start_suite(start_names=registered_target_names)

        # do RecvMsg to verify the SendMsg for receivers
        if final_recv_names:
            log_msg = f'log test: {get_ptime()}'
            recv_msg_serial_num = self.add_cmd(
                RecvMsg(cmd_runners=final_recv_names,
                        senders=sender_names,
                        exp_senders=sender_names,
                        exp_msgs=sender_msgs,
                        log_msg=log_msg))

            ############################################################
            # confirm the smart_recv
            ############################################################
            self.add_cmd(
                ConfirmResponse(cmd_runners=[self.commander_name],
                                confirm_cmd='RecvMsg',
                                confirm_serial_num=recv_msg_serial_num,
                                confirmers=final_recv_names))

        ################################################################
        # do RecvMsg to verify the SendMsg for senders
        ################################################################
        if exit_names:
            if num_senders >= 2:
                for exit_name in exit_names:
                    recv_msg_serial_num = self.add_cmd(
                        RecvMsg(cmd_runners=sender_names[1],
                                senders=exit_name,
                                exp_senders=exit_name,
                                exp_msgs=sender_1_msg_1))

                    ####################################################
                    # confirm the smart_recv
                    ####################################################
                    self.add_cmd(
                        ConfirmResponse(cmd_runners=[self.commander_name],
                                        confirm_cmd='RecvMsg',
                                        confirm_serial_num=recv_msg_serial_num,
                                        confirmers=[sender_names[1]]))

            if num_senders == 3:
                for exit_name in exit_names:
                    recv_msg_serial_num = self.add_cmd(
                        RecvMsg(cmd_runners=sender_names[2],
                                senders=exit_name,
                                exp_senders=exit_name,
                                exp_msgs=sender_2_msg_1))

                    ####################################################
                    # confirm the smart_recv
                    ####################################################
                    self.add_cmd(
                        ConfirmResponse(cmd_runners=[self.commander_name],
                                        confirm_cmd='RecvMsg',
                                        confirm_serial_num=recv_msg_serial_num,
                                        confirmers=[sender_names[2]]))

                    recv_msg_serial_num = self.add_cmd(
                        RecvMsg(cmd_runners=sender_names[2],
                                senders=exit_name,
                                exp_senders=exit_name,
                                exp_msgs=sender_2_msg_2))

                    ####################################################
                    # confirm the smart_recv
                    ####################################################
                    self.add_cmd(
                        ConfirmResponse(cmd_runners=[self.commander_name],
                                        confirm_cmd='RecvMsg',
                                        confirm_serial_num=recv_msg_serial_num,
                                        confirmers=[sender_names[2]]))

            # exit the exit names again after senders have read their
            # pending messages, and then verify exit names and senders
            # are no longer paired
            if timeout_type != TimeoutType.TimeoutTrue:
                self.build_exit_suite(cmd_runner=self.commander_name,
                                      names=exit_names)
                self.build_join_suite(
                    cmd_runners=self.commander_name,
                    join_target_names=exit_names)

            for sender_name in sender_names:
                exp_not_paired = [sender_name] + exit_names
                # self.add_cmd(VerifyPairedNot(
                #     cmd_runners=self.commander_name,
                #     exp_not_paired_names=exp_not_paired))
                self.add_cmd(VerifyConfig(
                    cmd_runners=self.commander_name,
                    verify_type=VerifyType.VerifyNotPaired,
                    names_to_check=exp_not_paired))

    ####################################################################
    # build_simple_scenario
    ####################################################################

    def build_simple_scenario(self) -> None:
        """Add config cmds to the scenario queue."""

        # self.add_cmd(ValidateConfig(
        #     cmd_runners='alpha'))
        self.add_cmd(VerifyConfig(
            cmd_runners='alpha',
            verify_type=VerifyType.VerifyStructures))
        self.add_cmd(CreateF1AutoStart(
            cmd_runners='alpha',
            f1_create_items=[
                F1CreateItem(name='beta',
                             auto_start=True,
                             target_rtn=outer_f1),
                F1CreateItem(name='charlie',
                             auto_start=True,
                             target_rtn=outer_f1,
                             app_config=AppConfig.RemoteThreadApp)
            ]))
        self.add_cmd(Pause(
            cmd_runners='alpha',
            pause_seconds=0.5))
        self.add_cmd(CreateF1NoStart(
            cmd_runners='alpha',
            f1_create_items=[
                F1CreateItem(name='delta',
                             auto_start=False,
                             target_rtn=outer_f1,
                             app_config=AppConfig.ScriptStyle),
                F1CreateItem(name='echo',
                             auto_start=False,
                             target_rtn=outer_f1,
                             app_config=AppConfig.RemoteThreadApp),
                F1CreateItem(name='fox',
                             auto_start=False,
                             target_rtn=outer_f1,
                             app_config=AppConfig.ScriptStyle),
                F1CreateItem(name='george',
                             auto_start=False,
                             target_rtn=outer_f1,
                             app_config=AppConfig.RemoteThreadApp)
            ]))
        # self.add_cmd(VerifyInRegistry(
        #     cmd_runners='alpha',
        #     exp_in_registry_names=['alpha', 'beta', 'charlie', 'delta',
        #                            'echo', 'fox', 'george']))
        self.add_cmd(VerifyConfig(
            cmd_runners='alpha',
            verify_type=VerifyType.VerifyInRegistry,
            names_to_check=['alpha', 'beta', 'charlie', 'delta', 'echo',
                            'fox', 'george']))
        # self.add_cmd(VerifyAlive(
        #     cmd_runners='alpha',
        #     exp_alive_names=['alpha', 'beta', 'charlie']))
        self.add_cmd(VerifyConfig(cmd_runners='alpha',
                                  verify_type=VerifyType.VerifyAlive,
                                  names_to_check=['alpha', 'beta', 'charlie']))
        # self.add_cmd(VerifyAliveNot(
        #     cmd_runners='alpha',
        #     exp_not_alive_names=['delta', 'echo', 'fox', 'george']))
        self.add_cmd(VerifyConfig(
            cmd_runners='alpha',
            verify_type=VerifyType.VerifyNotAlive,
            names_to_check=['delta', 'echo', 'fox', 'george']))
        # self.add_cmd(VerifyActive(
        #     cmd_runners='alpha',
        #     exp_active_names=['alpha', 'beta', 'charlie']))
        self.add_cmd(VerifyConfig(
            cmd_runners='alpha',
            verify_type=VerifyType.VerifyAliveState,
            names_to_check=['alpha', 'beta', 'charlie']))
        # self.add_cmd(VerifyRegistered(
        #     cmd_runners='alpha',
        #     exp_registered_names=['delta', 'echo', 'fox', 'george']))
        self.add_cmd(VerifyConfig(
            cmd_runners='alpha',
            verify_type=VerifyType.VerifyRegisteredState,
            names_to_check=['delta', 'echo', 'fox', 'george']))
        # self.add_cmd(VerifyState(
        #     cmd_runners='alpha',
        #     check_state_names=['alpha', 'beta', 'charlie'],
        #     expected_state=st.ThreadState.Alive))
        self.add_cmd(VerifyConfig(cmd_runners='alpha',
                                  verify_type=VerifyType.VerifyState,
                                  names_to_check=['alpha', 'beta', 'charlie'],
                                  state_to_check=st.ThreadState.Alive))
        # self.add_cmd(VerifyState(
        #     cmd_runners='alpha',
        #     check_state_names=['delta', 'echo', 'fox', 'george'],
        #     expected_state=st.ThreadState.Registered))
        self.add_cmd(VerifyConfig(
            cmd_runners='alpha',
            verify_type=VerifyType.VerifyState,
            names_to_check=['delta', 'echo', 'fox', 'george'],
            state_to_check=st.ThreadState.Registered))
        # self.add_cmd(VerifyPaired(
        #     cmd_runners='alpha',
        #     exp_paired_names=['alpha', 'beta', 'charlie', 'delta', 'echo',
        #                       'fox', 'george']))
        self.add_cmd(VerifyConfig(
            cmd_runners='alpha',
            verify_type=VerifyType.VerifyPaired,
            names_to_check=['alpha', 'beta', 'charlie', 'delta', 'echo',
                            'fox', 'george']))
        self.add_cmd(StartThread(
            cmd_runners='alpha',
            start_names=['delta', 'echo']))
        # self.add_cmd(VerifyAlive(
        #     cmd_runners='alpha',
        #     exp_alive_names=['alpha', 'beta', 'charlie', 'delta', 'echo']))
        self.add_cmd(VerifyConfig(
            cmd_runners='alpha',
            verify_type=VerifyType.VerifyAlive,
            names_to_check=['alpha', 'beta', 'charlie', 'delta', 'echo']))
        # self.add_cmd(VerifyActive(
        #     cmd_runners='alpha',
        #     exp_active_names=['alpha', 'beta', 'charlie', 'delta', 'echo']))
        self.add_cmd(VerifyConfig(
            cmd_runners='alpha',
            verify_type=VerifyType.VerifyAliveState,
            names_to_check=['alpha', 'beta', 'charlie', 'delta', 'echo']))
        # self.add_cmd(VerifyState(
        #     cmd_runners='alpha',
        #     check_state_names=['alpha', 'beta', 'charlie', 'delta', 'echo'],
        #     expected_state=st.ThreadState.Alive))
        self.add_cmd(VerifyConfig(
            cmd_runners='alpha',
            verify_type=VerifyType.VerifyState,
            names_to_check=['alpha', 'beta', 'charlie', 'delta', 'echo'],
            state_to_check=st.ThreadState.Alive))
        # self.add_cmd(ValidateConfig(
        #     cmd_runners='alpha'))
        self.add_cmd(VerifyConfig(
            cmd_runners='alpha',
            verify_type=VerifyType.VerifyStructures))
        ################################################################
        # smart_send
        ################################################################
        msgs_to_send = SendRecvMsgs(
            sender_names=['delta', 'echo'],
            receiver_names=['alpha', 'beta', 'charlie'],
            num_msgs=1,
            send_type=SendType.ToRemotes)

        send_msg_serial_num = self.add_cmd(
            SendMsg(cmd_runners=['delta', 'echo'],
                    receivers=['alpha', 'beta', 'charlie'],
                    msgs_to_send=msgs_to_send,
                    msg_idx=0,
                    log_msg='SendCmd test log message 1'))

        ################################################################
        # confirm the smart_send
        ################################################################
        self.add_cmd(
            ConfirmResponse(cmd_runners='alpha',
                            confirm_cmd='SendMsg',
                            confirm_serial_num=send_msg_serial_num,
                            confirmers=['delta', 'echo']))
        ################################################################
        # smart_recv
        ################################################################
        recv_msg_serial_num = self.add_cmd(
            RecvMsg(cmd_runners=['alpha', 'beta', 'charlie'],
                    senders=['delta', 'echo'],
                    exp_senders=['delta', 'echo'],
                    exp_msgs=msgs_to_send,
                    log_msg='RecvMsg test log message 2'))

        ################################################################
        # confirm the smart_recv
        ################################################################
        self.add_cmd(
            ConfirmResponse(cmd_runners='alpha',
                            confirm_cmd='RecvMsg',
                            confirm_serial_num=recv_msg_serial_num,
                            confirmers=['alpha', 'beta', 'charlie']))

        ################################################################
        # wait
        ################################################################
        self.add_cmd(
            Wait(cmd_runners='beta',
                 resumers='charlie',
                 exp_resumers='charlie',
                 stopped_remotes=set(),
                 log_msg='Wait test log message 3'))
        ################################################################
        # resume
        ################################################################
        self.add_cmd(
            Resume(cmd_runners='charlie',
                   targets='beta',
                   exp_resumed_targets='beta',
                   stopped_remotes=[],
                   log_msg='Resume test log message 4'))

        ################################################################
        # sync
        ################################################################
        self.add_cmd(
            Sync(cmd_runners='beta',
                 targets='charlie',
                 log_msg='Sync test log message 5'))
        self.add_cmd(
            Sync(cmd_runners='charlie',
                 targets='beta',
                 log_msg='Sync test log message 6'))

        ################################################################
        # stop all threads
        ################################################################

        self.add_cmd(StopThread(cmd_runners='alpha',
                                stop_names=['beta', 'charlie',
                                            'delta', 'echo']))
        # self.add_cmd(VerifyAliveNot(
        #     cmd_runners='alpha',
        #     exp_not_alive_names=['beta', 'charlie', 'delta', 'echo',
        #                          'fox', 'george']))
        self.add_cmd(VerifyConfig(
            cmd_runners='alpha',
            verify_type=VerifyType.VerifyNotAlive,
            names_to_check=['beta', 'charlie', 'delta', 'echo', 'fox',
                            'george']))
        # self.add_cmd(ValidateConfig(
        #     cmd_runners='alpha'))
        self.add_cmd(VerifyConfig(
            cmd_runners='alpha',
            verify_type=VerifyType.VerifyStructures))
        self.add_cmd(Join(
            cmd_runners='alpha',
            join_names=['beta', 'charlie', 'delta', 'echo'],
            log_msg='Join test log message 7'))
        # self.add_cmd(ValidateConfig(
        #     cmd_runners='alpha'))
        self.add_cmd(VerifyConfig(
            cmd_runners='alpha',
            verify_type=VerifyType.VerifyStructures))
        self.add_cmd(Unregister(
            cmd_runners='alpha',
            unregister_targets=['fox', 'george'],
            log_msg='Unregister test log message 8'))
        # self.add_cmd(VerifyInRegistryNot(
        #     cmd_runners='alpha',
        #     exp_not_in_registry_names=['fox', 'george']))
        self.add_cmd(VerifyConfig(
            cmd_runners='alpha',
            verify_type=VerifyType.VerifyNotInRegistry,
            names_to_check=['fox', 'george']))
        # self.add_cmd(ValidateConfig(
        #     cmd_runners='alpha'))
        self.add_cmd(VerifyConfig(
            cmd_runners='alpha',
            verify_type=VerifyType.VerifyStructures))

    ####################################################################
    # build_smart_start_suite
    ####################################################################
    def build_smart_start_suite(self,
                                num_auto_start: int,
                                num_manual_start: int,
                                num_unreg: int,
                                num_alive: int,
                                num_stopped: int
                                ) -> None:
        """Return a list of ConfigCmd items for smart_unreg.

        Args:
            num_auto_start: number of threads to auto start
            num_manual_start: number of threads to manually start
            num_unreg: number of thread that are unregistered
            num_alive: number of threads that are alive
            num_stopped: number of threads that are stopped

        """
        # Make sure we have enough threads
        num_alt_cmd_runners = 1
        assert (num_alt_cmd_runners
                + num_auto_start
                + num_manual_start
                + num_unreg
                + num_alive
                + num_stopped) <= len(self.unregistered_names)

        self.build_config(
            cmd_runner=self.commander_name,
            num_registered=num_manual_start,
            num_active=num_alt_cmd_runners + num_auto_start + num_alive + 1,
            num_stopped=num_stopped)

        self.log_name_groups()

        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose alt_cmd_runner
        ################################################################
        alt_cmd_runners = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_alt_cmd_runners,
            update_collection=True,
            var_name_for_log='alt_cmd_runner')

        ################################################################
        # choose manual_start_names
        ################################################################
        manual_start_names = self.choose_names(
            name_collection=self.registered_names,
            num_names_needed=num_manual_start,
            update_collection=False,
            var_name_for_log='manual_start_names')

        ################################################################
        # choose unreg_names
        ################################################################
        unreg_names = self.choose_names(
            name_collection=self.unregistered_names,
            num_names_needed=num_unreg,
            update_collection=False,
            var_name_for_log='unreg_names')

        ################################################################
        # choose alive_names
        ################################################################
        alive_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_alive,
            update_collection=True,
            var_name_for_log='alive_names')

        ################################################################
        # choose stopped_remotes
        ################################################################
        stopped_remotes = self.choose_names(
            name_collection=self.stopped_remotes,
            num_names_needed=num_stopped,
            update_collection=False,
            var_name_for_log='stopped_remotes')

        targets = (manual_start_names
                   + unreg_names
                   + alive_names
                   + stopped_remotes)

        unreg_remotes = (unreg_names
                         + alive_names
                         + stopped_remotes)

        if len(targets) % 2:
            smart_start_serial_num = self.add_cmd(
                StartThread(
                    cmd_runners=alt_cmd_runners[0],
                    start_names=targets,
                    unreg_remotes=unreg_remotes,
                    log_msg='smart_start test 1'))
            ################################################################
            # confirm the smart_recv
            ################################################################
            self.add_cmd(
                ConfirmResponse(cmd_runners='alpha',
                                confirm_cmd='StartThread',
                                confirm_serial_num=smart_start_serial_num,
                                confirmers=[alt_cmd_runners[0]]))
        else:
            self.add_cmd(
                StartThread(
                    cmd_runners=self.commander_name,
                    start_names=targets,
                    unreg_remotes=unreg_remotes,
                    log_msg='smart_start test 2'))

        if manual_start_names:
            self.registered_names -= set(manual_start_names)
            self.active_names |= set(manual_start_names)

    ####################################################################
    # build_start_suite
    ####################################################################
    def build_start_suite(self,
                          start_names: Iterable,
                          validate_config: Optional[bool] = True
                          ) -> None:
        """Return a list of ConfigCmd items for smart_unreg.

        Args:
            start_names: thread names to be started
            validate_config: indicates whether to validate the config

        """
        start_names = get_set(start_names)
        if not start_names.issubset(self.registered_names):
            self.abort_all_f1_threads()
            raise InvalidInputDetected(f'Input {start_names} is not a subset '
                                       'of registered names '
                                       f'{self.registered_names}')

        self.add_cmd(
            StartThread(cmd_runners=self.commander_name,
                        start_names=start_names))
        # self.add_cmd(VerifyActive(
        #         cmd_runners=self.commander_name,
        #         exp_active_names=start_names))
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyAliveState,
            names_to_check=start_names))

        if validate_config:
            # self.add_cmd(ValidateConfig(cmd_runners=self.commander_name))
            self.add_cmd(VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures))

        self.registered_names -= set(start_names)
        self.active_names |= set(start_names)

    ####################################################################
    # build_start_suite_num
    ####################################################################
    def build_start_suite_num(self,
                              num_to_start: int) -> None:
        """Return a list of ConfigCmd items for smart_unreg.

        Args:
            num_to_start: number of threads to be started

        """
        assert num_to_start > 0
        if len(self.registered_names) < num_to_start:
            self.abort_all_f1_threads()
            raise InvalidInputDetected(f'Input num_to_start {num_to_start} '
                                       f'is greater than the number of '
                                       f'registered threads '
                                       f'{len(self.registered_names)}')

        names: list[str] = list(
            random.sample(sorted(self.registered_names), num_to_start))

        return self.build_start_suite(start_names=names)

    ####################################################################
    # build_sync_scenario_suite
    ####################################################################
    def build_sync_scenario_suite(self,
                                  timeout_type: TimeoutType,
                                  num_syncers: int,
                                  num_stopped_syncers: int,
                                  num_timeout_syncers: int,
                                  ) -> None:
        """Build ConfigCmd items for sync scenarios.

        Args:
            timeout_type: timeout for None, False, or True
            num_syncers: number of threads that will successfully
                sync
            num_stopped_syncers: number of threads that will
                cause a not alive error
            num_timeout_syncers: number of threads that will
                cause a timeout error

        """
        # Make sure we have enough threads
        assert (num_syncers
                + num_stopped_syncers
                + num_timeout_syncers) <= len(self.unregistered_names)

        timeout_time = ((num_syncers * 0.64)
                        + (num_timeout_syncers * 0.64))

        pause_time = timeout_time
        if timeout_type == TimeoutType.TimeoutFalse:
            timeout_time *= 2  # prevent timeout
            timeout_time = max(timeout_time, 2)
        elif timeout_type == TimeoutType.TimeoutTrue:
            timeout_time *= 0.5  # force timeout

        self.build_config(
            cmd_runner=self.commander_name,
            num_registered=num_timeout_syncers,
            num_active=num_syncers + 1,
            num_stopped=num_stopped_syncers)

        self.log_name_groups()

        active_names_copy = self.active_names - {self.commander_name}

        ################################################################
        # choose syncer_names
        ################################################################
        syncer_names = self.choose_names(
            name_collection=active_names_copy,
            num_names_needed=num_syncers,
            update_collection=True,
            var_name_for_log='syncer_names')

        ################################################################
        # choose timeout_syncer_names
        ################################################################
        timeout_syncer_names = self.choose_names(
            name_collection=self.registered_names,
            num_names_needed=num_timeout_syncers,
            update_collection=False,
            var_name_for_log='timeout_syncer_names')

        ################################################################
        # choose stopped_syncer_names
        ################################################################
        stopped_syncer_names = self.choose_names(
            name_collection=self.stopped_remotes,
            num_names_needed=num_stopped_syncers,
            update_collection=False,
            var_name_for_log='stopped_syncer_names')

        all_targets: list[str] = (syncer_names
                                  + timeout_syncer_names
                                  + stopped_syncer_names)

        ################################################################
        # timeout True
        ################################################################
        if timeout_type == TimeoutType.TimeoutTrue:
            confirm_cmd_to_use = 'SyncTimeoutTrue'
            sync_serial_num = self.add_cmd(
                SyncTimeoutTrue(
                    cmd_runners=syncer_names,
                    targets=set(all_targets),
                    timeout=timeout_time,
                    timeout_remotes=set(timeout_syncer_names),
                    stopped_remotes=set(stopped_syncer_names)))
        else:
            ############################################################
            # timeout False
            ############################################################
            if timeout_type == TimeoutType.TimeoutFalse:
                confirm_cmd_to_use = 'SyncTimeoutFalse'
                sync_serial_num = self.add_cmd(
                    SyncTimeoutFalse(
                        cmd_runners=syncer_names,
                        targets=set(all_targets),
                        timeout=timeout_time,
                        timeout_remotes=set(timeout_syncer_names),
                        stopped_remotes=set(stopped_syncer_names)))
            else:
                ########################################################
                # timeout None
                ########################################################
                confirm_cmd_to_use = 'Sync'
                sync_serial_num = self.add_cmd(
                    Sync(cmd_runners=syncer_names,
                         targets=set(all_targets),
                         timeout=timeout_time,
                         timeout_remotes=set(timeout_syncer_names),
                         stopped_remotes=set(stopped_syncer_names),
                         log_msg='sync test1'))

            self.add_cmd(Pause(cmd_runners=self.commander_name,
                               pause_seconds=pause_time))
            ############################################################
            # start the registered syncers to get them active
            ############################################################
            if timeout_syncer_names:
                self.build_start_suite(
                    start_names=list(timeout_syncer_names),
                    validate_config=False)

            ############################################################
            # join stopped syncers and then create to get them active
            ############################################################
            # if stopped_syncer_names:
            #     self.build_join_suite(
            #         cmd_runners=self.commander_name,
            #         join_target_names=list(stopped_syncer_names))
            #     f1_create_items: list[F1CreateItem] = []
            #     for idx, name in enumerate(stopped_syncer_names):
            #         if idx % 2:
            #             app_config = AppConfig.ScriptStyle
            #         else:
            #             app_config = AppConfig.RemoteThreadApp
            #
            #         f1_create_items.append(F1CreateItem(name=name,
            #                                             auto_start=True,
            #                                             target_rtn=outer_f1,
            #                                             app_config=app_config))
            #     self.build_create_suite(
            #         f1_create_items=f1_create_items,
            #         validate_config=False)

            ############################################################
            # do sync for newly started syncers
            ############################################################
            if timeout_syncer_names:
                started_cmd_runners = list(timeout_syncer_names)
                sync_serial_num2 = self.add_cmd(
                    Sync(cmd_runners=started_cmd_runners,
                         targets=set(all_targets),
                         timeout=timeout_time,
                         timeout_remotes=set(timeout_syncer_names),
                         stopped_remotes=set(stopped_syncer_names),
                         log_msg='sync test2'))
                self.add_cmd(
                    ConfirmResponse(cmd_runners=[self.commander_name],
                                    confirm_cmd='Sync',
                                    confirm_serial_num=sync_serial_num2,
                                    confirmers=started_cmd_runners))

        ################################################################
        # confirm the sync
        ################################################################
        self.add_cmd(
            ConfirmResponse(cmd_runners=[self.commander_name],
                            confirm_cmd=confirm_cmd_to_use,
                            confirm_serial_num=sync_serial_num,
                            confirmers=list(syncer_names)))

    ####################################################################
    # build_unreg_suite
    ####################################################################
    def build_unreg_suite(self,
                          names: Iterable,
                          validate_config: bool = True) -> None:
        """Return a list of ConfigCmd items for smart_unreg.

        Args:
            names: thread name to be unregistered
            validate_config: specifies whether to verify the config
        """
        names = get_set(names)
        if not names.issubset(self.registered_names):
            self.abort_all_f1_threads()
            raise InvalidInputDetected(f'Input {names} is not a subset '
                                       'of registered names '
                                       f'{self.registered_names}')

        self.add_cmd(Unregister(cmd_runners=self.commander_name,
                                unregister_targets=names))
        # self.add_cmd(VerifyInRegistryNot(
        #     cmd_runners=self.commander_name,
        #     exp_not_in_registry_names=names))
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyNotInRegistry,
            names_to_check=names))
        # self.add_cmd(VerifyPairedNot(
        #     cmd_runners=self.commander_name,
        #     exp_not_paired_names=names))
        self.add_cmd(VerifyConfig(
            cmd_runners=self.commander_name,
            verify_type=VerifyType.VerifyNotPaired,
            names_to_check=names))

        if validate_config:
            # self.add_cmd(ValidateConfig(cmd_runners=self.commander_name))
            self.add_cmd(VerifyConfig(
                cmd_runners=self.commander_name,
                verify_type=VerifyType.VerifyStructures))

        self.registered_names -= set(names)
        self.unregistered_names |= set(names)

    ####################################################################
    # build_unreg_suite_num
    ####################################################################
    def build_unreg_suite_num(self,
                              num_to_unreg: int) -> None:
        """Return a list of ConfigCmd items for smart_unreg.

        Args:
            num_to_unreg: number of threads to be unregistered

        """
        assert num_to_unreg > 0
        if len(self.registered_names) < num_to_unreg:
            self.abort_all_f1_threads()
            raise InvalidInputDetected(f'Input num_to_unreg {num_to_unreg} '
                                       f'is greater than the number of '
                                       f'registered threads '
                                       f'{len(self.registered_names)}')

        names: list[str] = list(
            random.sample(sorted(self.registered_names), num_to_unreg))

        return self.build_unreg_suite(names=names)

    ####################################################################
    # choose_names
    ####################################################################
    def choose_names(
            self,
            name_collection: set[str],
            num_names_needed: int,
            update_collection: bool,
            var_name_for_log: str) -> list[str]:
        """Return a list of names picked from a set and issue log msg.

        Args:
            name_collection: set of names to choose from
            num_names_needed: number of names to choose
            update_collection: indicates whether to remove the chosen names
                from the set of names
            var_name_for_log: variable name to use for the log msg

        Returns:
            a list of names
        """
        chosen_names: list[str] = []
        if num_names_needed > 0:
            chosen_names = list(
                random.sample(sorted(name_collection), num_names_needed))
        if update_collection:
            name_collection -= set(chosen_names)

        self.log_test_msg(f'{var_name_for_log}: {chosen_names}')

        return chosen_names

    ####################################################################
    # create_f1_thread
    ####################################################################
    def create_f1_thread(self,
                         cmd_runner: str,
                         target: Callable,
                         name: str,
                         app_config: AppConfig,
                         auto_start: bool = True
                         ) -> None:
        """Create the f1_thread.

        Args:
            cmd_runner: name of thread doing the create
            target: the f1 routine that the thread will run
            name: name of the thread
            app_config: specifies the style of app to create
            auto_start: indicates whether the create should start the
                          thread
        """
        self.log_test_msg(f'create_f1_thread entry: {cmd_runner=}, '
                          f'{name=}')
        self.f1_process_cmds[name] = True

        self.monitor_pause = True

        is_thread_target = False
        if app_config == AppConfig.ScriptStyle:
            is_thread_target = True

        if is_thread_target:
            thread_create: st.ThreadCreate = st.ThreadCreate.Target
        else:
            thread_create: st.ThreadCreate = st.ThreadCreate.Thread

        if auto_start:
            auto_start_decision: AutoStartDecision = (
                AutoStartDecision.auto_start_yes)
        else:
            auto_start_decision: AutoStartDecision = (
                AutoStartDecision.auto_start_no)

        with self.ops_lock:
            self.expected_registered[name] = ThreadTracker(
                thread=None,
                is_alive=False,
                exiting=False,
                is_auto_started=auto_start,
                is_TargetThread=is_thread_target,
                exp_init_is_alive=False,
                exp_init_thread_state=st.ThreadState.Registered,
                thread_create=thread_create,
                auto_start_decision=auto_start_decision,
                st_state=st.ThreadState.Unregistered,
                found_del_pairs=defaultdict(int)
            )

        pe = self.pending_events[cmd_runner]
        pe[PE.start_request].append(StartRequest(
            req_type=st.ReqType.Smart_init,
            targets={name},
            unreg_remotes=set(),
            not_registered_remotes=set(),
            timeout_remotes=set(),
            stopped_remotes=set(),
            deadlock_remotes=set(),
            eligible_targets=set(),
            completed_targets=set(),
            first_round_completed=set(),
            stopped_target_threads=set(),
            exp_senders=set(),
            exp_resumers=set()))

        req_key_entry: RequestKey = ('smart_init',
                                     'entry')

        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ('smart_init',
                                    'exit')

        pe[PE.request_msg][req_key_exit] += 1

        if app_config == AppConfig.ScriptStyle:
            f1_thread = st.SmartThread(name=name,
                                       target=target,
                                       args=(name, self),
                                       auto_start=auto_start,
                                       max_msgs=self.max_msgs)
        elif app_config == AppConfig.RemoteThreadApp:
            f1_outer_app = OuterF1ThreadApp(
                config_ver=self,
                name=name,
                auto_start=auto_start,
                max_msgs=self.max_msgs)
            f1_thread = f1_outer_app.smart_thread
        else:
            raise UnrecognizedCmd('create_f1_thread does not recognize '
                                  f'{app_config=}')

        self.all_threads[name] = f1_thread
        self.expected_registered[name].thread = f1_thread

        self.monitor_pause = False

        self.cmd_waiting_event_items[cmd_runner] = threading.Event()

        self.monitor_event.set()

        self.log_test_msg(f'{cmd_runner=} create_f1_thread waiting '
                          f'for monitor')
        self.cmd_waiting_event_items[cmd_runner].wait()
        with self.ops_lock:
            del self.cmd_waiting_event_items[cmd_runner]

        self.log_test_msg(f'create_f1_thread exiting: {cmd_runner=}, '
                          f'{name=}')

    ########################################################################
    # get_config_snapshot
    ########################################################################
    def create_snapshot_data(self,
                             verify_name: str,
                             verify_idx: int,
                             verify_data: VerifyData
                             ) -> None:
        """Create and save a snapshot of real structures for verification.

        Args:
            verify_name: name of verify cmd
            verify_idx: index of the verify command
            verify_data: data to be saved with the snapshot
        """
        # with sel.SELockExcl(st.SmartThread._registry_lock):
        with conditional_registry_lock(lock=st.SmartThread._registry_lock,
                                       obtain_tf=verify_data.obtain_reg_lock):
            registry_items: dict[str, RegistrySnapshotItem] = {}
            for name, item in st.SmartThread._registry.items():
                registry_items[name] = RegistrySnapshotItem(
                    is_alive=item.thread.is_alive(),
                    state=item.st_state)

            pair_array_items: dict[st.PairKey, dict[
                str, StatusBlockSnapshotItem]] = {}
            for pair_key, connection_pair in (
                    st.SmartThread._pair_array.items()):
                pair_array_items[pair_key] = {}
                for name, sb_item in connection_pair.status_blocks.items():
                    pair_array_items[pair_key][name] = StatusBlockSnapshotItem(
                        pending_request=sb_item.request_pending,
                        pending_msg_count=sb_item.msg_q.qsize(),
                        pending_wait=sb_item.wait_event.is_set(),
                        pending_sync=sb_item.sync_event.is_set())

        self.snap_shot_data[verify_idx] = SnapShotDataItem(
            registry_items=registry_items.copy(),
            pair_array_items=pair_array_items.copy(),
            verify_data=verify_data
        )

        self.log_test_msg(
            f'Monitor Checkpoint: {verify_name} {verify_idx}')

    ####################################################################
    # dec_recv_timeout
    ####################################################################
    def dec_recv_timeout(self):
        """Decrement the receive timeout count."""
        with self.ops_lock:
            self.expected_num_recv_timeouts -= 1

    ####################################################################
    # del_thread
    ####################################################################
    def del_thread(self,
                   cmd_runner: str,
                   del_name: str,
                   process: str,
                   del_msg_idx: int
                   ) -> None:
        """Delete the thread from the ConfigVerifier.

        Args:
            cmd_runner: name of thread doing the delete (for log msg)
            del_name: name of thread to be deleted
            process: names the process, either join or smart_unreg
            del_msg_idx: index in the log for the del message
        """
        self.log_test_msg(f'del_thread entered: {cmd_runner=}, '
                          f'{del_name=}, {process=}')

        self.log_test_msg(f'del_thread exit: {cmd_runner=}, '
                          f'{del_name=}, {process=}')

    ####################################################################
    # exit_thread
    ####################################################################
    def exit_thread(self,
                    cmd_runner: str,
                    stopped_by: str):
        """Drive the commands received on the command queue.

        Args:
            cmd_runner: name of thread being stopped
            stopped_by: name of thread doing the stop

        """
        self.expected_registered[cmd_runner].stopped_by = stopped_by
        self.f1_process_cmds[cmd_runner] = False

    ####################################################################
    # f1_driver
    ####################################################################
    def f1_driver(self,
                  f1_name: str):
        """Drive the commands received on the command queue.

        Args:
            f1_name: name of thread doing the command

        """
        self.log_ver.add_call_seq(
            name='f1_driver',
            seq='test_smart_thread.py::ConfigVerifier.f1_driver')

        # We will stay in this loop to process command while the
        # f1_process_cmds dictionary entry for f1_name is True. The
        # ConfigCmdExitThread cmd runProcess method will simply set the
        # dictionary entry for f1_name to False so that we will then
        # exit after we indicate that the cmd is complete
        while self.f1_process_cmds[f1_name]:

            cmd: ConfigCmd = self.msgs.get_msg(f1_name, timeout=None)

            cmd.run_process(cmd_runner=f1_name)

            self.completed_cmds[f1_name].append(cmd.serial_num)

    ####################################################################
    # find_log_msgs
    ####################################################################
    def find_log_msgs(self,
                      search_msgs: StrOrList,
                      num_instances: int = 1) -> bool:
        """Find the requested log message in the log.

        Args:
            search_msgs: list of message to be found
            num_instances: number of instances to be found

        """
        if isinstance(search_msgs, str):
            search_msgs = [search_msgs]
        work_msgs: list[re.Pattern] = []
        for msg in search_msgs:
            work_msgs.append(re.compile(re.escape(msg)))
        num_tries_remaining = 2
        while num_tries_remaining:
            num_tries_remaining -= 1
            found_idxes: list[int] = []
            for idx in range(len(work_msgs)):
                found_idxes.append(0)
            for log_tuple in self.caplog_to_use.record_tuples:
                for idx, msg in enumerate(work_msgs):
                    if msg.match(log_tuple[2]):
                        found_idxes[idx] += 1
                        # if len(found_idxes) == len(work_msgs):
                        #     return True
            failed_instance_count = False
            for cnt in found_idxes:
                if cnt != num_instances:
                    failed_instance_count = True
                    break

            if failed_instance_count:
                if num_tries_remaining:
                    time.sleep(1.5)
                    continue
                return False

            if num_tries_remaining == 1:
                return True
            else:
                assert False

        return True

    ####################################################################
    # get_log_msg
    ####################################################################
    def get_log_msg(self,
                    search_msg: str,
                    skip_num: int = 0,
                    start_idx: int = 0,
                    end_idx: int = -1,
                    reverse_search: bool = False) -> str:
        """Search for a log message and return it.

        Args:
            search_msg: log message to search for as a regex
            skip_num: number of matches to skip
            start_idx: index from which to start
            end_idx: index of 1 past the index at which to stop
            reverse_search: indicates whether to search from the bottom

        Returns:
            the log message if found, otherwise an empty string
        """
        search_pattern: re.Pattern = re.compile(search_msg)
        num_skipped = 0
        work_log = self.caplog_to_use.record_tuples.copy()

        if end_idx == -1:
            end_idx = len(work_log)

        work_log = work_log[start_idx:end_idx]
        if reverse_search:
            work_log.reverse()

        for idx, log_tuple in enumerate(work_log):
            if search_pattern.match(log_tuple[2]):
                if num_skipped == skip_num:
                    if reverse_search:
                        ret_idx = start_idx + (len(work_log) - idx) - 1
                    else:
                        ret_idx = start_idx + idx
                    return log_tuple[2], ret_idx
                num_skipped += 1

        return '', -1

    ####################################################################
    # get_log_msgs
    ####################################################################
    def get_log_msgs(self) -> bool:
        """Search for a log messages and return them in order.

        Returns:
            True, if messages were found, False otherwise
        """
        # we should never call with a non-empty deque
        assert not self.log_found_items

        work_log = self.caplog_to_use.record_tuples.copy()

        end_idx = len(work_log)
        # print(f'\n{self.log_start_idx=}, {end_idx=}, {work_log[-1]=} \n')

        # return if no new log message have been issued since last call
        if self.log_start_idx >= end_idx:
            return False

        work_log = work_log[self.log_start_idx:end_idx]

        for idx, log_tuple in enumerate(work_log, self.log_start_idx):
            for log_search_item in self.log_search_items:
                if log_search_item.search_pattern.match(log_tuple[2]):
                    found_log_item = log_search_item.get_found_log_item(
                        found_log_msg=log_tuple[2],
                        found_log_idx=idx
                    )
                    self.log_found_items.append(found_log_item)

        # update next starting point
        self.log_start_idx = end_idx

        if self.log_found_items:
            return True
        else:
            return False

    ####################################################################
    # handle_did_clean_reg_log_msg
    ####################################################################
    def handle_did_clean_reg_log_msg(self,
                                     cmd_runner: str,
                                     targets: list[str],
                                     log_msg: str) -> None:
        """Handle the did cleanup of registry log message.

        Args:
            cmd_runner: thread name that did the cleanup
            targets: thread names that were removed
            log_msg: did cleanup log message

        """
        pe = self.pending_events[cmd_runner]

        if pe[PE.did_clean_reg_msg] <= 0:
            raise UnexpectedEvent(f'handle_did_clean_reg_log_msg encountered '
                                  f'unexpected log msg: {log_msg}')

        pe[PE.did_clean_reg_msg] -= 1
        self.add_log_msg(re.escape(log_msg))

        ################################################################
        # verify list of targets
        ################################################################
        rem_reg_list = pe[PE.rem_reg_targets].pop()

        if rem_reg_list != targets:
            raise IncorrectDataDetected(
                'handle_did_clean_reg_log_msg detected that the list of '
                f'removed targets {rem_reg_list} did not match the '
                f'log msg: {log_msg}')

    ####################################################################
    # handle_join
    ####################################################################
    def handle_join(self,
                    cmd_runner: str,
                    join_names: set[str],
                    unreg_names: set[str],
                    log_msg: str,
                    timeout_type: TimeoutType = TimeoutType.TimeoutNone,
                    timeout: Optional[IntOrFloat] = None,
                    timeout_names: Optional[set[str]] = None
                    ) -> None:
        """Handle the join execution and log msgs.

        Args:
            cmd_runner: name of thread doing the cmd
            join_names: target threads that we will join
            unreg_names: thread names that are already unregistered
            log_msg: log message to issue on the join (name be None)
            timeout_type: None, False, or True
            timeout: value for timeout on join request
            timeout_names: threads that are expected to timeout

        """
        self.log_test_msg(f'handle_join entry: {cmd_runner=}, {join_names=}')
        self.log_ver.add_call_seq(
            name='smart_join',
            seq='test_smart_thread.py::ConfigVerifier.handle_join')

        start_time = time.time()

        if timeout_names:
            timeout_remotes = timeout_names.copy()
        else:
            timeout_remotes = set()

        pe = self.pending_events[cmd_runner]

        pe[PE.start_request].append(
            StartRequest(req_type=st.ReqType.Smart_join,
                         timeout_type=timeout_type,
                         targets=join_names.copy(),
                         unreg_remotes=unreg_names.copy(),
                         not_registered_remotes=set(),
                         timeout_remotes=timeout_remotes,
                         stopped_remotes=set(),
                         deadlock_remotes=set(),
                         eligible_targets=set(),
                         completed_targets=set(),
                         first_round_completed=set(),
                         stopped_target_threads=set(),
                         exp_senders=set(),
                         exp_resumers=set()))

        req_key_entry: RequestKey = ('smart_join',
                                     'entry')

        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ('smart_join',
                                    'exit')

        # enter_exit = ('entry', 'exit')
        if timeout_type == TimeoutType.TimeoutNone:
            pe[PE.request_msg][req_key_exit] += 1
            self.all_threads[cmd_runner].smart_join(
                targets=join_names,
                log_msg=log_msg)

        elif timeout_type == TimeoutType.TimeoutFalse:
            pe[PE.request_msg][req_key_exit] += 1
            self.all_threads[cmd_runner].smart_join(
                targets=join_names,
                timeout=timeout,
                log_msg=log_msg)

        elif timeout_type == TimeoutType.TimeoutTrue:
            # enter_exit = ('entry', )
            error_msg = self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request='smart_join',
                    targets=join_names,
                    pending_remotes=timeout_names,
                    error_str='SmartThreadRequestTimedOut')
            with pytest.raises(st.SmartThreadRequestTimedOut) as exc:
                self.all_threads[cmd_runner].smart_join(
                    targets=join_names,
                    timeout=timeout,
                    log_msg=log_msg)

            err_str = str(exc.value)
            assert re.fullmatch(error_msg, err_str)

            self.add_log_msg(error_msg,
                             log_level=logging.ERROR)

        # self.add_request_log_msg(cmd_runner=cmd_runner,
        #                          smart_request='smart_join',
        #                          targets=join_names,
        #                          timeout=timeout,
        #                          timeout_type=timeout_type,
        #                          enter_exit=enter_exit,
        #                          log_msg=log_msg)

        elapsed_time: float = time.time() - start_time
        time_per_target: float = elapsed_time/len(join_names)

        self.monitor_event.set()

        self.wait_for_monitor(cmd_runner=cmd_runner,
                              rtn_name='handle_join')

        self.log_test_msg(f'handle_join exiting with {elapsed_time=}, '
                          f'{len(join_names)=}, {time_per_target=}')

    ####################################################################
    # handle_recv_msg
    ####################################################################
    def handle_recv_msg(self,
                        cmd_runner: str,
                        senders: set[str],
                        exp_senders: set[str],
                        exp_msgs: SendRecvMsgs,
                        stopped_remotes: set[str],
                        timeout_type: TimeoutType,
                        timeout: IntOrFloat,
                        timeout_names: set[str],
                        sender_count: Optional[int] = None,
                        log_msg: Optional[str] = None) -> None:
        """Handle the send_recv_cmd execution and log msgs.

        Args:
            cmd_runner: name of thread doing the cmd
            senders: names of the senders
            exp_senders: senders that are expected to have sent a msg
                based on the RecvType
            exp_msgs: expected messages by sender name
            stopped_remotes: names of remotes that are stopped.
            timeout_type: None, False, or True
            timeout: value to use for timeout
            timeout_names: names of remotes that fail to send a message
                within the timeout time.
            sender_count: number of senders needed to satisfy smart_recv
            log_msg: log message to issue on smart_recv

        """
        self.log_test_msg(f'handle_recv_msg entry: {cmd_runner=}, '
                          f'{senders=}, {sender_count=}, {exp_senders=},'
                          f' {stopped_remotes=}, {timeout_type=}, '
                          f'{timeout=}, {timeout_names=}')

        pe = self.pending_events[cmd_runner]
        pe[PE.start_request].append(
            StartRequest(req_type=st.ReqType.Smart_recv,
                         timeout_type=timeout_type,
                         targets=senders,
                         unreg_remotes=set(),
                         not_registered_remotes=set(),
                         timeout_remotes=timeout_names,
                         stopped_remotes=stopped_remotes.copy(),
                         deadlock_remotes=set(),
                         eligible_targets=set(),
                         completed_targets=set(),
                         first_round_completed=set(),
                         stopped_target_threads=set(),
                         exp_senders=exp_senders,
                         exp_resumers=set()))

        req_key_entry: RequestKey = ('smart_recv',
                                     'entry')

        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ('smart_recv',
                                    'exit')

        if stopped_remotes:
            with pytest.raises(st.SmartThreadRemoteThreadNotAlive):
                if timeout_type == TimeoutType.TimeoutNone:
                    self.all_threads[cmd_runner].smart_recv(
                        senders=senders,
                        sender_count=sender_count,
                        log_msg=log_msg)
                else:
                    self.all_threads[cmd_runner].smart_recv(
                        senders=senders,
                        sender_count=sender_count,
                        timeout=timeout,
                        log_msg=log_msg)

            # recover whatever message were read
            recvd_msgs = self.all_threads[cmd_runner].recvd_msgs

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request='smart_recv',
                    targets=senders,
                    error_str='SmartThreadRemoteThreadNotAlive',
                    stopped_remotes=stopped_remotes),
                log_level=logging.ERROR)

        elif timeout_type == TimeoutType.TimeoutNone:
            pe[PE.request_msg][req_key_exit] += 1
            recvd_msgs = self.all_threads[cmd_runner].smart_recv(
                senders=senders,
                sender_count=sender_count,
                log_msg=log_msg)

        elif timeout_type == TimeoutType.TimeoutFalse:
            pe[PE.request_msg][req_key_exit] += 1
            recvd_msgs = self.all_threads[cmd_runner].smart_recv(
                senders=senders,
                sender_count=sender_count,
                timeout=timeout,
                log_msg=log_msg)

        elif timeout_type == TimeoutType.TimeoutTrue:
            with pytest.raises(st.SmartThreadRequestTimedOut):
                self.all_threads[cmd_runner].smart_recv(
                    senders=senders,
                    sender_count=sender_count,
                    timeout=timeout,
                    log_msg=log_msg)

            # recover whatever message were read
            recvd_msgs = self.all_threads[cmd_runner].recvd_msgs

            self.dec_recv_timeout()

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request='smart_recv',
                    targets=senders,
                    error_str='SmartThreadRequestTimedOut',
                    stopped_remotes=stopped_remotes),
                log_level=logging.ERROR)

        assert sorted(exp_senders) == sorted(recvd_msgs.keys())
        for remote in exp_senders:
            assert recvd_msgs[remote] == exp_msgs.exp_received_msgs[
                cmd_runner][remote]

        self.wait_for_monitor(cmd_runner=cmd_runner,
                              rtn_name='handle_recv')

        self.log_test_msg(f'handle_recv_msg exit: {cmd_runner=}, '
                          f'{senders=}, {sender_count=}, {exp_senders=},'
                          f' {stopped_remotes=}, {timeout_type=}, '
                          f'{timeout=}, {timeout_names=}')

    ####################################################################
    # handle_request_entry_exit_log_msg
    ####################################################################
    def handle_request_entry_exit_log_msg(self,
                                          cmd_runner: str,
                                          request_name: str,
                                          entry_exit: str,
                                          targets: list[str],
                                          log_msg: str) -> None:
        """Handle the request entry exit log msgs.

        Args:
            cmd_runner: name of thread doing the cmd
            request_name: smart request name
            entry_exit: specifies whether entry or exit message
            targets: targets of the request
            log_msg: log message for the request

        """
        self.log_test_msg('handle_request_entry_exit_log_msg entry: '
                          f'{cmd_runner=}, {request_name=}, {entry_exit=}, '
                          f'{targets=}')
        pe = self.pending_events[cmd_runner]

        req_key: RequestKey = (request_name,
                               entry_exit)

        if pe[PE.request_msg][req_key] <= 0:
            error_msg = (
                f'handle_request_entry_exit_log_msg using {req_key=} '
                f'encountered unexpected log msg: {log_msg}')
            self.log_test_msg(error_msg)
            raise UnexpectedEvent(error_msg)

        pe[PE.request_msg][req_key] -= 1

        self.add_log_msg(re.escape(log_msg))

        if entry_exit == 'entry':
            try:
                req_start_item = pe[PE.start_request].popleft()
            except IndexError:
                raise UnexpectedEvent(
                    'handle_request_entry_exit_log_msg missing start_request '
                    f'for log msg: {log_msg}')

            if req_start_item.req_type.value != request_name:
                raise UnexpectedEvent(
                    'handle_request_entry_exit_log_msg expected '
                    f'{req_start_item.req_type.value=} but instead received '
                    f'log msg: {log_msg}')

            if not req_start_item.targets:
                sorted_targets = ['']
            else:
                sorted_targets = sorted(req_start_item.targets)

            if sorted_targets != sorted(targets):
                raise InvalidInputDetected(
                    'handle_request_entry_exit_log_msg expected '
                    f'{sorted_targets=} to be equal to '
                    f'{sorted(targets)=} for '
                    f'log msg: {log_msg}')

            pe[PE.current_request] = req_start_item

            if req_start_item.req_type.value in ('smart_send',
                                                 'smart_recv',
                                                 'smart_wait',
                                                 'smart_resume',
                                                 'smart_sync'):
                self.set_request_pending_flag(cmd_runner=cmd_runner,
                                              targets=set(targets),
                                              pending_request_flag=True)
            # if req_start_item.stopped_remotes:
            #     ref_key: CallRefKey = req_start_item.req_type.value
            #
            #     pe[PE.calling_refresh_msg][ref_key] += 1

        ################################################################
        # call handler for request
        ################################################################
        actions: dict[tuple[str, str], Callable[..., None]] = {
            ('smart_init', 'entry'):
                self.handle_request_smart_init_entry,
            ('smart_init', 'exit'):
                self.handle_request_smart_init_exit,
            ('smart_start', 'entry'):
                self.handle_request_smart_start_entry,
            ('smart_start', 'exit'):
                self.handle_request_smart_start_exit,
            ('smart_unreg', 'entry'):
                self.handle_request_smart_unreg_entry,
            ('smart_unreg', 'exit'):
                self.handle_request_smart_unreg_exit,
            ('smart_join', 'entry'):
                self.handle_request_smart_join_entry,
            ('smart_join', 'exit'):
                self.handle_request_smart_join_exit,
            ('smart_send', 'entry'):
                self.handle_request_smart_send_entry,
            ('smart_send', 'exit'):
                self.handle_request_smart_send_exit,
            ('smart_recv', 'entry'):
                self.handle_request_smart_recv_entry,
            ('smart_recv', 'exit'):
                self.handle_request_smart_recv_exit,
            ('smart_wait', 'entry'):
                self.handle_request_smart_wait_entry,
            ('smart_wait', 'exit'):
                self.handle_request_smart_wait_exit,
            ('smart_resume', 'entry'):
                self.handle_request_smart_resume_entry,
            ('smart_resume', 'exit'):
                self.handle_request_smart_resume_exit,
            ('smart_sync', 'entry'):
                self.handle_request_smart_sync_entry,
            ('smart_sync', 'exit'):
                self.handle_request_smart_sync_exit,
        }

        actions[(request_name, entry_exit)](cmd_runner=cmd_runner)

        if entry_exit == 'exit':
            self.log_test_msg('handle_req_entry_exit for exit with '
                              f'{pe[PE.current_request].req_type.value=}')

            if pe[PE.current_request].req_type.value in ('smart_send',
                                                         'smart_recv',
                                                         'smart_wait',
                                                         'smart_resume',
                                                         'smart_sync'):
                self.log_test_msg('handle_req_entry_exit calling set_pend '
                                  f'{cmd_runner=}, {targets=}, '
                                  f'{set(targets)=}')
                self.set_request_pending_flag(cmd_runner=cmd_runner,
                                              targets=set(targets),
                                              pending_request_flag=False)

            pe = self.pending_events[cmd_runner]

            if pe[PE.save_current_request].req_type != st.ReqType.NoReq:
                pe[PE.current_request] = pe[PE.save_current_request]
                pe[PE.save_current_request] = StartRequest(
                    req_type=st.ReqType.NoReq,
                    targets=set(),
                    unreg_remotes=set(),
                    not_registered_remotes=set(),
                    timeout_remotes=set(),
                    stopped_remotes=set(),
                    deadlock_remotes=set(),
                    eligible_targets=set(),
                    completed_targets=set(),
                    first_round_completed=set(),
                    stopped_target_threads=set(),
                    exp_senders=set(),
                    exp_resumers=set())
            else:
                pe[PE.current_request] = StartRequest(
                    req_type=st.ReqType.NoReq,
                    targets=set(),
                    unreg_remotes=set(),
                    not_registered_remotes=set(),
                    timeout_remotes=set(),
                    stopped_remotes=set(),
                    deadlock_remotes=set(),
                    eligible_targets=set(),
                    completed_targets=set(),
                    first_round_completed=set(),
                    stopped_target_threads=set(),
                    exp_senders=set(),
                    exp_resumers=set())

    ####################################################################
    # handle_request_smart_init_entry
    ####################################################################
    def handle_request_smart_init_entry(self,
                                        cmd_runner: str) -> None:
        """Handle the request entry for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]

        target = list(pe[PE.current_request].targets)[0]

        state_key: SetStateKey = (cmd_runner,
                                  target,
                                  st.ThreadState.Unregistered,
                                  st.ThreadState.Initializing)
        pe[PE.set_state_msg][state_key] += 1

        add_key: AddRegKey = (cmd_runner, target)
        pe[PE.add_reg_msg][add_key] += 1

        sub_key: SubProcessKey = (cmd_runner,
                                  'smart_init',
                                  '_register',
                                  'entry',
                                  target)
        pe[PE.subprocess_msg][sub_key] += 1

        sub_key: SubProcessKey = (cmd_runner,
                                  'smart_init',
                                  '_clean_registry',
                                  'entry',
                                  cmd_runner)
        pe[PE.subprocess_msg][sub_key] += 1

        sub_key: SubProcessKey = (cmd_runner,
                                  'smart_init',
                                  '_clean_pair_array',
                                  'entry',
                                  cmd_runner)
        pe[PE.subprocess_msg][sub_key] += 1

        # determine init completion msg

        thread_create = self.expected_registered[target].thread_create
        thread_state = self.expected_registered[target].exp_init_thread_state
        auto_start = self.expected_registered[target].auto_start_decision

        comp_key: InitCompKey = (target,
                                 thread_create,
                                 thread_state,
                                 auto_start)
        pe[PE.init_comp_msg][comp_key] += 1

        self.log_test_msg(f'handle_request_smart_init_entry {comp_key=}')

    ####################################################################
    # handle_request_smart_init_exit
    ####################################################################
    def handle_request_smart_init_exit(self,
                                       cmd_runner: str) -> None:
        """Handle the request exit for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        pass

    ####################################################################
    # handle_request_smart_start_entry
    ####################################################################
    def handle_request_smart_start_entry(self,
                                         cmd_runner: str) -> None:
        """Handle the request entry for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]

        eligible_targets = (
                pe[PE.current_request].targets.copy()
                - pe[PE.current_request].not_registered_remotes.copy())

        pe[PE.num_targets_remaining] = len(eligible_targets)

        for target in eligible_targets:
            state_key: SetStateKey = (cmd_runner,
                                      target,
                                      st.ThreadState.Registered,
                                      st.ThreadState.Starting)
            pe[PE.set_state_msg][state_key] += 1

    ####################################################################
    # handle_request_smart_start_exit
    ####################################################################
    def handle_request_smart_start_exit(self,
                                        cmd_runner: str) -> None:
        """Handle the request exit for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_request_smart_unreg_entry
    ####################################################################
    def handle_request_smart_unreg_entry(self,
                                         cmd_runner: str) -> None:
        """Handle the request entry for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]

        eligible_targets = (pe[PE.current_request].targets.copy()
                            - pe[PE.current_request].not_registered_remotes)
        pe[PE.current_request].eligible_targets = eligible_targets
        pe[PE.current_request].completed_targets = set()

        for target in eligible_targets:
            state_key: SetStateKey = (cmd_runner,
                                      target,
                                      st.ThreadState.Registered,
                                      st.ThreadState.Stopped)
            pe[PE.set_state_msg][state_key] += 1

            state_key: SetStateKey = (cmd_runner,
                                      target,
                                      st.ThreadState.Stopped,
                                      st.ThreadState.Unregistered)
            pe[PE.set_state_msg][state_key] += 1

        sub_key: SubProcessKey = (cmd_runner,
                                  'smart_unreg',
                                  '_clean_registry',
                                  'entry',
                                  cmd_runner)
        pe[PE.subprocess_msg][sub_key] += 1

        sub_key: SubProcessKey = (cmd_runner,
                                  'smart_unreg',
                                  '_clean_pair_array',
                                  'entry',
                                  cmd_runner)
        pe[PE.subprocess_msg][sub_key] += 1

    ####################################################################
    # handle_request_smart_unreg_exit
    ####################################################################
    def handle_request_smart_unreg_exit(self,
                                        cmd_runner: str) -> None:
        """Handle the request exit for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_request_smart_join_entry
    ####################################################################
    def handle_request_smart_join_entry(self,
                                        cmd_runner: str) -> None:
        """Handle the request entry for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]
        exp_first_round_completed: set[str] = set()
        delayed_remotes: set[str] = set()
        if pe[PE.current_request].timeout_type == TimeoutType.TimeoutTrue:
            timeout_remotes = pe[PE.current_request].timeout_remotes
        else:
            timeout_remotes = set()
            delayed_remotes: set[str] = pe[
                PE.current_request].timeout_remotes.copy()

        eligible_targets = (pe[PE.current_request].targets.copy()
                            - timeout_remotes)
        pe[PE.current_request].eligible_targets = eligible_targets
        pe[PE.current_request].completed_targets = set()
        for target in eligible_targets:
            if target in self.expected_registered:
                if self.expected_registered[
                        target].st_state == st.ThreadState.Stopped:
                    stop_key: ConfirmStopKey = (cmd_runner, target)
                    pe[PE.confirm_stop_msg][stop_key] += 1
                else:
                    state_key: SetStateKey = (cmd_runner,
                                              target,
                                              st.ThreadState.Alive,
                                              st.ThreadState.Stopped)
                    pe[PE.set_state_msg][state_key] += 1

                state_key: SetStateKey = (cmd_runner,
                                          target,
                                          st.ThreadState.Stopped,
                                          st.ThreadState.Unregistered)
                pe[PE.set_state_msg][state_key] += 1
                if (not self.expected_registered[target].is_alive
                        and self.expected_registered[
                        target].st_state == st.ThreadState.Alive):
                    exp_first_round_completed |= {target}
            else:
                if target in pe[PE.current_request].unreg_remotes:
                    unreg_key: AlreadyUnregKey = (cmd_runner, target)
                    pe[PE.already_unreg_msg][unreg_key] += 1
                    exp_first_round_completed |= {target}
                else:
                    raise InvalidConfigurationDetected(
                        f'handle_request_smart_join_entry {cmd_runner=} '
                        f'found {target=} is unregistered but not in the set '
                        f'of {pe[PE.current_request].unreg_remotes=}')

        if eligible_targets:
            sub_key: SubProcessKey = (cmd_runner,
                                      'smart_join',
                                      '_clean_registry',
                                      'entry',
                                      cmd_runner)
            pe[PE.subprocess_msg][sub_key] += 1
            self.log_test_msg(
                f'handle_request_smart_join_entry {cmd_runner=} added '
                f'subprocess_msg with {sub_key=} and bumped count to: '
                f'{pe[PE.subprocess_msg][sub_key]=}')

            sub_key: SubProcessKey = (cmd_runner,
                                      'smart_join',
                                      '_clean_pair_array',
                                      'entry',
                                      cmd_runner)
            pe[PE.subprocess_msg][sub_key] += 1

    ####################################################################
    # handle_request_smart_join_exit
    ####################################################################
    def handle_request_smart_join_exit(self,
                                       cmd_runner: str) -> None:
        """Handle the request exit for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_request_smart_send_entry
    ####################################################################
    def handle_request_smart_send_entry(self,
                                        cmd_runner: str) -> None:
        """Handle the request entry for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]

        # if pe[PE.current_request].timeout_type == TimeoutType.TimeoutTrue:
        #     timeout_remotes = pe[PE.current_request].timeout_remotes
        # else:
        #     timeout_remotes = set()
        #
        # eligible_targets = (pe[PE.current_request].targets.copy()
        #                     - timeout_remotes
        #                     - pe[PE.current_request].stopped_remotes)

        for target in pe[PE.current_request].exp_receivers:
            ack_key: AckKey = (target, 'smart_send')

            pe[PE.ack_msg][ack_key] += 1

    ####################################################################
    # handle_request_smart_send_exit
    ####################################################################
    def handle_request_smart_send_exit(self,
                                       cmd_runner: str) -> None:
        """Handle the request exit for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_request_smart_recv_entry
    ####################################################################
    def handle_request_smart_recv_entry(self,
                                        cmd_runner: str) -> None:
        """Handle the request entry for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]

        # if pe[PE.current_request].timeout_type == TimeoutType.TimeoutTrue:
        #     timeout_remotes = pe[PE.current_request].timeout_remotes
        # else:
        #     timeout_remotes = set()

        # eligible_targets = (pe[PE.current_request].targets.copy()
        #                     - timeout_remotes
        #                     - pe[PE.current_request].stopped_remotes)
        eligible_targets = pe[PE.current_request].exp_senders.copy()
        # self.log_test_msg(
        #     f'handle_request_smart_recv_entry {eligible_targets=}')
        for target in eligible_targets:
            # self.log_test_msg(f'handle_request_smart_recv_entry {target=}')
            ack_key: AckKey = (target, 'smart_recv')

            pe[PE.ack_msg][ack_key] += 1

    ####################################################################
    # handle_request_smart_recv_exit
    ####################################################################
    def handle_request_smart_recv_exit(self,
                                       cmd_runner: str) -> None:
        """Handle the request exit for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_request_smart_wait_entry
    ####################################################################
    def handle_request_smart_wait_entry(self,
                                        cmd_runner: str) -> None:
        """Handle the request entry for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]

        # if pe[PE.current_request].timeout_type == TimeoutType.TimeoutTrue:
        #     timeout_remotes = pe[PE.current_request].timeout_remotes
        # else:
        #     timeout_remotes = set()

        # eligible_targets = (pe[PE.current_request].targets.copy()
        #                     - timeout_remotes
        #                     - pe[PE.current_request].stopped_remotes
        #                     - pe[PE.current_request].deadlock_remotes)

        eligible_targets = pe[PE.current_request].exp_resumers.copy()
        for target in eligible_targets:
            ack_key: AckKey = (target, 'smart_wait')

            pe[PE.ack_msg][ack_key] += 1

    ####################################################################
    # handle_request_smart_wait_exit
    ####################################################################
    def handle_request_smart_wait_exit(self,
                                       cmd_runner: str) -> None:
        """Handle the request exit for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_request_smart_resume_entry
    ####################################################################
    def handle_request_smart_resume_entry(self,
                                          cmd_runner: str) -> None:
        """Handle the request entry for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]

        # if pe[PE.current_request].timeout_type == TimeoutType.TimeoutTrue:
        #     timeout_remotes = pe[PE.current_request].timeout_remotes
        # else:
        #     timeout_remotes = set()
        #
        # eligible_targets = (pe[PE.current_request].targets.copy()
        #                     - timeout_remotes
        #                     - pe[PE.current_request].stopped_remotes)

        for target in pe[PE.current_request].expected_resumed_targets:
            ack_key: AckKey = (target, 'smart_resume')

            pe[PE.ack_msg][ack_key] += 1

    ####################################################################
    # handle_request_smart_start_exit
    ####################################################################
    def handle_request_smart_resume_exit(self,
                                         cmd_runner: str) -> None:
        """Handle the request exit for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_request_smart_sync_entry
    ####################################################################
    def handle_request_smart_sync_entry(self,
                                        cmd_runner: str) -> None:
        """Handle the request entry for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]

        if pe[PE.current_request].timeout_type == TimeoutType.TimeoutTrue:
            timeout_remotes = pe[PE.current_request].timeout_remotes
        else:
            timeout_remotes = set()

        eligible_targets = (pe[PE.current_request].targets.copy()
                            - timeout_remotes
                            - pe[PE.current_request].stopped_remotes
                            - pe[PE.current_request].deadlock_remotes)

        for target in eligible_targets:
            ack_key: AckKey = (target, 'smart_sync_set')

            pe[PE.ack_msg][ack_key] += 1

            ack_key: AckKey = (target, 'smart_sync_achieved')

            pe[PE.ack_msg][ack_key] += 1

    ####################################################################
    # handle_request_smart_sync_exit
    ####################################################################
    def handle_request_smart_sync_exit(self,
                                       cmd_runner: str) -> None:
        """Handle the request exit for a request.

        Args:
            cmd_runner: thread name doing the request

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_request_entry_exit_log_msg
    ####################################################################
    def handle_request_refresh_log_msg(self,
                                       cmd_runner: str,
                                       request: str,
                                       targets: set[str],
                                       log_msg: str) -> None:
        """Handle the request refresh log msgs.

        Args:
            cmd_runner: name of thread doing the cmd
            request: smart request name
            targets: thread names of remaining targets
            log_msg: log message for the request

        """
        pe = self.pending_events[cmd_runner]

        targets_to_reset: set[str] = (pe[PE.current_request].targets
                                      - targets)

        ref_key: CallRefKey = request

        if pe[PE.calling_refresh_msg][ref_key] <= 0:
            raise UnexpectedEvent(
                f'handle_request_refresh_log_msg using {ref_key=} '
                f'detected unexpected log msg: {log_msg}'
            )

        pe[PE.calling_refresh_msg][ref_key] -= 1

        self.set_request_pending_flag(
            cmd_runner=cmd_runner,
            targets=targets_to_reset,
            pending_request_flag=False)

        sub_key: SubProcessKey = (cmd_runner,
                                  request,
                                  '_clean_registry',
                                  'entry',
                                  cmd_runner)
        pe[PE.subprocess_msg][sub_key] += 1

        sub_key: SubProcessKey = (cmd_runner,
                                  request,
                                  '_clean_pair_array',
                                  'entry',
                                  cmd_runner)
        pe[PE.subprocess_msg][sub_key] += 1

    ####################################################################
    # handle_recv_waiting_log_msg
    ####################################################################
    def handle_cmd_waiting_log_msg(self,
                                   cmd_runner: str) -> None:
        """Handle the send_cmd execution and log msgs.

        Args:
            cmd_runner: name of thread doing the cmd

        """
        # set the event for the cmd_runner
        self.cmd_waiting_event_items[cmd_runner].set()

    ####################################################################
    # handle_rem_reg_log_msg
    ####################################################################
    def handle_rem_reg_log_msg(self,
                               cmd_runner: str,
                               rem_name: str,
                               process: str,
                               log_msg: str
                          ) -> None:
        """Handle the removed from registry log message.

        Args:
            cmd_runner: thread name doing the cmd
            rem_name: thread name that was removed
            process: smart_thread request that was running
            log_msg: removed from registry log message

        """
        pe = self.pending_events[cmd_runner]

        rem_key: RemRegKey = (rem_name,
                              process)

        if pe[PE.rem_reg_msg][rem_key] <= 0:
            raise UnexpectedEvent(f'handle_rem_reg_log_msg encountered '
                                  f'unexpected log msg: {log_msg}')

        pe[PE.rem_reg_msg][rem_key] -= 1
        self.add_log_msg(re.escape(log_msg))

        # @sbt
        # del self.expected_registered[rem_name]

    ####################################################################
    # handle_add_pair_array_log_msg
    ####################################################################
    def handle_add_pair_array_log_msg(self,
                                      cmd_runner: str,
                                      pair_key: st.PairKey,
                                      log_msg) -> None:
        """Handle the reg update log msg.

        Args:
            cmd_runner: thread name adding entry to pair key
            pair_key: pair_key added to the pair_array
            log_msg: log message

        """
        pe = self.pending_events[cmd_runner]
        add_key: AddPaKey = (cmd_runner, pair_key)

        if pe[PE.add_pair_array_msg][add_key] <= 0:
            raise UnexpectedEvent(f'handle_add_pair_array_log_msg encountered '
                                  f'unexpected log msg: {log_msg}')

        pe[PE.add_pair_array_msg][add_key] -= 1
        self.add_log_msg(re.escape(log_msg))

    ####################################################################
    # handle_add_reg_log_msg
    ####################################################################
    def handle_add_reg_log_msg(self,
                               cmd_runner: str,
                               target: str,
                               log_msg: str) -> None:
        """Handle the reg update log msg.

        Args:
            cmd_runner: name of thread doing the cmd
            target: name of thread added to the registry
            log_msg: register update log message

        """
        pe = self.pending_events[cmd_runner]
        add_key: AddRegKey = (cmd_runner, target)

        if pe[PE.add_reg_msg][add_key] <= 0:
            raise UnexpectedEvent(f'handle_add_reg_log_msg using {add_key=} '
                                  'encountered unexpected '
                                  f'log msg: {log_msg}')

        pe[PE.add_reg_msg][add_key] -= 1
        self.add_log_msg(re.escape(log_msg))

        if target not in self.expected_registered:
            raise IncorrectDataDetected(
                f'handle_add_reg_log_msg detected {target=} is '
                'missing from expected_registered: '
                f'{self.expected_registered}')

        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]
        state_key: SetStateKey = (cmd_runner,
                                  target,
                                  st.ThreadState.Initializing,
                                  st.ThreadState.Registered)
        pe[PE.set_state_msg][state_key] += 1

    ####################################################################
    # handle_add_status_block_log_msg
    ####################################################################
    def handle_add_status_block_log_msg(self,
                                        cmd_runner: str,
                                        pair_key: st.PairKey,
                                        target: str,
                                        log_msg) -> None:
        """Handle the reg update log msg.

        Args:
            cmd_runner: thread name adding entry to pair key
            pair_key: pair_key added to the pair_array
            target: thread name added to status_block
            log_msg: log message

        """
        pe = self.pending_events[cmd_runner]
        add_key: AddStatusBlockKey = (cmd_runner, pair_key, target)

        if pe[PE.add_status_block_msg][add_key] <= 0:
            raise UnexpectedEvent('handle_add_status_block_log_msg using '
                                  f'{add_key=} encountered unexpected '
                                  f'log msg: {log_msg}')

        pe[PE.add_status_block_msg][add_key] -= 1
        self.add_log_msg(re.escape(log_msg))

    ####################################################################
    # handle_resume
    ####################################################################
    def handle_resume(self,
                      cmd_runner: str,
                      targets: set[str],
                      exp_resumed_targets: set[str],
                      stopped_remotes: set[str],
                      timeout: IntOrFloat,
                      timeout_names: set[str],
                      timeout_type: TimeoutType,
                      log_msg: Optional[str] = None) -> None:
        """Resume a waiter.

        Args:
            cmd_runner: thread doing the wait
            targets: names of threads to be resumed
            exp_resumed_targets: thread names that are expected to be resumed
            stopped_remotes: threads that are stopped and will result in
                a not alive error being raised
            timeout: timeout value for smart_resume
            timeout_names: names that will cause timeout
            timeout_type: None, False, or True
            log_msg: log msg for smart_resume
        """
        self.log_test_msg(f'handle_resume entry: {cmd_runner=}, {targets=}, '
                          f'{stopped_remotes=}, {timeout=}, {timeout_names=} '
                          f'{timeout_type=}')

        self.log_ver.add_call_seq(
            name='smart_resume',
            seq='test_smart_thread.py::ConfigVerifier.handle_resume')

        pe = self.pending_events[cmd_runner]
        pe[PE.start_request].append(
            StartRequest(req_type=st.ReqType.Smart_resume,
                         timeout_type=timeout_type,
                         targets=targets,
                         timeout_remotes=timeout_names,
                         stopped_remotes=stopped_remotes.copy(),
                         exp_resumed_targets=exp_resumed_targets))

        req_key_entry: RequestKey = ('smart_resume',
                                     'entry')

        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ('smart_resume',
                                    'exit')

        if stopped_remotes:
            with pytest.raises(st.SmartThreadRemoteThreadNotAlive):
                if timeout_type == TimeoutType.TimeoutNone:
                    self.all_threads[cmd_runner].smart_resume(
                        waiters=targets,
                        log_msg=log_msg)
                else:
                    self.all_threads[cmd_runner].smart_resume(
                        waiters=targets,
                        timeout=timeout,
                        log_msg=log_msg)

            resumed_targets = self.all_threads[cmd_runner].resumed_targets

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request='smart_resume',
                    targets=targets,
                    error_str='SmartThreadRemoteThreadNotAlive',
                    stopped_remotes=stopped_remotes),
                log_level=logging.ERROR)

        elif timeout_type == TimeoutType.TimeoutNone:
            pe[PE.request_msg][req_key_exit] += 1
            resumed_targets = self.all_threads[cmd_runner].smart_resume(
                waiters=targets,
                log_msg=log_msg)

        elif timeout_type == TimeoutType.TimeoutFalse:
            pe[PE.request_msg][req_key_exit] += 1
            resumed_targets = self.all_threads[cmd_runner].smart_resume(
                waiters=targets,
                timeout=timeout,
                log_msg=log_msg)

        elif timeout_type == TimeoutType.TimeoutTrue:
            with pytest.raises(st.SmartThreadRequestTimedOut):
                self.all_threads[cmd_runner].smart_resume(
                    waiters=targets,
                    timeout=timeout,
                    log_msg=log_msg)

            resumed_targets = self.all_threads[cmd_runner].resumed_targets

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request='smart_resume',
                    targets=targets,
                    error_str='SmartThreadRequestTimedOut',
                    stopped_remotes=stopped_remotes),
                log_level=logging.ERROR)

        assert exp_resumed_targets == resumed_targets
        # self.add_request_log_msg(cmd_runner=cmd_runner,
        #                          smart_request='smart_resume',
        #                          targets=targets,
        #                          timeout=timeout,
        #                          timeout_type=timeout_type,
        #                          enter_exit=enter_exit,
        #                          log_msg=log_msg)

        self.wait_for_monitor(cmd_runner=cmd_runner,
                              rtn_name='handle_resume')

        self.log_test_msg(f'handle_resume exit: {cmd_runner=}, {targets=}')

    ####################################################################
    # handle_send_msg
    ####################################################################
    def handle_send_msg(self,
                        cmd_runner: str,
                        receivers: set[str],
                        msgs_to_send: SendRecvMsgs,
                        msg_idx: int,
                        send_type: SendType,
                        log_msg: str,
                        timeout_type: TimeoutType = TimeoutType.TimeoutNone,
                        timeout: IntOrFloat = 0,
                        unreg_timeout_names: Optional[set[str]] = None,
                        fullq_timeout_names: Optional[set[str]] = None,
                        stopped_remotes: Optional[set[str]] = None) -> None:
        """Handle the send_cmd execution and log msgs.

        Args:
            cmd_runner: name of thread doing the cmd
            receivers: names of threads to receive the message
            msgs_to_send: message to send to the receivers
            msg_idx: index to use with msgs_to_send for this call
            send_type: specifies how to send the message
            log_msg: log message for smart_send to issue
            timeout_type: specifies None, False, or True
            timeout: value to use for timeout on the smart_send request
            unreg_timeout_names: names of threads that are unregistered
                and are expected to cause timeout
            fullq_timeout_names: names of threads whose msg_q is full
                and are expected to cause timeout
            stopped_remotes: names of threads that are stopped

        """
        self.log_test_msg(f'handle_send entry: {cmd_runner=}, {receivers=}, '
                          f'{send_type=}, {timeout_type=}, '
                          f'{unreg_timeout_names=}, {fullq_timeout_names=}, '
                          f'{stopped_remotes=}')
        self.log_ver.add_call_seq(
            name='smart_send',
            seq='test_smart_thread.py::ConfigVerifier.handle_send_msg')

        if send_type == SendType.Broadcast:
            receivers_to_use = set()
            exp_receivers = set()
            for remote, thread_tracker in self.expected_registered.items():
                if remote == cmd_runner:
                    continue
                if thread_tracker.st_state == st.ThreadState.Alive:
                    exp_receivers |= {remote}
        else:
            receivers_to_use = receivers.copy()
            exp_receivers = receivers.copy()

        timeout_remotes = set()
        if timeout_type == TimeoutType.TimeoutTrue and unreg_timeout_names:
            timeout_remotes |= unreg_timeout_names
        if fullq_timeout_names:
            timeout_remotes |= fullq_timeout_names

        exp_receivers -= timeout_remotes

        if stopped_remotes:
            exp_receivers -= stopped_remotes

        pe = self.pending_events[cmd_runner]
        pe[PE.start_request].append(
            StartRequest(req_type=st.ReqType.Smart_send,
                         timeout_type=timeout_type,
                         targets=receivers_to_use,
                         timeout_remotes=timeout_remotes,
                         stopped_remotes=stopped_remotes.copy(),
                         exp_receivers=exp_receivers))

        req_key_entry: RequestKey = ('smart_send',
                                     'entry')

        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ('smart_send',
                                    'exit')

        elapsed_time: float = 0
        start_time = time.time()

        if send_type == SendType.SRMsgs:
            # for a smart_send using the SendMsgs option, we need to
            # build a SendMsgs dict from the SendRecvMsgs test messages
            send_msg = msgs_to_send.get_send_msgs(sender_name=cmd_runner,
                                                  receiver_names=receivers,
                                                  msg_idx=msg_idx)
        else:
            send_msg = msgs_to_send.get_broadcast_msg(
                sender_name=cmd_runner,
                receiver_names=receivers,
                msg_idx=msg_idx)

        if stopped_remotes:
            with pytest.raises(st.SmartThreadRemoteThreadNotAlive):
                if timeout_type == TimeoutType.TimeoutNone:
                    self.all_threads[cmd_runner].smart_send(
                        receivers=receivers_to_use,
                        msg=send_msg,
                        log_msg=log_msg)
                else:
                    self.all_threads[cmd_runner].smart_send(
                        receivers=receivers_to_use,
                        msg=send_msg,
                        timeout=timeout,
                        log_msg=log_msg)

            sent_targets = self.all_threads[cmd_runner].sent_targets

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request='smart_send',
                    targets=receivers_to_use,
                    error_str='SmartThreadRemoteThreadNotAlive',
                    stopped_remotes=stopped_remotes),
                log_level=logging.ERROR)

        elif timeout_type == TimeoutType.TimeoutNone:
            pe[PE.request_msg][req_key_exit] += 1
            sent_targets = self.all_threads[cmd_runner].smart_send(
                receivers=receivers_to_use,
                msg=send_msg,
                log_msg=log_msg)
            elapsed_time += (time.time() - start_time)
        elif timeout_type == TimeoutType.TimeoutFalse:
            pe[PE.request_msg][req_key_exit] += 1
            sent_targets = self.all_threads[cmd_runner].smart_send(
                receivers=receivers_to_use,
                msg=send_msg,
                timeout=timeout,
                log_msg=log_msg)
            elapsed_time += (time.time() - start_time)
        elif timeout_type == TimeoutType.TimeoutTrue:
            with pytest.raises(st.SmartThreadRequestTimedOut):
                self.all_threads[cmd_runner].smart_send(
                    receivers=receivers_to_use,
                    msg=send_msg,
                    timeout=timeout,
                    log_msg=log_msg)
            elapsed_time += (time.time() - start_time)

            sent_targets = self.all_threads[cmd_runner].sent_targets

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request='smart_send',
                    targets=receivers_to_use,
                    error_str='SmartThreadRequestTimedOut',
                    stopped_remotes=set(stopped_remotes)),
                log_level=logging.ERROR)

        assert sent_targets == exp_receivers

        mean_elapsed_time = elapsed_time / len(receivers)
        self.log_test_msg(f'handle_send exit: {cmd_runner=} '
                          f'{elapsed_time=}, {len(receivers)=} '
                          f'{mean_elapsed_time=}')

    ####################################################################
    # handle_set_state_log_msg
    ####################################################################
    def handle_set_state_log_msg(self,
                                 cmd_runner: str,
                                 target: str,
                                 from_state: st.ThreadState,
                                 to_state: st.ThreadState,
                                 log_msg: str) -> None:
        """Handle the set state log msgs.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name whose state is being changed
            from_state: state being changed from
            to_state: ste being changed to
            log_msg: log message that is being processed

        Raises:
            UnexpectedEvent: handle_set_state_log_msg encountered
                unexpected log msg
            IncorrectDataDetected: handle_set_state_log_msg detected
                target is missing from expected_registered or current
                state does not match
        """
        pe = self.pending_events[cmd_runner]
        state_key: SetStateKey = (cmd_runner,
                                  target,
                                  from_state,
                                  to_state)
        if pe[PE.set_state_msg][state_key] <= 0:
            raise UnexpectedEvent('handle_set_state_log_msg using '
                                  f'{state_key=} encountered '
                                  f'unexpected log msg: {log_msg}')

        pe[PE.set_state_msg][state_key] -= 1
        self.add_log_msg(log_msg)

        if to_state != st.ThreadState.Unregistered:
            if target not in self.expected_registered:
                raise IncorrectDataDetected(
                    f'handle_set_state_log_msg detected {target=} is '
                    'missing from expected_registered: '
                    f'{self.expected_registered}')

            if self.expected_registered[target].st_state != from_state:
                raise IncorrectDataDetected(
                    'handle_set_state_log_msg detected current state '
                    f'{self.expected_registered[target].st_state=} '
                    f'does not match {from_state=} for {target=}')

            # looks good, set new state
            self.expected_registered[target].st_state = to_state

        ################################################################
        # Determine next action
        ################################################################
        ################################################################
        # call handler for request
        ################################################################
        actions: dict[tuple[st.ThreadState, st.ThreadState],
                      Callable[..., None]] = {
            (st.ThreadState.Unregistered, st.ThreadState.Initializing):
                self.handle_set_state_unreg_to_init,
            (st.ThreadState.Initializing, st.ThreadState.Registered):
                self.handle_set_state_init_to_reg,
            (st.ThreadState.Registered, st.ThreadState.Starting):
                self.handle_set_state_reg_to_start,
            (st.ThreadState.Registered, st.ThreadState.Alive):
                self.handle_set_state_reg_to_alive,
            (st.ThreadState.Starting, st.ThreadState.Alive):
                self.handle_set_state_start_to_alive,
            (st.ThreadState.Registered, st.ThreadState.Stopped):
                self.handle_set_state_reg_to_stop,
            (st.ThreadState.Alive, st.ThreadState.Stopped):
                self.handle_set_state_alive_to_stop,
            (st.ThreadState.Stopped, st.ThreadState.Unregistered):
                self.handle_set_state_stop_to_unreg,
        }

        actions[(from_state, to_state)](cmd_runner=cmd_runner,
                                        target=target)

    ####################################################################
    # handle_set_state_unreg_to_init
    ####################################################################
    def handle_set_state_unreg_to_init(self,
                                       cmd_runner: str,
                                       target: str) -> None:
        """Determine next step for set state.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name getting its state changed

        """
        ################################################################
        # next step is register
        ################################################################
        pass

    ####################################################################
    # handle_set_state_init_to_reg
    ####################################################################
    def handle_set_state_init_to_reg(self,
                                     cmd_runner: str,
                                     target: str) -> None:
        """Determine next step for set state.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name getting its state changed

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]
        if self.expected_registered[target].exp_init_is_alive:
            key: SetStateKey = (cmd_runner,
                                target,
                                st.ThreadState.Registered,
                                st.ThreadState.Alive)
            pe[PE.set_state_msg][key] += 1
        else:  # skip the reg to alive msg, proceed to reg add
            sub_key: SubProcessKey = (cmd_runner,
                                      'smart_init',
                                      '_add_to_pair_array',
                                      'entry',
                                      target)
            pe[PE.subprocess_msg][sub_key] += 1

    ####################################################################
    # handle_set_state_reg_to_start
    ####################################################################
    def handle_set_state_reg_to_start(self,
                                      cmd_runner: str,
                                      target: str) -> None:
        """Determine next step for set state.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name getting its state changed

        """
        ################################################################
        # determine next step
        ################################################################
        # @sbt - need to think about non-ThreadTarget cases ending
        # before we get back control from the threading start method,
        # in which case we will need to expected a set state from
        # starting to stopped
        pe = self.pending_events[cmd_runner]
        key: SetStateKey = (cmd_runner,
                            target,
                            st.ThreadState.Starting,
                            st.ThreadState.Alive)
        pe[PE.set_state_msg][key] += 1

    ####################################################################
    # handle_set_state_reg_to_alive
    ####################################################################
    def handle_set_state_reg_to_alive(self,
                                      cmd_runner: str,
                                      target: str) -> None:
        """Determine next step for set state.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name getting its state changed

        """
        self.expected_registered[target].is_alive = True

        ################################################################
        # next step is to add entry to pair array
        ################################################################
        pe = self.pending_events[cmd_runner]
        sub_key: SubProcessKey = (cmd_runner,
                                  'smart_init',
                                  '_add_to_pair_array',
                                  'entry',
                                  target)
        pe[PE.subprocess_msg][sub_key] += 1

    ####################################################################
    # handle_set_state_start_to_alive
    ####################################################################
    def handle_set_state_start_to_alive(self,
                                        cmd_runner: str,
                                        target: str) -> None:
        """Determine next step for set state.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name getting its state changed

        """
        self.expected_registered[target].is_alive = True

        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]
        pe[PE.num_targets_remaining] -= 1
        # if pe.num_targets_remaining == 0:
        #     req_key: RequestKey = ('smart_start',
        #                            'exit')
        #
        #     pe.request_msg[req_key] += 1

    ####################################################################
    # handle_set_state_reg_to_stop
    ####################################################################
    def handle_set_state_reg_to_stop(self,
                                     cmd_runner: str,
                                     target: str) -> None:
        """Determine next step for set state.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name getting its state changed

        """
        pass
        ################################################################
        # next step is register
        ################################################################
        # pe = self.pending_events[cmd_runner]
        # sub_key: SubProcessKey = (cmd_runner,
        #                           'smart_unreg',
        #                           '_clean_registry',
        #                           'entry',
        #                           target)
        # pe[PE.subprocess_msg][sub_key] += 1

    ####################################################################
    # handle_set_state_alive_to_stop
    ####################################################################
    def handle_set_state_alive_to_stop(self,
                                       cmd_runner: str,
                                       target: str) -> None:
        """Determine next step for set state.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name getting its state changed

        """
        self.expected_registered[target].is_alive = False

        ################################################################
        # next step is register
        ################################################################
        # pe = self.pending_events[cmd_runner]
        # if pe[PE.current_request].req_type == st.ReqType.Smart_join:
        #     sub_key: SubProcessKey = (cmd_runner,
        #                               'smart_join',
        #                               '_clean_registry',
        #                               'entry',
        #                               target)
        #     pe[PE.subprocess_msg][sub_key] += 1

    ####################################################################
    # handle_set_state_alive_to_stop
    ####################################################################
    def handle_set_state_stop_to_unreg(self,
                                      cmd_runner: str,
                                      target: str) -> None:
        """Determine next step for set state.

        Args:
            cmd_runner: thread name doing the state change
            target: thread name getting its state changed

        """
        pass

    ####################################################################
    # handle_start
    ####################################################################
    def handle_start(self,
                     cmd_runner: str,
                     start_names: set[str],
                     unreg_remotes: Optional[set[str]] = None,
                     log_msg: Optional[str] = None) -> None:
        """Start the named thread.

        Args:
            cmd_runner: thread doing the starts
            start_names: names of the threads to start
            unreg_remotes: names of threads that are not in the
                registered state
            log_msg: message for log
        """
        self.log_test_msg(f'{cmd_runner=} handle_start entry '
                          f'for {start_names=}')

        self.log_ver.add_call_seq(
            name='smart_start',
            seq='test_smart_thread.py::ConfigVerifier.handle_start')

        if unreg_remotes:
            not_reg_remotes = unreg_remotes
        else:
            not_reg_remotes = set()

        pe = self.pending_events[cmd_runner]
        pe[PE.start_request].append(
            StartRequest(req_type=st.ReqType.Smart_start,
                         targets=start_names,
                         unreg_remotes=set(),
                         not_registered_remotes=not_reg_remotes,
                         timeout_remotes=set(),
                         stopped_remotes=set(),
                         deadlock_remotes=set(),
                         eligible_targets=set(),
                         completed_targets=set(),
                         first_round_completed=set(),
                         stopped_target_threads=set(),
                         exp_senders=set(),
                         exp_resumers=set()))

        req_key_entry: RequestKey = ('smart_start',
                                     'entry')

        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ('smart_start',
                                    'exit')

        exp_started_names = start_names
        # enter_exit = ('entry', 'exit')
        if unreg_remotes:
            exp_started_names -= unreg_remotes
            # enter_exit = ('entry',)
            with pytest.raises(st.SmartThreadRemoteThreadNotRegistered):
                self.all_threads[cmd_runner].smart_start(
                    targets=start_names,
                    log_msg=log_msg)

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request='smart_start',
                    targets=start_names,
                    error_str='SmartThreadRemoteThreadNotRegistered',
                    unreg_remotes=unreg_remotes),
                log_level=logging.ERROR)
        else:
            pe[PE.request_msg][req_key_exit] += 1
            self.all_threads[cmd_runner].smart_start(
                targets=start_names,
                log_msg=log_msg)

        # for start_name in exp_started_names:
        #     self.add_log_msg(
        #         f'{cmd_runner} set state for thread {start_name} '
        #         'from ThreadState.Registered to ThreadState.Starting')
        #     self.add_log_msg(
        #         f'{cmd_runner} set state for thread {start_name} '
        #         f'from ThreadState.Starting to ThreadState.Alive')
        #
        # self.add_request_log_msg(cmd_runner=cmd_runner,
        #                          smart_request='smart_start',
        #                          targets=start_names,
        #                          timeout=0,
        #                          timeout_type=TimeoutType.TimeoutNone,
        #                          enter_exit=enter_exit,
        #                          log_msg=None)

        self.monitor_event.set()
        if exp_started_names:
            self.wait_for_monitor(cmd_runner=cmd_runner,
                                  rtn_name='handle_start')

        self.log_test_msg(f'{cmd_runner=} handle_start exiting '
                          f'for {start_names=}')

    ####################################################################
    # handle_start_request_log_msg
    ####################################################################
    def handle_start_request_log_msg(self,
                                     cmd_runner: str,
                                     req_start_item: StartRequest) -> None:
        """Process the start request event.

        Args:
            cmd_runner: thread name doing the request
            req_start_item: contains the request specifics

        """
        self.log_test_msg(f'handle_start_request_log_msg entered, '
                          f'{cmd_runner=}, {req_start_item=}')
        eligible_targets: set[str] = set()
        self.pending_events[cmd_runner][PE.current_request] = req_start_item
        if req_start_item.req_type == st.ReqType.Smart_start:
            eligible_targets = (req_start_item.targets.copy()
                                - req_start_item.not_registered_remotes.copy())
            from_state = st.ThreadState.Registered
            to_state = st.ThreadState.Alive
        elif req_start_item.req_type == st.ReqType.Smart_unreg:
            eligible_targets = (req_start_item.targets.copy()
                                - req_start_item.not_registered_remotes.copy())
            from_state = st.ThreadState.Registered
            to_state = st.ThreadState.Stopped

        elif req_start_item.req_type == st.ReqType.Smart_join:
            pre_eligible_targets = (req_start_item.targets.copy()
                                   - req_start_item.timeout_remotes.copy())
            for name in pre_eligible_targets:
                if (name in self.expected_registered
                        and self.expected_registered[name].is_TargetThread):
                    eligible_targets |= {name}

            from_state = st.ThreadState.Alive
            to_state = st.ThreadState.Stopped
        else:
            raise UnrecognizedCmd('handle_start_request_log_msg does not '
                                  f'recognize {req_start_item.req_type=}')

        for name in eligible_targets:
            key: SetStateKey = (cmd_runner,
                                name,
                                from_state,
                                to_state)
            self.pending_events[cmd_runner][PE.set_state_msg][key] += 1

    ####################################################################
    # handle_subprocess_entry_exit_log_msg
    ####################################################################
    def handle_subprocess_entry_exit_log_msg(self,
                                             cmd_runner: str,
                                             request_name: str,
                                             subprocess_name: str,
                                             entry_exit: str,
                                             target: str,
                                             log_msg: str) -> None:
        """Handle the subprocess message for a request.

        Args:
            cmd_runner: thread name doing the request
            request_name: request that is calling subprocess
            subprocess_name: subprocess being done
            entry_exit: specifies whether entry or exit of subprocess
            target: thread name of smart_thread
            log_msg: entry or exit log message for subprocess

        """
        pe = self.pending_events[cmd_runner]
        sub_key: SubProcessKey = (cmd_runner,
                                  request_name,
                                  subprocess_name,
                                  entry_exit,
                                  target)
        if pe[PE.subprocess_msg][sub_key] <= 0:
            error_msg = (
                f'handle_subprocess_entry_exit_log_msg using {sub_key=}, '
                f'{pe[PE.subprocess_msg]=}, '
                f'encountered unexpected log msg: {log_msg}')
            self.log_test_msg(error_msg)
            self.abort_all_f1_threads()
            raise UnexpectedEvent(error_msg)

        pe[PE.subprocess_msg][sub_key] -= 1
        self.add_log_msg(log_msg)

        ################################################################
        # call handler for subprocess
        ################################################################
        actions: dict[tuple[str, str], Callable[..., None]] = {
            ('_register', 'entry'):
                self.handle_subprocess_register_entry,
            ('_register', 'exit'):
                self.handle_subprocess_register_exit,
            ('_clean_registry', 'entry'):
                self.handle_subprocess_clean_registry_entry,
            ('_clean_registry', 'exit'):
                self.handle_subprocess_clean_registry_exit,
            ('_clean_pair_array', 'entry'):
                self.handle_subprocess_clean_pair_array_entry,
            ('_clean_pair_array', 'exit'):
                self.handle_subprocess_clean_pair_array_exit,
            ('_add_to_pair_array', 'entry'):
                self.handle_subprocess_add_to_pair_array_entry,
            ('_add_to_pair_array', 'exit'):
                self.handle_subprocess_add_to_pair_array_exit,
        }

        actions[(subprocess_name, entry_exit)](cmd_runner=cmd_runner,
                                               request_name=request_name,
                                               target=target)

    ####################################################################
    # handle_subprocess_register_entry
    ####################################################################
    def handle_subprocess_register_entry(self,
                                         cmd_runner: str,
                                         request_name: str,
                                         target: str) -> None:
        """Handle the subprocess entry for a request.

        Args:
            cmd_runner: thread name doing the request
            request_name: request that is calling subprocess
            target: thread name of smart_thread

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_subprocess_register_exit
    ####################################################################
    def handle_subprocess_register_exit(self,
                                        cmd_runner: str,
                                        request_name: str,
                                        target: str) -> None:
        """Handle the subprocess exit for a request.

        Args:
            cmd_runner: thread name doing the request
            request_name: request that is calling subprocess
            target: thread name of smart_thread

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]

        if (self.expected_registered[target].auto_start_decision
                == AutoStartDecision.auto_start_yes):
            pe[PE.save_current_request] = pe[PE.current_request]
            pe[PE.start_request].append(
                StartRequest(req_type=st.ReqType.Smart_start,
                             targets={target},
                             unreg_remotes=set(),
                             not_registered_remotes=set(),
                             timeout_remotes=set(),
                             stopped_remotes=set(),
                             deadlock_remotes=set(),
                             eligible_targets=set(),
                             completed_targets=set(),
                             first_round_completed=set(),
                             stopped_target_threads=set(),
                             exp_senders=set(),
                             exp_resumers=set()))

            req_key_entry: RequestKey = ('smart_start',
                                         'entry')

            pe[PE.request_msg][req_key_entry] += 1

            req_key_exit: RequestKey = ('smart_start',
                                        'exit')

            pe[PE.request_msg][req_key_exit] += 1

    ####################################################################
    # handle_subprocess_clean_registry_entry
    ####################################################################
    def handle_subprocess_clean_registry_entry(self,
                                               cmd_runner: str,
                                               request_name: str,
                                               target: str) -> None:
        """Handle the subprocess entry for a request.

        Args:
            cmd_runner: thread name doing the request
            request_name: request that is calling subprocess
            target: thread name of smart_thread

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]

        self.clean_registry(cmd_runner=cmd_runner,
                            target=target)

        sub_key: SubProcessKey = (cmd_runner,
                                  request_name,
                                  '_clean_registry',
                                  'exit',
                                  cmd_runner)
        pe[PE.subprocess_msg][sub_key] += 1

    ####################################################################
    # handle_subprocess_clean_registry_exit
    ####################################################################
    def handle_subprocess_clean_registry_exit(self,
                                              cmd_runner: str,
                                              request_name: str,
                                              target: str) -> None:
        """Handle the subprocess exit for a request.

        Args:
            cmd_runner: thread name doing the request
            request_name: request that is calling subprocess
            target: thread name of smart_thread

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_subprocess_clean_pair_array_entry
    ####################################################################
    def handle_subprocess_clean_pair_array_entry(self,
                                                 cmd_runner: str,
                                                 request_name: str,
                                                 target: str) -> None:
        """Handle the subprocess entry for a request.

        Args:
            cmd_runner: thread name doing the request
            request_name: request that is calling subprocess
            target: thread name of smart_thread

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]
        # if commander is initializing, pair array is empty

        if not (request_name == 'smart_init'
                and self.commander_name in pe[PE.current_request].targets):
            self.clean_pair_array(cmd_runner=cmd_runner)

        sub_key: SubProcessKey = (cmd_runner,
                                  request_name,
                                  '_clean_pair_array',
                                  'exit',
                                  cmd_runner)
        pe[PE.subprocess_msg][sub_key] += 1

    ####################################################################
    # handle_subprocess_clean_pair_array_exit
    ####################################################################
    def handle_subprocess_clean_pair_array_exit(self,
                                                cmd_runner: str,
                                                request_name: str,
                                                target: str) -> None:
        """Handle the subprocess exit for a request.

        Args:
            cmd_runner: thread name doing the request
            request_name: request that is calling subprocess
            target: thread name of smart_thread

        """
        ################################################################
        # determine next step
        ################################################################
        pass

    ####################################################################
    # handle_subprocess_add_to_pair_array_entry
    ####################################################################
    def handle_subprocess_add_to_pair_array_entry(self,
                                                  cmd_runner: str,
                                                  request_name: str,
                                                  target: str) -> None:
        """Handle the subprocess entry for a request.

        Args:
            cmd_runner: thread name doing the request
            request_name: request that is calling subprocess
            target: thread name of smart_thread

        """
        pe = self.pending_events[cmd_runner]
        # add_to_pair_array returns true if pair array was updated
        if self.add_to_pair_array(cmd_runner=cmd_runner,
                                  add_name=target):
            pe[PE.update_pair_array_utc_msg] += 1

        ################################################################
        # determine next step
        ################################################################

        sub_key: SubProcessKey = (cmd_runner,
                                  request_name,
                                  '_add_to_pair_array',
                                  'exit',
                                  target)
        pe[PE.subprocess_msg][sub_key] += 1

    ####################################################################
    # handle_subprocess_add_to_pair_array_exit
    ####################################################################
    def handle_subprocess_add_to_pair_array_exit(self,
                                                 cmd_runner: str,
                                                 request_name: str,
                                                 target: str) -> None:
        """Handle the subprocess exit for a request.

        Args:
            cmd_runner: thread name doing the request
            request_name: request that is calling subprocess
            target: thread name of smart_thread

        """
        ################################################################
        # determine next step
        ################################################################
        pe = self.pending_events[cmd_runner]
        sub_key: SubProcessKey = (cmd_runner,
                                  request_name,
                                  '_register',
                                  'exit',
                                  target)
        pe[PE.subprocess_msg][sub_key] += 1

    ####################################################################
    # wait_for_monitor
    ####################################################################
    def wait_for_monitor(self,
                         cmd_runner: str,
                         rtn_name: str) -> None:
        """Start the named thread.

        Args:
            cmd_runner: thread doing the starts
            rtn_name: name of rtn that will wait

        """
        with self.ops_lock:
            self.cmd_waiting_event_items[cmd_runner] = threading.Event()
        self.log_test_msg(
            f'{cmd_runner=} {rtn_name} waiting for monitor')
        self.monitor_event.set()
        self.cmd_waiting_event_items[cmd_runner].wait()
        with self.ops_lock:
            del self.cmd_waiting_event_items[cmd_runner]

    ####################################################################
    # handle_stopped_log_msg
    ####################################################################
    def handle_stopped_log_msg(self,
                               cmd_runner: str,
                               stopped_name: str,
                               log_idx) -> None:
        """Set the status for a thread that was stopped.

        Args:
            cmd_runner: the names of the thread that did the stop
            stopped_name: name of thread that was stopped
            log_idx: index of stopped log msg

        """
        with self.ops_lock:
            self.recently_stopped[stopped_name] = log_idx
            if stopped_name in self.expected_registered:
                self.expected_registered[stopped_name].is_alive = False
            self.stopped_event_items[cmd_runner].targets.remove(stopped_name)
            if not self.stopped_event_items[cmd_runner].targets:
                self.stopped_event_items[cmd_runner].client_event.set()

    ####################################################################
    # handle_sync
    ####################################################################
    def handle_sync(self,
                    cmd_runner: str,
                    targets: set[str],
                    timeout: IntOrFloat,
                    timeout_remotes: set[str],
                    stopped_remotes: set[str],
                    conflict_remotes: set[str],
                    timeout_type: TimeoutType,
                    log_msg: Optional[str] = None) -> None:
        """Issue smart_sync.

        Args:
            cmd_runner: the names of the thread that did the stop
            targets: name of remotes to sync with
            timeout: value to use for timeout
            timeout_remotes: names of threads that cause timeout
            stopped_remotes: remotes that will cause a not alive error
            conflict_remotes: remotes that are doing a wait instead
                of a sync which will cause a deadlock
            timeout_type: specifies whether timeout is None, False, or
                True
            log_msg: log msg to be specified with the sync request
        """
        self.log_test_msg(f'{cmd_runner=} handle_sync entry for '
                          f'{targets=}, {timeout_type=}, {timeout_remotes=}, '
                          f'{stopped_remotes=}, {conflict_remotes=}')

        self.log_ver.add_call_seq(
            name='smart_sync',
            seq='test_smart_thread.py::ConfigVerifier.handle_sync')

        pe = self.pending_events[cmd_runner]
        pe[PE.start_request].append(
            StartRequest(req_type=st.ReqType.Smart_sync,
                         timeout_type=timeout_type,
                         targets=targets,
                         unreg_remotes=set(),
                         not_registered_remotes=set(),
                         timeout_remotes=timeout_remotes,
                         stopped_remotes=stopped_remotes.copy(),
                         deadlock_remotes=conflict_remotes,
                         eligible_targets=set(),
                         completed_targets=set(),
                         first_round_completed=set(),
                         stopped_target_threads=set(),
                         exp_senders=set(),
                         exp_resumers=set()))

        req_key_entry: RequestKey = ('smart_sync',
                                     'entry')
        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ('smart_sync',
                                    'exit')

        assert targets
        exp_completed_syncs: set[str] = targets.copy()
        # enter_exit = ('entry', 'exit')
        if stopped_remotes:
            exp_completed_syncs -= stopped_remotes
            exp_completed_syncs -= timeout_remotes
            # enter_exit = ('entry',)
            assert targets
            with pytest.raises(st.SmartThreadRemoteThreadNotAlive):
                if timeout_type == TimeoutType.TimeoutNone:
                    self.all_threads[cmd_runner].smart_sync(
                        targets=targets,
                        log_msg=log_msg)
                else:
                    self.all_threads[cmd_runner].smart_sync(
                        targets=targets,
                        timeout=timeout,
                        log_msg=log_msg)

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request='smart_sync',
                    targets=targets,
                    error_str='SmartThreadRemoteThreadNotAlive',
                    stopped_remotes=stopped_remotes,
                    conflict_remotes=conflict_remotes),
                log_level=logging.ERROR)

        elif conflict_remotes:
            # enter_exit = ('entry',)
            with pytest.raises(st.SmartThreadConflictDeadlockDetected):
                if timeout_type == TimeoutType.TimeoutNone:
                    self.all_threads[cmd_runner].smart_sync(
                        targets=targets,
                        log_msg=log_msg)
                else:
                    self.all_threads[cmd_runner].smart_sync(
                        targets=targets,
                        timeout=timeout,
                        log_msg=log_msg)

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request='smart_sync',
                    targets=targets,
                    error_str='SmartThreadConflictDeadlockDetected',
                    stopped_remotes=stopped_remotes,
                    conflict_remotes=conflict_remotes),
                log_level=logging.ERROR)

        elif timeout_type == TimeoutType.TimeoutNone:
            pe[PE.request_msg][req_key_exit] += 1
            self.all_threads[cmd_runner].smart_sync(
                targets=targets,
                log_msg=log_msg)

        elif timeout_type == TimeoutType.TimeoutFalse:
            pe[PE.request_msg][req_key_exit] += 1
            self.all_threads[cmd_runner].smart_sync(
                targets=targets,
                timeout=timeout,
                log_msg=log_msg)

        elif timeout_type == TimeoutType.TimeoutTrue:
            exp_completed_syncs -= stopped_remotes
            exp_completed_syncs -= timeout_remotes
            # enter_exit = ('entry',)
            with pytest.raises(st.SmartThreadRequestTimedOut):
                self.all_threads[cmd_runner].smart_sync(
                    targets=targets,
                    timeout=timeout,
                    log_msg=log_msg)

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request='smart_sync',
                    targets=targets,
                    error_str='SmartThreadRequestTimedOut',
                    pending_remotes=timeout_remotes,
                    stopped_remotes=stopped_remotes,
                    conflict_remotes=conflict_remotes),
                log_level=logging.ERROR)

        # self.add_request_log_msg(cmd_runner=cmd_runner,
        #                          smart_request='smart_sync',
        #                          targets=targets,
        #                          timeout=timeout,
        #                          timeout_type=timeout_type,
        #                          enter_exit=enter_exit,
        #                          log_msg=log_msg)

        self.monitor_event.set()

        if exp_completed_syncs:
            self.wait_for_monitor(cmd_runner=cmd_runner,
                                  rtn_name='handle_sync')

        self.log_test_msg(f'{cmd_runner=} handle_sync exit for '
                          f'{targets=}')

    ####################################################################
    # get_request_log_msg
    ####################################################################
    def add_request_log_msg(self,
                            cmd_runner: str,
                            smart_request: str,
                            targets: set[str],
                            timeout: IntOrFloat,
                            timeout_type: TimeoutType,
                            enter_exit: tuple[str, ...],
                            log_msg: Optional[str] = None) -> None:
        """Build and add the request log message.

        Args:
            cmd_runner: thread doing the request
            smart_request: name of smart_request
            targets: target of the smart request
            timeout: timeout value
            timeout_type: None, False, True
            enter_exit: enter and exit or just enter
            log_msg: log message to append

        """
        log_msg_body = re.escape(f'requestor: {cmd_runner} '
                                 f'targets: {sorted(targets)} ')
        if timeout > 0 and timeout_type != TimeoutType.TimeoutNone:
            log_msg_body += f'timeout value: {timeout} '
        else:
            log_msg_body += 'timeout value: None '

        # do not use re.escape for call sequence - it has regex
        log_msg_body += f'{self.log_ver.get_call_seq(smart_request)}'

        if log_msg:
            log_msg_body += f' {re.escape(log_msg)}'

        for enter_exit in enter_exit:
            self.add_log_msg(f'{smart_request} {enter_exit}: {log_msg_body}')

    ####################################################################
    # get_timeout_msg
    ####################################################################
    def get_error_msg(self,
                      cmd_runner: str,
                      smart_request: str,
                      targets: set[str],
                      error_str: str,
                      pending_remotes: Optional[set[str]] = None,
                      stopped_remotes: Optional[set[str]] = None,
                      unreg_remotes: Optional[set[str]] = None,
                      conflict_remotes: Optional[set[str]] = None,
                      deadlock_remotes: Optional[set[str]] = None,
                      full_send_q_remotes: Optional[set[str]] = None
                      ) -> str:
        """Build the timeout message.

        Args:
            cmd_runner: thread doing the request
            smart_request: name of smart_request
            targets: target of the smart request
            error_str: smart_thread error as string
            pending_remotes: names of threads that are pending
            stopped_remotes: names of threads that are stopped
            unreg_remotes: names of threads that are not registered
            conflict_remotes: names of sync/wait deadlock threads
            deadlock_remotes: names of wait/wait deadlock threads
            full_send_q_remotes: names threads whose send_q is full

        Returns:
            error msg string for log and raise

        """
        targets_msg = re.escape(
            f'while processing a {smart_request} '
            f'request with targets '
            f'{sorted(targets)}.')

        if not pending_remotes:
            if smart_request in ('smart_join', 'smart_start', 'smart_unreg'):
                pending_remotes = self.all_threads[
                    cmd_runner].work_remotes
            else:
                pending_remotes = [
                    remote for pk, remote, _ in self.all_threads[
                        cmd_runner].work_pk_remotes]
        # pending_msg = re.escape(
        #     f' Remotes that are pending: '
        #     f'{sorted(pending_remotes)}.')

        pending_msg = (
            r" Remotes that are pending: \[([a-z0-9_]*|,|'| )*\].")

        if stopped_remotes:
            stopped_msg = re.escape(
                ' Remotes that are stopped: '
                f'{sorted(stopped_remotes)}.')
        else:
            stopped_msg = ''

        # stopped_msg = (
        #     r" Remotes that are stopped: \[([a-z0-9_]*|,|'| )*\].")

        if unreg_remotes:
            unreg_msg = re.escape(
                ' Remotes that are not registered: '
                f'{sorted(unreg_remotes)}.')
        else:
            unreg_msg = ''

        if deadlock_remotes or conflict_remotes:
            dr_search = r"\[(,| "
            for name in deadlock_remotes | conflict_remotes:
                dr_search += "|'" + name + "'"
            dr_search += r")+\]"
            deadlock_msg = (f' Remotes doing a smart_wait '
                            'request that are deadlocked: '
                            f'{dr_search}.')
        else:
            deadlock_msg = ''

        if full_send_q_remotes:
            full_send_q_msg = (
                f' Remotes who have a full send_q: '
                f'{sorted(full_send_q_remotes)}.')
        else:
            full_send_q_msg = ''

        return (
            f'{cmd_runner} raising {error_str} {targets_msg}'
            f'{pending_msg}{stopped_msg}{unreg_msg}'
            f'{deadlock_msg}{full_send_q_msg}')

    ####################################################################
    # handle_unregister
    ####################################################################
    def handle_unregister(self,
                          cmd_runner: str,
                          unregister_targets: set[str],
                          not_registered_remotes: set[str],
                          log_msg: Optional[str] = None) -> None:
        """Unregister the named threads.

        Args:
            cmd_runner: name of thread doing the smart_unreg
            unregister_targets: names of threads to be unregistered
            not_registered_remotes: thread names that are not is registered
                state
            log_msg: log msg for the smart_unreg request

        """
        self.log_test_msg(f'handle_unregister entry for {cmd_runner=}, '
                          f'{unregister_targets=}')

        self.log_ver.add_call_seq(
            name='smart_unreg',
            seq='test_smart_thread.py::ConfigVerifier.handle_unregister')

        eligible_targets = unregister_targets.copy() - not_registered_remotes

        pe = self.pending_events[cmd_runner]

        pe[PE.start_request].append(
            StartRequest(req_type=st.ReqType.Smart_unreg,
                         targets=unregister_targets.copy(),
                         unreg_remotes=set(),
                         not_registered_remotes=not_registered_remotes.copy(),
                         timeout_remotes=set(),
                         stopped_remotes=set(),
                         deadlock_remotes=set(),
                         eligible_targets=set(),
                         completed_targets=set(),
                         first_round_completed=set(),
                         stopped_target_threads=set(),
                         exp_senders=set(),
                         exp_resumers=set()))

        req_key_entry: RequestKey = ('smart_unreg',
                                     'entry')
        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ('smart_unreg',
                                    'exit')

        # enter_exit = ('entry', 'exit')
        if not_registered_remotes:
            # enter_exit = ('entry',)
            with pytest.raises(st.SmartThreadRemoteThreadNotRegistered):
                self.all_threads[cmd_runner].smart_unreg(
                    targets=unregister_targets,
                    log_msg=log_msg)

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request='smart_unreg',
                    targets=unregister_targets,
                    error_str='SmartThreadRemoteThreadNotRegistered',
                    unreg_remotes=not_registered_remotes),
                log_level=logging.ERROR)

        else:
            pe[PE.request_msg][req_key_exit] += 1
            self.all_threads[cmd_runner].smart_unreg(
                targets=unregister_targets,
                log_msg=log_msg)

        self.monitor_event.set()

        with self.ops_lock:
            self.cmd_waiting_event_items[cmd_runner] = threading.Event()

        self.log_test_msg(f'{cmd_runner=} handle_unregister waiting for '
                          f'monitor')

        # self.add_request_log_msg(cmd_runner=cmd_runner,
        #                          smart_request='smart_unreg',
        #                          targets=unregister_targets,
        #                          timeout=0,
        #                          timeout_type=TimeoutType.TimeoutNone,
        #                          enter_exit=enter_exit,
        #                          log_msg=log_msg)

        self.cmd_waiting_event_items[cmd_runner].wait()
        with self.ops_lock:
            del self.cmd_waiting_event_items[cmd_runner]

        self.log_test_msg(f'handle_unregister exiting: {cmd_runner=}')

    ####################################################################
    # handle_wait
    ####################################################################
    def handle_wait(self,
                    cmd_runner: str,
                    resumers: set[str],
                    exp_resumers: set[str],
                    timeout: IntOrFloat,
                    timeout_remotes: set[str],
                    stopped_remotes: set[str],
                    conflict_remotes: set[str],
                    deadlock_remotes: set[str],
                    timeout_type: TimeoutType,
                    resumer_count: Optional[int] = None,
                    log_msg: Optional[str] = None) -> None:
        """Wait for a resume.

        Args:
            cmd_runner: thread doing the wait
            resumers: threads doing the resume
            exp_resumers: thread names of resumers that the wait will
                determine did a resume
            timeout: value to use on smart_wait timeout arg
            timeout_remotes: names of threads that will cause timeout
            stopped_remotes: names of thread that will cause not_alive
            conflict_remotes: names of threads that will cause conflict
            deadlock_remotes: names of threads that will cause deadlock
            timeout_type: specifies None, False, or True
            resumer_count: number of resumes needed to satisfy
                smart_wait
            log_msg: optional log message to specify on the smart_wait

        """
        self.log_test_msg(f'handle_wait entry for {cmd_runner=}, '
                          f'{resumers=}, {resumer_count=}, {stopped_remotes=}, '
                          f'{timeout_remotes=}, {conflict_remotes=} '
                          f'{deadlock_remotes=}')

        self.log_ver.add_call_seq(
            name='smart_wait',
            seq='test_smart_thread.py::ConfigVerifier.handle_wait')

        pe = self.pending_events[cmd_runner]
        pe[PE.start_request].append(
            StartRequest(req_type=st.ReqType.Smart_wait,
                         timeout_type=timeout_type,
                         targets=resumers,
                         timeout_remotes=timeout_remotes.copy(),
                         stopped_remotes=stopped_remotes.copy(),
                         deadlock_remotes=(conflict_remotes.copy() |
                                           deadlock_remotes.copy()),
                         exp_resumers=exp_resumers))

        req_key_entry: RequestKey = ('smart_wait',
                                     'entry')
        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ('smart_wait',
                                    'exit')

        exp_completed_resumers: set[str] = resumers.copy()

        if timeout_remotes:
            exp_completed_resumers -= timeout_remotes

        if conflict_remotes:
            exp_completed_resumers -= conflict_remotes

        if deadlock_remotes:
            exp_completed_resumers -= deadlock_remotes

        if stopped_remotes:
            exp_completed_resumers -= stopped_remotes

        resumed_by: set[str] = set()
        if stopped_remotes:
            with pytest.raises(st.SmartThreadRemoteThreadNotAlive):
                if timeout_type == TimeoutType.TimeoutNone:
                    self.all_threads[cmd_runner].smart_wait(
                        resumers=resumers,
                        resumer_count=resumer_count,
                        log_msg=log_msg)
                else:
                    self.all_threads[cmd_runner].smart_wait(
                        resumers=resumers,
                        resumer_count=resumer_count,
                        timeout=timeout,
                        log_msg=log_msg)

            resumed_by = self.all_threads[cmd_runner].resumed_by

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request='smart_wait',
                    targets=resumers,
                    error_str='SmartThreadRemoteThreadNotAlive',
                    stopped_remotes=stopped_remotes,
                    conflict_remotes=conflict_remotes),
                log_level=logging.ERROR)

        elif conflict_remotes or deadlock_remotes:
            # enter_exit = ('entry',)
            with pytest.raises(st.SmartThreadDeadlockDetected):
                if timeout_type == TimeoutType.TimeoutNone:
                    self.all_threads[cmd_runner].smart_wait(
                        resumers=resumers,
                        resumer_count=resumer_count,
                        log_msg=log_msg)
                else:
                    self.all_threads[cmd_runner].smart_wait(
                        resumers=resumers,
                        resumer_count=resumer_count,
                        timeout=timeout,
                        log_msg=log_msg)

            resumed_by = self.all_threads[cmd_runner].resumed_by

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request='smart_wait',
                    targets=resumers,
                    error_str='SmartThreadConflictDeadlockDetected',
                    stopped_remotes=stopped_remotes,
                    conflict_remotes=conflict_remotes,
                    deadlock_remotes=deadlock_remotes),
                log_level=logging.ERROR)

        elif timeout_type == TimeoutType.TimeoutNone:
            pe[PE.request_msg][req_key_exit] += 1
            resumed_by = self.all_threads[cmd_runner].smart_wait(
                resumers=resumers,
                resumer_count=resumer_count,
                log_msg=log_msg)

        elif timeout_type == TimeoutType.TimeoutFalse:
            pe[PE.request_msg][req_key_exit] += 1
            resumed_by = self.all_threads[cmd_runner].smart_wait(
                resumers=resumers,
                resumer_count=resumer_count,
                timeout=timeout,
                log_msg=log_msg)

        elif timeout_type == TimeoutType.TimeoutTrue:
            # enter_exit = ('entry',)
            with pytest.raises(st.SmartThreadRequestTimedOut):
                self.all_threads[cmd_runner].smart_wait(
                    resumers=resumers,
                    resumer_count=resumer_count,
                    timeout=timeout,
                    log_msg=log_msg)

            resumed_by = self.all_threads[cmd_runner].resumed_by

            self.add_log_msg(
                self.get_error_msg(
                    cmd_runner=cmd_runner,
                    smart_request='smart_wait',
                    targets=resumers,
                    error_str='SmartThreadRequestTimedOut',
                    pending_remotes=timeout_remotes,
                    stopped_remotes=stopped_remotes,
                    conflict_remotes=conflict_remotes),
                log_level=logging.ERROR)

        assert resumed_by == exp_resumers
        # self.add_request_log_msg(cmd_runner=cmd_runner,
        #                          smart_request='smart_wait',
        #                          targets=resumers,
        #                          timeout=timeout,
        #                          timeout_type=timeout_type,
        #                          enter_exit=enter_exit,
        #                          log_msg=log_msg)

        # for resumer in exp_completed_resumers:
        #     self.monitor_event.set()
        #     self.add_log_msg(
        #         new_log_msg=f'{cmd_runner} smart_wait resumed by {resumer}',
        #         log_level=logging.INFO)

        if exp_resumers:
            self.wait_for_monitor(cmd_runner=cmd_runner,
                                  rtn_name='handle_wait')

        self.log_test_msg(f'handle_wait exit for {cmd_runner=}, '
                          f'{resumers=}, {stopped_remotes=}')

    ####################################################################
    # lock_obtain
    ####################################################################
    @staticmethod
    def lock_obtain() -> None:
        """Obtain the registry lock exclusive."""
        st.SmartThread._registry_lock.obtain_excl(timeout=60)

    ####################################################################
    # lock_release
    ####################################################################
    @staticmethod
    def lock_release() -> None:
        """Increment the pending operations count."""
        st.SmartThread._registry_lock.release()

    ####################################################################
    # lock_swap
    ####################################################################
    def lock_swap(self,
                  cmd_runner: str,
                  new_positions: list[str]) -> None:
        """Increment the pending operations count.

        Args:
            cmd_runner: thread name doing the cmd
            new_positions: the desired positions on the lock queue
        """
        assert len(new_positions) == len(
            st.SmartThread._registry_lock.owner_wait_q)
        with self.ops_lock:
            for idx, pos_name in enumerate(new_positions):
                if (st.SmartThread._registry_lock.owner_wait_q[idx].thread.name
                        != pos_name):
                    save_pos = st.SmartThread._registry_lock.owner_wait_q[idx]
                    # find our desired position
                    new_pos = None
                    # for (idx2, owner_waiter in enumerate(
                    #            st.SmartThread._registry_lock.owner_wait_q)):
                    for idx2 in range(len(
                            st.SmartThread._registry_lock.owner_wait_q)):

                        if (st.SmartThread._registry_lock.owner_wait_q[idx2]
                                .thread.name == pos_name):
                            new_pos = (
                                st.SmartThread._registry_lock.owner_wait_q[
                                    idx2])
                            break
                    assert new_pos is not None
                    st.SmartThread._registry_lock.owner_wait_q[idx] = new_pos
                    st.SmartThread._registry_lock.owner_wait_q[idx2] = save_pos

    ####################################################################
    # lock_verify
    ####################################################################
    def lock_verify(self,
                    cmd_runner: str,
                    exp_positions: list[str],
                    line_num: int) -> None:
        """Increment the pending operations count.

        Args:
            cmd_runner: name of thread that will get the lock
            exp_positions: the expected positions on the lock queue
            line_num: the line number where the cmd was issued

        Raises:
            FailedLockVerify: lock_verify from {line_num=} timed out
                after {timeout_value} seconds waiting for the
                {exp_positions=} to match
                {st.SmartThread._registry_lock.owner_wait_q=}.

        """
        # self.log_test_msg(f'lock_verify entry: {cmd_runner=}, '
        #                   f'{exp_positions=}, {line_num=}')
        start_time = time.time()
        timeout_value = 60
        lock_verified = False
        while not lock_verified:
            lock_verified = True  # assume lock will verify
            with self.ops_lock:
                if (len(exp_positions) != len(
                        st.SmartThread._registry_lock.owner_wait_q)):
                    lock_verified = False
                else:
                    for idx, expected_name in enumerate(exp_positions):
                        if (st.SmartThread._registry_lock.owner_wait_q[
                                idx].thread.name != expected_name):
                            lock_verified = False
                            break
            if not lock_verified:
                if (time.time() - start_time) > timeout_value:
                    raise FailedLockVerify(
                        f'lock_verify from {line_num=} timed out after'
                        f' {timeout_value} seconds waiting for the '
                        f'{exp_positions=} to match \n'
                        f'{st.SmartThread._registry_lock.owner_wait_q=} ')
                time.sleep(0.2)
        # self.log_test_msg(f'lock_verify exit: {cmd_runner=}, '
        #                   f'{exp_positions=}, {line_num=}')

    ####################################################################
    # log_name_groups
    ####################################################################
    def log_name_groups(self) -> None:
        """Issue log msgs to show the names in each set."""
        log_msg = f'unregistered_names: {sorted(self.unregistered_names)}'
        self.log_ver.add_msg(log_msg=re.escape(log_msg))
        logger.debug(log_msg)

        log_msg = f'registered_names: {sorted(self.registered_names)}'
        self.log_ver.add_msg(log_msg=re.escape(log_msg))
        logger.debug(log_msg)

        log_msg = f'active_names: {sorted(self.active_names)}'
        self.log_ver.add_msg(log_msg=re.escape(log_msg))
        logger.debug(log_msg)

        log_msg = f'stopped_remotes: {sorted(self.stopped_remotes)}'
        self.log_ver.add_msg(log_msg=re.escape(log_msg))
        logger.debug(log_msg)

    ####################################################################
    # log_test_msg
    ####################################################################
    def log_test_msg(self,
                     log_msg: str) -> None:
        """Issue log msgs for test rtn.

        Args:
            log_msg: the message to log

        """
        if (self.allow_log_test_msg
                or 'waiting for monitor' in log_msg
                or 'has been stopped by' in log_msg):
            self.log_ver.add_msg(log_msg=re.escape(log_msg))
            logger.debug(log_msg, stacklevel=2)

    ####################################################################
    # main_driver
    ####################################################################
    def main_driver(self) -> None:
        """Delete the thread from the ConfigVerifier."""
        self.log_ver.add_call_seq(
            name='main_driver',
            seq='test_smart_thread.py::ConfigVerifier.main_driver')

        while self.cmd_suite:
            cmd: ConfigCmd = self.cmd_suite.popleft()
            self.log_test_msg(f'config_cmd: {cmd}')

            if not cmd.cmd_runners:
                raise InvalidInputDetected('main_driver detected an empty '
                                           'set of cmd_runners')
            for name in cmd.cmd_runners:
                if name == self.commander_name:
                    continue
                self.msgs.queue_msg(target=name,
                                    msg=cmd)

            if self.commander_name in cmd.cmd_runners:
                cmd.run_process(cmd_runner=self.commander_name)
                self.completed_cmds[self.commander_name].append(cmd.serial_num)

    # ####################################################################
    # # set_pending_status_msgs
    # ####################################################################
    # def set_pending_status_msgs(self) -> None:
    #     """Set the expected status msgs displayed from reg cleanup."""
    #     self.log_test_msg('set_pending_status_msgs entered with '
    #                       f'{self.expected_registered=}')
    #     for name, item in self.expected_registered.items():
    #         if name == self.commander_name:
    #             continue
    #         if not item.is_alive and item.st_state == st.ThreadState.Alive:
    #             state_to_use = st.ThreadState.Stopped
    #         else:
    #             state_to_use = item.st_state
    #         self.pending_events[name].status_msg[
    #             (item.is_alive, state_to_use)] += 1

    ####################################################################
    # set_recv_timeout
    ####################################################################
    def set_recv_timeout(self, num_timeouts: int):
        """Set the expected number of receive timeouts.

        Args:
            num_timeouts: number or expected timeouts to set

        """
        with self.ops_lock:
            self.expected_num_recv_timeouts = num_timeouts

    ####################################################################
    # stop_thread
    ####################################################################
    def stop_thread(self,
                    cmd_runner: str,
                    stop_names: set[str],
                    reset_ops_count: bool = False) -> None:
        """Start the named thread.

        Args:
            cmd_runner: name of thread doing the stop thread
            stop_names: names of the threads to stop
            reset_ops_count: specifies whether to set the
                pending_ops_count to zero
        """
        self.log_test_msg(f'{cmd_runner=} stop_thread entry for {stop_names=}')

        self.stopped_event_items[cmd_runner] = MonitorEventItem(
            client_event=threading.Event(),
            targets=stop_names.copy()
        )

        for stop_name in stop_names:
            self.stopping_names.append(stop_name)
            if stop_name not in self.pending_events:
                raise InvalidConfigurationDetected(
                    'stop_thread detected missing pending transition '
                    f'for {stop_name}: {self.pending_events=}')
            if stop_name not in self.expected_registered:
                raise InvalidConfigurationDetected(
                    f'stop_thread attempting to stop {stop_name} which is '
                    f'not in the registry: {self.expected_registered=}')

            self.monitor_event.set()
            exit_cmd = ExitThread(cmd_runners=stop_name,
                                  stopped_by=cmd_runner)
            self.add_cmd_info(exit_cmd)
            self.msgs.queue_msg(target=stop_name,
                                msg=exit_cmd)

        work_names = stop_names.copy()
        while work_names:
            for stop_name in work_names:
                if not self.all_threads[stop_name].thread.is_alive():
                    self.log_test_msg(f'{stop_name} has been stopped by '
                                      f'{cmd_runner}')
                    self.monitor_event.set()
                    if reset_ops_count:
                        with self.ops_lock:
                            for pair_key in self.expected_pairs.keys():
                                if stop_name in pair_key:
                                    self.expected_pairs[pair_key][
                                        stop_name].reset_ops_count = True
                    work_names -= {stop_name}
                    break
                time.sleep(0.05)

        self.log_test_msg(f'{cmd_runner=} stop_thread waiting for monitor')
        self.monitor_event.set()
        self.stopped_event_items[cmd_runner].client_event.wait()

        # self.wait_for_monitor(cmd_runner=cmd_runner,
        #                       rtn_name='handle_recv')

        self.log_test_msg(f'{cmd_runner=} stop_thread exiting for '
                          f'{stop_names=}')

    ####################################################################
    # add_to_pair_array
    ####################################################################
    def add_to_pair_array(self,
                          cmd_runner: str,
                          add_name: str) -> bool:
        """Add thread to pair array.

        Args:
            cmd_runner: thread name doing the update
            add_name: thread name to add

        Returns:
            True if name was added, False otherwise

        Raises:
            InvalidConfigurationDetected: Attempt to add thread to
                existing pair array that has an empty ThreadPairStatus
                dict, or that already has the thread in the pair array,
                or that did not have the other name in the pair array.

        """
        self.log_test_msg(f'add_to_pair_array entry: {cmd_runner=}, '
                          f'{add_name=}')

        pe = self.pending_events[cmd_runner]

        if add_name not in self.expected_registered:
            raise IncorrectDataDetected(
                f'add_to_pair_array detected {add_name=} not '
                f'found in {self.expected_registered=}'
            )
        changed = False
        for other_name in self.expected_registered.keys():
            if ((other_name == add_name)
                    or self.expected_registered[
                        other_name].st_state == st.ThreadState.Unregistered):
                continue
            self.log_test_msg(f'add_to_pair_array proceeding with '
                              f'{add_name=}, {other_name=}')
            changed = True
            pair_key = st.SmartThread._get_pair_key(add_name, other_name)

            if pair_key not in self.expected_pairs:
                self.log_test_msg(f'add_to_pair_array {pair_key=} not in '
                                  f'{self.expected_pairs=}')
                self.expected_pairs[pair_key] = {
                    add_name: ThreadPairStatus(
                        reset_ops_count=False),
                    other_name: ThreadPairStatus(
                        reset_ops_count=False)}
                add_key: AddPaKey = (cmd_runner,
                                     pair_key)
                pe[PE.add_pair_array_msg][add_key] += 1

                for pair_name in pair_key:
                    add_status_key: AddStatusBlockKey = (cmd_runner,
                                                         pair_key,
                                                         pair_name)
                    pe[PE.add_status_block_msg][add_status_key] += 1

            # if pair_key already exists, we need to add name
            # as a resurrected thread
            else:  # we already have a pair_key, need to add name
                self.log_test_msg(f'add_to_pair_array {pair_key=} in '
                                  f'{self.expected_pairs=}')
                if not self.expected_pairs[pair_key]:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        'Attempt to add thread to existing pair array '
                        'that has an empty ThreadPairStatus dict')
                if add_name in self.expected_pairs[pair_key].keys():
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'{cmd_runner} attempted to add {add_name} to '
                        f'pair array for {pair_key=} that already '
                        'has the thread in the pair array')

                if other_name not in self.expected_pairs[pair_key].keys():
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        'Attempt to add thread to pair array that did '
                        'not have the other name in the pair array')

                # looks OK, just add in the new name
                self.expected_pairs[pair_key][add_name] = ThreadPairStatus(
                    reset_ops_count=False)

                add_status_key: AddStatusBlockKey = (cmd_runner,
                                                     pair_key,
                                                     add_name)
                pe[PE.add_status_block_msg][add_status_key] += 1

                # self.log_test_msg(f'{cmd_runner} '
                #                   'resurrected expected_pairs '
                #                   f'for {pair_key=}, {add_name=} with '
                #                   f'{add_poc=}')

        self.log_test_msg(f'add_to_pair_array exit: {cmd_runner=}, '
                          f'{add_name=}')
        return changed

    ####################################################################
    # clean_pair_array
    ####################################################################
    def clean_pair_array(self,
                         cmd_runner: str) -> None:
        """Remove entries from pair array as needed.

        Args:
            cmd_runner: thread name doing the _clean_pair_array

        Raises:
            InvalidConfigurationDetected: Attempt to add thread to
                existing pair array that has an empty ThreadPairStatus
                dict, or that already has the thread in the pair array,
                or that did not have the other name in the pair array.

        """
        self.log_test_msg(f'clean_pair_array entry: {cmd_runner=} ')

        pe = self.pending_events[cmd_runner]

        changed = False
        pair_keys_to_delete = []
        for pair_key in self.expected_pairs:
            if (pair_key[0] in self.expected_registered
                    and self.expected_registered[pair_key[0]].st_state
                    != st.ThreadState.Initializing
                    and pair_key[1] in self.expected_registered
                    and self.expected_registered[pair_key[1]].st_state
                    != st.ThreadState.Initializing):
                # self.log_test_msg('clean_pair_array continue with '
                #                   f'{pair_key=}')
                continue

            # one or both need to be removed from pair_array
            pae = self.expected_pairs[pair_key]
            # self.log_test_msg('clean_pair_array processing '
            #                   f'{pair_key=}')

            for name in pair_key:
                pending_request = False
                pending_msg = False
                pending_wait = False
                pending_sync = False
                defer = False
                if name in pae:
                    if pae[name].pending_request:
                        pending_request = True
                        defer = True
                    if pae[name].pending_msg_count:
                        pending_msg = True
                        defer = True
                    if pae[name].pending_wait:
                        pending_wait = True
                        defer = True
                    if pae[name].pending_sync:
                        pending_sync = True
                        defer = True

                    def_del_reasons: DefDelReasons = DefDelReasons(
                        pending_request=pending_request,
                        pending_msg=pending_msg,
                        pending_wait=pending_wait,
                        pending_sync=pending_sync)

                    rem_sb_key: RemSbKey = (name, pair_key, def_del_reasons)

                    if name in self.expected_registered and defer:
                        self.log_test_msg('clean_pair_array deferred '
                                          f'{pair_key=}, {name=}, '
                                          f'{rem_sb_key=}')
                        pe[PE.rem_status_block_def_msg][rem_sb_key] += 1
                    else:
                        del pae[name]
                        # self.log_test_msg(
                        #     f'clean_pair_array about to increment '
                        #     f'{pe[PE.rem_status_block_msg][rem_sb_key]=} '
                        #     f'for {cmd_runner=} with {rem_sb_key=}'
                        # )
                        pe[PE.rem_status_block_msg][rem_sb_key] += 1
                        self.log_test_msg('clean_pair_array removed '
                                          f'{pair_key=}, {name=}, '
                                          f'{rem_sb_key=}')
                        changed = True

            if not pae:
                pair_keys_to_delete.append(pair_key)

        if pair_keys_to_delete:
            changed = True
            for pair_key in pair_keys_to_delete:
                del self.expected_pairs[pair_key]
                rem_pae_key: RemPaeKey = (cmd_runner, pair_key)
                pe[PE.rem_pair_array_entry_msg][rem_pae_key] += 1

        if changed:
            pe[PE.did_cleanup_pair_array_utc_msg] += 1
            self.log_test_msg(f'clean_pair_array for {cmd_runner=} '
                              f'{pe[PE.did_cleanup_pair_array_utc_msg]=}')

        self.log_test_msg(f'clean_pair_array exit: {cmd_runner=} ')

    ####################################################################
    # clean_registry
    ####################################################################
    def clean_registry(self,
                       cmd_runner: str,
                       target: str) -> None:
        """Remove entries from the registry as needed.

        Args:
            cmd_runner: thread name doing the _clean_pair_array
            target: thread name that is being processed

        Raises:
            InvalidConfigurationDetected: Attempt to add thread to
                existing pair array that has an empty ThreadPairStatus
                dict, or that already has the thread in the pair array,
                or that did not have the other name in the pair array.

        """
        self.log_test_msg(f'clean_registry entry: {cmd_runner=}, {target=}')
        rem_targets: list[str] = []
        pe = self.pending_events[cmd_runner]
        request = pe[PE.current_request].req_type.value
        with self.ops_lock:
            for key, item in self.expected_registered.items():
                if (not item.is_alive
                        and item.st_state == st.ThreadState.Alive):
                    state_to_use = st.ThreadState.Stopped
                else:
                    state_to_use = item.st_state
                if (state_to_use != st.ThreadState.Unregistered
                        and state_to_use != st.ThreadState.Initializing):
                    self.pending_events[key][PE.status_msg][
                        (item.is_alive, state_to_use)] += 1
                    self.log_test_msg(
                        f'clean_registry status key {key=}'
                        f'{(item.is_alive, state_to_use)=}')
                if (not item.is_alive
                        and item.st_state == st.ThreadState.Stopped):
                    rem_key: RemRegKey = (
                        key,
                        request)
                    pe[PE.rem_reg_msg][rem_key] += 1
                    rem_targets.append(key)
                    self.log_test_msg(f'clean_registry deleting {key=}')

            completed: set[str] = set()
            if pe[PE.current_request].req_type in (st.ReqType.Smart_unreg,
                                                   st.ReqType.Smart_join):
                # if this is first visit to clean_registry
                if (pe[PE.current_request].unreg_remotes
                        and not pe[PE.current_request].completed_targets):
                    pe[PE.current_request].completed_targets |= pe[
                        PE.current_request].unreg_remotes
                    completed |= pe[PE.current_request].unreg_remotes

            if rem_targets:
                pe[PE.did_clean_reg_msg] += 1
                pe[PE.rem_reg_targets].append(rem_targets)

                for target in rem_targets:
                    del self.expected_registered[target]
                    if target in pe[PE.current_request].eligible_targets:
                        pe[PE.current_request].completed_targets |= {target}
                        completed |= {target}

            if pe[PE.current_request].req_type in (st.ReqType.Smart_unreg,
                                                   st.ReqType.Smart_join):
                # if pe[PE.current_request].first_round_completed:
                #     pe[PE.current_request].first_round_completed = set()
                # else:
                s_com = sorted(completed)

                uj_key: UnregJoinSuccessKey = (
                    pe[PE.current_request].req_type.value,
                    s_com[0])
                pe[PE.unreg_join_success_msg][uj_key] += 1
                self.log_test_msg(
                    'clean_registry added '
                    f'unreg_join_success_msg with {uj_key=}')

                if pe[PE.current_request].req_type == st.ReqType.Smart_join:
                    all_targets = pe[PE.current_request].targets.copy()
                    completed = pe[PE.current_request].completed_targets.copy()
                    remaining = all_targets - completed

                    prog_key: JoinProgKey = (len(completed), len(remaining))
                    pe[PE.join_progress_msg][prog_key] += 1
                    self.log_test_msg(
                        'clean_registry added '
                        f'join_progress_msg with {prog_key=}')

            self.log_test_msg(
                f'clean_registry has '
                f'{len(pe[PE.current_request].completed_targets)=} and '
                f'{len(pe[PE.current_request].targets)=}')
            self.log_test_msg(
                f'clean_registry has '
                f'{pe[PE.current_request].completed_targets=} and '
                f'{pe[PE.current_request].targets=}')

            if (len(pe[PE.current_request].completed_targets)
                    < len(pe[PE.current_request].eligible_targets)):
                if pe[PE.current_request].req_type == st.ReqType.Smart_join:
                    sub_key: SubProcessKey = (cmd_runner,
                                              'smart_join',
                                              '_clean_registry',
                                              'entry',
                                              cmd_runner)
                    pe[PE.subprocess_msg][sub_key] += 1
                    self.log_test_msg(
                        f'clean_registry {cmd_runner=} added '
                        f'subprocess_msg with {sub_key=} and bumped count to: '
                        f'{pe[PE.subprocess_msg][sub_key]=}')

                    sub_key: SubProcessKey = (cmd_runner,
                                              'smart_join',
                                              '_clean_pair_array',
                                              'entry',
                                              cmd_runner)
                    pe[PE.subprocess_msg][sub_key] += 1

        self.log_test_msg(f'clean_registry exit: {cmd_runner=}, {target=}')

    ####################################################################
    # verify_config
    ####################################################################
    def verify_config(self,
                      verify_idx: int):
        """Verify that the SmartThread config is correct.

        Args:
            verify_idx: index for the saved snapshot data
        """
        verify_data: VerifyData = self.snap_shot_data[verify_idx].verify_data

        actions: dict[VerifyType, Callable[..., None]] = {
            VerifyType.VerifyStructures: self.verify_structures,
            VerifyType.VerifyAlive: self.verify_alive,
            VerifyType.VerifyNotAlive: self.verify_not_alive,
            VerifyType.VerifyState: self.verify_state,
            VerifyType.VerifyInRegistry: self.verify_in_registry,
            VerifyType.VerifyNotInRegistry: self.verify_not_in_registry,
            VerifyType.VerifyAliveState: self.verify_active_state,
            VerifyType.VerifyRegisteredState: self.verify_registered_state,
            VerifyType.VerifyStoppedState: self.verify_stopped_state,
            VerifyType.VerifyPaired: self.verify_paired,
            VerifyType.VerifyNotPaired: self.verify_not_paired,
            VerifyType.VerifyHalfPaired: self.verify_half_paired,
            VerifyType.VerifyPendingFlags: self.verify_pending_flags,

        }

        # actions[verify_data.verify_type](
        #     cmd_runner=verify_data.cmd_runner,
        #     names_to_check=verify_data.names_to_check,
        #     aux_names=verify_data.aux_names,
        #     state_to_check=verify_data.state_to_check,
        #     real_reg_items=self.snap_shot_data[verify_idx].registry_items,
        #     real_pair_array_items=self.snap_shot_data[
        #         verify_idx].pair_array_items
        # )
        actions[verify_data.verify_type](
            real_reg_items=self.snap_shot_data[verify_idx].registry_items,
            real_pair_array_items=self.snap_shot_data[
                verify_idx].pair_array_items,
            verify_data=verify_data
        )

    ####################################################################
    # verify_structures
    ####################################################################
    def verify_structures(self,
                          real_reg_items: RegistryItems,
                          real_pair_array_items: PairArrayItems,
                          verify_data: VerifyData
                          ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        for name, real_reg_item in real_reg_items.items():
            if name not in self.expected_registered:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_config found SmartThread real registry has entry '
                    f'for {name=} that is missing from the expected_registry. '
                    f'{self.expected_registered.keys()=}')
            if (self.expected_registered[name].is_alive
                    != real_reg_item.is_alive):
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_config found SmartThread real registry has '
                    f'entry for {name=} that has is_alive of '
                    f'{real_reg_item.is_alive} which does not match the '
                    f'expected_registered is_alive of '
                    f'{self.expected_registered[name].is_alive}')
            if self.expected_registered[name].st_state != real_reg_item.state:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_config found SmartThread real registry has '
                    f'entry for {name=} that has status of '
                    f'{real_reg_item.state} which does not match the '
                    f'mock expected_registered status of '
                    f'{self.expected_registered[name].st_state}')

        # verify expected_registered matches real registry
        for name, tracker in self.expected_registered.items():
            if name not in real_reg_items:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_config found expected_registered has an entry '
                    f'for {name=} that is missing from real '
                    f'SmartThread._registry')

        # verify pair_array matches expected_pairs
        for pair_key, status_blocks in real_pair_array_items.items():
            if len(status_blocks) == 0:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_config found pair_key {pair_key} in real '
                    f'SmartThread._pair_array that has an empty status_blocks')
            if pair_key not in self.expected_pairs:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_config found pair_key {pair_key} in real '
                    f'SmartThread._pair_array that is not found in '
                    f'expected_pairs')
            for name, status_item in status_blocks.items():
                if name not in real_reg_items:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_config found SmartThread real pair_array '
                        f'has a status_blocks entry for {name=} that is '
                        f'missing from the real registry. ')

                if name not in self.expected_registered:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_config found {name=} in real '
                        f'SmartThread._pair_array status_blocks for pair_key'
                        f' {pair_key}, but is missing in mock '
                        f'expected_registered')

                if name not in self.expected_pairs[pair_key].keys():
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_config found {name=} in real '
                        f'SmartThread._pair_array status_blocks for pair_key'
                        f' {pair_key}, but is missing in expected_pairs')

                if len(status_blocks) == 1:
                    if not (status_item.pending_request
                            or status_item.pending_msg_count
                            or status_item.pending_wait
                            or status_item.pending_sync):
                        self.abort_all_f1_threads()
                        raise InvalidConfigurationDetected(
                            f'verify_config found {name=} in real '
                            f'SmartThread._pair_array status_blocks for '
                            f'pair_key {pair_key}, but it is a single '
                            f'name that has no pending reasons')
                mock_status_item = self.expected_pairs[pair_key][name]
                if (status_item.pending_request
                        != mock_status_item.pending_request):
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_config found {name=} in real '
                        f'SmartThread._pair_array status_blocks for '
                        f'pair_key {pair_key} has '
                        f'{status_item.pending_request=} which does not '
                        f'match {mock_status_item.pending_request=}')
                if (status_item.pending_msg_count
                        != mock_status_item.pending_msg_count):
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_config found {name=} in real '
                        f'SmartThread._pair_array status_blocks for '
                        f'pair_key {pair_key} has '
                        f'{status_item.pending_msg_count=} which does not '
                        f'match {mock_status_item.pending_msg_count=}')
                if (status_item.pending_wait
                        != mock_status_item.pending_wait):
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_config found {name=} in real '
                        f'SmartThread._pair_array status_blocks for '
                        f'pair_key {pair_key} has '
                        f'{status_item.pending_wait=} which does not '
                        f'match {mock_status_item.pending_wait=}')
                if (status_item.pending_sync
                        != mock_status_item.pending_sync):
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_config found {name=} in real '
                        f'SmartThread._pair_array status_blocks for '
                        f'pair_key {pair_key} has '
                        f'{status_item.pending_sync=} which does not '
                        f'match {mock_status_item.pending_sync=}')

        # verify expected_pairs matches pair_array
        for pair_key, mock_status_blocks in self.expected_pairs.items():
            if pair_key not in real_pair_array_items:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_config found {pair_key=} in expected_pairs but '
                    f'not in real SmartThread._pair_array')
            for name, mock_status_item in mock_status_blocks.items():
                if name not in real_reg_items:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_config found SmartThread mock pair_array '
                        f'has a status_blocks entry for {name=} that is '
                        f'missing from the real registry. ')

                if name not in self.expected_registered:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_config found {name=} in mock '
                        f'pair_array status_blocks for pair_key'
                        f' {pair_key}, but is missing in '
                        f'mock expected_registered')

                if name not in real_pair_array_items[pair_key]:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_config found {name=} in mock '
                        f'expected_pairs for pair_key {pair_key}, but not in '
                        'real SmartThread._pair_array status_blocks')

    ####################################################################
    # verify_alive
    ####################################################################
    def verify_alive(self,
                     real_reg_items: RegistryItems,
                     real_pair_array_items: PairArrayItems,
                     verify_data: VerifyData
                     ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        for name in verify_data.names_to_check:
            if not real_reg_items[name].is_alive:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_alive found {name} has '
                    f'{real_reg_items[name].is_alive=} '
                    'which is not equal to the expected is_alive of True ')
            if not self.expected_registered[name].is_alive:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_alive found {name=} has mock '
                    f'{self.expected_registered[name].is_alive=} which is '
                    'not equal to the expected is_alive of True ')

    ####################################################################
    # verify_not_alive
    ####################################################################
    def verify_not_alive(self,
                        real_reg_items: RegistryItems,
                        real_pair_array_items: PairArrayItems,
                        verify_data: VerifyData
                        ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        for name in verify_data.names_to_check:
            if real_reg_items[name].is_alive:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_not_alive found {name=} has real '
                    f'{real_reg_items[name].is_alive=} '
                    'which is not equal to the expected is_alive of False ')
            if self.expected_registered[name].is_alive:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_not_alive found {name=} has mock '
                    f'{self.expected_registered[name].is_alive=} which is '
                    'not equal to the expected is_alive of False')

    ####################################################################
    # verify_state
    ####################################################################
    def verify_state(self,
                     real_reg_items: RegistryItems,
                     real_pair_array_items: PairArrayItems,
                     verify_data: VerifyData
                     ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        for name in verify_data.names_to_check:
            if (real_reg_items[name].state != verify_data.state_to_check
                    or self.expected_registered[name].st_state
                    != verify_data.state_to_check):
                self.abort_all_f1_threads()
                self.log_test_msg(
                    f'verify_state for {name=}: {verify_data.state_to_check=} '
                    f'does not match either/both {real_reg_items[name].state} '
                    f'or {self.expected_registered[name].st_state} per '
                    f'{verify_data.cmd_runner=}')
                raise InvalidConfigurationDetected(
                    f'verify_state for {name=}: {verify_data.state_to_check=} '
                    f'does not match either/both {real_reg_items[name].state} '
                    f'or {self.expected_registered[name].st_state} per '
                    f'{verify_data.cmd_runner=}')

    ####################################################################
    # verify_in_registry
    ####################################################################
    def verify_in_registry(self,
                           real_reg_items: RegistryItems,
                           real_pair_array_items: PairArrayItems,
                           verify_data: VerifyData
                           ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        for name in verify_data.names_to_check:
            if name not in real_reg_items:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_in_registry found {name=} is not registered in '
                    f'the real SmartThread._registry per '
                    f'{verify_data.cmd_runner=}')
            if name not in self.expected_registered:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_in_registry found {name=} is not registered in '
                    f'the mock SmartThread._registry per '
                    f'{verify_data.cmd_runner=}')

    ####################################################################
    # verify_not_in_registry
    ####################################################################
    def verify_not_in_registry(self,
                               real_reg_items: RegistryItems,
                               real_pair_array_items: PairArrayItems,
                               verify_data: VerifyData
                               ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        for name in verify_data.names_to_check:
            if name in real_reg_items:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_not_in_registry found {name=} is registered in '
                    f'the real SmartThread._registry per '
                    f'{verify_data.cmd_runner=}')
            if name in self.expected_registered:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_in_registry_not found {name=} is registered in '
                    f'the mock expected_registered per '
                    f'{verify_data.cmd_runner=}')

    ####################################################################
    # verify_active_state
    ####################################################################
    def verify_active_state(self,
                            real_reg_items: RegistryItems,
                            real_pair_array_items: PairArrayItems,
                            verify_data: VerifyData
                            ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        self.verify_in_registry(real_reg_items=real_reg_items,
                                real_pair_array_items=real_pair_array_items,
                                verify_data=verify_data)

        self.verify_alive(real_reg_items=real_reg_items,
                          real_pair_array_items=real_pair_array_items,
                          verify_data=verify_data)

        verify_data.state_to_check = st.ThreadState.Alive
        self.verify_state(real_reg_items=real_reg_items,
                          real_pair_array_items=real_pair_array_items,
                          verify_data=verify_data)

        if len(verify_data.names_to_check) > 1:
            self.verify_paired(real_reg_items=real_reg_items,
                               real_pair_array_items=real_pair_array_items,
                               verify_data=verify_data)

    ####################################################################
    # verify_registered_state
    ####################################################################
    def verify_registered_state(self,
                                real_reg_items: RegistryItems,
                                real_pair_array_items: PairArrayItems,
                                verify_data: VerifyData
                                ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        self.verify_in_registry(real_reg_items=real_reg_items,
                                real_pair_array_items=real_pair_array_items,
                                verify_data=verify_data)

        self.verify_not_alive(real_reg_items=real_reg_items,
                              real_pair_array_items=real_pair_array_items,
                              verify_data=verify_data)

        verify_data.state_to_check = st.ThreadState.Registered
        self.verify_state(real_reg_items=real_reg_items,
                          real_pair_array_items=real_pair_array_items,
                          verify_data=verify_data)

        if len(verify_data.names_to_check) > 1:
            self.verify_paired(real_reg_items=real_reg_items,
                               real_pair_array_items=real_pair_array_items,
                               verify_data=verify_data)

    ####################################################################
    # verify_stopped_state
    ####################################################################
    def verify_stopped_state(self,
                             real_reg_items: RegistryItems,
                             real_pair_array_items: PairArrayItems,
                             verify_data: VerifyData
                             ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        self.verify_in_registry(real_reg_items=real_reg_items,
                                real_pair_array_items=real_pair_array_items,
                                verify_data=verify_data)

        self.verify_not_alive(real_reg_items=real_reg_items,
                              real_pair_array_items=real_pair_array_items,
                              verify_data=verify_data)

        for name in verify_data.names_to_check:
            if real_reg_items[name].state not in (st.ThreadState.Alive,
                                                  st.ThreadState.Stopped):
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_state found {name=} has real state '
                    f'{real_reg_items[name].state} not equal to the expected '
                    f'state of {st.ThreadState.Alive} or '
                    f'{st.ThreadState.Stopped} per {cmd_runner=}')
            if self.expected_registered[name].st_state not in (
                    st.ThreadState.Alive,
                    st.ThreadState.Stopped):
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_state found {name=} has mock state '
                    f'{self.expected_registered[name].st_state} not equal to '
                    f'the expected state of {st.ThreadState.Alive} or '
                    f'{st.ThreadState.Stopped} per {cmd_runner=}')

        if len(verify_data.names_to_check) > 1:
            self.verify_paired(real_reg_items=real_reg_items,
                               real_pair_array_items=real_pair_array_items,
                               verify_data=verify_data)

    ####################################################################
    # verify_paired
    ####################################################################
    def verify_paired(self,
                      real_reg_items: RegistryItems,
                      real_pair_array_items: PairArrayItems,
                      verify_data: VerifyData
                      ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        pair_keys = combinations(sorted(verify_data.names_to_check), 2)
        for pair_key in pair_keys:
            if pair_key not in real_pair_array_items:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_paired found {pair_key=} is not '
                    f'in the real pair_array')

            if pair_key not in self.expected_pairs:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_paired found {pair_key=} is not '
                    f'in the mock pair_array')

            for name in pair_key:
                if name not in real_pair_array_items[pair_key]:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_paired found {name=} for {pair_key=} does '
                        f'not have a status block in the real pair_array')

                if name not in self.expected_pairs[pair_key]:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_paired found {name=} for {pair_key=} does '
                        f'not have a status block in the mock pair_array')

    ####################################################################
    # verify_not_paired
    ####################################################################
    def verify_not_paired(self,
                          real_reg_items: RegistryItems,
                          real_pair_array_items: PairArrayItems,
                          verify_data: VerifyData
                          ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        pair_keys = combinations(sorted(verify_data.names_to_check), 2)
        for pair_key in pair_keys:
            if pair_key in real_pair_array_items:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_not_paired found {pair_key=} is in '
                    f'in the real pair_array')

            if pair_key in self.expected_pairs:
                self.abort_all_f1_threads()
                raise InvalidConfigurationDetected(
                    f'verify_not_paired found {pair_key=} is in '
                    f'in the mock pair_array')

    ####################################################################
    # verify_half_paired
    ####################################################################
    def verify_half_paired(self,
                           real_reg_items: RegistryItems,
                           real_pair_array_items: PairArrayItems,
                           verify_data: VerifyData
                           ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        for removed_name in verify_data.aux_names:
            for exp_remaining_name in verify_data.names_to_check:
                pair_key = st.SmartThread._get_pair_key(removed_name,
                                                        exp_remaining_name)
                if pair_key not in real_pair_array_items:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_half_paired found {pair_key=} is not '
                        f'in the real pair_array')

                num_real_status_blocks = len(real_pair_array_items[pair_key])
                if num_real_status_blocks != 1:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_half_paired found {num_real_status_blocks=} '
                        f'is not equal to 1 in the real pair_array')

                if exp_remaining_name not in real_pair_array_items[pair_key]:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_half_paired found {exp_remaining_name=} does '
                        f'not have a status block in the real pair_array for '
                        f'{pair_key=}.')

                if pair_key not in self.expected_pairs:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_half_paired found {pair_key=} is not '
                        f'in the mock pair_array')
                num_mock_status_blocks = len(self.expected_pairs[pair_key])
                if num_mock_status_blocks != 1:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_half_paired found {num_mock_status_blocks=} '
                        f'is not 1 in the mock pair_array')
                if exp_remaining_name not in self.expected_pairs[pair_key]:
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_half_paired found {exp_remaining_name=} does '
                        f'not have a status block in the mock pair_array for '
                        f'{pair_key=}.')

    ####################################################################
    # verify_half_paired
    ####################################################################
    def verify_pending_flags(self,
                             real_reg_items: RegistryItems,
                             real_pair_array_items: PairArrayItems,
                             verify_data: VerifyData
                           ) -> None:
        """Verify that the SmartThread config is correct.

        Args:
            real_reg_items: snapshot of real registry items
            real_pair_array_items: snapshot of real pair array
            verify_data: contains data items used for the verification

        Raises:
            InvalidConfigurationDetected: validate_config has found a
            mismatch between the real and mock configuration

        """
        for remote_name in verify_data.aux_names:
            for check_name in verify_data.names_to_check:
                pair_key = st.SmartThread._get_pair_key(remote_name,
                                                        check_name)
                if pair_key not in real_pair_array_items:
                    self.log_test_msg(
                        f'verify_pending_flags 1 found {pair_key=} is not '
                        f'in the real pair_array needed to check '
                        f'{check_name=}, {remote_name=}')
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_pending_flags found {pair_key=} is not '
                        f'in the real pair_array needed to check '
                        f'{check_name=}, {remote_name=}')

                if check_name not in real_pair_array_items[pair_key]:
                    self.log_test_msg(
                        f'verify_pending_flags 2 found {check_name=} does '
                        f'not have a status block in the real pair_array for '
                        f'{pair_key=}.')
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_pending_flags found {check_name=} does '
                        f'not have a status block in the real pair_array for '
                        f'{pair_key=}.')

                if pair_key not in self.expected_pairs:
                    self.log_test_msg(
                        f'verify_pending_flags 3 found {pair_key=} is not '
                        f'in the mock pair_array needed to check '
                        f'{check_name=}, {remote_name=}')
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_pending_flags found {pair_key=} is not '
                        f'in the mock pair_array needed to check '
                        f'{check_name=}, {remote_name=}')

                if check_name not in self.expected_pairs[pair_key]:
                    self.log_test_msg(
                        f'verify_pending_flags 4 found {check_name=} does '
                        f'not have a status block in the mock pair_array for '
                        f'{pair_key=}.')
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_pending_flags 4 found {check_name=} does '
                        f'not have a status block in the mock pair_array for '
                        f'{pair_key=}.')

                real_sb = real_pair_array_items[pair_key][check_name]
                real_pending_flags = PendingFlags(
                    pending_request=real_sb.pending_request,
                    pending_msgs=real_sb.pending_msg_count,
                    pending_wait=real_sb.pending_wait,
                    pending_sync=real_sb.pending_sync
                )

                mock_sb = self.expected_pairs[pair_key][check_name]
                mock_pending_flags = PendingFlags(
                    pending_request=mock_sb.pending_request,
                    pending_msgs=mock_sb.pending_msg_count,
                    pending_wait=mock_sb.pending_wait,
                    pending_sync=mock_sb.pending_sync
                )
                if ((real_pending_flags != verify_data.exp_pending_flags)
                        or (mock_pending_flags !=
                            verify_data.exp_pending_flags)):
                    self.log_test_msg(
                        f'verify_pending_flags 5 found {pair_key=}, '
                        f'{check_name=} does have matching pending flags: '
                        f'{real_pending_flags=}, '
                        f'{mock_pending_flags=}, '
                        f'{verify_data.exp_pending_flags=}.')
                    self.abort_all_f1_threads()
                    raise InvalidConfigurationDetected(
                        f'verify_pending_flags found {pair_key=}, '
                        f'{check_name=} does not have matching pending flags: '
                        f'{real_pending_flags=}, '
                        f'{mock_pending_flags=}, '
                        f'{verify_data.exp_pending_flags=}.')

    ####################################################################
    # verify_counts
    ####################################################################
    def verify_counts(self,
                      verify_idx: int) -> None:
        """Verify that the given counts are correct.

        Args:
            verify_idx: index for the saved snapshot data

        """
        real_reg_items = self.snap_shot_data[verify_idx].registry_items
        real_pair_array_items = self.snap_shot_data[
            verify_idx].pair_array_items
        verify_counts_data = self.snap_shot_data[
            verify_idx].verify_data

        registered_found_real = 0
        active_found_real = 0
        stopped_found_real = 0
        for name, real_reg_item in real_reg_items.items():
            if real_reg_item.is_alive:
                if real_reg_item.state == st.ThreadState.Alive:
                    active_found_real += 1
            else:
                if real_reg_item.state == st.ThreadState.Registered:
                    registered_found_real += 1
                elif (real_reg_item.state == st.ThreadState.Alive
                        or real_reg_item.state == st.ThreadState.Stopped):
                    stopped_found_real += 1

        registered_found_mock = 0
        active_found_mock = 0
        stopped_found_mock = 0
        for name, thread_tracker in self.expected_registered.items():
            if thread_tracker.is_alive:
                if thread_tracker.st_state == st.ThreadState.Alive:
                    active_found_mock += 1
            else:
                if thread_tracker.st_state == st.ThreadState.Registered:
                    registered_found_mock += 1
                elif (thread_tracker.st_state == st.ThreadState.Alive
                        or thread_tracker.st_state == st.ThreadState.Stopped):
                    stopped_found_mock += 1

        if not (verify_counts_data.num_registered
                == registered_found_real
                == registered_found_mock):
            self.abort_all_f1_threads()
            raise InvalidConfigurationDetected(
                f'verify_counts found expected '
                f'{verify_counts_data.num_registered=} is not equal to '
                f'{registered_found_real=} and/or {registered_found_mock=}')

        if not (verify_counts_data.num_active
                == active_found_real
                == active_found_mock):
            self.abort_all_f1_threads()
            raise InvalidConfigurationDetected(
                f'verify_counts found expected '
                f'{verify_counts_data.num_active=} is not equal to '
                f'{active_found_real=} and/or {active_found_mock=}')

        if not (verify_counts_data.num_stopped
                == stopped_found_real
                == stopped_found_mock):
            self.abort_all_f1_threads()
            raise InvalidConfigurationDetected(
                f'verify_counts found expected '
                f'{verify_counts_data.num_stopped=} is not equal to '
                f'{stopped_found_real=} and/or {stopped_found_mock=}')

    ####################################################################
    # verify_def_del
    ####################################################################
    def verify_def_del(self,
                       cmd_runner: str,
                       def_del_scenario: DefDelScenario,
                       receiver_names: list[str],
                       sender_names: list[str],
                       waiter_names: list[str],
                       resumer_names: list[str],
                       del_names: list[str],
                       add_names: list[str],
                       deleter_names: list[str],
                       adder_names: list[str]
                       ) -> None:
        """Verify that the given counts are correct.

        Args:
            cmd_runner: name of thread doing the cmd
            def_del_scenario: deferred delete scenario to verify
            receiver_names: names that do smart_recv
            sender_names: names that do smart_send
            waiter_names: names that do smart_wait
            resumer_names: names that do smart_resume
            del_names: names deleted during recv or wait
            add_names: names added during recv or wait
            deleter_names: names that do the delete
            adder_names: names that do the add

        Raises:
            FailedDefDelVerify: verify_def_del found neither smart_recv
                nor wait initial config_cmd log messages - one and only
                one is expected.
            InvalidConfigurationDetected: verify_def_del found pair_key
                is in real or mock pair array but is not in both

        """
        ################################################################
        # start by gathering log messages, both expected and not
        ################################################################
        ################################################################
        # get first config_cmd smart_recv log msg
        ################################################################
        search_msg = (r"config_cmd: RecvMsg\(serial=[0-9]+, line=[0-9]+, "
                      f"cmd_runners='{receiver_names[0]}', "
                      f"senders='{sender_names[0]}'")

        cc_recv_0_log_msg, cc_recv_0_log_pos = self.get_log_msg(
            search_msg=search_msg,
            skip_num=0,
            start_idx=0,
            # end_idx=log_idx,
            reverse_search=False)

        ################################################################
        # get first wait config_cmd log msg
        ################################################################
        search_msg = (r"config_cmd: Wait\(serial=[0-9]+, line=[0-9]+, "
                      f"cmd_runners='{waiter_names[0]}', "
                      f"resumers=")

        cc_wait_0_log_msg, cc_wait_0_log_pos = self.get_log_msg(
            search_msg=search_msg,
            skip_num=0,
            start_idx=0,
            # end_idx=log_idx,
            reverse_search=False)

        if not cc_recv_0_log_msg and not cc_wait_0_log_msg:
            raise FailedDefDelVerify('verify_def_del found neither smart_recv '
                                     'nor wait initial config_cmd log '
                                     'messages - one and only one is '
                                     'expected.')
        if cc_recv_0_log_msg:
            start_log_idx = cc_recv_0_log_pos + 1
        else:
            start_log_idx = cc_wait_0_log_pos + 1

        ################################################################
        # get config_cmd log msg for VerifyDefDel
        ################################################################
        search_msg = (r"config_cmd: VerifyDefDel\(serial=[0-9]+, line=[0-9]+, "
                      f"cmd_runners='{self.commander_name}', "
                      f"def_del_scenario=")

        cc_verify_dd_log_msg, cc_verify_dd_log_pos = self.get_log_msg(
            search_msg=search_msg,
            skip_num=0,
            start_idx=start_log_idx,
            # end_idx=log_idx,
            reverse_search=False)

        if not cc_verify_dd_log_msg:
            raise FailedDefDelVerify('verify_def_del failed to find the '
                                     'VerifyDefDel config_cmd log msg')
        end_log_idx = cc_verify_dd_log_pos

        ################################################################
        # get first smart_recv log msg
        ################################################################
        search_msg = (f'{receiver_names[0]} smart_recv received msg from '
                      f'{sender_names[0]}')

        recv_0_log_msg, recv_0_log_pos = self.get_log_msg(
            search_msg=search_msg,
            skip_num=0,
            start_idx=start_log_idx,
            end_idx=end_log_idx,
            reverse_search=False)

        ################################################################
        # get first smart_recv pair array log msgs found
        ################################################################
        recv_0_pa_msgs_found = self.find_def_del_pair_array_msgs(
            cmd_runner=receiver_names[0],
            request_type=st.ReqType.Smart_recv,
            deleted_names=[sender_names[0], resumer_names[0]],
            def_del_names=receiver_names + waiter_names,
            start_log_idx=start_log_idx,
            end_log_idx=end_log_idx)

        ################################################################
        # get second smart_recv log msg
        ################################################################
        search_msg = (f'{receiver_names[1]} smart_recv received msg from '
                      f'{sender_names[0]}')

        recv_1_log_msg, recv_1_log_pos = self.get_log_msg(
            search_msg=search_msg,
            skip_num=0,
            start_idx=start_log_idx,
            end_idx=end_log_idx,
            reverse_search=False)

        ################################################################
        # get second smart_recv pair array log msgs found
        ################################################################
        recv_1_pa_msgs_found = self.find_def_del_pair_array_msgs(
            cmd_runner=receiver_names[1],
            request_type=st.ReqType.Smart_recv,
            deleted_names=[sender_names[0], resumer_names[0]],
            def_del_names=receiver_names + waiter_names,
            start_log_idx=start_log_idx,
            end_log_idx=end_log_idx)
        ################################################################
        # get first wait log msg
        ################################################################
        search_msg = (f'{waiter_names[0]} smart_wait resumed by '
                      f'{resumer_names[0]}')

        wait_0_log_msg, wait_0_log_pos = self.get_log_msg(
            search_msg=search_msg,
            skip_num=0,
            start_idx=start_log_idx,
            end_idx=end_log_idx,
            reverse_search=False)

        ################################################################
        # get first wait pair array log msgs found
        ################################################################
        wait_0_pa_msgs_found = self.find_def_del_pair_array_msgs(
            cmd_runner=waiter_names[0],
            request_type=st.ReqType.Smart_wait,
            deleted_names=[sender_names[0], resumer_names[0]],
            def_del_names=receiver_names + waiter_names,
            start_log_idx=start_log_idx,
            end_log_idx=end_log_idx)

        ################################################################
        # get second wait log msg
        ################################################################
        search_msg = (f'{waiter_names[1]} smart_wait resumed by '
                      f'{resumer_names[0]}')

        wait_1_log_msg, wait_1_log_pos = self.get_log_msg(
            search_msg=search_msg,
            skip_num=0,
            start_idx=start_log_idx,
            end_idx=end_log_idx,
            reverse_search=False)

        ################################################################
        # get second wait pair array log msgs found
        ################################################################
        wait_1_pa_msgs_found = self.find_def_del_pair_array_msgs(
            cmd_runner=waiter_names[1],
            request_type=st.ReqType.Smart_wait,
            deleted_names=[sender_names[0], resumer_names[0]],
            def_del_names=receiver_names + waiter_names,
            start_log_idx=start_log_idx,
            end_log_idx=end_log_idx)

        ################################################################
        # get join log msgs found
        ################################################################
        del_pa_msgs_found = self.find_def_del_pair_array_msgs(
            cmd_runner=deleter_names[0],
            request_type=st.ReqType.Smart_join,
            deleted_names=[sender_names[0], resumer_names[0]],
            def_del_names=receiver_names + waiter_names,
            start_log_idx=start_log_idx,
            end_log_idx=end_log_idx)

        ################################################################
        # get add log msgs found
        ################################################################
        add_pa_msgs_found = self.find_def_del_pair_array_msgs(
            cmd_runner=adder_names[0],
            request_type=st.ReqType.Smart_init,
            deleted_names=[sender_names[0], resumer_names[0]],
            def_del_names=receiver_names + waiter_names,
            start_log_idx=start_log_idx,
            end_log_idx=end_log_idx)

        ################################################################
        # verify real variables
        ################################################################
        pair_key_exists: dict[tuple[str, str], bool] = {}
        for deleted_name in sender_names + resumer_names:
            for def_del_name in receiver_names + waiter_names:
                pair_key = st.SmartThread._get_pair_key(name0=deleted_name,
                                                        name1=def_del_name)
                if pair_key in st.SmartThread._pair_array:
                    pair_key_exists[pair_key] = True
                    if pair_key not in self.expected_pairs:
                        raise InvalidConfigurationDetected(
                            f'verify_def_del found {pair_key=} is in real '
                            'pair array but is not in mock pair array')
                else:
                    pair_key_exists[pair_key] = False
                    if pair_key in self.expected_pairs:
                        raise InvalidConfigurationDetected(
                            f'verify_def_del found {pair_key=} is not in '
                            'real pair array but is in mock pair array')

        ################################################################
        # verify for NormalRecv and ResurrectionRecv
        ################################################################
        if (def_del_scenario == DefDelScenario.NormalRecv
                or def_del_scenario == DefDelScenario.ResurrectionRecv):
            if not recv_0_log_msg:
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} failed to find the '
                    'recv_0_log_msg')
            if recv_1_log_msg or wait_0_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected log msg: '
                    f'{recv_1_log_msg=}, '
                    f'{wait_0_log_msg=}, '
                    f'{wait_1_log_msg=}')

            if (recv_0_pa_msgs_found.entered_rpa
                    or recv_0_pa_msgs_found.updated_pa
                    or recv_1_pa_msgs_found.entered_rpa
                    or recv_1_pa_msgs_found.updated_pa
                    or wait_0_pa_msgs_found.entered_rpa
                    or wait_0_pa_msgs_found.updated_pa
                    or wait_1_pa_msgs_found.entered_rpa
                    or wait_1_pa_msgs_found.updated_pa
                    or del_pa_msgs_found.entered_rpa
                    or del_pa_msgs_found.updated_pa
                    or add_pa_msgs_found.entered_rpa
                    or add_pa_msgs_found.updated_pa):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'{recv_0_pa_msgs_found.entered_rpa=}, '
                    f'{recv_0_pa_msgs_found.updated_pa=}, '
                    f'{recv_1_pa_msgs_found.updated_pa=}, '
                    f'{wait_0_pa_msgs_found.entered_rpa=}, '
                    f'{wait_0_pa_msgs_found.updated_pa=}, '
                    f'{wait_1_pa_msgs_found.entered_rpa=}, '
                    f'{wait_1_pa_msgs_found.updated_pa=}, '
                    f'{del_pa_msgs_found.entered_rpa=}, '
                    f'{del_pa_msgs_found.updated_pa=}, '
                    f'{add_pa_msgs_found.entered_rpa=}, '
                    f'{add_pa_msgs_found.updated_pa=}')
            if (len(recv_0_pa_msgs_found.removed_sb_entry)
                    or len(recv_0_pa_msgs_found.removed_pa_entry)
                    or len(recv_1_pa_msgs_found.removed_sb_entry)
                    or len(recv_1_pa_msgs_found.removed_pa_entry)
                    or len(wait_0_pa_msgs_found.removed_sb_entry)
                    or len(wait_0_pa_msgs_found.removed_pa_entry)
                    or len(wait_1_pa_msgs_found.removed_sb_entry)
                    or len(wait_1_pa_msgs_found.removed_pa_entry)
                    or len(del_pa_msgs_found.removed_sb_entry)
                    or len(del_pa_msgs_found.removed_pa_entry)
                    or len(add_pa_msgs_found.removed_sb_entry)
                    or len(add_pa_msgs_found.removed_pa_entry)):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'{recv_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{del_pa_msgs_found.removed_sb_entry=}, '
                    f'{del_pa_msgs_found.removed_pa_entry=}, '
                    f'{add_pa_msgs_found.removed_sb_entry=}, '
                    f'{add_pa_msgs_found.removed_pa_entry=}')

        ################################################################
        # verify for NormalWait and ResurrectionWait
        ################################################################
        if (def_del_scenario == DefDelScenario.NormalWait
                or def_del_scenario == DefDelScenario.ResurrectionWait):
            if not wait_0_log_msg:
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} failed to find the '
                    'recv_0_log_msg')
            if recv_0_log_msg or recv_1_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected log msg: '
                    f'{recv_1_log_msg=}, '
                    f'{wait_0_log_msg=}, '
                    f'{wait_1_log_msg=}')

            if (recv_0_pa_msgs_found.entered_rpa
                    or recv_0_pa_msgs_found.updated_pa
                    or recv_1_pa_msgs_found.entered_rpa
                    or recv_1_pa_msgs_found.updated_pa
                    or wait_0_pa_msgs_found.entered_rpa
                    or wait_0_pa_msgs_found.updated_pa
                    or wait_1_pa_msgs_found.entered_rpa
                    or wait_1_pa_msgs_found.updated_pa
                    or del_pa_msgs_found.entered_rpa
                    or del_pa_msgs_found.updated_pa
                    or add_pa_msgs_found.entered_rpa
                    or add_pa_msgs_found.updated_pa):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'{recv_0_pa_msgs_found.entered_rpa=}, '
                    f'{recv_0_pa_msgs_found.updated_pa=}, '
                    f'{recv_1_pa_msgs_found.updated_pa=}, '
                    f'{wait_0_pa_msgs_found.entered_rpa=}, '
                    f'{wait_0_pa_msgs_found.updated_pa=}, '
                    f'{wait_1_pa_msgs_found.entered_rpa=}, '
                    f'{wait_1_pa_msgs_found.updated_pa=}, '
                    f'{del_pa_msgs_found.entered_rpa=}, '
                    f'{del_pa_msgs_found.updated_pa=}, '
                    f'{add_pa_msgs_found.entered_rpa=}, '
                    f'{add_pa_msgs_found.updated_pa=}')

            if (len(recv_0_pa_msgs_found.removed_sb_entry)
                    or len(recv_0_pa_msgs_found.removed_pa_entry)
                    or len(recv_1_pa_msgs_found.removed_sb_entry)
                    or len(recv_1_pa_msgs_found.removed_pa_entry)
                    or len(wait_0_pa_msgs_found.removed_sb_entry)
                    or len(wait_0_pa_msgs_found.removed_pa_entry)
                    or len(wait_1_pa_msgs_found.removed_sb_entry)
                    or len(wait_1_pa_msgs_found.removed_pa_entry)
                    or len(del_pa_msgs_found.removed_sb_entry)
                    or len(del_pa_msgs_found.removed_pa_entry)
                    or len(add_pa_msgs_found.removed_sb_entry)
                    or len(add_pa_msgs_found.removed_pa_entry)):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'{recv_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{del_pa_msgs_found.removed_sb_entry=}, '
                    f'{del_pa_msgs_found.removed_pa_entry=}, '
                    f'{add_pa_msgs_found.removed_sb_entry=}, '
                    f'{add_pa_msgs_found.removed_pa_entry=}')

        ################################################################
        # verify for Recv0Recv1
        ################################################################
        if def_del_scenario == DefDelScenario.Recv0Recv1:
            if not (recv_0_log_msg and recv_1_log_msg):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} failed to find the '
                    'one or both recv messages:  '
                    f'{recv_0_log_msg=}, '
                    f'{recv_1_log_msg=}')
            if wait_0_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected log msg: '
                    f'{wait_0_log_msg=}, '
                    f'{wait_1_log_msg=}')

            if ((not recv_0_pa_msgs_found.entered_rpa)
                    or (not recv_0_pa_msgs_found.updated_pa)
                    or (not recv_1_pa_msgs_found.entered_rpa)
                    or recv_1_pa_msgs_found.updated_pa
                    or wait_0_pa_msgs_found.entered_rpa
                    or wait_0_pa_msgs_found.updated_pa
                    or wait_1_pa_msgs_found.entered_rpa
                    or wait_1_pa_msgs_found.updated_pa
                    or del_pa_msgs_found.entered_rpa
                    or del_pa_msgs_found.updated_pa
                    or add_pa_msgs_found.entered_rpa
                    or add_pa_msgs_found.updated_pa):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'\n{recv_0_pa_msgs_found.entered_rpa=}, '
                    f'{recv_0_pa_msgs_found.updated_pa=}, '
                    f'\n{recv_1_pa_msgs_found.entered_rpa=}, '
                    f'{recv_1_pa_msgs_found.updated_pa=}, '
                    f'\n{wait_0_pa_msgs_found.entered_rpa=}, '
                    f'{wait_0_pa_msgs_found.updated_pa=}, '
                    f'\n{wait_1_pa_msgs_found.entered_rpa=}, '
                    f'{wait_1_pa_msgs_found.updated_pa=}, '
                    f'\n{del_pa_msgs_found.entered_rpa=}, '
                    f'{del_pa_msgs_found.updated_pa=}, '
                    f'\n{add_pa_msgs_found.entered_rpa=}, '
                    f'{add_pa_msgs_found.updated_pa=}')
            if ((len(recv_0_pa_msgs_found.removed_sb_entry) == 0)
                    or (len(recv_0_pa_msgs_found.removed_pa_entry) == 0)
                    or len(recv_1_pa_msgs_found.removed_sb_entry)
                    or len(recv_1_pa_msgs_found.removed_pa_entry)
                    or len(wait_0_pa_msgs_found.removed_sb_entry)
                    or len(wait_0_pa_msgs_found.removed_pa_entry)
                    or len(wait_1_pa_msgs_found.removed_sb_entry)
                    or len(wait_1_pa_msgs_found.removed_pa_entry)
                    or len(del_pa_msgs_found.removed_sb_entry)
                    or len(del_pa_msgs_found.removed_pa_entry)
                    or len(add_pa_msgs_found.removed_sb_entry)
                    or len(add_pa_msgs_found.removed_pa_entry)):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'\n{recv_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_0_pa_msgs_found.removed_pa_entry=}, '
                    f'\n{recv_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_pa_entry=}, '
                    f'\n{wait_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_pa_entry=}, '
                    f'\n{wait_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_pa_entry=}, '
                    f'\n{del_pa_msgs_found.removed_sb_entry=}, '
                    f'{del_pa_msgs_found.removed_pa_entry=}, '
                    f'\n{add_pa_msgs_found.removed_sb_entry=}, '
                    f'{add_pa_msgs_found.removed_pa_entry=}')
            exp_pair_keys: list[tuple[str, str]] = []
            pair_key = st.SmartThread._get_pair_key(name0=sender_names[0],
                                                    name1=receiver_names[0])
            exp_pair_keys.append(pair_key)
            pair_key = st.SmartThread._get_pair_key(name0=sender_names[0],
                                                    name1=receiver_names[1])
            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (pair_key not in recv_0_pa_msgs_found.removed_sb_entry
                        or pair_key
                        not in recv_0_pa_msgs_found.removed_pa_entry):
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from {exp_pair_keys=} is missing '
                        f'from {recv_0_pa_msgs_found.removed_sb_entry=} or '
                        f'{recv_0_pa_msgs_found.removed_pa_entry=}')
            for pair_key in recv_0_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{recv_0_pa_msgs_found.removed_sb_entry=} is '
                        f'missing from {exp_pair_keys=}')
            for pair_key in recv_0_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{recv_0_pa_msgs_found.removed_pa_entry=} is '
                        f'missing from {exp_pair_keys=}')

        ################################################################
        # verify for Recv1Recv0
        ################################################################
        if def_del_scenario == DefDelScenario.Recv1Recv0:
            if not (recv_0_log_msg and recv_1_log_msg):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} failed to find the '
                    'one or both recv messages:  '
                    f'{recv_0_log_msg=}, '
                    f'{recv_1_log_msg=}')
            if wait_0_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected log msg: '
                    f'{wait_0_log_msg=}, '
                    f'{wait_1_log_msg=}')

            if ((not recv_0_pa_msgs_found.entered_rpa)
                    or recv_0_pa_msgs_found.updated_pa
                    or (not recv_1_pa_msgs_found.entered_rpa)
                    or (not recv_1_pa_msgs_found.updated_pa)
                    or wait_0_pa_msgs_found.entered_rpa
                    or wait_0_pa_msgs_found.updated_pa
                    or wait_1_pa_msgs_found.entered_rpa
                    or wait_1_pa_msgs_found.updated_pa
                    or del_pa_msgs_found.entered_rpa
                    or del_pa_msgs_found.updated_pa
                    or add_pa_msgs_found.entered_rpa
                    or add_pa_msgs_found.updated_pa):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'\n{recv_0_pa_msgs_found.entered_rpa=}, '
                    f'{recv_0_pa_msgs_found.updated_pa=}, '
                    f'\n{recv_1_pa_msgs_found.entered_rpa=}, '
                    f'{recv_1_pa_msgs_found.updated_pa=}, '
                    f'\n{wait_0_pa_msgs_found.entered_rpa=}, '
                    f'{wait_0_pa_msgs_found.updated_pa=}, '
                    f'\n{wait_1_pa_msgs_found.entered_rpa=}, '
                    f'{wait_1_pa_msgs_found.updated_pa=}, '
                    f'\n{del_pa_msgs_found.entered_rpa=}, '
                    f'{del_pa_msgs_found.updated_pa=}, '
                    f'\n{add_pa_msgs_found.entered_rpa=}, '
                    f'{add_pa_msgs_found.updated_pa=}')
            if (len(recv_0_pa_msgs_found.removed_sb_entry)
                    or len(recv_0_pa_msgs_found.removed_pa_entry)
                    or (len(recv_1_pa_msgs_found.removed_sb_entry) == 0)
                    or (len(recv_1_pa_msgs_found.removed_pa_entry) == 0)
                    or len(wait_0_pa_msgs_found.removed_sb_entry)
                    or len(wait_0_pa_msgs_found.removed_pa_entry)
                    or len(wait_1_pa_msgs_found.removed_sb_entry)
                    or len(wait_1_pa_msgs_found.removed_pa_entry)
                    or len(del_pa_msgs_found.removed_sb_entry)
                    or len(del_pa_msgs_found.removed_pa_entry)
                    or len(add_pa_msgs_found.removed_sb_entry)
                    or len(add_pa_msgs_found.removed_pa_entry)):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'{recv_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{del_pa_msgs_found.removed_sb_entry=}, '
                    f'{del_pa_msgs_found.removed_pa_entry=}, '
                    f'{add_pa_msgs_found.removed_sb_entry=}, '
                    f'{add_pa_msgs_found.removed_pa_entry=}')
            exp_pair_keys: list[tuple[str, str]] = []
            pair_key = st.SmartThread._get_pair_key(name0=sender_names[0],
                                                    name1=receiver_names[0])
            exp_pair_keys.append(pair_key)
            pair_key = st.SmartThread._get_pair_key(name0=sender_names[0],
                                                    name1=receiver_names[1])
            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (pair_key not in recv_1_pa_msgs_found.removed_sb_entry
                        or pair_key
                        not in recv_1_pa_msgs_found.removed_pa_entry):
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from {exp_pair_keys=} is missing '
                        f'from {recv_1_pa_msgs_found.removed_sb_entry=} or '
                        f'{recv_1_pa_msgs_found.removed_pa_entry=}')
            for pair_key in recv_1_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{recv_1_pa_msgs_found.removed_sb_entry=} is '
                        f'missing from {exp_pair_keys=}')
            for pair_key in recv_1_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{recv_1_pa_msgs_found.removed_pa_entry=} is '
                        f'missing from {exp_pair_keys=}')

        ################################################################
        # verify for Wait0Wait1
        ################################################################
        if def_del_scenario == DefDelScenario.Wait0Wait1:
            if not (wait_0_log_msg and wait_1_log_msg):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} failed to find the '
                    'one or both wait messages:  '
                    f'{wait_0_log_msg=}, '
                    f'{wait_1_log_msg=}')
            if recv_0_log_msg or recv_1_log_msg:
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected log msg: '
                    f'{recv_0_log_msg=}, '
                    f'{recv_1_log_msg=}')

            if (recv_0_pa_msgs_found.entered_rpa
                    or recv_0_pa_msgs_found.updated_pa
                    or recv_1_pa_msgs_found.entered_rpa
                    or recv_1_pa_msgs_found.updated_pa
                    or (not wait_0_pa_msgs_found.entered_rpa)
                    or (not wait_0_pa_msgs_found.updated_pa)
                    or (not wait_1_pa_msgs_found.entered_rpa)
                    or wait_1_pa_msgs_found.updated_pa
                    or del_pa_msgs_found.entered_rpa
                    or del_pa_msgs_found.updated_pa
                    or add_pa_msgs_found.entered_rpa
                    or add_pa_msgs_found.updated_pa):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'{recv_0_pa_msgs_found.entered_rpa=}, '
                    f'{recv_0_pa_msgs_found.updated_pa=}, '
                    f'{recv_1_pa_msgs_found.updated_pa=}, '
                    f'{wait_0_pa_msgs_found.entered_rpa=}, '
                    f'{wait_0_pa_msgs_found.updated_pa=}, '
                    f'{wait_1_pa_msgs_found.entered_rpa=}, '
                    f'{wait_1_pa_msgs_found.updated_pa=}, '
                    f'{del_pa_msgs_found.entered_rpa=}, '
                    f'{del_pa_msgs_found.updated_pa=}, '
                    f'{add_pa_msgs_found.entered_rpa=}, '
                    f'{add_pa_msgs_found.updated_pa=}')
            if (len(recv_0_pa_msgs_found.removed_sb_entry)
                    or len(recv_0_pa_msgs_found.removed_pa_entry)
                    or len(recv_1_pa_msgs_found.removed_sb_entry)
                    or len(recv_1_pa_msgs_found.removed_pa_entry)
                    or (len(wait_0_pa_msgs_found.removed_sb_entry) == 0)
                    or (len(wait_0_pa_msgs_found.removed_pa_entry) == 0)
                    or len(wait_1_pa_msgs_found.removed_sb_entry)
                    or len(wait_1_pa_msgs_found.removed_pa_entry)
                    or len(del_pa_msgs_found.removed_sb_entry)
                    or len(del_pa_msgs_found.removed_pa_entry)
                    or len(add_pa_msgs_found.removed_sb_entry)
                    or len(add_pa_msgs_found.removed_pa_entry)):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'{recv_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{del_pa_msgs_found.removed_sb_entry=}, '
                    f'{del_pa_msgs_found.removed_pa_entry=}, '
                    f'{add_pa_msgs_found.removed_sb_entry=}, '
                    f'{add_pa_msgs_found.removed_pa_entry=}')
            exp_pair_keys: list[tuple[str, str]] = []
            pair_key = st.SmartThread._get_pair_key(name0=resumer_names[0],
                                                    name1=waiter_names[0])
            exp_pair_keys.append(pair_key)
            pair_key = st.SmartThread._get_pair_key(name0=resumer_names[0],
                                                    name1=waiter_names[1])
            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (pair_key not in wait_0_pa_msgs_found.removed_sb_entry
                        or pair_key
                        not in wait_0_pa_msgs_found.removed_pa_entry):
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from {exp_pair_keys=} is missing '
                        f'from {wait_0_pa_msgs_found.removed_sb_entry=} or '
                        f'{wait_0_pa_msgs_found.removed_pa_entry=}')
            for pair_key in wait_0_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{wait_0_pa_msgs_found.removed_sb_entry=} is '
                        f'missing from {exp_pair_keys=}')
            for pair_key in wait_0_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{wait_0_pa_msgs_found.removed_pa_entry=} is '
                        f'missing from {exp_pair_keys=}')

        ################################################################
        # verify for Wait1Wait0
        ################################################################
        if def_del_scenario == DefDelScenario.Wait1Wait0:
            if not (wait_0_log_msg and wait_1_log_msg):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} failed to find the '
                    'one or both wait messages:  '
                    f'{wait_0_log_msg=}, '
                    f'{wait_1_log_msg=}')
            if recv_0_log_msg or recv_1_log_msg:
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected log msg: '
                    f'{recv_0_log_msg=}, '
                    f'{recv_1_log_msg=}')

            if (recv_0_pa_msgs_found.entered_rpa
                    or recv_0_pa_msgs_found.updated_pa
                    or recv_1_pa_msgs_found.entered_rpa
                    or recv_1_pa_msgs_found.updated_pa
                    or (not wait_0_pa_msgs_found.entered_rpa)
                    or wait_0_pa_msgs_found.updated_pa
                    or (not wait_1_pa_msgs_found.entered_rpa)
                    or (not wait_1_pa_msgs_found.updated_pa)
                    or del_pa_msgs_found.entered_rpa
                    or del_pa_msgs_found.updated_pa
                    or add_pa_msgs_found.entered_rpa
                    or add_pa_msgs_found.updated_pa):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'{recv_0_pa_msgs_found.entered_rpa=}, '
                    f'{recv_0_pa_msgs_found.updated_pa=}, '
                    f'{recv_1_pa_msgs_found.updated_pa=}, '
                    f'{wait_0_pa_msgs_found.entered_rpa=}, '
                    f'{wait_0_pa_msgs_found.updated_pa=}, '
                    f'{wait_1_pa_msgs_found.entered_rpa=}, '
                    f'{wait_1_pa_msgs_found.updated_pa=}, '
                    f'{del_pa_msgs_found.entered_rpa=}, '
                    f'{del_pa_msgs_found.updated_pa=}, '
                    f'{add_pa_msgs_found.entered_rpa=}, '
                    f'{add_pa_msgs_found.updated_pa=}')
            if (len(recv_0_pa_msgs_found.removed_sb_entry)
                    or len(recv_0_pa_msgs_found.removed_pa_entry)
                    or len(recv_1_pa_msgs_found.removed_sb_entry)
                    or len(recv_1_pa_msgs_found.removed_pa_entry)
                    or len(wait_0_pa_msgs_found.removed_sb_entry)
                    or len(wait_0_pa_msgs_found.removed_pa_entry)
                    or (len(wait_1_pa_msgs_found.removed_sb_entry) == 0)
                    or (len(wait_1_pa_msgs_found.removed_pa_entry) == 0)
                    or len(del_pa_msgs_found.removed_sb_entry)
                    or len(del_pa_msgs_found.removed_pa_entry)
                    or len(add_pa_msgs_found.removed_sb_entry)
                    or len(add_pa_msgs_found.removed_pa_entry)):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'{recv_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{del_pa_msgs_found.removed_sb_entry=}, '
                    f'{del_pa_msgs_found.removed_pa_entry=}, '
                    f'{add_pa_msgs_found.removed_sb_entry=}, '
                    f'{add_pa_msgs_found.removed_pa_entry=}')
            exp_pair_keys: list[tuple[str, str]] = []
            pair_key = st.SmartThread._get_pair_key(name0=resumer_names[0],
                                                    name1=waiter_names[0])
            exp_pair_keys.append(pair_key)
            pair_key = st.SmartThread._get_pair_key(name0=resumer_names[0],
                                                    name1=waiter_names[1])
            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (pair_key not in wait_1_pa_msgs_found.removed_sb_entry
                        or pair_key
                        not in wait_1_pa_msgs_found.removed_pa_entry):
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from {exp_pair_keys=} is missing '
                        f'from {wait_1_pa_msgs_found.removed_sb_entry=} or '
                        f'{wait_1_pa_msgs_found.removed_pa_entry=}')
            for pair_key in wait_1_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{wait_1_pa_msgs_found.removed_sb_entry=} is '
                        f'missing from {exp_pair_keys=}')
            for pair_key in wait_1_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{wait_1_pa_msgs_found.removed_pa_entry=} is '
                        f'missing from {exp_pair_keys=}')

        ################################################################
        # verify for RecvWait
        ################################################################
        if def_del_scenario == DefDelScenario.RecvWait:
            if not (recv_0_log_msg and wait_0_log_msg):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} failed to find the '
                    'one or both wait messages:  '
                    f'{recv_0_log_msg=}, '
                    f'{wait_0_log_msg=}')
            if recv_1_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected log msg: '
                    f'{recv_1_log_msg=}, '
                    f'{wait_1_log_msg=}')

            if ((not recv_0_pa_msgs_found.entered_rpa)
                    or (not recv_0_pa_msgs_found.updated_pa)
                    or recv_1_pa_msgs_found.entered_rpa
                    or recv_1_pa_msgs_found.updated_pa
                    or (not wait_0_pa_msgs_found.entered_rpa)
                    or wait_0_pa_msgs_found.updated_pa
                    or wait_1_pa_msgs_found.entered_rpa
                    or wait_1_pa_msgs_found.updated_pa
                    or del_pa_msgs_found.entered_rpa
                    or del_pa_msgs_found.updated_pa
                    or add_pa_msgs_found.entered_rpa
                    or add_pa_msgs_found.updated_pa):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'{recv_0_pa_msgs_found.entered_rpa=}, '
                    f'{recv_0_pa_msgs_found.updated_pa=}, '
                    f'{recv_1_pa_msgs_found.updated_pa=}, '
                    f'{wait_0_pa_msgs_found.entered_rpa=}, '
                    f'{wait_0_pa_msgs_found.updated_pa=}, '
                    f'{wait_1_pa_msgs_found.entered_rpa=}, '
                    f'{wait_1_pa_msgs_found.updated_pa=}, '
                    f'{del_pa_msgs_found.entered_rpa=}, '
                    f'{del_pa_msgs_found.updated_pa=}, '
                    f'{add_pa_msgs_found.entered_rpa=}, '
                    f'{add_pa_msgs_found.updated_pa=}')
            if ((len(recv_0_pa_msgs_found.removed_sb_entry) == 0)
                    or (len(recv_0_pa_msgs_found.removed_pa_entry) == 0)
                    or len(recv_1_pa_msgs_found.removed_sb_entry)
                    or len(recv_1_pa_msgs_found.removed_pa_entry)
                    or len(wait_0_pa_msgs_found.removed_sb_entry)
                    or len(wait_0_pa_msgs_found.removed_pa_entry)
                    or len(wait_1_pa_msgs_found.removed_sb_entry)
                    or len(wait_1_pa_msgs_found.removed_pa_entry)
                    or len(del_pa_msgs_found.removed_sb_entry)
                    or len(del_pa_msgs_found.removed_pa_entry)
                    or len(add_pa_msgs_found.removed_sb_entry)
                    or len(add_pa_msgs_found.removed_pa_entry)):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'{recv_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{del_pa_msgs_found.removed_sb_entry=}, '
                    f'{del_pa_msgs_found.removed_pa_entry=}, '
                    f'{add_pa_msgs_found.removed_sb_entry=}, '
                    f'{add_pa_msgs_found.removed_pa_entry=}')
            exp_pair_keys: list[tuple[str, str]] = []
            pair_key = st.SmartThread._get_pair_key(name0=sender_names[0],
                                                    name1=receiver_names[0])
            exp_pair_keys.append(pair_key)
            pair_key = st.SmartThread._get_pair_key(name0=resumer_names[0],
                                                    name1=waiter_names[0])
            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (pair_key not in recv_0_pa_msgs_found.removed_sb_entry
                        or pair_key
                        not in recv_0_pa_msgs_found.removed_pa_entry):
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from {exp_pair_keys=} is missing '
                        f'from {recv_0_pa_msgs_found.removed_sb_entry=} or '
                        f'{recv_0_pa_msgs_found.removed_pa_entry=}')
            for pair_key in recv_0_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{recv_0_pa_msgs_found.removed_sb_entry=} is '
                        f'missing from {exp_pair_keys=}')
            for pair_key in recv_0_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{recv_0_pa_msgs_found.removed_pa_entry=} is '
                        f'missing from {exp_pair_keys=}')

        ################################################################
        # verify for WaitRecv
        ################################################################
        if def_del_scenario == DefDelScenario.WaitRecv:
            if not (recv_0_log_msg and wait_0_log_msg):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} failed to find the '
                    'one or both wait messages:  '
                    f'{recv_0_log_msg=}, '
                    f'{wait_0_log_msg=}')
            if recv_1_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected log msg: '
                    f'{recv_1_log_msg=}, '
                    f'{wait_1_log_msg=}')

            if ((not recv_0_pa_msgs_found.entered_rpa)
                    or recv_0_pa_msgs_found.updated_pa
                    or recv_1_pa_msgs_found.entered_rpa
                    or recv_1_pa_msgs_found.updated_pa
                    or (not wait_0_pa_msgs_found.entered_rpa)
                    or (not wait_0_pa_msgs_found.updated_pa)
                    or wait_1_pa_msgs_found.entered_rpa
                    or wait_1_pa_msgs_found.updated_pa
                    or del_pa_msgs_found.entered_rpa
                    or del_pa_msgs_found.updated_pa
                    or add_pa_msgs_found.entered_rpa
                    or add_pa_msgs_found.updated_pa):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'{recv_0_pa_msgs_found.entered_rpa=}, '
                    f'{recv_0_pa_msgs_found.updated_pa=}, '
                    f'{recv_1_pa_msgs_found.updated_pa=}, '
                    f'{wait_0_pa_msgs_found.entered_rpa=}, '
                    f'{wait_0_pa_msgs_found.updated_pa=}, '
                    f'{wait_1_pa_msgs_found.entered_rpa=}, '
                    f'{wait_1_pa_msgs_found.updated_pa=}, '
                    f'{del_pa_msgs_found.entered_rpa=}, '
                    f'{del_pa_msgs_found.updated_pa=}, '
                    f'{add_pa_msgs_found.entered_rpa=}, '
                    f'{add_pa_msgs_found.updated_pa=}')
            if (len(recv_0_pa_msgs_found.removed_sb_entry)
                    or len(recv_0_pa_msgs_found.removed_pa_entry)
                    or len(recv_1_pa_msgs_found.removed_sb_entry)
                    or len(recv_1_pa_msgs_found.removed_pa_entry)
                    or (len(wait_0_pa_msgs_found.removed_sb_entry) == 0)
                    or (len(wait_0_pa_msgs_found.removed_pa_entry) == 0)
                    or len(wait_1_pa_msgs_found.removed_sb_entry)
                    or len(wait_1_pa_msgs_found.removed_pa_entry)
                    or len(del_pa_msgs_found.removed_sb_entry)
                    or len(del_pa_msgs_found.removed_pa_entry)
                    or len(add_pa_msgs_found.removed_sb_entry)
                    or len(add_pa_msgs_found.removed_pa_entry)):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'{recv_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{del_pa_msgs_found.removed_sb_entry=}, '
                    f'{del_pa_msgs_found.removed_pa_entry=}, '
                    f'{add_pa_msgs_found.removed_sb_entry=}, '
                    f'{add_pa_msgs_found.removed_pa_entry=}')
            exp_pair_keys: list[tuple[str, str]] = []
            pair_key = st.SmartThread._get_pair_key(name0=sender_names[0],
                                                    name1=receiver_names[0])
            exp_pair_keys.append(pair_key)
            pair_key = st.SmartThread._get_pair_key(name0=resumer_names[0],
                                                    name1=waiter_names[0])
            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (pair_key not in wait_0_pa_msgs_found.removed_sb_entry
                        or pair_key
                        not in wait_0_pa_msgs_found.removed_pa_entry):
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from {exp_pair_keys=} is missing '
                        f'from {wait_0_pa_msgs_found.removed_sb_entry=} or '
                        f'{wait_0_pa_msgs_found.removed_pa_entry=}')
            for pair_key in wait_0_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{wait_0_pa_msgs_found.removed_sb_entry=} is '
                        f'missing from {exp_pair_keys=}')
            for pair_key in wait_0_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{wait_0_pa_msgs_found.removed_pa_entry=} is '
                        f'missing from {exp_pair_keys=}')

        ################################################################
        # verify for RecvDel
        ################################################################
        if def_del_scenario == DefDelScenario.RecvDel:
            if not recv_0_log_msg:
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} failed to find the '
                    'recv message:  '
                    f'{recv_0_log_msg=}')
            if recv_1_log_msg or wait_0_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected log msg: '
                    f'{recv_1_log_msg=}, '
                    f'{wait_0_log_msg=}, '
                    f'{wait_1_log_msg=}')

            if ((not recv_0_pa_msgs_found.entered_rpa)
                    or recv_0_pa_msgs_found.updated_pa
                    or recv_1_pa_msgs_found.entered_rpa
                    or recv_1_pa_msgs_found.updated_pa
                    or wait_0_pa_msgs_found.entered_rpa
                    or wait_0_pa_msgs_found.updated_pa
                    or wait_1_pa_msgs_found.entered_rpa
                    or wait_1_pa_msgs_found.updated_pa
                    or (not del_pa_msgs_found.entered_rpa)
                    or (not del_pa_msgs_found.updated_pa)
                    or add_pa_msgs_found.entered_rpa
                    or add_pa_msgs_found.updated_pa):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'\n{recv_0_pa_msgs_found.entered_rpa=}, '
                    f'{recv_0_pa_msgs_found.updated_pa=}, '
                    f'\n{recv_1_pa_msgs_found.entered_rpa=}, '
                    f'{recv_1_pa_msgs_found.updated_pa=}, '
                    f'\n{wait_0_pa_msgs_found.entered_rpa=}, '
                    f'{wait_0_pa_msgs_found.updated_pa=}, '
                    f'\n{wait_1_pa_msgs_found.entered_rpa=}, '
                    f'{wait_1_pa_msgs_found.updated_pa=}, '
                    f'\n{del_pa_msgs_found.entered_rpa=}, '
                    f'{del_pa_msgs_found.updated_pa=}, '
                    f'\n{add_pa_msgs_found.entered_rpa=}, '
                    f'{add_pa_msgs_found.updated_pa=}')
            if (len(recv_0_pa_msgs_found.removed_sb_entry)
                    or len(recv_0_pa_msgs_found.removed_pa_entry)
                    or len(recv_1_pa_msgs_found.removed_sb_entry)
                    or len(recv_1_pa_msgs_found.removed_pa_entry)
                    or len(wait_0_pa_msgs_found.removed_sb_entry)
                    or len(wait_0_pa_msgs_found.removed_pa_entry)
                    or len(wait_1_pa_msgs_found.removed_sb_entry)
                    or len(wait_1_pa_msgs_found.removed_pa_entry)
                    or (len(del_pa_msgs_found.removed_sb_entry) == 0)
                    or (len(del_pa_msgs_found.removed_pa_entry) == 0)
                    or len(add_pa_msgs_found.removed_sb_entry)
                    or len(add_pa_msgs_found.removed_pa_entry)):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'{recv_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{del_pa_msgs_found.removed_sb_entry=}, '
                    f'{del_pa_msgs_found.removed_pa_entry=}, '
                    f'{add_pa_msgs_found.removed_sb_entry=}, '
                    f'{add_pa_msgs_found.removed_pa_entry=}')
            exp_pair_keys: list[tuple[str, str]] = []
            pair_key = st.SmartThread._get_pair_key(name0=sender_names[0],
                                                    name1=receiver_names[0])

            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (pair_key not in del_pa_msgs_found.removed_sb_entry
                        or pair_key
                        not in del_pa_msgs_found.removed_pa_entry):
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from {exp_pair_keys=} is missing '
                        f'from {del_pa_msgs_found.removed_sb_entry=} or '
                        f'{del_pa_msgs_found.removed_pa_entry=}')
            for pair_key in del_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{del_pa_msgs_found.removed_sb_entry=} is '
                        f'missing from {exp_pair_keys=}')
            for pair_key in del_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{del_pa_msgs_found.removed_pa_entry=} is '
                        f'missing from {exp_pair_keys=}')

        ################################################################
        # verify for RecvAdd
        ################################################################
        if def_del_scenario == DefDelScenario.RecvAdd:
            if not recv_0_log_msg:
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} failed to find the '
                    'recv message:  '
                    f'{recv_0_log_msg=}')
            if recv_1_log_msg or wait_0_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected log msg: '
                    f'{recv_1_log_msg=}, '
                    f'{wait_0_log_msg=}, '
                    f'{wait_1_log_msg=}')

            if (not recv_0_pa_msgs_found.entered_rpa
                    or recv_0_pa_msgs_found.updated_pa
                    or recv_1_pa_msgs_found.entered_rpa
                    or recv_1_pa_msgs_found.updated_pa
                    or wait_0_pa_msgs_found.entered_rpa
                    or wait_0_pa_msgs_found.updated_pa
                    or wait_1_pa_msgs_found.entered_rpa
                    or wait_1_pa_msgs_found.updated_pa
                    or del_pa_msgs_found.entered_rpa
                    or del_pa_msgs_found.updated_pa
                    or not add_pa_msgs_found.entered_rpa
                    or not add_pa_msgs_found.updated_pa):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'\n{recv_0_pa_msgs_found.entered_rpa=}, '
                    f'{recv_0_pa_msgs_found.updated_pa=}, '
                    f'\n{recv_1_pa_msgs_found.entered_rpa=}, '
                    f'{recv_1_pa_msgs_found.updated_pa=}, '
                    f'\n{wait_0_pa_msgs_found.entered_rpa=}, '
                    f'{wait_0_pa_msgs_found.updated_pa=}, '
                    f'\n{wait_1_pa_msgs_found.entered_rpa=}, '
                    f'{wait_1_pa_msgs_found.updated_pa=}, '
                    f'\n{del_pa_msgs_found.entered_rpa=}, '
                    f'{del_pa_msgs_found.updated_pa=}, '
                    f'\n{add_pa_msgs_found.entered_rpa=}, '
                    f'{add_pa_msgs_found.updated_pa=}')
            if (len(recv_0_pa_msgs_found.removed_sb_entry)
                    or len(recv_0_pa_msgs_found.removed_pa_entry)
                    or len(recv_1_pa_msgs_found.removed_sb_entry)
                    or len(recv_1_pa_msgs_found.removed_pa_entry)
                    or len(wait_0_pa_msgs_found.removed_sb_entry)
                    or len(wait_0_pa_msgs_found.removed_pa_entry)
                    or len(wait_1_pa_msgs_found.removed_sb_entry)
                    or len(wait_1_pa_msgs_found.removed_pa_entry)
                    or len(del_pa_msgs_found.removed_sb_entry)
                    or len(del_pa_msgs_found.removed_pa_entry)
                    or (len(add_pa_msgs_found.removed_sb_entry) == 0)
                    or (len(add_pa_msgs_found.removed_pa_entry) == 0)):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'{recv_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{del_pa_msgs_found.removed_sb_entry=}, '
                    f'{del_pa_msgs_found.removed_pa_entry=}, '
                    f'{add_pa_msgs_found.removed_sb_entry=}, '
                    f'{add_pa_msgs_found.removed_pa_entry=}')
            exp_pair_keys: list[tuple[str, str]] = []
            pair_key = st.SmartThread._get_pair_key(name0=sender_names[0],
                                                    name1=receiver_names[0])

            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (pair_key not in add_pa_msgs_found.removed_sb_entry
                        or pair_key
                        not in add_pa_msgs_found.removed_pa_entry):
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from {exp_pair_keys=} is missing '
                        f'from {add_pa_msgs_found.removed_sb_entry=} or '
                        f'{add_pa_msgs_found.removed_pa_entry=}')
            for pair_key in add_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{add_pa_msgs_found.removed_sb_entry=} is '
                        f'missing from {exp_pair_keys=}')
            for pair_key in add_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{add_pa_msgs_found.removed_pa_entry=} is '
                        f'missing from {exp_pair_keys=}')

        ################################################################
        # verify for WaitDel
        ################################################################
        if def_del_scenario == DefDelScenario.WaitDel:
            if not wait_0_log_msg:
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} failed to find the '
                    'wait message:  '
                    f'{wait_0_log_msg=}')
            if recv_0_log_msg or recv_1_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected log msg: '
                    f'{recv_0_log_msg=}, '
                    f'{recv_1_log_msg=}, '
                    f'{wait_1_log_msg=}')

            if (recv_0_pa_msgs_found.entered_rpa
                    or recv_0_pa_msgs_found.updated_pa
                    or recv_1_pa_msgs_found.entered_rpa
                    or recv_1_pa_msgs_found.updated_pa
                    or (not wait_0_pa_msgs_found.entered_rpa)
                    or wait_0_pa_msgs_found.updated_pa
                    or wait_1_pa_msgs_found.entered_rpa
                    or wait_1_pa_msgs_found.updated_pa
                    or (not del_pa_msgs_found.entered_rpa)
                    or (not del_pa_msgs_found.updated_pa)
                    or add_pa_msgs_found.entered_rpa
                    or add_pa_msgs_found.updated_pa):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'{recv_0_pa_msgs_found.entered_rpa=}, '
                    f'{recv_0_pa_msgs_found.updated_pa=}, '
                    f'{recv_1_pa_msgs_found.updated_pa=}, '
                    f'{wait_0_pa_msgs_found.entered_rpa=}, '
                    f'{wait_0_pa_msgs_found.updated_pa=}, '
                    f'{wait_1_pa_msgs_found.entered_rpa=}, '
                    f'{wait_1_pa_msgs_found.updated_pa=}, '
                    f'{del_pa_msgs_found.entered_rpa=}, '
                    f'{del_pa_msgs_found.updated_pa=}, '
                    f'{add_pa_msgs_found.entered_rpa=}, '
                    f'{add_pa_msgs_found.updated_pa=}')
            if (len(recv_0_pa_msgs_found.removed_sb_entry)
                    or len(recv_0_pa_msgs_found.removed_pa_entry)
                    or len(recv_1_pa_msgs_found.removed_sb_entry)
                    or len(recv_1_pa_msgs_found.removed_pa_entry)
                    or len(wait_0_pa_msgs_found.removed_sb_entry)
                    or len(wait_0_pa_msgs_found.removed_pa_entry)
                    or len(wait_1_pa_msgs_found.removed_sb_entry)
                    or len(wait_1_pa_msgs_found.removed_pa_entry)
                    or (len(del_pa_msgs_found.removed_sb_entry) == 0)
                    or (len(del_pa_msgs_found.removed_pa_entry) == 0)
                    or len(add_pa_msgs_found.removed_sb_entry)
                    or len(add_pa_msgs_found.removed_pa_entry)):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'{recv_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{del_pa_msgs_found.removed_sb_entry=}, '
                    f'{del_pa_msgs_found.removed_pa_entry=}, '
                    f'{add_pa_msgs_found.removed_sb_entry=}, '
                    f'{add_pa_msgs_found.removed_pa_entry=}')
            exp_pair_keys: list[tuple[str, str]] = []
            pair_key = st.SmartThread._get_pair_key(name0=resumer_names[0],
                                                    name1=waiter_names[0])

            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (pair_key not in del_pa_msgs_found.removed_sb_entry
                        or pair_key
                        not in del_pa_msgs_found.removed_pa_entry):
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from {exp_pair_keys=} is missing '
                        f'from {del_pa_msgs_found.removed_sb_entry=} or '
                        f'{del_pa_msgs_found.removed_pa_entry=}')
            for pair_key in del_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{del_pa_msgs_found.removed_sb_entry=} is '
                        f'missing from {exp_pair_keys=}')
            for pair_key in del_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{del_pa_msgs_found.removed_pa_entry=} is '
                        f'missing from {exp_pair_keys=}')

        ################################################################
        # verify for WaitAdd
        ################################################################
        if def_del_scenario == DefDelScenario.WaitAdd:
            if not wait_0_log_msg:
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} failed to find the '
                    'recv message:  '
                    f'{wait_0_log_msg=}')
            if recv_0_log_msg or recv_1_log_msg or wait_1_log_msg:
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected log msg: '
                    f'{recv_0_log_msg=}, '
                    f'{recv_1_log_msg=}, '
                    f'{wait_1_log_msg=}')

            if (recv_0_pa_msgs_found.entered_rpa
                    or recv_0_pa_msgs_found.updated_pa
                    or recv_1_pa_msgs_found.entered_rpa
                    or recv_1_pa_msgs_found.updated_pa
                    or not wait_0_pa_msgs_found.entered_rpa
                    or wait_0_pa_msgs_found.updated_pa
                    or wait_1_pa_msgs_found.entered_rpa
                    or wait_1_pa_msgs_found.updated_pa
                    or del_pa_msgs_found.entered_rpa
                    or del_pa_msgs_found.updated_pa
                    or not add_pa_msgs_found.entered_rpa
                    or not add_pa_msgs_found.updated_pa):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'\n{recv_0_pa_msgs_found.entered_rpa=}, '
                    f'{recv_0_pa_msgs_found.updated_pa=}, '
                    f'\n{recv_1_pa_msgs_found.entered_rpa=}, '
                    f'{recv_1_pa_msgs_found.updated_pa=}, '
                    f'\n{wait_0_pa_msgs_found.entered_rpa=}, '
                    f'{wait_0_pa_msgs_found.updated_pa=}, '
                    f'\n{wait_1_pa_msgs_found.entered_rpa=}, '
                    f'{wait_1_pa_msgs_found.updated_pa=}, '
                    f'\n{del_pa_msgs_found.entered_rpa=}, '
                    f'{del_pa_msgs_found.updated_pa=}, '
                    f'\n{add_pa_msgs_found.entered_rpa=}, '
                    f'{add_pa_msgs_found.updated_pa=}')
            if (len(recv_0_pa_msgs_found.removed_sb_entry)
                    or len(recv_0_pa_msgs_found.removed_pa_entry)
                    or len(recv_1_pa_msgs_found.removed_sb_entry)
                    or len(recv_1_pa_msgs_found.removed_pa_entry)
                    or len(wait_0_pa_msgs_found.removed_sb_entry)
                    or len(wait_0_pa_msgs_found.removed_pa_entry)
                    or len(wait_1_pa_msgs_found.removed_sb_entry)
                    or len(wait_1_pa_msgs_found.removed_pa_entry)
                    or len(del_pa_msgs_found.removed_sb_entry)
                    or len(del_pa_msgs_found.removed_pa_entry)
                    or (len(add_pa_msgs_found.removed_sb_entry) == 0)
                    or (len(add_pa_msgs_found.removed_pa_entry) == 0)):
                raise FailedDefDelVerify(
                    f'verify_def_del {def_del_scenario=} found an '
                    'unexpected pair array activity '
                    f'{recv_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{recv_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_0_pa_msgs_found.removed_pa_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_sb_entry=}, '
                    f'{wait_1_pa_msgs_found.removed_pa_entry=}, '
                    f'{del_pa_msgs_found.removed_sb_entry=}, '
                    f'{del_pa_msgs_found.removed_pa_entry=}, '
                    f'{add_pa_msgs_found.removed_sb_entry=}, '
                    f'{add_pa_msgs_found.removed_pa_entry=}')
            exp_pair_keys: list[tuple[str, str]] = []
            pair_key = st.SmartThread._get_pair_key(name0=resumer_names[0],
                                                    name1=waiter_names[0])

            exp_pair_keys.append(pair_key)

            for pair_key in exp_pair_keys:
                if (pair_key not in add_pa_msgs_found.removed_sb_entry
                        or pair_key
                        not in add_pa_msgs_found.removed_pa_entry):
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from {exp_pair_keys=} is missing '
                        f'from {add_pa_msgs_found.removed_sb_entry=} or '
                        f'{add_pa_msgs_found.removed_pa_entry=}')
            for pair_key in add_pa_msgs_found.removed_sb_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{add_pa_msgs_found.removed_sb_entry=} is '
                        f'missing from {exp_pair_keys=}')
            for pair_key in add_pa_msgs_found.removed_pa_entry:
                if pair_key not in exp_pair_keys:
                    raise FailedDefDelVerify(
                        f'verify_def_del {def_del_scenario=} detected '
                        f'that {pair_key=} from '
                        f'{add_pa_msgs_found.removed_pa_entry=} is '
                        f'missing from {exp_pair_keys=}')

    ####################################################################
    # find_pair_array_msgs
    ####################################################################
    def find_def_del_pair_array_msgs(self,
                                     cmd_runner: str,
                                     request_type: st.ReqType,
                                     deleted_names: list[str],
                                     def_del_names: list[str],
                                     start_log_idx: int,
                                     end_log_idx: int
                                     ) -> PaLogMsgsFound:
        """Find pair array update log msgs for the given names.

        Args:
            cmd_runner: name of thread doing the pair array updates
            request_type: the ReqType for the request
            deleted_names: names of threads that were previously deleted
                that caused the def_del_names to be a deferred delete
            def_del_names: names of deferred delete threads
            start_log_idx: index of where to start the log msgs search
            end_log_idx: index where to stop the log msgs search

        Returns:
            a set of bool indicators for which messages were found
        """
        ################################################################
        # find entered refresh pair array log msg
        ################################################################
        search_msg = (f'{request_type.value} _clean_pair_array entry: '
                      f'cmd_runner: {cmd_runner}')

        log_msg, log_pos = self.get_log_msg(
            search_msg=search_msg,
            skip_num=0,
            start_idx=start_log_idx,
            end_idx=end_log_idx,
            reverse_search=False)

        if log_msg:
            entered_rpa_log_msg_found = True
        else:
            entered_rpa_log_msg_found = False

        ################################################################
        # find removed status_blocks entry log msgs
        ################################################################
        found_removed_status_block_msgs: list[tuple[str, str]] = []
        found_removed_pa_entry_msgs: list[tuple[str, str]] = []
        for deleted_name in deleted_names:
            for def_del_name in def_del_names:
                pair_key = st.SmartThread._get_pair_key(name0=deleted_name,
                                                        name1=def_del_name)
                search_msg1 = (
                    f"{cmd_runner} removed status_blocks entry for "
                    fr"PairKey\(name0='{pair_key[0]}', "
                    fr"name1='{pair_key[1]}'\), "
                    f"name = {def_del_name}")

                search_msg2 = (f"{cmd_runner} removed _pair_array entry for "
                               fr"PairKey\(name0='{pair_key[0]}', "
                               fr"name1='{pair_key[1]}'\)")

                log_msg1, log_pos1 = self.get_log_msg(
                    search_msg=search_msg1,
                    skip_num=0,
                    start_idx=start_log_idx,
                    end_idx=end_log_idx,
                    reverse_search=False)

                if log_msg1:
                    found_removed_status_block_msgs.append(pair_key)

                log_msg2, log_pos2 = self.get_log_msg(
                    search_msg=search_msg2,
                    skip_num=0,
                    start_idx=start_log_idx,
                    end_idx=end_log_idx,
                    reverse_search=False)

                if log_msg2:
                    found_removed_pa_entry_msgs.append(pair_key)

        ################################################################
        # get updated pair array log msg
        ################################################################
        search_msg = (f'{cmd_runner} did cleanup of _pair_array at UTC '
                      f'{time_match}')

        log_msg, log_pos = self.get_log_msg(
            search_msg=search_msg,
            skip_num=0,
            start_idx=start_log_idx,
            end_idx=end_log_idx,
            reverse_search=False)

        if log_msg:
            upa_log_msg_found = True
        else:
            upa_log_msg_found = False

        return PaLogMsgsFound(
            entered_rpa=entered_rpa_log_msg_found,
            removed_sb_entry=found_removed_status_block_msgs,
            removed_pa_entry=found_removed_pa_entry_msgs,
            updated_pa=upa_log_msg_found)

    ####################################################################
    # wait_for_recv_msg_timeouts
    ####################################################################
    def wait_for_recv_msg_timeouts(self,
                                   cmd_runner: str):
        """Verify that the receivers have timed out.

        Args:
            cmd_runner: thread doing the wait
        """
        while True:
            with self.ops_lock:
                if self.expected_num_recv_timeouts == 0:
                    return
            time.sleep(0.1)

    ####################################################################
    # wait_for_request_timeouts
    ####################################################################
    def wait_for_request_timeouts(self,
                                  cmd_runner: str,
                                  actor_names: set[str],
                                  timeout_names: set[str],
                                  use_work_remotes: bool,
                                  as_subset: bool) -> None:
        """Verify that the actor have detected the timeout threads.

        Args:
            cmd_runner: thread doing the WaitForTimeouts
            actor_names: thread names to verify that they recognized the
                timeout_names as being delayed
            timeout_names: threads that cause timeout by being in state
                other than a state that the actor can proceed
            use_work_remotes: if True, compare against work_remotes,
                else pk_remotes
            as_subset: if True, the wait is satisfied when the
                timeout_names are a subset of the pk_remotes

        Raises:
            CmdTimedOut: wait_for_request_timeouts timed out

        """
        work_actors = actor_names.copy()
        start_time = time.time()
        work_names: set[str] = set()
        while work_actors:
            for actor in work_actors:
                if use_work_remotes:
                    work_names = self.all_threads[actor].work_remotes
                else:
                    work_names = {
                        remote for pk, remote, _ in self.all_threads[
                            actor].work_pk_remotes}
                if (timeout_names == work_names
                        or (as_subset
                            and timeout_names <= work_names)):
                    work_actors.remove(actor)
                    break

            time.sleep(0.1)
            if start_time + 30 < time.time():
                raise CmdTimedOut('wait_for_request_timeouts timed out '
                                  f'with {work_actors=}, '
                                  f'{sorted(timeout_names)=}, '
                                  f'{sorted(work_names)=}')


########################################################################
# expand_cmds
########################################################################
def expand_list(nested_list: list[Any]) -> list[Any]:
    """Return a list of items from a nested list of lists.

    Args:
        nested_list: a list containing nested lists of items

    Returns:
        a single list of items
    """
    ret_list: list[Any] = []
    for item in nested_list:
        if isinstance(item, list):
            ret_list.extend(expand_list(item))
        else:
            ret_list.append(item)
    return ret_list


########################################################################
# CommanderCurrentApp class
########################################################################
class CommanderCurrentApp:
    """Outer thread app for test."""
    def __init__(self,
                 config_ver: ConfigVerifier,
                 name: str,
                 max_msgs: int
                 ) -> None:
        """Initialize the object.

        Args:
            config_ver: configuration verifier and test support methods
            name: name of thread
            max_msgs: max number of messages for msg_q

        """
        self.config_ver = config_ver
        self.smart_thread = st.SmartThread(
            name=name,
            auto_start=False,
            max_msgs=max_msgs)

        # self.config_ver.commander_thread = self.smart_thread

    def run(self) -> None:
        """Run the test."""
        self.config_ver.main_driver()


########################################################################
# OuterThreadApp class
########################################################################
class OuterThreadApp(threading.Thread):
    """Outer thread app for test."""
    def __init__(self,
                 config_ver: ConfigVerifier,
                 name: str,
                 # auto_start: bool,
                 max_msgs: int
                 ) -> None:
        """Initialize the object.

        Args:
            config_ver: configuration verifier and test support methods
            name: name of thread
            max_msgs: max number of messages for msg_q

        """
        super().__init__()
        threading.current_thread().name = name
        self.config_ver = config_ver
        self.smart_thread = st.SmartThread(
            name=name,
            thread=self,
            auto_start=False,
            max_msgs=max_msgs)

        # self.config_ver.commander_thread = self.smart_thread

    def run(self) -> None:
        """Run the test."""
        name = self.smart_thread.name

        # self.smart_thread.smart_start(name)

        self.config_ver.log_ver.add_call_seq(
            name='smart_start',
            seq='test_smart_thread.py::OuterThreadApp.run')

        # self.config_ver.add_request_log_msg(
        #     cmd_runner=name,
        #     smart_request='smart_start',
        #     targets={name},
        #     timeout=0,
        #     timeout_type=TimeoutType.TimeoutNone,
        #     enter_exit=('entry', 'exit'),
        #     log_msg=None)
        #
        # self.config_ver.add_log_msg(
        #     f'{name} set state for thread {name} from '
        #     'ThreadState.Registered to ThreadState.Alive'
        # )

        self.config_ver.monitor_event.set()

        self.config_ver.main_driver()


########################################################################
# OuterSmartThreadApp class
########################################################################
class OuterSmartThreadApp(st.SmartThread, threading.Thread):
    """Outer thread app for test with both thread and SmartThread."""
    def __init__(self,
                 config_ver: ConfigVerifier,
                 name: str,
                 max_msgs: int
                 ) -> None:
        """Initialize the object.

        Args:
            config_ver: configuration verifier and test support methods
            name: name of thread
            max_msgs: max number of messages for msg_q

        """
        # super().__init__()
        threading.Thread.__init__(self)
        threading.current_thread().name = name
        st.SmartThread.__init__(
            self,
            name=name,
            thread=self,
            auto_start=False,
            max_msgs=max_msgs)
        self.config_ver = config_ver
        # self.config_ver.commander_thread = self

    def run(self) -> None:
        """Run the test."""
        # self._set_state(
        #     target_thread=self,
        #     new_state=st.ThreadState.Alive)
        # name = self.name
        #
        # self.smart_start(name)
        #
        # self.config_ver.log_ver.add_call_seq(
        #     name='smart_start',
        #     seq='test_smart_thread.py::OuterSmartThreadApp.run')
        #
        # self.config_ver.add_request_log_msg(
        #     cmd_runner=name,
        #     smart_request='smart_start',
        #     targets={name},
        #     timeout=0,
        #     timeout_type=TimeoutType.TimeoutNone,
        #     enter_exit=('entry', 'exit'),
        #     log_msg=None)

        # self.config_ver.add_log_msg(
        #     f'{name} set state for thread {name} from '
        #     'ThreadState.Registered to ThreadState.Alive'
        # )


        # self.config_ver.monitor_event.set()
        self.config_ver.main_driver()


########################################################################
# OuterSmartThreadApp2 class
########################################################################
class OuterSmartThreadApp2(threading.Thread, st.SmartThread):
    """Outer thread app for test with both thread and SmartThread."""
    def __init__(self,
                 config_ver: ConfigVerifier,
                 name: str,
                 max_msgs: int
                 ) -> None:
        """Initialize the object.

        Args:
            config_ver: configuration verifier and test support methods
            name: name of thread
            max_msgs: max number of messages for msg_q

        """
        # super().__init__()
        threading.Thread.__init__(self)
        threading.current_thread().name = name
        st.SmartThread.__init__(
            self,
            name=name,
            thread=self,
            auto_start=False,
            max_msgs=max_msgs)
        self.config_ver = config_ver
        # self.config_ver.commander_thread = self

    def run(self) -> None:
        """Run the test."""
        self.config_ver.main_driver()


########################################################################
# OuterF1ThreadApp class
########################################################################
class OuterF1ThreadApp(threading.Thread):
    """Outer thread app for test."""
    def __init__(self,
                 config_ver: ConfigVerifier,
                 name: str,
                 auto_start: bool,
                 max_msgs: int
                 ) -> None:
        """Initialize the object.

        Args:
            config_ver: configuration verifier and test support methods
            name: name of thread
            auto_start: True, start thread
            max_msgs: max number of messages for msg_q

        """
        super().__init__()
        self.config_ver = config_ver
        self.name = name
        self.smart_thread = st.SmartThread(
            name=name,
            thread=self,
            # auto_start=False,
            auto_start=auto_start,
            max_msgs=max_msgs)
        # if auto_start:
        #     self.smart_thread.smart_start(name)

    def run(self) -> None:
        """Run the test."""
        self.config_ver.log_test_msg(
            f'OuterF1ThreadApp.run() entry: {self.name}')

        # self.config_ver.f1_driver(f1_name=self.smart_thread.name)
        self.config_ver.f1_driver(f1_name=self.name)

        ####################################################################
        # exit
        ####################################################################
        self.config_ver.log_test_msg(
            f'OuterF1ThreadApp.run() exit: {self.name}')


########################################################################
# outer_f1
########################################################################
def outer_f1(f1_name: str, f1_config_ver: ConfigVerifier):
    """Target routine in the outer scope.

    Args:
        f1_name: thread name
        f1_config_ver: configuration verifier instance

    """
    f1_config_ver.log_test_msg(
        f'outer_f1 entry: {f1_name}')

    f1_config_ver.f1_driver(f1_name=f1_name)

    ####################################################################
    # exit
    ####################################################################
    f1_config_ver.log_test_msg(
        f'outer_f1 exit: {f1_name}')


########################################################################
# commander_config
########################################################################
commander_config: dict[int, AppConfig] = {
    0: AppConfig.ScriptStyle,
    1: AppConfig.CurrentThreadApp,
    2: AppConfig.RemoteThreadApp,
    3: AppConfig.RemoteSmartThreadApp,
    4: AppConfig.RemoteSmartThreadApp2}

num_commander_configs = len(commander_config)


########################################################################
# TestSmartThreadErrors class
########################################################################
class TestSmartThreadExamples:
    """Test class for SmartThread example tests."""

    ####################################################################
    # test_smart_thread_instantiation_example_1
    ####################################################################
    def test_smart_thread_instantiation_example_1(self,
                                                  capsys: Any) -> None:
        """Test smart_thread instantiation example 1.

        Create a SmartThread configuration for threads named alpha and
        beta, send and receive a message, and resume a wait. Note the
        use of auto_start=False and doing the smart_start.

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1() -> None:
            print('f1 beta entered')
            beta_smart_thread.smart_send(receivers='alpha',
                                         msg='hi alpha, this is beta')
            beta_smart_thread.smart_wait(resumers='alpha')
            print('f1 beta exiting')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        beta_smart_thread = SmartThread(name='beta',
                                        target=f1,
                                        auto_start=False)
        beta_smart_thread.smart_start()

        recvd_msgs = alpha_smart_thread.smart_recv(senders='beta')
        print(recvd_msgs['beta'])
        alpha_smart_thread.smart_resume(waiters='beta')
        alpha_smart_thread.smart_join(targets='beta')
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1 beta entered\n'
        expected_result += "['hi alpha, this is beta']\n"
        expected_result += 'f1 beta exiting\n'
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_thread_instantiation_example_2
    ####################################################################
    def test_smart_thread_instantiation_example_2(self,
                                                  capsys: Any) -> None:
        """Test smart_thread instantiation example 2.

        Create a SmartThread configuration for threads named alpha and
        beta, send and receive a message, and resume a wait. Note the
        use of auto_start=True and passing the SmartThread instance to
        the target via the thread_parm_name.

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1(smart_thread: SmartThread) -> None:
            print('f1 beta entered')
            smart_thread.smart_send(receivers='alpha',
                                    msg='hi alpha, this is beta')
            smart_thread.smart_wait(resumers='alpha')
            print('f1 beta exiting')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1,
                    auto_start=True,
                    thread_parm_name='smart_thread')
        recvd_msgs = alpha_smart_thread.smart_recv(senders='beta')
        print(recvd_msgs['beta'])
        alpha_smart_thread.smart_resume(waiters='beta')
        alpha_smart_thread.smart_join(targets='beta')
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1 beta entered\n'
        expected_result += "['hi alpha, this is beta']\n"
        expected_result += 'f1 beta exiting\n'
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_thread_instantiation_example_3
    ####################################################################
    def test_smart_thread_instantiation_example_3(self,
                                                  capsys: Any) -> None:
        """Test smart_thread instantiation example 3.

        Create a SmartThread configuration for threads named alpha and
        beta, send and receive a message, and resume a wait. Note the
        use of threading.Thread to create and start the beta thread and
        having the target thread instantiate the SmartThread.

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import threading

        def f1() -> None:
            print('f1 beta entered')
            beta_smart_thread = SmartThread(name='beta')
            beta_smart_thread.smart_send(receivers='alpha',
                                         msg='hi alpha, this is beta')
            beta_smart_thread.smart_wait(resumers='alpha')
            print('f1 beta exiting')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        beta_thread = threading.Thread(target=f1, name='beta')
        beta_thread.start()
        recvd_msgs = alpha_smart_thread.smart_recv(senders='beta')
        print(recvd_msgs['beta'])
        alpha_smart_thread.smart_resume(waiters='beta')
        alpha_smart_thread.smart_join(targets='beta')
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1 beta entered\n'
        expected_result += "['hi alpha, this is beta']\n"
        expected_result += 'f1 beta exiting\n'
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_thread_instantiation_example_4
    ####################################################################
    def test_smart_thread_instantiation_example_4(self,
                                                  capsys: Any) -> None:
        """Test smart_thread instantiation example 4.

        Create a SmartThread configuration for threads named alpha and
        beta, send and receive a message, and resume a wait. Note the
        use of the ThreadApp class that inherits threading.Thread as a
        base and uses a run method. This example demonstrates the use of
        the *thread* argument on the SmartThread instantiation.

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import threading
        import time

        class ThreadApp(threading.Thread):
            """Example thread app."""

            def __init__(self, name: str) -> None:
                """Initialize the object.

                Args:
                    name: name of thread

                """
                super().__init__(name=name)
                self.smart_thread = SmartThread(
                    name=name,
                    thread=self,
                    auto_start=False)
                self.smart_thread.smart_start()

            def run(self) -> None:
                """Run the test."""
                print(f'{self.smart_thread.name} entry to run method')
                self.smart_thread.smart_send(msg='hi alpha, this is beta',
                                             receivers='alpha')
                time.sleep(1)
                print(f'{self.smart_thread.name} about to wait')
                self.smart_thread.smart_wait(resumers='alpha')
                print(f'{self.smart_thread.name} exiting run method')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        ThreadApp(name='beta')
        recvd_msgs = alpha_smart_thread.smart_recv(senders='beta')
        print(recvd_msgs['beta'])
        time.sleep(2)
        print('alpha about to resume beta')
        alpha_smart_thread.smart_resume(waiters='beta')
        alpha_smart_thread.smart_join(targets='beta')
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'beta entry to run method\n'
        expected_result += "['hi alpha, this is beta']\n"
        expected_result += 'beta about to wait\n'
        expected_result += 'alpha about to resume beta\n'
        expected_result += 'beta exiting run method\n'
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_thread_instantiation_example_5
    ####################################################################
    def test_smart_thread_instantiation_example_5(self,
                                                  capsys: Any) -> None:
        """Test smart_thread instantiation example 5.

        Create a SmartThread configuration for threads named alpha and
        beta, send and receive a message, and resume a wait. Note the
        use of the SmartThreadApp class that multipli inherits
        threading.Thread and SmartThread and uses a run method. This
        example demonstrates the use of the *thread* argument on the
        SmartThread instantiation.

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import threading
        import time

        class SmartThreadApp(threading.Thread, SmartThread):
            """Example thread app."""

            def __init__(self, name: str) -> None:
                """Initialize the object.

                Args:
                    name: name of thread

                """
                threading.Thread.__init__(self, name=name)
                SmartThread.__init__(self,
                                     name=name,
                                     thread=self,
                                     auto_start=True)

            def run(self) -> None:
                """Run the test."""
                print(f'{self.name} entry to run method')
                self.smart_send(msg='hi alpha, this is beta',
                                receivers='alpha')
                time.sleep(1)
                print(f'{self.name} about to wait')
                self.smart_wait(resumers='alpha')
                print(f'{self.name} exiting run method')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThreadApp(name='beta')
        recvd_msgs = alpha_smart_thread.smart_recv(senders='beta')
        print(recvd_msgs['beta'])
        time.sleep(2)
        print('alpha about to resume beta')
        alpha_smart_thread.smart_resume(waiters='beta')
        alpha_smart_thread.smart_join(targets='beta')
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'beta entry to run method\n'
        expected_result += "['hi alpha, this is beta']\n"
        expected_result += 'beta about to wait\n'
        expected_result += 'alpha about to resume beta\n'
        expected_result += 'beta exiting run method\n'
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_start_example_1
    ####################################################################
    def test_smart_start_example_1(self,
                                   capsys: Any) -> None:
        """Test smart_start example 1.

        Create and start a SmartThread.

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1() -> None:
            print('f1 beta entered')
            print('f1 beta exiting')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        beta_smart_thread = SmartThread(name='beta',
                                        target=f1,
                                        auto_start=False)
        print('alpha about to start beta')
        beta_smart_thread.smart_start()
        alpha_smart_thread.smart_join(targets='beta')
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'alpha about to start beta\n'
        expected_result += 'f1 beta entered\n'
        expected_result += 'f1 beta exiting\n'
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_start_example_2
    ####################################################################
    def test_smart_start_example_2(self,
                                   capsys: Any) -> None:
        """Test smart_start example 2.

        Create and start two SmartThread threads.

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1_beta() -> None:
            print('f1_beta entered')
            print('f1_beta exiting')

        def f2_charlie() -> None:
            time.sleep(1)
            print('f2_charlie entered')
            print('f2_charlie exiting')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1_beta,
                    auto_start=False)
        SmartThread(name='charlie',
                    target=f2_charlie,
                    auto_start=False)
        print('alpha about to start beta and charlie')
        alpha_smart_thread.smart_start(targets=['beta', 'charlie'])
        alpha_smart_thread.smart_join(targets=['beta', 'charlie'])
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'alpha about to start beta and charlie\n'
        expected_result += 'f1_beta entered\n'
        expected_result += 'f1_beta exiting\n'
        expected_result += 'f2_charlie entered\n'
        expected_result += 'f2_charlie exiting\n'
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_unreg_example_1
    ####################################################################
    def test_smart_unreg_example_1(self,
                                   capsys: Any) -> None:
        """Test smart_unreg example 1.

        Create and unregister a SmartThread thread.

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1_beta() -> None:
            print('f1_beta entered')
            print('f1_beta exiting')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        print('alpha about to create beta')
        SmartThread(name='beta',
                    target=f1_beta,
                    auto_start=False)
        print('alpha about to unregister beta')
        alpha_smart_thread.smart_unreg(targets='beta')
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'alpha about to create beta\n'
        expected_result += 'alpha about to unregister beta\n'
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_join_example_1
    ####################################################################
    def test_smart_join_example_1(self,
                                  capsys: Any) -> None:
        """Test smart_join example 1.

        Create and join a SmartThread thread.

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1_beta() -> None:
            print('f1_beta entered')
            print('f1_beta exiting')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        print('alpha about to create beta')
        SmartThread(name='beta',
                    target=f1_beta)
        time.sleep(1)
        print('alpha about to join beta')
        alpha_smart_thread.smart_join(targets='beta')
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'alpha about to create beta\n'
        expected_result += 'f1_beta entered\n'
        expected_result += 'f1_beta exiting\n'
        expected_result += 'alpha about to join beta\n'
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_send_example_1
    ####################################################################
    def test_smart_send_example_1(self,
                                  capsys: Any) -> None:
        """Test smart_send example 1.

        send a single message to a single remote thread

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1(smart_thread: SmartThread) -> None:
            print('f1 beta entered')
            recvd_msgs = smart_thread.smart_recv(senders='alpha')
            print(recvd_msgs['alpha'])
            print('f1 beta exiting')

        print('mainline alpha entered')
        logger.debug('mainline entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1,
                    thread_parm_name='smart_thread')
        alpha_smart_thread.smart_send(msg='hello beta', receivers='beta')
        alpha_smart_thread.smart_join(targets='beta')
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1 beta entered\n'
        expected_result += "['hello beta']\n"
        expected_result += 'f1 beta exiting\n'
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_send_example_2
    ####################################################################
    def test_smart_send_example_2(self,
                                  capsys: Any) -> None:
        """Test smart_send example 2.

        send a single message to multiple remote threads

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1(smart_thread: SmartThread) -> None:
            if smart_thread.name == 'charlie':
                time.sleep(1)  # delay to control msg interleaving
            print(f'f1 {smart_thread.name} entered')
            recvd_msgs = smart_thread.smart_recv(senders='alpha')
            print(recvd_msgs['alpha'])
            print(f'f1 {smart_thread.name} exiting')
        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1,
                    thread_parm_name='smart_thread')
        SmartThread(name='charlie',
                    target=f1,
                    thread_parm_name='smart_thread')
        alpha_smart_thread.smart_send(msg='hello remotes',
                                      receivers=('beta', 'charlie'))
        alpha_smart_thread.smart_join(targets=('beta', 'charlie'))
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1 beta entered\n'
        expected_result += "['hello remotes']\n"
        expected_result += 'f1 beta exiting\n'
        expected_result += 'f1 charlie entered\n'
        expected_result += "['hello remotes']\n"
        expected_result += 'f1 charlie exiting\n'
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_send_example_3
    ####################################################################
    def test_smart_send_example_3(self,
                                  capsys: Any) -> None:
        """Test smart_send example 3.

        send a single message to all alive remote threads in the
        configuration as a broadcast (by simply omitting the *receivers*
        argument). Note the use of smart_wait and smart_resume to
        coordinate the actions for ordered and consistent print output.

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1(smart_thread: SmartThread,
               wait_for: Optional[str] = None,
               resume_target: Optional[str] = None) -> None:
            if wait_for:
                smart_thread.smart_wait(resumers=wait_for)
            print(f'f1 {smart_thread.name} entered')
            recvd_msgs = smart_thread.smart_recv(senders='alpha')
            print(recvd_msgs['alpha'])
            print(f'f1 {smart_thread.name} exiting')
            if resume_target:
                smart_thread.smart_resume(waiters=resume_target)

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1,
                    thread_parm_name='smart_thread',
                    kwargs={'resume_target': 'charlie'})
        SmartThread(name='charlie',
                    target=f1,
                    thread_parm_name='smart_thread',
                    kwargs={'wait_for': 'beta',
                            'resume_target': 'delta'})
        SmartThread(name='delta',
                    target=f1,
                    thread_parm_name='smart_thread',
                    kwargs={'wait_for': 'charlie',
                            'resume_target': 'alpha'})
        alpha_smart_thread.smart_send(msg='hello remotes')
        alpha_smart_thread.smart_wait(resumers='delta')
        alpha_smart_thread.smart_join(targets=('beta', 'charlie', 'delta'))
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1 beta entered\n'
        expected_result += "['hello remotes']\n"
        expected_result += 'f1 beta exiting\n'
        expected_result += 'f1 charlie entered\n'
        expected_result += "['hello remotes']\n"
        expected_result += 'f1 charlie exiting\n'
        expected_result += 'f1 delta entered\n'
        expected_result += "['hello remotes']\n"
        expected_result += 'f1 delta exiting\n'
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_send_example_4
    ####################################################################
    def test_smart_send_example_4(self,
                                  capsys: Any) -> None:
        """Test smart_send example 4.

        send multiple messages to a single remote thread

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1(smart_thread: SmartThread) -> None:
            print(f'f1 {smart_thread.name} entered')
            recvd_msgs = smart_thread.smart_recv(senders='alpha')
            print(recvd_msgs['alpha'])
            print(f'f1 {smart_thread.name} exiting')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1,
                    thread_parm_name='smart_thread')
        alpha_smart_thread.smart_send(msg=('hello beta',
                                      'have a great day', 42))
        alpha_smart_thread.smart_join(targets='beta')
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1 beta entered\n'
        expected_result += ("[('hello beta', "
                            "'have a great day', 42)]\n")
        expected_result += 'f1 beta exiting\n'
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_send_example_5
    ####################################################################
    def test_smart_send_example_5(self,
                                  capsys: Any) -> None:
        """Test smart_send example 5.

        send multiple messages to multiple remote threads

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1(smart_thread: SmartThread,
               wait_for: Optional[str] = None,
               resume_target: Optional[str] = None) -> None:
            if wait_for:
                smart_thread.smart_wait(resumers=wait_for)
            print(f'f1 {smart_thread.name} entered')
            recvd_msgs = smart_thread.smart_recv(senders='alpha')
            print(recvd_msgs['alpha'])
            print(f'f1 {smart_thread.name} exiting')
            if resume_target:
                smart_thread.smart_resume(waiters=resume_target)

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1,
                    thread_parm_name='smart_thread',
                    kwargs={'resume_target': 'charlie'})
        SmartThread(name='charlie',
                    target=f1,
                    thread_parm_name='smart_thread',
                    kwargs={'wait_for': 'beta',
                            'resume_target': 'delta'})
        SmartThread(name='delta',
                    target=f1,
                    thread_parm_name='smart_thread',
                    kwargs={'wait_for': 'charlie',
                            'resume_target': 'alpha'})
        alpha_smart_thread.smart_send(msg=['hello remotes',
                                           'have a great day', 42],
                                      receivers=['beta', 'charlie', 'delta'])
        alpha_smart_thread.smart_wait(resumers='delta')
        alpha_smart_thread.smart_join(targets=('beta', 'charlie', 'delta'))
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1 beta entered\n'
        expected_result += ("[['hello remotes', "
                            "'have a great day', 42]]\n")
        expected_result += 'f1 beta exiting\n'
        expected_result += 'f1 charlie entered\n'
        expected_result += ("[['hello remotes', "
                            "'have a great day', 42]]\n")
        expected_result += 'f1 charlie exiting\n'
        expected_result += 'f1 delta entered\n'
        expected_result += ("[['hello remotes', "
                            "'have a great day', 42]]\n")
        expected_result += 'f1 delta exiting\n'
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_send_example_6
    ####################################################################
    def test_smart_send_example_6(self,
                                  capsys: Any) -> None:
        """Test smart_send example 6.

        send any mixture of single and multiple messages individually to
        each remote thread

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import (SmartThread,
                                                       SendMsgs)

        def f1(smart_thread: SmartThread,
               wait_for: Optional[str] = None,
               resume_target: Optional[str] = None) -> None:
            if wait_for:
                smart_thread.smart_wait(resumers=wait_for)
            print(f'f1 {smart_thread.name} entered')
            recvd_msgs = smart_thread.smart_recv(senders='alpha')
            print(recvd_msgs['alpha'])
            print(f'f1 {smart_thread.name} exiting')
            if resume_target:
                smart_thread.smart_resume(waiters=resume_target)

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1,
                    thread_parm_name='smart_thread',
                    kwargs={'resume_target': 'charlie'})
        SmartThread(name='charlie',
                    target=f1,
                    thread_parm_name='smart_thread',
                    kwargs={'wait_for': 'beta',
                            'resume_target': 'delta'})
        SmartThread(name='delta',
                    target=f1,
                    thread_parm_name='smart_thread',
                    kwargs={'wait_for': 'charlie',
                            'resume_target': 'alpha'})
        msgs_to_send = SendMsgs(send_msgs={
            'beta': 'hi beta',
            'charlie': ('hi charlie', 'have a great day'),
            'delta': [42, 'hi delta', {'nums': (1, 2, 3)}]})
        alpha_smart_thread.smart_send(msg=msgs_to_send)
        alpha_smart_thread.smart_wait(resumers='delta')
        alpha_smart_thread.smart_join(targets=('beta', 'charlie', 'delta'))
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1 beta entered\n'
        expected_result += "['hi beta']\n"
        expected_result += 'f1 beta exiting\n'
        expected_result += 'f1 charlie entered\n'
        expected_result += ("[('hi charlie', "
                            "'have a great day')]\n")
        expected_result += 'f1 charlie exiting\n'
        expected_result += 'f1 delta entered\n'
        expected_result += ("[[42, 'hi delta', "
                            "{'nums': (1, 2, 3)}]]\n")
        expected_result += 'f1 delta exiting\n'
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_recv_example_1
    ####################################################################
    def test_smart_recv_example_1(self,
                                  capsys: Any) -> None:
        """Test smart_recv example 1.

        receive a single message from a single remote thread

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1(smart_thread: SmartThread) -> None:
            print('f1 beta entered')
            smart_thread.smart_send(msg='hi alpha', receivers='alpha')
            print('f1 beta exiting')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1,
                    thread_parm_name='smart_thread')
        recvd_msgs = alpha_smart_thread.smart_recv(senders='beta')
        print(recvd_msgs['beta'])
        alpha_smart_thread.smart_join(targets='beta')
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1 beta entered\n'
        expected_result += 'f1 beta exiting\n'
        expected_result += "['hi alpha']\n"
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_recv_example_2
    ####################################################################
    def test_smart_recv_example_2(self,
                                  capsys: Any) -> None:
        """Test smart_recv example 2.

        receive a single message from multiple remote threads

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1(smart_thread: SmartThread) -> None:
            print(f'f1 {smart_thread.name} entered')
            smart_thread.smart_send(msg=f'{smart_thread.name} says hi',
                                    receivers='alpha')
            print(f'f1 {smart_thread.name} exiting')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1,
                    thread_parm_name='smart_thread')
        time.sleep(0.2)
        SmartThread(name='charlie',
                    target=f1,
                    thread_parm_name='smart_thread')
        time.sleep(0.2)
        recvd_msgs = alpha_smart_thread.smart_recv(senders=('beta', 'charlie'))
        print(recvd_msgs['beta'])
        print(recvd_msgs['charlie'])
        alpha_smart_thread.smart_join(targets=('beta', 'charlie'))
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1 beta entered\n'
        expected_result += 'f1 beta exiting\n'
        expected_result += 'f1 charlie entered\n'
        expected_result += 'f1 charlie exiting\n'
        expected_result += "['beta says hi']\n"
        expected_result += "['charlie says hi']\n"
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_recv_example_3
    ####################################################################
    def test_smart_recv_example_3(self,
                                  capsys: Any) -> None:
        """Test smart_recv example 3.

        receive a single message from all remote threads in the
        configuration

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1(greeting: str, smart_thread: SmartThread) -> None:
            print(f'f1 {smart_thread.name} entered')
            smart_thread.smart_send(msg=f'{greeting}',
                                    receivers='alpha')
            print(f'f1 {smart_thread.name} exiting')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1,
                    thread_parm_name='smart_thread',
                    args=('hi',))
        time.sleep(0.2)
        SmartThread(name='charlie',
                    target=f1,
                    thread_parm_name='smart_thread',
                    args=('hello',))
        time.sleep(0.2)
        SmartThread(name='delta',
                    target=f1,
                    thread_parm_name='smart_thread',
                    args=('aloha',))
        time.sleep(1.5)
        recvd_msgs = alpha_smart_thread.smart_recv()
        print(recvd_msgs['beta'])
        print(recvd_msgs['charlie'])
        print(recvd_msgs['delta'])
        alpha_smart_thread.smart_join(targets=('beta', 'charlie', 'delta'))
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1 beta entered\n'
        expected_result += 'f1 beta exiting\n'
        expected_result += 'f1 charlie entered\n'
        expected_result += 'f1 charlie exiting\n'
        expected_result += 'f1 delta entered\n'
        expected_result += 'f1 delta exiting\n'
        expected_result += "['hi']\n"
        expected_result += "['hello']\n"
        expected_result += "['aloha']\n"
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_recv_example_4
    ####################################################################
    def test_smart_recv_example_4(self,
                                  capsys: Any) -> None:
        """Test smart_recv example 4.

        receive multiple messages from a single remote thread

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1(greeting: str, smart_thread: SmartThread) -> None:
            print(f'f1 {smart_thread.name} entered')
            smart_thread.smart_send(msg=f'{greeting}', receivers='alpha')
            smart_thread.smart_send(msg=["great to be here",
                                         "life is good"],
                                    receivers='alpha')
            smart_thread.smart_send(msg=("we should do lunch sometime",
                                         "Tuesday afternoons are best"),
                                    receivers='alpha')
            print(f'f1 {smart_thread.name} exiting')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1,
                    thread_parm_name='smart_thread',
                    args=('hi',))
        time.sleep(1)  # give enough time to allow all sends to complete
        recvd_msgs = alpha_smart_thread.smart_recv(senders='beta')
        print(recvd_msgs['beta'])
        alpha_smart_thread.smart_join(targets='beta')
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1 beta entered\n'
        expected_result += 'f1 beta exiting\n'
        expected_result += "['hi', "
        expected_result += "['great to be here', 'life is good'], "
        expected_result += ("('we should do lunch sometime', "
                            "'Tuesday afternoons are best')]\n")
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_recv_example_5
    ####################################################################
    def test_smart_recv_example_5(self,
                                  capsys: Any) -> None:
        """Test smart_recv example 5.

        receive any mixture of single and multiple messages from
        specified remote threads

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread

        def f1(greeting: str,
               smart_thread: SmartThread,
               wait_for: Optional[str] = None,
               resume_target: Optional[str] = None) -> None:
            if wait_for:
                smart_thread.smart_wait(resumers=wait_for)
            print(f'f1 {smart_thread.name} entered')
            smart_thread.smart_send(msg=f'{greeting}', receivers='alpha')
            if smart_thread.name in ('charlie', 'delta'):
                smart_thread.smart_send(msg=["miles to go", (1, 2, 3)],
                                        receivers='alpha')
            if smart_thread.name == 'delta':
                smart_thread.smart_send(msg={'forty_two': 42, 42: 42},
                                        receivers='alpha')
            print(f'f1 {smart_thread.name} exiting')
            if resume_target:
                smart_thread.smart_resume(waiters=resume_target)

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1,
                    thread_parm_name='smart_thread',
                    args=('hi',),
                    kwargs={'resume_target': 'charlie'})
        SmartThread(name='charlie',
                    target=f1,
                    thread_parm_name='smart_thread',
                    args=('hello',),
                    kwargs={'wait_for': 'beta',
                            'resume_target': 'delta'})
        SmartThread(name='delta',
                    target=f1,
                    thread_parm_name='smart_thread',
                    args=('aloha',),
                    kwargs={'wait_for': 'charlie',
                            'resume_target': 'alpha'})
        alpha_smart_thread.smart_wait(resumers='delta')
        recvd_msgs = alpha_smart_thread.smart_recv(senders={'beta', 'delta'})
        print(recvd_msgs['beta'])
        print(recvd_msgs['delta'])
        recvd_msgs = alpha_smart_thread.smart_recv(senders={'charlie'})
        print(recvd_msgs['charlie'])
        alpha_smart_thread.smart_join(targets=('beta',
                                               'charlie',
                                               'delta'))
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1 beta entered\n'
        expected_result += 'f1 beta exiting\n'
        expected_result += 'f1 charlie entered\n'
        expected_result += 'f1 charlie exiting\n'
        expected_result += 'f1 delta entered\n'
        expected_result += 'f1 delta exiting\n'
        expected_result += "['hi']\n"
        expected_result += ("['aloha', ['miles to go', (1, 2, 3)], "
                            "{'forty_two': 42, 42: 42}]\n")
        expected_result += ("['hello', "
                            "['miles to go', (1, 2, 3)]]\n")
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_wait_example_1
    ####################################################################
    def test_smart_wait_example_1(self,
                                  capsys: Any) -> None:
        """Test smart_wait example 1.

        smart_wait followed by smart_resume

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1(smart_thread: SmartThread) -> None:
            print(f'f1 {smart_thread.name} about to wait')
            resumed_by = smart_thread.smart_wait(resumers='alpha')
            print(f'f1 {smart_thread.name} resumed by {resumed_by}')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1,
                    thread_parm_name='smart_thread')
        time.sleep(1)  # allow time for smart_wait to be issued
        print('alpha about to resume beta')
        alpha_smart_thread.smart_resume(waiters='beta')
        alpha_smart_thread.smart_join(targets='beta')
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1 beta about to wait\n'
        expected_result += 'alpha about to resume beta\n'
        expected_result += "f1 beta resumed by {'alpha'}\n"
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_wait_example_2
    ####################################################################
    def test_smart_wait_example_2(self,
                                  capsys: Any) -> None:
        """Test smart_wait example 2.

        smart_wait followed by smart_resume

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1(smart_thread: SmartThread) -> None:
            time.sleep(1)  # allow time for smart_resume to be issued
            print(f'f1 {smart_thread.name} about to wait')
            resumed_by = smart_thread.smart_wait(resumers='alpha')
            print(f'f1 {smart_thread.name} resumed by {resumed_by}')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1,
                    thread_parm_name='smart_thread')
        print('alpha about to resume beta')
        alpha_smart_thread.smart_resume(waiters='beta')

        alpha_smart_thread.smart_join(targets='beta')
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'alpha about to resume beta\n'
        expected_result += "f1 beta about to wait\n"
        expected_result += "f1 beta resumed by {'alpha'}\n"
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_wait_example_3
    ####################################################################
    def test_smart_wait_example_3(self,
                                  capsys: Any) -> None:
        """Test smart_wait example 3.

        smart_wait for multiple resumers with WaitFor.All

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread, WaitFor
        import time

        def f1(smart_thread: SmartThread) -> None:
            print(f'f1 {smart_thread.name} about to resume alpha')
            smart_thread.smart_resume(waiters='alpha')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1,
                    thread_parm_name='smart_thread')
        time.sleep(1)  # allow time for alpha to wait
        SmartThread(name='charlie',
                    target=f1,
                    thread_parm_name='smart_thread')
        time.sleep(1)  # allow time for alpha to wait
        SmartThread(name='delta',
                    target=f1,
                    thread_parm_name='smart_thread')
        time.sleep(1)  # allow time for alpha to wait
        print('alpha about to wait for all threads')
        resumed_by = alpha_smart_thread.smart_wait(
            resumers=['beta', 'charlie', 'delta'])
        print(f'alpha resumed by resumers={sorted(resumed_by)}')

        alpha_smart_thread.smart_join(targets=['beta', 'charlie', 'delta'])
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1 beta about to resume alpha\n'
        expected_result += 'f1 charlie about to resume alpha\n'
        expected_result += 'f1 delta about to resume alpha\n'
        expected_result += 'alpha about to wait for all threads\n'
        expected_result += ("alpha resumed by "
                            "resumers=['beta', 'charlie', 'delta']\n")
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_wait_example_4
    ####################################################################
    def test_smart_wait_example_4(self,
                                  capsys: Any) -> None:
        """Test smart_wait example 4.

        smart_wait for multiple resumers with WaitFor.Any

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread, WaitFor
        import time

        def f1(smart_thread: SmartThread) -> None:
            print(f'f1 {smart_thread.name} about to resume alpha')
            smart_thread.smart_resume(waiters='alpha')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1,
                    thread_parm_name='smart_thread')
        time.sleep(1)
        SmartThread(name='charlie',
                    target=f1,
                    thread_parm_name='smart_thread')
        time.sleep(1)
        print('alpha about to wait for any threads')
        resumed_by = alpha_smart_thread.smart_wait(
            resumers=['beta', 'charlie', 'delta'],
            resumer_count=1)
        print(f'alpha resumed by resumers={sorted(resumed_by)}')
        SmartThread(name='delta',
                    target=f1,
                    thread_parm_name='smart_thread')
        time.sleep(1)  # allow time for alpha to wait
        print('alpha about to wait for any threads')
        resumed_by = alpha_smart_thread.smart_wait(
            resumers=['beta', 'charlie', 'delta'],
            resumer_count=1)
        print(f'alpha resumed by resumers={sorted(resumed_by)}')

        alpha_smart_thread.smart_join(targets=['beta', 'charlie', 'delta'])
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1 beta about to resume alpha\n'
        expected_result += 'f1 charlie about to resume alpha\n'
        expected_result += 'alpha about to wait for any threads\n'
        expected_result += "alpha resumed by resumers=['beta', 'charlie']\n"
        expected_result += 'f1 delta about to resume alpha\n'
        expected_result += 'alpha about to wait for any threads\n'
        expected_result += "alpha resumed by resumers=['delta']\n"
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_wait_example_5
    ####################################################################
    def test_smart_wait_example_5(self,
                                  capsys: Any) -> None:
        """Test smart_wait example 5.

        smart_wait for any resumers in configuration

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1(smart_thread: SmartThread) -> None:
            print(f'f1 {smart_thread.name} about to resume alpha')
            smart_thread.smart_resume(waiters='alpha')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1,
                    thread_parm_name='smart_thread')
        time.sleep(1)
        SmartThread(name='charlie',
                    target=f1,
                    thread_parm_name='smart_thread')
        time.sleep(1)
        print('alpha about to wait for any threads')
        resumed_by = alpha_smart_thread.smart_wait()
        print(f'alpha resumed by resumers={sorted(resumed_by)}')
        SmartThread(name='delta',
                    target=f1,
                    thread_parm_name='smart_thread')
        time.sleep(1)  # allow time for alpha to wait
        print('alpha about to wait for any threads')
        resumed_by = alpha_smart_thread.smart_wait()
        print(f'alpha resumed by resumers={sorted(resumed_by)}')

        alpha_smart_thread.smart_join(targets=['beta', 'charlie', 'delta'])
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1 beta about to resume alpha\n'
        expected_result += 'f1 charlie about to resume alpha\n'
        expected_result += 'alpha about to wait for any threads\n'
        expected_result += "alpha resumed by resumers=['beta', 'charlie']\n"
        expected_result += 'f1 delta about to resume alpha\n'
        expected_result += 'alpha about to wait for any threads\n'
        expected_result += "alpha resumed by resumers=['delta']\n"
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_resume_example_1
    ####################################################################
    def test_smart_resume_example_1(self,
                                    capsys: Any) -> None:
        """Test smart_resume example 1.

        Invoke ''smart_resume()'' for threads that invoke
        ''smart_wait()'' both before and after the ''smart_resume()''

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1_beta(smart_thread: SmartThread) -> None:
            print('f1_beta about to wait')
            smart_thread.smart_wait(resumers='alpha')
            print('f1_beta back from wait')

        def f2_charlie(smart_thread: SmartThread) -> None:
            time.sleep(1)
            print('f2_charlie about to wait')
            smart_thread.smart_wait(resumers='alpha')
            time.sleep(1)
            print('f2_charlie back from wait')

        def f3_delta(smart_thread: SmartThread) -> None:
            time.sleep(5)
            print('f3_delta about to wait')
            smart_thread.smart_wait(resumers='alpha')
            print('f3_delta back from wait')

        def f4_echo(smart_thread: SmartThread) -> None:
            time.sleep(7)
            print('f4_echo about to wait')
            smart_thread.smart_wait(resumers='alpha')
            print('f4_echo back from wait')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1_beta,
                    thread_parm_name='smart_thread')
        SmartThread(name='charlie',
                    target=f2_charlie,
                    thread_parm_name='smart_thread')
        SmartThread(name='delta',
                    target=f3_delta,
                    thread_parm_name='smart_thread')
        SmartThread(name='echo',
                    target=f4_echo,
                    thread_parm_name='smart_thread')
        time.sleep(2)
        print('alpha about to resume threads')
        alpha_smart_thread.smart_resume(waiters=('beta',
                                                 'charlie',
                                                 'delta',
                                                 'echo'))
        alpha_smart_thread.smart_join(targets=['beta',
                                               'charlie',
                                               'delta',
                                               'echo'])
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1_beta about to wait\n'
        expected_result += 'f2_charlie about to wait\n'
        expected_result += "alpha about to resume threads\n"
        expected_result += 'f1_beta back from wait\n'
        expected_result += 'f2_charlie back from wait\n'
        expected_result += 'f3_delta about to wait\n'
        expected_result += 'f3_delta back from wait\n'
        expected_result += 'f4_echo about to wait\n'
        expected_result += 'f4_echo back from wait\n'
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_sync_example_1
    ####################################################################
    def test_smart_sync_example_1(self,
                                  capsys: Any) -> None:
        """Test smart_sync example 1.

        Invoke ''smart_sync()'' for three threads

        Args:
            capsys: pytest fixture to get the print output
        """
        from scottbrian_paratools.smart_thread import SmartThread
        import time

        def f1_beta(smart_thread: SmartThread) -> None:
            print('f1_beta about to sync with alpha and charlie')
            smart_thread.smart_sync(targets=['alpha', 'charlie'])
            print('f1_beta back from sync')

        def f2_charlie(smart_thread: SmartThread) -> None:
            print('f2_charlie about to sync with alpha and beta')
            smart_thread.smart_sync(targets=['alpha', 'beta'])
            time.sleep(1)
            print('f2_charlie back from sync')

        print('mainline alpha entered')
        alpha_smart_thread = SmartThread(name='alpha')
        SmartThread(name='beta',
                    target=f1_beta,
                    thread_parm_name='smart_thread')
        time.sleep(1)
        SmartThread(name='charlie',
                    target=f2_charlie,
                    thread_parm_name='smart_thread')
        time.sleep(1)
        print('alpha about to sync with beta and charlie')
        alpha_smart_thread.smart_sync(targets=['beta', 'charlie'])
        time.sleep(2)
        print('alpha back from sync')
        alpha_smart_thread.smart_join(targets=['beta', 'charlie'])
        print('mainline alpha exiting')

        expected_result = 'mainline alpha entered\n'
        expected_result += 'f1_beta about to sync with alpha and charlie\n'
        expected_result += 'f2_charlie about to sync with alpha and beta\n'
        expected_result += "alpha about to sync with beta and charlie\n"
        expected_result += 'f1_beta back from sync\n'
        expected_result += 'f2_charlie back from sync\n'
        expected_result += 'alpha back from sync\n'
        expected_result += 'mainline alpha exiting\n'

        captured = capsys.readouterr().out

        assert captured == expected_result

        logger.debug('mainline exiting')


####################################################################
# scenario_driver
####################################################################
def scenario_driver(
        scenario_builder: Callable[..., None],
        scenario_builder_args: dict[str, Any],
        caplog_to_use: pytest.CaptureFixture[str],
        commander_config: AppConfig = AppConfig.ScriptStyle
) -> None:
    """Build and run a scenario.

    Args:
        scenario_builder: the ConfigVerifier builder method to call
        scenario_builder_args: the args to pass to the builder
        caplog_to_use: the capsys to capture log messages
        commander_config: specifies how the commander will run

    """
    ################################################################
    # f1
    ################################################################
    def f1(f1_name: str, f1_config_ver: ConfigVerifier):
        log_msg_f1 = f'f1 entered for {f1_name}'
        log_ver.add_msg(log_level=logging.DEBUG,
                        log_msg=log_msg_f1)
        logger.debug(log_msg_f1)

        f1_config_ver.f1_driver(f1_name=f1_name)

        ############################################################
        # exit
        ############################################################
        log_msg_f1 = f'f1 exiting for {f1_name}'
        log_ver.add_msg(log_level=logging.DEBUG,
                        log_msg=log_msg_f1)
        logger.debug(log_msg_f1)

    ################################################################
    # Set up log verification and start tests
    ################################################################
    commander_name = 'alpha'
    log_ver = LogVer(log_name=__name__)
    log_ver.add_call_seq(name=commander_name,
                         seq=get_formatted_call_sequence())

    random.seed(42)
    msgs = Msgs()

    config_ver = ConfigVerifier(commander_name=commander_name,
                                log_ver=log_ver,
                                caplog_to_use=caplog_to_use,
                                msgs=msgs,
                                max_msgs=10)

    config_ver.log_test_msg('mainline entered')
    config_ver.log_test_msg(f'scenario builder: {scenario_builder}')
    config_ver.log_test_msg(f'scenario args: {scenario_builder_args}')
    config_ver.log_test_msg(f'{commander_config=}')

    config_ver.unregistered_names -= {commander_name}
    config_ver.active_names |= {commander_name}

    scenario_builder(config_ver,
                     **scenario_builder_args)

    # config_ver.add_cmd(ValidateConfig(cmd_runners=commander_name))
    config_ver.add_cmd(VerifyConfig(
        cmd_runners=commander_name,
        verify_type=VerifyType.VerifyStructures))

    names = list(config_ver.active_names - {commander_name})
    config_ver.build_exit_suite(cmd_runner=commander_name,
                                names=names)

    config_ver.build_join_suite(
        cmd_runners=[config_ver.commander_name],
        join_target_names=names)

    def initialize_config_ver(cmd_thread: st.SmartThread,
                              auto_start: bool,
                              auto_start_decision: AutoStartDecision,
                              exp_alive: bool,
                              thread_create: st.ThreadCreate,
                              exp_state: st.ThreadState) -> None:
        """Set up the mock registry for the commander.

        Args:
            cmd_thread: the commander thread
            auto_start: specifies whether auto_start was specified
                on the init
            auto_start_decision: specifies whether an auto start is
                not needed, yes, or no
            exp_alive: specifies whether the thread is expected to
                be alive at the end of smart_init
            thread_create: specifies which create style is done
            exp_state: the expected state after smart_init

        """
        config_ver.all_threads[commander_name] = cmd_thread

        config_ver.expected_registered[commander_name] = ThreadTracker(
            thread=cmd_thread,
            is_alive=False,
            exiting=False,
            is_auto_started=auto_start,
            is_TargetThread=False,
            exp_init_is_alive=exp_alive,
            exp_init_thread_state=exp_state,
            thread_create=thread_create,
            auto_start_decision=auto_start_decision,
            st_state=st.ThreadState.Unregistered,
            found_del_pairs=defaultdict(int)
        )

        pe = config_ver.pending_events[commander_name]
        pe[PE.start_request].append(
            StartRequest(req_type=st.ReqType.Smart_init,
                         targets={commander_name},
                         unreg_remotes=set(),
                         not_registered_remotes=set(),
                         timeout_remotes=set(),
                         stopped_remotes=set(),
                         deadlock_remotes=set(),
                         eligible_targets=set(),
                         completed_targets=set(),
                         first_round_completed=set(),
                         stopped_target_threads=set(),
                         exp_senders=set(),
                         exp_resumers=set()))

        req_key_entry: RequestKey = ('smart_init',
                                     'entry')
        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ('smart_init',
                                    'exit')
        pe[PE.request_msg][req_key_exit] += 1

        config_ver.commander_thread_config_built = True

    ################################################################
    # start commander
    ################################################################
    config_ver.monitor_pause = True
    if commander_config == AppConfig.ScriptStyle:
        commander_thread = st.SmartThread(
            name=commander_name)

        initialize_config_ver(
            cmd_thread=commander_thread,
            auto_start=True,
            auto_start_decision=AutoStartDecision.auto_start_obviated,
            exp_alive=True,
            exp_state=st.ThreadState.Alive,
            thread_create=st.ThreadCreate.Current)
        config_ver.monitor_pause = False
        config_ver.main_driver()
    elif commander_config == AppConfig.CurrentThreadApp:
        cmd_current_app = CommanderCurrentApp(
            config_ver=config_ver,
            name=commander_name,
            max_msgs=10)

        initialize_config_ver(
            cmd_thread=cmd_current_app.smart_thread,
            auto_start=False,
            auto_start_decision=AutoStartDecision.auto_start_no,
            exp_alive=True,
            exp_state=st.ThreadState.Alive,
            thread_create=st.ThreadCreate.Current)
        config_ver.monitor_pause = False
        cmd_current_app.run()
    elif commander_config == AppConfig.RemoteThreadApp:
        outer_thread_app = OuterThreadApp(
            config_ver=config_ver,
            name=commander_name,
            max_msgs=10)

        initialize_config_ver(
            cmd_thread=outer_thread_app.smart_thread,
            auto_start=False,
            auto_start_decision=AutoStartDecision.auto_start_no,
            exp_alive=False,
            exp_state=st.ThreadState.Registered,
            thread_create=st.ThreadCreate.Thread)
        config_ver.monitor_pause = False

        pe = config_ver.pending_events[commander_name]
        pe[PE.start_request].append(
            StartRequest(req_type=st.ReqType.Smart_start,
                         targets={commander_name},
                         unreg_remotes=set(),
                         not_registered_remotes=set(),
                         timeout_remotes=set(),
                         stopped_remotes=set(),
                         deadlock_remotes=set(),
                         eligible_targets=set(),
                         completed_targets=set(),
                         first_round_completed=set(),
                         stopped_target_threads=set(),
                         exp_senders=set(),
                         exp_resumers=set()))

        req_key_entry: RequestKey = ('smart_start',
                                     'entry')

        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ('smart_start',
                                    'exit')
        pe[PE.request_msg][req_key_exit] += 1

        outer_thread_app.smart_thread.smart_start()
        outer_thread_app.join()
    elif commander_config == AppConfig.RemoteSmartThreadApp:
        outer_thread_app = OuterSmartThreadApp(
            config_ver=config_ver,
            name=commander_name,
            max_msgs=10)

        initialize_config_ver(
            cmd_thread=outer_thread_app,
            auto_start=False,
            auto_start_decision=AutoStartDecision.auto_start_no,
            exp_alive=False,
            exp_state=st.ThreadState.Registered,
            thread_create=st.ThreadCreate.Thread)
        config_ver.monitor_pause = False

        pe = config_ver.pending_events[commander_name]
        pe[PE.start_request].append(
            StartRequest(req_type=st.ReqType.Smart_start,
                         targets={commander_name},
                         unreg_remotes=set(),
                         not_registered_remotes=set(),
                         timeout_remotes=set(),
                         stopped_remotes=set(),
                         deadlock_remotes=set(),
                         eligible_targets=set(),
                         completed_targets=set(),
                         first_round_completed=set(),
                         stopped_target_threads=set(),
                         exp_senders=set(),
                         exp_resumers=set()))

        req_key_entry: RequestKey = ('smart_start',
                                     'entry')

        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ('smart_start',
                                    'exit')
        pe[PE.request_msg][req_key_exit] += 1

        outer_thread_app.smart_start(commander_name)
        threading.Thread.join(outer_thread_app)
    elif commander_config == AppConfig.RemoteSmartThreadApp2:
        outer_thread_app = OuterSmartThreadApp2(
            config_ver=config_ver,
            name=commander_name,
            max_msgs=10)

        initialize_config_ver(
            cmd_thread=outer_thread_app,
            auto_start=False,
            auto_start_decision=AutoStartDecision.auto_start_no,
            exp_alive=False,
            exp_state=st.ThreadState.Registered,
            thread_create=st.ThreadCreate.Thread)
        config_ver.monitor_pause = False

        pe = config_ver.pending_events[commander_name]
        pe[PE.start_request].append(
            StartRequest(req_type=st.ReqType.Smart_start,
                         targets={commander_name},
                         unreg_remotes=set(),
                         not_registered_remotes=set(),
                         timeout_remotes=set(),
                         stopped_remotes=set(),
                         deadlock_remotes=set(),
                         eligible_targets=set(),
                         completed_targets=set(),
                         first_round_completed=set(),
                         stopped_target_threads=set(),
                         exp_senders=set(),
                         exp_resumers=set()))

        req_key_entry: RequestKey = ('smart_start',
                                     'entry')

        pe[PE.request_msg][req_key_entry] += 1

        req_key_exit: RequestKey = ('smart_start',
                                    'exit')
        pe[PE.request_msg][req_key_exit] += 1

        outer_thread_app.smart_start(commander_name)
        threading.Thread.join(outer_thread_app)
    else:
        raise UnrecognizedCmd('scenario_driver does not recognize '
                              f'{commander_config=}')

    ################################################################
    # check that pending events are complete
    ################################################################

    config_ver.log_test_msg('Monitor Checkpoint: check_pending_events 42')
    config_ver.monitor_event.set()
    config_ver.check_pending_events_complete_event.wait()

    config_ver.monitor_exit = True
    config_ver.monitor_event.set()
    config_ver.monitor_thread.join()

    ################################################################
    # check log results
    ################################################################
    match_results = log_ver.get_match_results(
        caplog=caplog_to_use)
    log_ver.print_match_results(match_results)
    log_ver.verify_log_results(match_results)

    logger.debug('mainline exiting')


########################################################################
# TestSmartThreadScenarios class
########################################################################
class TestSmartThreadSmokeTest:
    """Test class for SmartThread scenarios."""

    ####################################################################
    # test_smart_thread_simple_scenarios
    ####################################################################
    def test_smart_thread_simple_scenarios(
            self,
            caplog: pytest.CaptureFixture[str],
            commander_config_arg: AppConfig
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            caplog: pytest fixture to capture log output
            commander_config_arg: specifies the config for the commander
            log_level_arg: specifies the log level

        """
        args_for_scenario_builder: dict[str, Any] = {}

        scenario_driver(
            scenario_builder=ConfigVerifier.build_simple_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config_arg)

    ####################################################################
    # test_config_build_scenarios
    ####################################################################
    def test_config_build_scenarios(
            self,
            num_registered_1_arg: int,
            num_active_1_arg: int,
            num_stopped_1_arg: int,
            num_registered_2_arg: int,
            num_active_2_arg: int,
            num_stopped_2_arg: int,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_registered_1_arg: number of threads to initially build
                as registered
            num_active_1_arg: number of threads to initially build as
                active
            num_stopped_1_arg: number of threads to initially build as
                stopped
            num_registered_2_arg: number of threads to reconfigure as
                registered
            num_active_2_arg: number of threads to reconfigure as
                active
            num_stopped_2_arg: number of threads to reconfigure as
                stopped
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            'num_registered_1': num_registered_1_arg,
            'num_active_1': num_active_1_arg,
            'num_stopped_1': num_stopped_1_arg,
            'num_registered_2': num_registered_2_arg,
            'num_active_2': num_active_2_arg,
            'num_stopped_2': num_stopped_2_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_config_build_suite,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog)


########################################################################
# TestSmartThreadScenarios class
########################################################################
class TestSmartBasicScenarios:
    """Test class for SmartThread scenarios."""

    ####################################################################
    # test_send_scenario
    ####################################################################
    @pytest.mark.parametrize("num_senders_arg", [1])
    @pytest.mark.parametrize("num_receivers_arg", [1])
    @pytest.mark.parametrize("num_msgs_arg", [1])
    @pytest.mark.parametrize("send_type_arg", [SendType.ToRemotes,
                                               SendType.Broadcast,
                                               SendType.SRMsgs])
    @pytest.mark.cover
    def test_send_scenario_cover(
            self,
            num_senders_arg: int,
            num_receivers_arg: int,
            num_msgs_arg: int,
            send_type_arg: SendType,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_senders_arg: number of sender threads
            num_receivers_arg: number of receiver threads
            num_msgs_arg: number of message to send
            send_type_arg: type of send to do
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            'num_senders': num_senders_arg,
            'num_receivers': num_receivers_arg,
            'num_msgs': num_msgs_arg,
            'send_type': send_type_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_send_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog)

    ####################################################################
    # test_send_scenario
    ####################################################################
    @pytest.mark.parametrize("num_senders_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_receivers_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_msgs_arg", [1, 2, 3])
    @pytest.mark.parametrize("send_type_arg", [SendType.ToRemotes,
                                               SendType.Broadcast,
                                               SendType.SRMsgs])
    def test_send_scenario(
            self,
            num_senders_arg: int,
            num_receivers_arg: int,
            num_msgs_arg: int,
            send_type_arg: SendType,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_senders_arg: number of sender threads
            num_receivers_arg: number of receiver threads
            num_msgs_arg: number of message to send
            send_type_arg: type of send to do
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            'num_senders': num_senders_arg,
            'num_receivers': num_receivers_arg,
            'num_msgs': num_msgs_arg,
            'send_type': send_type_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_send_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog)

    ####################################################################
    # test_recv_basic_scenarios
    ####################################################################
    @pytest.mark.parametrize("num_senders_arg", [0, 1, 2, 3])
    @pytest.mark.parametrize("num_msgs_arg", [1, 2, 3])
    @pytest.mark.parametrize("sender_count_arg", [0, 1, 2, 3])
    @pytest.mark.parametrize("recv_type_arg", [RecvType.PartialSenders,
                                               RecvType.MatchSenders,
                                               RecvType.ExtraSenders,
                                               RecvType.UnmatchSenders])
    # @pytest.mark.parametrize("num_senders_arg", [0])
    # @pytest.mark.parametrize("num_msgs_arg", [1])
    # @pytest.mark.parametrize("recv_type_arg", [RecvType.ExtraSenders])
    def test_recv_basic_scenario(
            self,
            num_senders_arg: int,
            num_msgs_arg: int,
            sender_count_arg: int,
            recv_type_arg: RecvType,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_senders_arg: number of senders
            num_msgs_arg: number of message to send
            sender_count_arg: number senders needed to satify smart_recv
            recv_type_arg: type of recv to do
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            'num_senders': num_senders_arg,
            'num_msgs': num_msgs_arg,
            'sender_count': sender_count_arg,
            'recv_type': recv_type_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_recv_basic_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog)

    ####################################################################
    # test_resume_basic_scenario
    ####################################################################
    @pytest.mark.parametrize("num_resumers_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_waiters_arg", [1, 2, 3])
    def test_resume_basic_scenario(
            self,
            num_resumers_arg: int,
            num_waiters_arg: int,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_resumers_arg: number of resumers
            num_waiters_arg: number of waiters
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            'num_resumers': num_resumers_arg,
            'num_waiters': num_waiters_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_resume_basic_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog)

    ####################################################################
    # test_wait_basic_scenario
    ####################################################################
    @pytest.mark.parametrize("num_resumers_arg", [0, 1, 2, 3])
    @pytest.mark.parametrize("resumer_count_arg", [0, 1, 2, 3])
    @pytest.mark.parametrize("wait_type_arg", [WaitType.PartialResumers,
                                               WaitType.MatchResumers,
                                               WaitType.ExtraResumers,
                                               WaitType.UnmatchResumers])
    def test_wait_basic_scenario(
            self,
            num_resumers_arg: int,
            resumer_count_arg: int,
            wait_type_arg: WaitType,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_resumers_arg: number of resumers beyond what is
                required for the wait_type_arg
            resumer_count_arg: resumer_count specification for smart_wait
            wait_type_arg: type of wait to do
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            'num_resumers': num_resumers_arg,
            'resumer_count': resumer_count_arg,
            'wait_type': wait_type_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_wait_basic_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog)

    ####################################################################
    # test_sync_basic_scenario
    ####################################################################
    @pytest.mark.parametrize("num_syncers_arg", [2, 3, 4])
    @pytest.mark.parametrize("num_extras_arg", [0, 1, 2])
    def test_sync_basic_scenario(
            self,
            num_syncers_arg: int,
            num_extras_arg: int,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_syncers_arg: number of threads doing sync
            num_extras_arg: number of extra threads not involved in the
                sync request
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            'num_syncers': num_syncers_arg,
            'num_extras':num_extras_arg
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_sync_basic_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog)

    ####################################################################
    # test_pending_sans_sync_scenario
    ####################################################################
    @pytest.mark.parametrize("request_type_arg", [st.ReqType.Smart_send,
                                                  st.ReqType.Smart_recv,
                                                  st.ReqType.Smart_wait,
                                                  st.ReqType.Smart_resume,
                                                  ])
    @pytest.mark.parametrize("pending_request_tf_arg", [True, False])
    @pytest.mark.parametrize("pending_msg_count_arg", [0, 1, 2])
    @pytest.mark.parametrize("pending_wait_tf_arg", [True, False])
    def test_pending_sans_sync_scenario(
            self,
            request_type_arg: st.ReqType,
            pending_request_tf_arg: bool,
            pending_msg_count_arg: int,
            pending_wait_tf_arg: bool,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            request_type_arg: request type that is to get the pending
                flags set on it
            pending_request_tf_arg: if True, pending_request flag is to
                be set
            pending_msg_count_arg: number of msgs to be placed on the
                pending thread
            pending_wait_tf_arg: if True, pending_wait flag is to be set
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            'request_type': request_type_arg,
            'pending_request_tf': pending_request_tf_arg,
            'pending_msg_count': pending_msg_count_arg,
            'pending_wait_tf': pending_wait_tf_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_pending_sans_sync_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog)

    ####################################################################
    # test_pending_sync_only_scenario
    ####################################################################
    @pytest.mark.parametrize("pending_msg_count_arg", [0, 1, 2])
    @pytest.mark.parametrize("pending_wait_tf_arg", [True, False])
    @pytest.mark.parametrize("pending_sync_tf_arg", [True, False])
    def test_pending_sync_only_scenario(
            self,
            pending_msg_count_arg: int,
            pending_wait_tf_arg: bool,
            pending_sync_tf_arg: bool,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            pending_msg_count_arg: number of msgs to be placed on the
                pending thread
            pending_wait_tf_arg: if True, pending_wait flag is to be set
            pending_sync_tf_arg: if True, pending_sync flag is to be set
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            'pending_msg_count': pending_msg_count_arg,
            'pending_wait_tf': pending_wait_tf_arg,
            'pending_sync_tf': pending_wait_tf_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_pending_sync_only_scenarios,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog)

    ####################################################################
    # test_remove_reasons_scenario
    ####################################################################
    @pytest.mark.parametrize("pending_msg_count_arg", [0, 1, 2])
    @pytest.mark.parametrize("pending_wait_tf_arg", [True, False])
    @pytest.mark.parametrize("pending_sync_tf_arg", [True, False])
    def test_remove_reasons_scenario(
            self,
            pending_msg_count_arg: int,
            pending_wait_tf_arg: bool,
            pending_sync_tf_arg: bool,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            pending_msg_count_arg: number of msgs to be placed on the
                pending thread
            pending_wait_tf_arg: if True, pending_wait flag is to be set
            pending_sync_tf_arg: if True, pending_sync flag is to be set
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            'pending_msg_count': pending_msg_count_arg,
            'pending_wait_tf': pending_wait_tf_arg,
            'pending_sync_tf': pending_sync_tf_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_remove_reasons_scenarios,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog)

    ####################################################################
    # test_backout_sync_remote_scenario
    ####################################################################
    @pytest.mark.cover
    def test_backout_sync_remote_scenario(
            self,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {}

        scenario_driver(
            scenario_builder=ConfigVerifier.build_backout_sync_remote_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog)

    ####################################################################
    # test_backout_sync_local_scenario
    ####################################################################
    @pytest.mark.cover
    def test_backout_sync_local_scenario(
            self,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {}

        scenario_driver(
            scenario_builder=ConfigVerifier.build_backout_sync_local_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog)


########################################################################
# TestSmartThreadScenarios class
########################################################################
class TestSmartThreadComboScenarios:
    """Test class for SmartThread scenarios."""

    ####################################################################
    # test_join_timeout_scenario
    ####################################################################
    @pytest.mark.parametrize("timeout_type_arg",
                             [TimeoutType.TimeoutNone,
                              TimeoutType.TimeoutFalse,
                              TimeoutType.TimeoutTrue])
    @pytest.mark.parametrize("num_active_no_target_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_no_delay_exit_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_delay_exit_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_delay_unreg_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_no_delay_reg_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_delay_reg_arg", [0, 1, 2])
    def test_join_timeout_scenario(
            self,
            timeout_type_arg: TimeoutType,
            num_active_no_target_arg: int,
            num_no_delay_exit_arg: int,
            num_delay_exit_arg: int,
            num_delay_unreg_arg: int,
            num_no_delay_reg_arg: int,
            num_delay_reg_arg: int,
            caplog: pytest.CaptureFixture[str]
            ) -> None:
        """Test error cases in the _regref remote array method.

        Args:
            timeout_type_arg: specifies whether the smart_join should
                be coded with timeout and whether the smart_join should
                succeed or fail with a timeout
            num_active_no_target_arg: number of threads that should be
                active and stay active during the join as non-targets
            num_no_delay_exit_arg: number of threads that should be
                active and targeted for join, and then exited
                immediately to allow the join to succeed
            num_delay_exit_arg: number of threads that should be active
                and targeted for join, and then be exited after a short
                delay to allow a TimeoutFalse join to succeed, and a
                long delay to cause a TimeoutTrue join to
                timeout and a TimeoutNone to eventually succeed
            num_delay_unreg_arg: number of threads that should be
                unregistered and targeted for join. These will cause the
                already unregistered log message and will be considered
                as successfully joined in the smart_join completion
                message. They will be eventually started to show that
                they are unaffected by the smart_join once they are
                recognized as already unregistered.
            num_no_delay_reg_arg: number of threads that should be
                registered and targeted for join, and then be
                be immediately started and exited to allow the
                join to succeed
            num_delay_reg_arg: number of threads that should be
                registered and targeted for join, and then be started
                and exited after a short delay to allow a TimeoutFalse
                join to succeed, and a long delay to cause a TimeoutTrue
                join to timeout and a TimeoutNone to eventually succeed
            caplog: pytest fixture to capture log output

        """
        assert num_active_no_target_arg > 0

        delay_arg_counts = (
                num_no_delay_exit_arg
                + num_delay_exit_arg
                + num_delay_unreg_arg
                + num_no_delay_reg_arg
                + num_delay_reg_arg)

        if timeout_type_arg == TimeoutType.TimeoutNone:
            if delay_arg_counts == 0:
                return
        else:
            if (num_delay_exit_arg
                    + num_delay_reg_arg) == 0:
                return

        args_for_scenario_builder: dict[str, Any] = {
            'timeout_type': timeout_type_arg,
            'num_active_no_target': num_active_no_target_arg,
            'num_no_delay_exit': num_no_delay_exit_arg,
            'num_delay_exit': num_delay_exit_arg,
            'num_delay_unreg': num_delay_unreg_arg,
            'num_no_delay_reg': num_no_delay_reg_arg,
            'num_delay_reg': num_delay_reg_arg
        }

        command_config_num = (num_active_no_target_arg
                              + delay_arg_counts) % num_commander_configs

        scenario_driver(
            scenario_builder=ConfigVerifier.build_join_timeout_suite,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config[command_config_num])

    ####################################################################
    # test_def_del_scenarios
    ####################################################################
    @pytest.mark.parametrize("def_del_scenario_arg", def_del_scenario_arg_list)
    def test_def_del_scenarios(
            self,
            def_del_scenario_arg: DefDelScenario,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            def_del_scenario_arg: specifies the type of test to do
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            'def_del_scenario': def_del_scenario_arg
        }

        command_config_num = def_del_scenario_arg.value % num_commander_configs

        scenario_driver(
            scenario_builder=ConfigVerifier.build_def_del_suite,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config[command_config_num]
        )

    # ####################################################################
    # # test_def_del_reasons
    # ####################################################################
    # def_del_reasons_0 = DefDelReasons(False, False, False, False)
    # def_del_reasons_1 = DefDelReasons(False, False, False, True)
    # def_del_reasons_2 = DefDelReasons(False, False, True, False)
    # def_del_reasons_3 = DefDelReasons(False, False, True, True)
    # def_del_reasons_4 = DefDelReasons(False, True, False, False)
    # def_del_reasons_5 = DefDelReasons(False, True, False, True)
    # def_del_reasons_6 = DefDelReasons(False, True, True, False)
    # def_del_reasons_7 = DefDelReasons(False, True, True, True)
    # def_del_reasons_8 = DefDelReasons(True, False, False, False)
    # def_del_reasons_9 = DefDelReasons(True, False, False, True)
    # def_del_reasons_a = DefDelReasons(True, False, True, False)
    # def_del_reasons_b = DefDelReasons(True, False, True, True)
    # def_del_reasons_c = DefDelReasons(True, True, False, True)
    # def_del_reasons_d = DefDelReasons(True, True, False, False)
    # def_del_reasons_e = DefDelReasons(True, True, True, True)
    # def_del_reasons_f = DefDelReasons(True, True, True, False)
    #
    #
    # @pytest.mark.parametrize("name_0_pend_arg", (def_del_reasons_0,
    #                                              def_del_reasons_1,
    #                                              def_del_reasons_2,
    #                                              def_del_reasons_3,
    #                                              def_del_reasons_4,
    #                                              def_del_reasons_5,
    #                                              def_del_reasons_6,
    #                                              def_del_reasons_7,
    #                                              def_del_reasons_8,
    #                                              def_del_reasons_9,
    #                                              def_del_reasons_a,
    #                                              def_del_reasons_b,
    #                                              def_del_reasons_c,
    #                                              def_del_reasons_d,
    #                                              def_del_reasons_e,
    #                                              def_del_reasons_f))
    # @pytest.mark.parametrize("name_1_pend_arg", (def_del_reasons_0,
    #                                              def_del_reasons_1,
    #                                              def_del_reasons_2,
    #                                              def_del_reasons_3,
    #                                              def_del_reasons_4,
    #                                              def_del_reasons_5,
    #                                              def_del_reasons_6,
    #                                              def_del_reasons_7,
    #                                              def_del_reasons_8,
    #                                              def_del_reasons_9,
    #                                              def_del_reasons_a,
    #                                              def_del_reasons_b,
    #                                              def_del_reasons_c,
    #                                              def_del_reasons_d,
    #                                              def_del_reasons_e,
    #                                              def_del_reasons_f))
    # @pytest.mark.parametrize("name_2_pend_arg", (def_del_reasons_0,
    #                                              def_del_reasons_1,
    #                                              def_del_reasons_2,
    #                                              def_del_reasons_3,
    #                                              def_del_reasons_4,
    #                                              def_del_reasons_5,
    #                                              def_del_reasons_6,
    #                                              def_del_reasons_7,
    #                                              def_del_reasons_8,
    #                                              def_del_reasons_9,
    #                                              def_del_reasons_a,
    #                                              def_del_reasons_b,
    #                                              def_del_reasons_c,
    #                                              def_del_reasons_d,
    #                                              def_del_reasons_e,
    #                                              def_del_reasons_f))
    # def test_def_del_reasons(
    #         self,
    #         name_0_pend_arg: DefDelReasons,
    #         name_1_pend_arg: DefDelReasons,
    #         name_2_pend_arg: DefDelReasons,
    #         caplog: pytest.CaptureFixture[str]
    # ) -> None:
    #     """Test pending reasons.
    #
    #     Args:
    #         name_0_pend_arg: reasons for name 0
    #         name_1_pend_arg: reasons for name 1
    #         name_2_pend_arg: reasons for name 2
    #         caplog: pytest fixture to capture log output
    #
    #     """
    #     command_config_num = ((name_0_pend_arg.pending_request
    #                            + name_0_pend_arg.pending_msg
    #                            + name_0_pend_arg.pending_wait
    #                            + name_0_pend_arg.pending_sync
    #                            + name_1_pend_arg.pending_request
    #                            + name_1_pend_arg.pending_msg
    #                            + name_1_pend_arg.pending_wait
    #                            + name_1_pend_arg.pending_sync)
    #                           % num_commander_configs)
    #
    #     args_for_scenario_builder: dict[str, Any] = {
    #         'name_0_pend': name_0_pend_arg,
    #         'name_1_pend': name_1_pend_arg,
    #         'name_2_pend': name_2_pend_arg,
    #     }
    #
    #     scenario_driver(
    #         scenario_builder=ConfigVerifier.build_def_del_pending_scenario,
    #         scenario_builder_args=args_for_scenario_builder,
    #         caplog_to_use=caplog,
    #         commander_config=commander_config[command_config_num]
    #     )

    ####################################################################
    # test_rotate_state_scenarios
    ####################################################################
    def test_rotate_state_scenarios(
            self,
            timeout_type_arg: TimeoutType,
            req0_arg: SmartRequestType,
            req1_arg: SmartRequestType,
            req0_when_req1_state_arg: tuple[st.ThreadState, int],
            req0_when_req1_lap_arg: int,
            req1_lap_arg_arg: int,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            timeout_type_arg: specifies whether the smart_recv should
                be coded with timeout and whether the smart_recv should
                succeed or fail with a timeout
            req0_arg: the SmartRequest that req0 will make
            req1_arg: the SmartRequest that req1 will make
            req0_when_req1_state_arg: req0 will issue SmartRequest when
                req1 transitions to this state
            req0_when_req1_lap_arg: req0 will issue SmartRequest when
                req1 transitions during this lap
            req1_lap_arg_arg: lap 0 or 1 when req1 SmartRequest is to be
                issued
            caplog: pytest fixture to capture log output

        """
        commander_config = AppConfig.ScriptStyle

        args_for_scenario_builder: dict[str, Any] = {
            'timeout_type': timeout_type_arg,
            'req0': req0_arg,
            'req1': req1_arg,
            'req0_when_req1_state': req0_when_req1_state_arg,
            'req0_when_req1_lap': req0_when_req1_lap_arg,
            'req1_lap': req1_lap_arg_arg
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_rotate_state_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config
        )

    ####################################################################
    # test_recv_msg_scenarios
    ####################################################################
    def test_recv_msg_scenarios(
            self,
            timeout_type_arg: TimeoutType,
            recv_msg_state_arg: tuple[st.ThreadState, int],
            recv_msg_lap_arg: int,
            send_msg_lap_arg: int,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            timeout_type_arg: specifies whether the smart_recv should
                be coded with timeout and whether the smart_recv should
                succeed or fail with a timeout
            recv_msg_state_arg: sender state when smart_recv is to be
                issued
            recv_msg_lap_arg: lap 0 or 1 when the smart_recv is to be
                issued
            send_msg_lap_arg: lap 0 or 1 when the smart_send is to be
                issued
            caplog: pytest fixture to capture log output

        """
        args_for_scenario_builder: dict[str, Any] = {
            'timeout_type': timeout_type_arg,
            'recv_msg_state': recv_msg_state_arg,
            'recv_msg_lap': recv_msg_lap_arg,
            'send_msg_lap': send_msg_lap_arg
        }

        command_config_num = (timeout_type_arg.value
                              + recv_msg_lap_arg
                              + send_msg_lap_arg) % num_commander_configs
        scenario_driver(
            scenario_builder=ConfigVerifier.build_recv_msg_suite,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config[command_config_num]
        )

    ####################################################################
    # test_send_rotate_state_scenarios
    ####################################################################
    def test_send_rotate_state_scenarios(
            self,
            timeout_type_arg: TimeoutType,
            send_msg_state_arg: tuple[st.ThreadState, int],
            send_msg_lap_arg: int,
            recv_msg_lap_arg: int,
            send_resume_arg: str,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            timeout_type_arg: specifies whether the smart_recv should
                be coded with timeout and whether the smart_recv should
                succeed or fail with a timeout
            send_msg_state_arg: sender state when smart_send is to be
                issued
            send_msg_lap_arg: lap 0 or 1 when the smart_send is to be
                issued
            recv_msg_lap_arg: lap 0 or 1 when the smart_recv is to be
                issued
            send_resume_arg: specifies whether to test send or resume
            caplog: pytest fixture to capture log output

        """
        commander_config = AppConfig.ScriptStyle

        args_for_scenario_builder: dict[str, Any] = {
            'timeout_type': timeout_type_arg,
            'send_msg_state': send_msg_state_arg,
            'send_msg_lap': send_msg_lap_arg,
            'recv_msg_lap': recv_msg_lap_arg,
            'send_resume': send_resume_arg
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_send_rotate_state_scenario,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config
        )

    ####################################################################
    # test_send_msg_timeout_scenarios
    ####################################################################
    def test_send_msg_timeout_scenarios(
            self,
            timeout_type_arg: TimeoutType,
            num_senders_arg: int,
            num_active_targets_arg: int,
            num_registered_targets_arg: int,
            num_unreg_timeouts_arg: int,
            num_exit_timeouts_arg: int,
            num_full_q_timeouts_arg: int,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            timeout_type_arg: specifies whether the smart_send should
                be coded with timeout and whether the smart_send should
                succeed or fail with a timeout
            num_senders_arg: number of threads to send msgs
            num_active_targets_arg: number of active threads to recv
            num_registered_targets_arg: number registered thread to
                recv
            num_unreg_timeouts_arg: number of threads to be receivers that
                cause a timeout by being unregistering
            num_exit_timeouts_arg: number of threads to be receivers that
                cause a timeout by exiting
            num_full_q_timeouts_arg: number of threads to be receivers
                that cause a timeout by having a full msgq
            caplog: pytest fixture to capture log output

        """
        total_arg_counts = (
                num_active_targets_arg
                + num_registered_targets_arg
                + num_unreg_timeouts_arg
                + num_exit_timeouts_arg
                + num_full_q_timeouts_arg)
        if timeout_type_arg == TimeoutType.TimeoutNone:
            if total_arg_counts == 0:
                return
        else:
            if (num_unreg_timeouts_arg
                    + num_exit_timeouts_arg
                    + num_full_q_timeouts_arg) == 0:
                return

        command_config_num = total_arg_counts % 5
        if command_config_num == 0:
            commander_config = AppConfig.ScriptStyle
        elif command_config_num == 1:
            commander_config = AppConfig.CurrentThreadApp
        elif command_config_num == 2:
            commander_config = AppConfig.RemoteThreadApp
        elif command_config_num == 3:
            commander_config = AppConfig.RemoteSmartThreadApp
        else:
            commander_config = AppConfig.RemoteSmartThreadApp2

        args_for_scenario_builder: dict[str, Any] = {
            'timeout_type': timeout_type_arg,
            'num_senders': num_senders_arg,
            'num_active_targets': num_active_targets_arg,
            'num_registered_targets': num_registered_targets_arg,
            'num_unreg_timeouts': num_unreg_timeouts_arg,
            'num_exit_timeouts': num_exit_timeouts_arg,
            'num_full_q_timeouts': num_full_q_timeouts_arg
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_send_msg_timeout_suite,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config)

    ####################################################################
    # test_resume_timeout_scenarios
    ####################################################################
    @pytest.mark.parametrize("timeout_type_arg",
                             [TimeoutType.TimeoutNone,
                              TimeoutType.TimeoutFalse,
                              TimeoutType.TimeoutTrue])
    @pytest.mark.parametrize("num_resumers_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_active_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_registered_before_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_registered_after_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_unreg_no_delay_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_unreg_delay_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_stopped_no_delay_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_stopped_delay_arg", [0, 1, 2])
    def test_resume_timeout_scenarios(
            self,
            timeout_type_arg: TimeoutType,
            num_resumers_arg: int,
            num_active_arg: int,
            num_registered_before_arg: int,
            num_registered_after_arg: int,
            num_unreg_no_delay_arg: int,
            num_unreg_delay_arg: int,
            num_stopped_no_delay_arg: int,
            num_stopped_delay_arg: int,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            timeout_type_arg: specifies whether to issue the resume with
                timeout, and is so whether the resume should timeout
                or, by starting exited threads in time, not timeout
            num_resumers_arg: number of threads doing resumes
            num_active_arg: number threads active, thus no timeout
            num_registered_before_arg: number threads registered, thus
                no timeout, issued before the resume is issued
            num_registered_after_arg: number threads registered, thus no
                timeout, issued after the resume is issued
            num_unreg_no_delay_arg: number threads unregistered before
                the resume is done, and are then created and started
                within the allowed timeout
            num_unreg_delay_arg: number threads unregistered before the
                resume is done, and are then created and started after
                the allowed timeout
            num_stopped_no_delay_arg: number of threads stopped before
                the resume and cause a timeout
            num_stopped_delay_arg: number of threads stopped
                before the resume and are then joined, created, and
                started within the allowed timeout
            caplog: pytest fixture to capture log output

        """
        total_arg_counts = (
                num_active_arg
                + num_registered_before_arg
                + num_registered_after_arg
                + num_unreg_no_delay_arg
                + num_unreg_delay_arg
                + num_stopped_no_delay_arg
                + num_stopped_delay_arg)
        if timeout_type_arg == TimeoutType.TimeoutNone:
            if total_arg_counts == 0:
                return
        else:
            if (num_unreg_delay_arg + num_stopped_delay_arg) == 0:
                return

        command_config_num = total_arg_counts % 5
        if command_config_num == 0:
            commander_config = AppConfig.ScriptStyle
        elif command_config_num == 1:
            commander_config = AppConfig.CurrentThreadApp
        elif command_config_num == 2:
            commander_config = AppConfig.RemoteThreadApp
        elif command_config_num == 3:
            commander_config = AppConfig.RemoteSmartThreadApp
        else:
            commander_config = AppConfig.RemoteSmartThreadApp2

        args_for_scenario_builder: dict[str, Any] = {
            'timeout_type': timeout_type_arg,
            'num_resumers': num_resumers_arg,
            'num_active': num_active_arg,
            'num_registered_before': num_registered_before_arg,
            'num_registered_after': num_registered_after_arg,
            'num_unreg_no_delay': num_unreg_no_delay_arg,
            'num_unreg_delay': num_unreg_delay_arg,
            'num_stopped_no_delay': num_stopped_no_delay_arg,
            'num_stopped_delay': num_stopped_delay_arg
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_resume_timeout_suite,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config)

    ####################################################################
    # test_resume_scenarios
    ####################################################################
    @pytest.mark.parametrize("num_resumers_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_start_before_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_unreg_before_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_stop_before_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_unreg_after_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_stop_after_ok_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_stop_after_err_arg", [0, 1, 2])
    def test_resume_scenarios(
            self,
            num_resumers_arg: int,
            num_start_before_arg: int,
            num_unreg_before_arg: int,
            num_stop_before_arg: int,
            num_unreg_after_arg: int,
            num_stop_after_ok_arg: int,
            num_stop_after_err_arg: int,
            caplog: pytest.CaptureFixture[str],
            monkeypatch: Any
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_resumers_arg: number of threads doing resumes
            num_start_before_arg: number of target threads that will
                be started and issue a wait before the resume is done,
                and should succeed
            num_unreg_before_arg: number of target threads that will be
                registered and then unregistered before the resume, and
                then started after the resume, and should succeed
            num_stop_before_arg: number of target threads that will
                be started and then stopped (but not joined) before the
                resume, and should result in a not alive error
            num_unreg_after_arg: number of target threads that will be
                unregistered after the resume, and should cause an error
            num_stop_after_ok_arg: number of target threads that will
                be started after the resume is issued, and will stay
                alive long enough for the resume to set the wait_event,
                and will then be stopped and joined, and should result
                in success
            num_stop_after_err_arg: number of target threads that will
                be started after the resume is issued, and will quickly
                be stopped and joined before the resume has a chance to
                see that is is alive to sety the wait_event, and should
                result in a not alive error
            caplog: pytest fixture to capture log output
            monkeypatch: pytest fixture used to modify code for testing

        """
        ################################################################
        # monkeypatch for SmartThread._get_target_state
        ################################################################
        monkeypatch.setattr(st.SmartThread,
                            "_get_target_state",
                            MockGetTargetState.mock_get_target_state)

        total_arg_counts = (
            num_resumers_arg
            + num_start_before_arg
            + num_unreg_before_arg
            + num_stop_before_arg
            + num_unreg_after_arg
            + num_stop_after_ok_arg
            + num_stop_after_err_arg)

        if total_arg_counts - num_resumers_arg == 0:
            return

        command_config_num = total_arg_counts % 5
        if command_config_num == 0:
            commander_config = AppConfig.ScriptStyle
        elif command_config_num == 1:
            commander_config = AppConfig.CurrentThreadApp
        elif command_config_num == 2:
            commander_config = AppConfig.RemoteThreadApp
        elif command_config_num == 3:
            commander_config = AppConfig.RemoteSmartThreadApp
        else:
            commander_config = AppConfig.RemoteSmartThreadApp2

        args_for_scenario_builder: dict[str, Any] = {
            'num_resumers': num_resumers_arg,
            'num_start_before': num_start_before_arg,
            'num_unreg_before': num_unreg_before_arg,
            'num_stop_before': num_stop_before_arg,
            'num_unreg_after': num_unreg_after_arg,
            'num_stop_after_ok': num_stop_after_ok_arg,
            'num_stop_after_err': num_stop_after_err_arg
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_resume_scenarios,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config)

    ####################################################################
    # test_wait_scenarios
    ####################################################################
    @pytest.mark.parametrize("num_waiters_arg", [1, 2, 3])
    @pytest.mark.parametrize("num_start_before_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_unreg_before_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_stop_before_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_unreg_after_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_stop_after_ok_arg", [0, 1, 2])
    @pytest.mark.parametrize("num_stop_after_err_arg", [0, 1, 2])
    def test_wait_scenarios(
            self,
            num_waiters_arg: int,
            num_start_before_arg: int,
            num_unreg_before_arg: int,
            num_stop_before_arg: int,
            num_unreg_after_arg: int,
            num_stop_after_ok_arg: int,
            num_stop_after_err_arg: int,
            caplog: pytest.CaptureFixture[str],
            monkeypatch: Any
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            num_waiters_arg: number of threads doing resumes
            num_start_before_arg: number of target threads that will
                be started and issue a wait before the resume is done,
                and should succeed
            num_unreg_before_arg: number of target threads that will be
                registered and then unregistered before the resume, and
                then started after the resume, and should succeed
            num_stop_before_arg: number of target threads that will
                be started and then stopped (but not joined) before the
                resume, and should result in a not alive error
            num_unreg_after_arg: number of target threads that will be
                unregistered after the resume, and should cause an error
            num_stop_after_ok_arg: number of target threads that will
                be started after the resume is issued, and will stay
                alive long enough for the resume to set the wait_event,
                and will then be stopped and joined, and should result
                in success
            num_stop_after_err_arg: number of target threads that will
                be started after the resume is issued, and will quickly
                be stopped and joined before the resume has a chance to
                see that is is alive to sety the wait_event, and should
                result in a not alive error
            caplog: pytest fixture to capture log output
            monkeypatch: pytest fixture used to modify code for testing

        """
        ################################################################
        # monkeypatch for SmartThread._get_target_state
        ################################################################
        monkeypatch.setattr(st.SmartThread,
                            "_get_target_state",
                            MockGetTargetState.mock_get_target_state)

        total_arg_counts = (
                num_waiters_arg
                + num_start_before_arg
                + num_unreg_before_arg
                + num_stop_before_arg
                + num_unreg_after_arg
                + num_stop_after_ok_arg
                + num_stop_after_err_arg)

        if total_arg_counts - num_waiters_arg == 0:
            return

        command_config_num = total_arg_counts % 5
        if command_config_num == 0:
            commander_config = AppConfig.ScriptStyle
        elif command_config_num == 1:
            commander_config = AppConfig.CurrentThreadApp
        elif command_config_num == 2:
            commander_config = AppConfig.RemoteThreadApp
        elif command_config_num == 3:
            commander_config = AppConfig.RemoteSmartThreadApp
        else:
            commander_config = AppConfig.RemoteSmartThreadApp2

        args_for_scenario_builder: dict[str, Any] = {
            'num_waiters': num_waiters_arg,
            'num_start_before': num_start_before_arg,
            'num_unreg_before': num_unreg_before_arg,
            'num_stop_before': num_stop_before_arg,
            'num_unreg_after': num_unreg_after_arg,
            'num_stop_after_ok': num_stop_after_ok_arg,
            'num_stop_after_err': num_stop_after_err_arg
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_wait_scenarios,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config)

    ####################################################################
    # test_recv_msg_scenarios
    ####################################################################
    def test_wait_scenarios2(
            self,
            timeout_type_arg: TimeoutType,
            wait_state_arg: st.ThreadState,
            wait_lap_arg: int,
            resume_lap_arg: int,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test meta configuration scenarios.

        Args:
            timeout_type_arg: specifies whether the smart_recv should
                be coded with timeout and whether the smart_recv should
                succeed or fail with a timeout
            wait_state_arg: resumer state when wait is to be
                issued
            wait_lap_arg: lap 0 or 1 when the wait is to be
                issued
            resume_lap_arg: lap 0 or 1 when the resume is to be
                issued
            caplog: pytest fixture to capture log output

        """
        commander_config = AppConfig.ScriptStyle

        args_for_scenario_builder: dict[str, Any] = {
            'timeout_type': timeout_type_arg,
            'wait_state': wait_state_arg,
            'wait_lap': wait_lap_arg,
            'resume_lap': resume_lap_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_wait_suite,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config
        )

    ####################################################################
    # test_wait_timeout_scenarios
    ####################################################################
    def test_wait_scenarios3(
            self,
            num_waiters_arg: int,
            num_actors_arg: int,
            actor_1_arg: Actors,
            actor_2_arg: Actors,
            actor_3_arg: Actors,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test wait scenarios.

        Args:
            num_waiters_arg: number of threads that will do the wait
            num_actors_arg: number of actor threads
            actor_1_arg: type of actor that will do the first resume
            actor_2_arg: type of actor that will do the second resume
            actor_3_arg: type of actor that will do the third resume
            caplog: pytest fixture to capture log output

        """
        total_arg_counts = (
                num_waiters_arg
                + num_actors_arg)

        command_config_num = total_arg_counts % 5
        if command_config_num == 0:
            commander_config = AppConfig.ScriptStyle
        elif command_config_num == 1:
            commander_config = AppConfig.CurrentThreadApp
        elif command_config_num == 2:
            commander_config = AppConfig.RemoteThreadApp
        elif command_config_num == 3:
            commander_config = AppConfig.RemoteSmartThreadApp
        else:
            commander_config = AppConfig.RemoteSmartThreadApp2

        # args_for_scenario_builder: dict[str, Any] = {
        #     'num_waiters': num_waiters_arg,
        #     'actor_list': [(actor_1_arg, num_actor_1_arg),
        #                    (actor_2_arg, num_actor_2_arg),
        #                    (actor_3_arg, num_actor_3_arg)]
        # }
        args_for_scenario_builder: dict[str, Any] = {
            'num_waiters': num_waiters_arg,
            'num_actors': num_actors_arg,
            'actor_list': [actor_1_arg, actor_2_arg, actor_3_arg]
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_wait_scenario_suite,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config
        )

    ####################################################################
    # test_sync_scenarios
    ####################################################################
    def test_sync_scenarios(
            self,
            timeout_type_arg: TimeoutType,
            num_syncers_arg: int,
            num_stopped_syncers_arg: int,
            num_timeout_syncers_arg: int,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test smart_sync scenarios.

        Args:
            timeout_type_arg: timeout for None, False, or True
            num_syncers_arg: number of threads that will successfully
                sync
            num_stopped_syncers_arg: number of threads that will
                cause a not alive error
            num_timeout_syncers_arg: number of threads that will
                cause a timeout error
            caplog: pytest fixture to capture log output

        """
        total_arg_counts = (
                num_syncers_arg
                + num_stopped_syncers_arg
                + num_timeout_syncers_arg)

        if total_arg_counts < 2:  # we need at least two to sync
            return

        if (timeout_type_arg == TimeoutType.TimeoutTrue
                and (num_timeout_syncers_arg == 0)):
            return

        command_config_num = total_arg_counts % 5
        if command_config_num == 0:
            commander_config = AppConfig.ScriptStyle
        elif command_config_num == 1:
            commander_config = AppConfig.CurrentThreadApp
        elif command_config_num == 2:
            commander_config = AppConfig.RemoteThreadApp
        elif command_config_num == 3:
            commander_config = AppConfig.RemoteSmartThreadApp
        else:
            commander_config = AppConfig.RemoteSmartThreadApp2

        args_for_scenario_builder: dict[str, Any] = {
            'timeout_type': timeout_type_arg,
            'num_syncers': num_syncers_arg,
            'num_stopped_syncers': num_stopped_syncers_arg,
            'num_timeout_syncers': num_timeout_syncers_arg,
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_sync_scenario_suite,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config
        )

    ####################################################################
    # test_deadlock_conflict_scenarios
    ####################################################################
    def test_conflict_deadlock_scenarios(
            self,
            conflict_deadlock_1_arg: ConflictDeadlockScenario,
            conflict_deadlock_2_arg: ConflictDeadlockScenario,
            conflict_deadlock_3_arg: ConflictDeadlockScenario,
            num_cd_actors_arg: int,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test smart_sync scenarios.

        Args:
            conflict_deadlock_1_arg: first scenario
            conflict_deadlock_2_arg: second scenario
            conflict_deadlock_3_arg: third scenario
            num_cd_actors_arg: number syncers, resumers, and waiters
            caplog: pytest fixture to capture log output

        """
        command_config_num = num_cd_actors_arg % 5
        if command_config_num == 0:
            commander_config = AppConfig.ScriptStyle
        elif command_config_num == 1:
            commander_config = AppConfig.CurrentThreadApp
        elif command_config_num == 2:
            commander_config = AppConfig.RemoteThreadApp
        elif command_config_num == 3:
            commander_config = AppConfig.RemoteSmartThreadApp
        else:
            commander_config = AppConfig.RemoteSmartThreadApp2

        args_for_scenario_builder: dict[str, Any] = {
            'scenario_list': [conflict_deadlock_1_arg,
                              conflict_deadlock_2_arg,
                              conflict_deadlock_3_arg],
            'num_cd_actors': num_cd_actors_arg
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_conf_dead_scenario_suite,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_config
        )

    ####################################################################
    # test_smart_start_scenarios
    ####################################################################
    def test_smart_start_scenarios(
            self,
            num_auto_start_arg: int,
            num_manual_start_arg: int,
            num_unreg_arg: int,
            num_alive_arg: int,
            num_stopped_arg: int,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test smart_sync scenarios.

        Args:
            num_auto_start_arg: number of threads to auto start
            num_manual_start_arg: number of thread to manually start
            num_unreg_arg: number threads to not create for timeout
            num_alive_arg: number threads alive already
            num_stopped_arg: number threads stopped
            caplog: pytest fixture to capture log output

        """
        total_num_targets = (num_manual_start_arg
                             + num_unreg_arg
                             + num_alive_arg
                             + num_stopped_arg)

        if total_num_targets == 0:
            return

        commander_configs: tuple[AppConfig, ...] = (
            AppConfig.ScriptStyle,
            AppConfig.CurrentThreadApp,
            AppConfig.RemoteThreadApp,
            AppConfig.RemoteSmartThreadApp,
            AppConfig.RemoteSmartThreadApp2
        )

        args_for_scenario_builder: dict[str, Any] = {
            'num_auto_start': num_auto_start_arg,
            'num_manual_start': num_manual_start_arg,
            'num_unreg': num_unreg_arg,
            'num_alive': num_alive_arg,
            'num_stopped': num_stopped_arg
        }

        scenario_driver(
            scenario_builder=ConfigVerifier.build_smart_start_suite,
            scenario_builder_args=args_for_scenario_builder,
            caplog_to_use=caplog,
            commander_config=commander_configs[
                total_num_targets % len(commander_configs)]
        )

    ####################################################################
    # test_smart_thread_log_msg
    ####################################################################
    def test_smart_thread_log_msg(
            self,
            log_level_arg: int,
            caplog: pytest.CaptureFixture[str]
    ) -> None:
        """Test smart_thread logging.

        Args:
            log_level_arg: logging level to set
            caplog: pytest fixture to capture log output

        Notes:
            1) pytest.ini log_cli_level sets the root level - it
               overrides the level set by basicConfig in conftest
            2) if pytest.ini log_cli_level is not set, conftest sets the
               level
            3) if conftest is not specified, the level defaults to
               WARNING
            4) logging.getLogger('scottbrian_paratools').setLevel(
               logging.DEBUG) overrides the root setting, whether
               default, set by conftest, or set by pytest.ini
            5) logging.getLogger('scottbrian_paratools.smart_thread')
               .setLevel(logging.INFO) overrides all of the above.
            6) Basic strategy is to not specify the level with 4 or 5 -
               just let the application set the level using basicConfig

        """
        ################################################################
        # add_log_msgs
        ################################################################
        def add_log_msgs(log_msgs: StrOrList,
                         log_name: str,
                         log_level: int) -> None:
            """Add log message to log ver if log level is active.

            Args:
                log_msgs: messages to add
                log_name: name of log it is associated with
                log_level: log level of the msg
            """
            if isinstance(log_msgs, str):
                log_msgs = [log_msgs]

            if log_level_arg <= log_level:
                for log_msg in log_msgs:
                    log_ver.add_msg(log_level=log_level,
                                    log_msg=log_msg,
                                    log_name=log_name)

        ################################################################
        # f1
        ################################################################
        def f1(f1_name: str):
            """F1 routine.

            Args:
                f1_name: name of f1
            """
            log_msg_f1 = f'f1 entered for {f1_name}'
            add_log_msgs(log_msgs=log_msg_f1,
                         log_level=logging.DEBUG,
                         log_name=test_log_name)
            logger.debug(log_msg_f1)

            time.sleep(1)

            f1_st.smart_recv(senders='alpha')

            f1_st.smart_wait(resumers='alpha')

            f1_st.smart_sync(targets='alpha')

            ############################################################
            # exit
            ############################################################
            log_msg_f1 = f'f1 exiting for {f1_name}'
            add_log_msgs(log_msgs=log_msg_f1,
                         log_level=logging.DEBUG,
                         log_name=test_log_name)
            logger.debug(log_msg_f1)

        ################################################################
        # Set up log verification and start tests
        # The following code gets the root logger from the
        # logging Manager dictionary using the parent of smart_thread.
        # This is not the way it would normally be done but it suits
        # our purpose to test that the log messages are being issued or
        # suppressed correctly based on logging levels.
        ################################################################
        my_root = logging.Logger.manager.loggerDict[
            'scottbrian_paratools'].parent
        my_root.setLevel(log_level_arg)

        commander_name = 'alpha'
        f1_name = 'beta'
        log_ver = LogVer(log_name=__name__)
        log_ver.add_call_seq(name=commander_name,
                             seq=get_formatted_call_sequence())

        test_log_name = __name__
        smart_thread_log_name = 'scottbrian_paratools.smart_thread'

        log_msg = f'{my_root.name=}, {my_root.level=}'
        add_log_msgs(log_msgs=log_msg,
                     log_level=max(log_level_arg, logging.DEBUG),
                     log_name=test_log_name)
        logger.log(level=max(log_level_arg, logging.DEBUG), msg=log_msg)

        log_msg = 'mainline entered'
        add_log_msgs(log_msgs=log_msg,
                     log_level=logging.WARN,
                     log_name=test_log_name)
        logger.warning(log_msg)

        ################################################################
        # start commander
        ################################################################
        commander_thread = st.SmartThread(
            name=commander_name,
            max_msgs=10)

        f1_st = st.SmartThread(
            name=f1_name,
            target=f1,
            args=(f1_name, ),
            max_msgs=10)

        commander_thread.smart_send(receivers='beta',
                                    msg='alpha sends to beta')

        commander_thread.smart_resume(waiters='beta')

        commander_thread.smart_sync(targets='beta')

        commander_thread.smart_join(targets='beta')

        f1_st = st.SmartThread(
            name=f1_name,
            target=f1,
            args=(f1_name,),
            auto_start=False)

        commander_thread.smart_unreg(targets='beta')

        ################################################################
        # commander log messages
        ################################################################
        commander_debug_log_msgs = [
            ('alpha set state for thread alpha from '
             'ThreadState.Unregistered to ThreadState.Initializing'),
            'alpha obtained _registry_lock, class name = SmartThread',
            ('alpha set state for thread alpha from '
             'ThreadState.Initializing to ThreadState.Alive'),
            'alpha added alpha to SmartThread registry at UTC',
            'alpha entered _clean_pair_array',
            ("smart_send entry: requestor: alpha receivers: "
             r"\['beta'\] timeout value: None "
             "test_smart_thread.py::TestSmartThreadScenarios."
             "test_smart_thread_log_msg:"),
            ("smart_send exit: requestor: alpha receivers: "
             r"\['beta'\] timeout value: None "
             "test_smart_thread.py::TestSmartThreadScenarios."
             "test_smart_thread_log_msg:"),
            ("smart_join entry: requestor: alpha targets: "
             r"\['beta'\] timeout value: None "
             "test_smart_thread.py::TestSmartThreadScenarios."
             "test_smart_thread_log_msg:"),
            ("smart_join exit: requestor: alpha targets: "
             r"\['beta'\] timeout value: None "
             "test_smart_thread.py::TestSmartThreadScenarios."
             "test_smart_thread_log_msg:"),
            ('alpha set state for thread beta from '
             'ThreadState.Alive to '
             'ThreadState.Stopped'),
            (r"name=alpha, smart_thread=SmartThread\(name='alpha'\), "
             r"s_alive\(\)=True, "
             "state=<ThreadState.Alive: 16>"),
            (r"name=beta, smart_thread=SmartThread\(name='beta', "
             r"target=f1, args=\('beta',\)\), "
             r"is_alive\(\)=False, "
             "state=<ThreadState.Stopped: 32>"),
            ("alpha removed beta from registry for "
             "process='join'"),
            'alpha entered _clean_pair_array',
            ("alpha removed status_blocks entry for pair_key = "
             r"\('alpha', 'beta'\), name = beta"),
            ("alpha removed status_blocks entry for pair_key = "
             r"\('alpha', 'beta'\), name = alpha"),
            ("alpha removed _pair_array entry for pair_key = "
             r"\('alpha', 'beta'\)"),
            'alpha updated _pair_array at UTC',
            "alpha did cleanup of registry at UTC",
            'alpha did successful smart_join of beta.',
            (r"smart_resume entry: requestor: alpha targets: \['beta'\] "
             "timeout value: None "
             "test_smart_thread.py::TestSmartThreadScenarios"
             ".test_smart_thread_log_msg:"),
            (r"smart_resume exit: requestor: alpha targets: \['beta'\] "
             "timeout value: None "
             "test_smart_thread.py::TestSmartThreadScenarios"
             ".test_smart_thread_log_msg:"),
            (r"smart_sync entry: requestor: alpha targets: \['beta'\] timeout "
             "value: None test_smart_thread.py::TestSmartThreadScenarios."
             "test_smart_thread_log_msg:"),
            (r"smart_sync exit: requestor: alpha targets: \['beta'\] timeout "
             "value: None test_smart_thread.py::TestSmartThreadScenarios."
             "test_smart_thread_log_msg:"),
            ('alpha set state for thread beta from ThreadState.Unregistered '
             'to ThreadState.Initializing'),
            'alpha obtained _registry_lock, class name = SmartThread',
            (r"name=alpha, smart_thread=SmartThread\(name='alpha'\), "
             r"is_alive\(\)=True, "
             "state=<ThreadState.Alive: 16>"),
            ('alpha set state for thread beta from ThreadState.Initializing '
             'to ThreadState.Registered'),
            'alpha added beta to SmartThread registry at UTC',
            'alpha entered _clean_pair_array',
            ("alpha created _clean_pair_array with pair_key = "
             r"\('alpha', 'beta'\)"),
            ("alpha added status_blocks entry for pair_key = "
             r"\('alpha', 'beta'\), name = alpha"),
            ("alpha added status_blocks entry for pair_key = "
             r"\('alpha', 'beta'\), name = beta"),
            'alpha updated _pair_array at UTC',
            (r"smart_unreg entry: requestor: alpha targets: \['beta'\] "
             "timeout value: None "
             "test_smart_thread.py::TestSmartThreadScenarios."
             "test_smart_thread_log_msg:"),
            (r"smart_unreg exit: requestor: alpha targets: \['beta'\] "
             "timeout value: None "
             "test_smart_thread.py::TestSmartThreadScenarios."
             "test_smart_thread_log_msg:"),
            ('alpha set state for thread beta from ThreadState.Registered to '
             'ThreadState.Stopped'),
            (r"name=alpha, smart_thread=SmartThread\(name='alpha'\), "
             r"is_alive\(\)=True, "
             "state=<ThreadState.Alive: 16>"),
            (r"name=beta, smart_thread=SmartThread\(name='beta', target=f1, "
             r"args=\('beta',\)\), is_alive\(\)=False, "
             "state=<ThreadState.Stopped: 32>"),
            "alpha removed beta from registry for process='smart_unreg'",
            'alpha entered _clean_pair_array',
            ("alpha removed status_blocks entry for pair_key = "
             r"\('alpha', 'beta'\), name = beta"),
            ("alpha removed status_blocks entry for pair_key = "
             r"\('alpha', 'beta'\), name = alpha"),
            ("alpha removed _pair_array entry for pair_key = "
             r"\('alpha', 'beta'\)"),
            'alpha updated _pair_array at UTC',
            "alpha did cleanup of registry at UTC",
            'alpha did successful smart_unreg of beta.',
        ]

        commander_info_log_msgs = [
            'alpha sent message to beta',
            'alpha smart_sync resumed by beta'
        ]

        add_log_msgs(
            log_msgs=commander_debug_log_msgs,
            log_level=logging.DEBUG,
            log_name=smart_thread_log_name)

        add_log_msgs(
            log_msgs=commander_info_log_msgs,
            log_level=logging.INFO,
            log_name=smart_thread_log_name)

        ################################################################
        # f1 beta log messages
        ################################################################
        f1_beta_debug_log_msgs = [
            ('alpha set state for thread beta from '
             'ThreadState.Unregistered to '
             'ThreadState.Initializing'),
            ('alpha obtained _registry_lock, class name = '
             'SmartThread'),
            (r"name=alpha, smart_thread=SmartThread\(name='alpha'\), "
             r"is_alive\(\)=True, "
             "state=<ThreadState.Alive: 16>"),
            ('alpha set state for thread beta from '
             'ThreadState.Initializing to '
             'ThreadState.Registered'),
            'alpha added beta to SmartThread registry at UTC',
            'alpha entered _clean_pair_array',
            ("alpha created _clean_pair_array with pair_key "
             r"= \('alpha', 'beta'\)"),
            ("alpha added status_blocks entry for pair_key "
             r"= \('alpha', 'beta'\), name = alpha"),
            ("alpha added status_blocks entry for pair_key "
             r"= \('alpha', 'beta'\), name = beta"),
            'alpha updated _pair_array at UTC',
            ("smart_start entry: requestor: alpha targets: "
             r"\['beta'\] timeout value: None "
             "smart_thread.py::SmartThread.__init__:"),
            ('alpha set state for thread beta from '
             'ThreadState.Registered to '
             'ThreadState.Starting'),
            ('alpha set state for thread beta from '
             'ThreadState.Starting to '
             'ThreadState.Alive'),
            ("smart_start exit: requestor: alpha targets: "
             r"\['beta'\] timeout value: None "
             "smart_thread.py::SmartThread.__init__:"),
            ("smart_recv entry: requestor: beta targets: "
             r"\['alpha'\] timeout value: None "
             "test_smart_thread.py::f1:"),
            ("smart_recv exit: requestor: beta targets: "
             r"\['alpha'\] timeout value: None "
             "test_smart_thread.py::f1:"),
            (r"smart_wait entry: requestor: beta targets: \['alpha'\] "
             "timeout value: None test_smart_thread.py::f1:"),
            (r"smart_wait exit: requestor: beta targets: \['alpha'\] "
             "timeout value: None test_smart_thread.py::f1:"),
            (r"smart_sync entry: requestor: beta targets: \['alpha'\] timeout "
             "value: None test_smart_thread.py::f1:"),
            (r"smart_sync exit: requestor: beta targets: \['alpha'\] timeout "
             "value: None test_smart_thread.py::f1:"),
        ]

        f1_beta_info_log_msgs = [
            'beta received msg from alpha',
            'beta smart_wait resumed by alpha',
            'beta smart_sync resumed by alpha'
        ]

        add_log_msgs(
            log_msgs=f1_beta_debug_log_msgs,
            log_level=logging.DEBUG,
            log_name=smart_thread_log_name)

        add_log_msgs(
            log_msgs=f1_beta_info_log_msgs,
            log_level=logging.INFO,
            log_name=smart_thread_log_name)

        ################################################################
        # check log results
        ################################################################
        match_results = log_ver.get_match_results(caplog=caplog)
        log_ver.print_match_results(match_results)
        log_ver.verify_log_results(match_results)

        logger.warning('mainline exiting')

    # ##################################################################
    # # test_smart_thread_scenarios
    # ##################################################################
    # def test_smart_thread_random_scenarios(
    #         self,
    #         random_seed_arg: int,
    #         caplog: pytest.CaptureFixture[str]
    # ) -> None:
    #     """Test meta configuration scenarios.
    #
    #     Args:
    #         caplog: pytest fixture to capture log output
    #
    #     """
    #
    #     random.seed(random_seed_arg)
    #     num_threads = random.randint(2, 8)
    #
    #     f1_names = list(config_ver.f1_thread_names.keys())
    #
    #     f1_names_to_use = random.sample(f1_names, num_threads)
    #
    #     names = ['alpha'] + f1_names_to_use


########################################################################
# TestSmartThreadInterface class
########################################################################
class TestSmartThreadInterface:
    """Test class for SmartThread example tests."""
    ####################################################################
    # test_smart_thread_interface_1
    ####################################################################
    @pytest.mark.parametrize("num_f1_args",
                             [(0, 0, 0), (0, 0, 1), (0, 0, 2), (0, 0, 3),
                              (0, 1, 0), (0, 1, 1), (0, 1, 2), (0, 1, 3),
                              (0, 2, 0), (0, 2, 1), (0, 2, 2), (0, 2, 3),
                              (0, 3, 0), (0, 3, 1), (0, 3, 2), (0, 3, 3),
                              (1, 0, 0), (1, 0, 1), (1, 0, 2), (1, 0, 3),
                              (1, 1, 0), (1, 1, 1), (1, 1, 2), (1, 1, 3),
                              (1, 2, 0), (1, 2, 1), (1, 2, 2), (1, 2, 3),
                              (1, 3, 0), (1, 3, 1), (1, 3, 2), (1, 3, 3)
                              ])
    def test_smart_thread_interface_1(self,
                                      num_f1_args: tuple[int, int, int]
                                      ) -> None:
        """Test smart_send example 1 with no parms.

        Args:
            num_f1_args: number of arguments to specify
        """
        from scottbrian_paratools.smart_thread import SmartThread, ThreadState

        def f1_0_0_0() -> None:
            logger.debug('f1 beta entry')
            logger.debug('there are no args to check')
            assert num_f1_args == (0, 0, 0)
            logger.debug('f1 beta exit')

        def f1_0_0_1(arg1: int) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}')
            assert arg1 == 42
            assert num_f1_args == (0, 0, 1)
            logger.debug('f1 beta exit')

        def f1_0_0_2(arg1: int, arg2: str) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert num_f1_args == (0, 0, 2)
            logger.debug('f1 beta exit')

        def f1_0_0_3(arg1: int, arg2: str, arg3: list[int]) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}, {arg3=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert num_f1_args == (0, 0, 3)
            logger.debug('f1 beta exit')

        def f1_0_1_0(kwarg1: int) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{kwarg1=}')
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 0)
            logger.debug('f1 beta exit')

        def f1_0_1_1(arg1: int,
                     kwarg1: int) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}')
            logger.debug(f'{kwarg1=}')
            assert arg1 == 42
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 1)
            logger.debug('f1 beta exit')

        def f1_0_1_2(arg1: int, arg2: str,
                     kwarg1: int) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}')
            logger.debug(f'{kwarg1=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 2)
            logger.debug('f1 beta exit')

        def f1_0_1_3(arg1: int, arg2: str, arg3: list[int],
                     kwarg1: int) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}, {arg3=}')
            logger.debug(f'{kwarg1=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 3)
            logger.debug('f1 beta exit')

        def f1_0_2_0(kwarg1: int, kwarg2: str) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{kwarg1=}, {kwarg2=}')
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 0)
            logger.debug('f1 beta exit')

        def f1_0_2_1(arg1: int,
                     kwarg1: int, kwarg2: str) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}')
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 1)
            logger.debug('f1 beta exit')

        def f1_0_2_2(arg1: int, arg2: str,
                     kwarg1: int, kwarg2: str) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 2)
            logger.debug('f1 beta exit')

        def f1_0_2_3(arg1: int, arg2: str, arg3: list[int],
                     kwarg1: int, kwarg2: str) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}, {arg3=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 3)
            logger.debug('f1 beta exit')

        def f1_0_3_0(kwarg1: int, kwarg2: str, kwarg3: list[int]) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{kwarg1=}, {kwarg2=}, {kwarg3=}')
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (0, 3, 0)
            logger.debug('f1 beta exit')

        def f1_0_3_1(arg1: int,
                     kwarg1: int, kwarg2: str, kwarg3: list[int]) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}, {kwarg3=}')
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (0, 3, 1)
            logger.debug('f1 beta exit')

        def f1_0_3_2(arg1: int, arg2: str,
                     kwarg1: int, kwarg2: str, kwarg3: list[int]) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}, {kwarg3=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (0, 3, 2)
            logger.debug('f1 beta exit')

        def f1_0_3_3(arg1: int, arg2: str, arg3: list[int],
                     kwarg1: int, kwarg2: str, kwarg3: list[int]) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}, {arg3=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}, {kwarg3=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg3 == [11, 22, 33]
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 3, 3)
            logger.debug('f1 beta exit')

        def f1_1_0_0(smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{smart_thread=}')
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 0, 0)
            logger.debug('f1 beta exit')

        def f1_1_0_1(arg1: int,
                     smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}')
            assert arg1 == 42
            logger.debug(f'{smart_thread=}')
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 0, 1)
            logger.debug('f1 beta exit')

        def f1_1_0_2(arg1: int, arg2: str,
                     smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 0, 2)
            logger.debug('f1 beta exit')

        def f1_1_0_3(arg1: int, arg2: str, arg3: list[int],
                     smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}, {arg3=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 0, 3)
            logger.debug('f1 beta exit')

        def f1_1_1_0(kwarg1: int,
                     smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{kwarg1=}')
            logger.debug(f'{smart_thread=}')
            assert kwarg1 == 13
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 1, 0)
            logger.debug('f1 beta exit')

        def f1_1_1_1(arg1: int,
                     smart_thread: SmartThread,
                     kwarg1: int) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}')
            logger.debug(f'{kwarg1=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert kwarg1 == 13
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 1, 1)
            logger.debug('f1 beta exit')

        def f1_1_1_2(arg1: int, arg2: str,
                     kwarg1: int,
                     smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}')
            logger.debug(f'{kwarg1=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 1, 2)
            logger.debug('f1 beta exit')

        def f1_1_1_3(arg1: int, arg2: str, arg3: list[int],
                     smart_thread: SmartThread,
                     kwarg1: int) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}, {arg3=}')
            logger.debug(f'{kwarg1=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 1, 3)
            logger.debug('f1 beta exit')

        def f1_1_2_0(kwarg1: int, kwarg2: str,
                     smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{kwarg1=}, {kwarg2=}')
            logger.debug(f'{smart_thread=}')
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 2, 0)
            logger.debug('f1 beta exit')

        def f1_1_2_1(arg1: int,
                     kwarg1: int,
                     smart_thread: SmartThread,
                     kwarg2: str) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 2, 1)
            logger.debug('f1 beta exit')

        def f1_1_2_2(arg1: int, arg2: str,
                     kwarg1: int, kwarg2: str,
                     smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 2, 2)
            logger.debug('f1 beta exit')

        def f1_1_2_3(arg1: int, arg2: str, arg3: list[int],
                     smart_thread: SmartThread,
                     kwarg1: int, kwarg2: str) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}, {arg3=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 2, 3)
            logger.debug('f1 beta exit')

        def f1_1_3_0(kwarg1: int,
                     kwarg2: str,
                     smart_thread: SmartThread,
                     kwarg3: list[int]) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{kwarg1=}, {kwarg2=}, {kwarg3=}')
            logger.debug(f'{smart_thread=}')
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 3, 0)
            logger.debug('f1 beta exit')

        def f1_1_3_1(arg1: int,
                     kwarg1: int,
                     smart_thread: SmartThread,
                     kwarg2: str,
                     kwarg3: list[int]) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}, {kwarg3=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 3, 1)
            logger.debug('f1 beta exit')

        def f1_1_3_2(arg1: int, arg2: str,
                     kwarg1: int,
                     kwarg2: str,
                     kwarg3: list[int],
                     smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}, {kwarg3=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 3, 2)
            logger.debug('f1 beta exit')

        def f1_1_3_3(arg1: int, arg2: str, arg3: list[int],
                     kwarg1: int, kwarg2: str, kwarg3: list[int],
                     smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}, {arg3=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}, {kwarg3=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg3 == [11, 22, 33]
            assert kwarg2 == "second kwarg"
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 3, 3)
            logger.debug('f1 beta exit')

        logger.debug('mainline entered')
        alpha_smart_thread = SmartThread(name='alpha')
        if num_f1_args == (0, 0, 0):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_0_0_0)
        elif num_f1_args == (0, 0, 1):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_0_0_1,
                                            args=(42, ))
        elif num_f1_args == (0, 0, 2):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_0_0_2,
                                            args=(42, "my arg 2"))
        elif num_f1_args == (0, 0, 3):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_0_0_3,
                                            args=(42, "my arg 2", [1, 2, 3]))
        elif num_f1_args == (0, 1, 0):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_0_1_0,
                                            kwargs={'kwarg1': 13})
        elif num_f1_args == (0, 1, 1):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_0_1_1,
                                            args=(42, ),
                                            kwargs={'kwarg1': 13})
        elif num_f1_args == (0, 1, 2):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_0_1_2,
                                            args=(42, "my arg 2"),
                                            kwargs={'kwarg1': 13})
        elif num_f1_args == (0, 1, 3):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_0_1_3,
                                            args=(42, "my arg 2", [1, 2, 3]),
                                            kwargs={'kwarg1': 13})
        elif num_f1_args == (0, 2, 0):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_0_2_0,
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg"})
        elif num_f1_args == (0, 2, 1):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_0_2_1,
                                            args=(42, ),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg"})
        elif num_f1_args == (0, 2, 2):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_0_2_2,
                                            args=(42, "my arg 2"),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg"})
        elif num_f1_args == (0, 2, 3):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_0_2_3,
                                            args=(42, "my arg 2", [1, 2, 3]),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg"})
        elif num_f1_args == (0, 3, 0):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_0_3_0,
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg",
                                                    'kwarg3': [11, 22, 33]})
        elif num_f1_args == (0, 3, 1):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_0_3_1,
                                            args=(42, ),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg",
                                                    'kwarg3': [11, 22, 33]})
        elif num_f1_args == (0, 3, 2):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_0_3_2,
                                            args=(42, "my arg 2"),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg",
                                                    'kwarg3': [11, 22, 33]})
        elif num_f1_args == (0, 3, 3):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_0_3_3,
                                            args=(42, "my arg 2", [1, 2, 3]),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg",
                                                    'kwarg3': [11, 22, 33]})
        elif num_f1_args == (1, 0, 0):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_1_0_0,
                                            thread_parm_name='smart_thread')
        elif num_f1_args == (1, 0, 1):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_1_0_1,
                                            thread_parm_name='smart_thread',
                                            args=(42, ))
        elif num_f1_args == (1, 0, 2):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_1_0_2,
                                            thread_parm_name='smart_thread',
                                            args=(42, "my arg 2"))
        elif num_f1_args == (1, 0, 3):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_1_0_3,
                                            thread_parm_name='smart_thread',
                                            args=(42, "my arg 2", [1, 2, 3]))
        elif num_f1_args == (1, 1, 0):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_1_1_0,
                                            thread_parm_name='smart_thread',
                                            kwargs={'kwarg1': 13})
        elif num_f1_args == (1, 1, 1):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_1_1_1,
                                            thread_parm_name='smart_thread',
                                            args=(42, ),
                                            kwargs={'kwarg1': 13})
        elif num_f1_args == (1, 1, 2):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_1_1_2,
                                            thread_parm_name='smart_thread',
                                            args=(42, "my arg 2"),
                                            kwargs={'kwarg1': 13})
        elif num_f1_args == (1, 1, 3):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_1_1_3,
                                            thread_parm_name='smart_thread',
                                            args=(42, "my arg 2", [1, 2, 3]),
                                            kwargs={'kwarg1': 13})
        elif num_f1_args == (1, 2, 0):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_1_2_0,
                                            thread_parm_name='smart_thread',
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg"})
        elif num_f1_args == (1, 2, 1):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_1_2_1,
                                            thread_parm_name='smart_thread',
                                            args=(42, ),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg"})
        elif num_f1_args == (1, 2, 2):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_1_2_2,
                                            thread_parm_name='smart_thread',
                                            args=(42, "my arg 2"),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg"})
        elif num_f1_args == (1, 2, 3):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_1_2_3,
                                            thread_parm_name='smart_thread',
                                            args=(42, "my arg 2", [1, 2, 3]),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg"})
        elif num_f1_args == (1, 3, 0):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_1_3_0,
                                            thread_parm_name='smart_thread',
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg",
                                                    'kwarg3': [11, 22, 33]})
        elif num_f1_args == (1, 3, 1):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_1_3_1,
                                            thread_parm_name='smart_thread',
                                            args=(42, ),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg",
                                                    'kwarg3': [11, 22, 33]})
        elif num_f1_args == (1, 3, 2):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_1_3_2,
                                            thread_parm_name='smart_thread',
                                            args=(42, "my arg 2"),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg",
                                                    'kwarg3': [11, 22, 33]})
        elif num_f1_args == (1, 3, 3):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1_1_3_3,
                                            thread_parm_name='smart_thread',
                                            args=(42, "my arg 2", [1, 2, 3]),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg",
                                                    'kwarg3': [11, 22, 33]})

        time.sleep(0.5)
        assert beta_smart_thread._get_state('beta') == ThreadState.Stopped
        alpha_smart_thread.smart_join(targets='beta')
        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_thread_interface_2
    ####################################################################
    @pytest.mark.parametrize("num_f1_args",
                             [(0, 0, 0), (0, 0, 1), (0, 0, 2), (0, 0, 3),
                              (0, 1, 0), (0, 1, 1), (0, 1, 2), (0, 1, 3),
                              (0, 2, 0), (0, 2, 1), (0, 2, 2), (0, 2, 3),
                              (0, 3, 0), (0, 3, 1), (0, 3, 2), (0, 3, 3),
                              (1, 0, 0), (1, 0, 1), (1, 0, 2), (1, 0, 3),
                              (1, 1, 0), (1, 1, 1), (1, 1, 2), (1, 1, 3),
                              (1, 2, 0), (1, 2, 1), (1, 2, 2), (1, 2, 3),
                              (1, 3, 0), (1, 3, 1), (1, 3, 2), (1, 3, 3)
                              ])
    def test_smart_thread_interface_2(self,
                                      num_f1_args: tuple[int, int, int]
                                      ) -> None:
        """Test smart_send example 2 with no parms.

        Args:
            num_f1_args: number of arguments to specify
        """
        from scottbrian_paratools.smart_thread import SmartThread, ThreadState

        def f1_0_0_0() -> None:
            logger.debug('f1 beta entry')
            logger.debug('there are no args to check')
            assert num_f1_args == (0, 0, 0)
            logger.debug('f1 beta exit')

        def f1_0_0_1(arg1: int) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}')
            assert arg1 == 42
            assert num_f1_args == (0, 0, 1)
            logger.debug('f1 beta exit')

        def f1_0_0_2(arg1: int, arg2: str) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert num_f1_args == (0, 0, 2)
            logger.debug('f1 beta exit')

        def f1_0_0_3(arg1: int, arg2: str, arg3: list[int]) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}, {arg3=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert num_f1_args == (0, 0, 3)
            logger.debug('f1 beta exit')

        def f1_0_1_0(kwarg1: int) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{kwarg1=}')
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 0)
            logger.debug('f1 beta exit')

        def f1_0_1_1(arg1: int,
                     kwarg1: int) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}')
            logger.debug(f'{kwarg1=}')
            assert arg1 == 42
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 1)
            logger.debug('f1 beta exit')

        def f1_0_1_2(arg1: int, arg2: str,
                     kwarg1: int) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}')
            logger.debug(f'{kwarg1=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 2)
            logger.debug('f1 beta exit')

        def f1_0_1_3(arg1: int, arg2: str, arg3: list[int],
                     kwarg1: int) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}, {arg3=}')
            logger.debug(f'{kwarg1=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert num_f1_args == (0, 1, 3)
            logger.debug('f1 beta exit')

        def f1_0_2_0(kwarg1: int, kwarg2: str) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{kwarg1=}, {kwarg2=}')
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 0)
            logger.debug('f1 beta exit')

        def f1_0_2_1(arg1: int,
                     kwarg1: int, kwarg2: str) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}')
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 1)
            logger.debug('f1 beta exit')

        def f1_0_2_2(arg1: int, arg2: str,
                     kwarg1: int, kwarg2: str) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 2)
            logger.debug('f1 beta exit')

        def f1_0_2_3(arg1: int, arg2: str, arg3: list[int],
                     kwarg1: int, kwarg2: str) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}, {arg3=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 2, 3)
            logger.debug('f1 beta exit')

        def f1_0_3_0(kwarg1: int, kwarg2: str, kwarg3: list[int]) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{kwarg1=}, {kwarg2=}, {kwarg3=}')
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (0, 3, 0)
            logger.debug('f1 beta exit')

        def f1_0_3_1(arg1: int,
                     kwarg1: int, kwarg2: str, kwarg3: list[int]) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}, {kwarg3=}')
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (0, 3, 1)
            logger.debug('f1 beta exit')

        def f1_0_3_2(arg1: int, arg2: str,
                     kwarg1: int, kwarg2: str, kwarg3: list[int]) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}, {kwarg3=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert num_f1_args == (0, 3, 2)
            logger.debug('f1 beta exit')

        def f1_0_3_3(arg1: int, arg2: str, arg3: list[int],
                     kwarg1: int, kwarg2: str, kwarg3: list[int]) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}, {arg3=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}, {kwarg3=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg3 == [11, 22, 33]
            assert kwarg2 == "second kwarg"
            assert num_f1_args == (0, 3, 3)
            logger.debug('f1 beta exit')

        def f1_1_0_0(smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{smart_thread=}')
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 0, 0)
            logger.debug('f1 beta exit')

        def f1_1_0_1(arg1: int,
                     smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}')
            assert arg1 == 42
            logger.debug(f'{smart_thread=}')
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 0, 1)
            logger.debug('f1 beta exit')

        def f1_1_0_2(arg1: int, arg2: str,
                     smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 0, 2)
            logger.debug('f1 beta exit')

        def f1_1_0_3(arg1: int, arg2: str, arg3: list[int],
                     smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}, {arg3=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 0, 3)
            logger.debug('f1 beta exit')

        def f1_1_1_0(kwarg1: int,
                     smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{kwarg1=}')
            logger.debug(f'{smart_thread=}')
            assert kwarg1 == 13
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 1, 0)
            logger.debug('f1 beta exit')

        def f1_1_1_1(arg1: int,
                     smart_thread: SmartThread,
                     kwarg1: int) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}')
            logger.debug(f'{kwarg1=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert kwarg1 == 13
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 1, 1)
            logger.debug('f1 beta exit')

        def f1_1_1_2(arg1: int, arg2: str,
                     kwarg1: int,
                     smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}')
            logger.debug(f'{kwarg1=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 1, 2)
            logger.debug('f1 beta exit')

        def f1_1_1_3(arg1: int, arg2: str, arg3: list[int],
                     smart_thread: SmartThread,
                     kwarg1: int) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}, {arg3=}')
            logger.debug(f'{kwarg1=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 1, 3)
            logger.debug('f1 beta exit')

        def f1_1_2_0(kwarg1: int, kwarg2: str,
                     smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{kwarg1=}, {kwarg2=}')
            logger.debug(f'{smart_thread=}')
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 2, 0)
            logger.debug('f1 beta exit')

        def f1_1_2_1(arg1: int,
                     kwarg1: int,
                     smart_thread: SmartThread,
                     kwarg2: str) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 2, 1)
            logger.debug('f1 beta exit')

        def f1_1_2_2(arg1: int, arg2: str,
                     kwarg1: int, kwarg2: str,
                     smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 2, 2)
            logger.debug('f1 beta exit')

        def f1_1_2_3(arg1: int, arg2: str, arg3: list[int],
                     smart_thread: SmartThread,
                     kwarg1: int, kwarg2: str) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}, {arg3=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 2, 3)
            logger.debug('f1 beta exit')

        def f1_1_3_0(kwarg1: int,
                     kwarg2: str,
                     smart_thread: SmartThread,
                     kwarg3: list[int]) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{kwarg1=}, {kwarg2=}, {kwarg3=}')
            logger.debug(f'{smart_thread=}')
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 3, 0)
            logger.debug('f1 beta exit')

        def f1_1_3_1(arg1: int,
                     kwarg1: int,
                     smart_thread: SmartThread,
                     kwarg2: str,
                     kwarg3: list[int]) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}, {kwarg3=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 3, 1)
            logger.debug('f1 beta exit')

        def f1_1_3_2(arg1: int, arg2: str,
                     kwarg1: int,
                     kwarg2: str,
                     kwarg3: list[int],
                     smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}, {kwarg3=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert kwarg1 == 13
            assert kwarg2 == "second kwarg"
            assert kwarg3 == [11, 22, 33]
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 3, 2)
            logger.debug('f1 beta exit')

        def f1_1_3_3(arg1: int, arg2: str, arg3: list[int],
                     kwarg1: int, kwarg2: str, kwarg3: list[int],
                     smart_thread: SmartThread) -> None:
            logger.debug('f1 beta entry')
            logger.debug(f'{arg1=}, {arg2=}, {arg3=}')
            logger.debug(f'{kwarg1=}, {kwarg2=}, {kwarg3=}')
            logger.debug(f'{smart_thread=}')
            assert arg1 == 42
            assert arg2 == "my arg 2"
            assert arg3 == [1, 2, 3]
            assert kwarg1 == 13
            assert kwarg3 == [11, 22, 33]
            assert kwarg2 == "second kwarg"
            assert smart_thread._get_state('beta') == ThreadState.Alive
            assert num_f1_args == (1, 3, 3)
            logger.debug('f1 beta exit')

        logger.debug('mainline entered')
        alpha_smart_thread = SmartThread(name='alpha')

        f1_target_to_specify = (f'f1_'
                                f'{num_f1_args[0]}_'
                                f'{num_f1_args[1]}_'
                                f'{num_f1_args[2]}')

        smart_thread_name_to_specify = None
        args_to_specify = None
        kwargs_to_specify = None
        if num_f1_args[0] == 1:
            smart_thread_name_to_specify = 'smart_thread'

        if num_f1_args[1] >= 1:
            kwargs_to_specify = {'kwarg1': 13}
        if num_f1_args[1] >= 2:
            kwargs_to_specify['kwarg2'] = "second kwarg"
        if num_f1_args[1] == 3:
            kwargs_to_specify['kwarg3'] = [11, 22, 33]

        if num_f1_args[2] == 1:
            args_to_specify = (42, )
        if num_f1_args[2] >= 2:
            args_to_specify = (42, "my arg 2")
        if num_f1_args[2] == 3:
            args_to_specify = (42, "my arg 2", [1, 2, 3])

        logger.debug(f'Before: {kwargs_to_specify}')

        if smart_thread_name_to_specify:
            if args_to_specify:
                if kwargs_to_specify:
                    beta_smart_thread = SmartThread(
                        name='beta',
                        target=eval(f1_target_to_specify),
                        thread_parm_name=smart_thread_name_to_specify,
                        args=args_to_specify,
                        kwargs=kwargs_to_specify)
                else:
                    beta_smart_thread = SmartThread(
                        name='beta',
                        target=eval(f1_target_to_specify),
                        thread_parm_name=smart_thread_name_to_specify,
                        args=args_to_specify)
            else:
                if kwargs_to_specify:
                    beta_smart_thread = SmartThread(
                        name='beta',
                        target=eval(f1_target_to_specify),
                        thread_parm_name=smart_thread_name_to_specify,
                        kwargs=kwargs_to_specify)
                else:
                    beta_smart_thread = SmartThread(
                        name='beta',
                        target=eval(f1_target_to_specify),
                        thread_parm_name=smart_thread_name_to_specify)
        else:
            if args_to_specify:
                if kwargs_to_specify:
                    beta_smart_thread = SmartThread(
                        name='beta',
                        target=eval(f1_target_to_specify),
                        args=args_to_specify,
                        kwargs=kwargs_to_specify)
                else:
                    beta_smart_thread = SmartThread(
                        name='beta',
                        target=eval(f1_target_to_specify),
                        args=args_to_specify)
            else:
                if kwargs_to_specify:
                    beta_smart_thread = SmartThread(
                        name='beta',
                        target=eval(f1_target_to_specify),
                        kwargs=kwargs_to_specify)
                else:
                    beta_smart_thread = SmartThread(
                        name='beta',
                        target=eval(f1_target_to_specify))

        logger.debug(f'After: {kwargs_to_specify}')
        time.sleep(0.5)
        assert beta_smart_thread._get_state('beta') == ThreadState.Stopped
        alpha_smart_thread.smart_join(targets='beta')
        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_thread_interface_3
    ####################################################################
    @pytest.mark.parametrize("num_f1_args",
                             [(0, 0, 0), (0, 0, 1), (0, 0, 2), (0, 0, 3),
                              (0, 1, 0), (0, 1, 1), (0, 1, 2), (0, 1, 3),
                              (0, 2, 0), (0, 2, 1), (0, 2, 2), (0, 2, 3),
                              (0, 3, 0), (0, 3, 1), (0, 3, 2), (0, 3, 3),
                              (1, 0, 0), (1, 0, 1), (1, 0, 2), (1, 0, 3),
                              (1, 1, 0), (1, 1, 1), (1, 1, 2), (1, 1, 3),
                              (1, 2, 0), (1, 2, 1), (1, 2, 2), (1, 2, 3),
                              (1, 3, 0), (1, 3, 1), (1, 3, 2), (1, 3, 3)
                              ])
    def test_smart_thread_interface_3(self,
                                      num_f1_args: tuple[int, int, int]
                                      ) -> None:
        """Test smart_send example 3 with no parms.

        Args:
            num_f1_args: number of arguments to specify
        """
        from scottbrian_paratools.smart_thread import SmartThread, ThreadState

        def f1(*args, **kwargs) -> None:
            logger.debug('f1 beta entry')

            exp_args = (0, 42, "my arg 2", [1, 2, 3])
            exp_kwargs = {'kwarg1': 13,
                          'kwarg2': "second kwarg",
                          'kwarg3': [11, 22, 33]
                          }
            args_str = ''
            comma = ''
            for idx, arg in enumerate(args, 1):
                args_str = f'{args_str}{comma}arg{idx}={arg}'
                comma = ', '
                assert arg == exp_args[idx]
            if args_str:
                logger.debug(args_str)

            smart_thread_arg = False
            kwargs_str = ''
            comma = ''
            for key, value in kwargs.items():
                if key == 'smart_thread':
                    smart_thread_arg = True
                    smart_thread = value
                else:
                    kwargs_str = f'{kwargs_str}{comma}{key}={value}'
                    comma = ', '
                    assert exp_kwargs[key] == value
            if kwargs_str:
                logger.debug(kwargs_str)

            if smart_thread_arg:
                logger.debug(f'{smart_thread=}')
                assert smart_thread._get_state('beta') == ThreadState.Alive

            logger.debug('f1 beta exit')

        logger.debug('mainline entered')
        alpha_smart_thread = SmartThread(name='alpha')
        if num_f1_args == (0, 0, 0):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1)
        elif num_f1_args == (0, 0, 1):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            args=(42, ))
        elif num_f1_args == (0, 0, 2):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            args=(42, "my arg 2"))
        elif num_f1_args == (0, 0, 3):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            args=(42, "my arg 2", [1, 2, 3]))
        elif num_f1_args == (0, 1, 0):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            kwargs={'kwarg1': 13})
        elif num_f1_args == (0, 1, 1):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            args=(42, ),
                                            kwargs={'kwarg1': 13})
        elif num_f1_args == (0, 1, 2):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            args=(42, "my arg 2"),
                                            kwargs={'kwarg1': 13})
        elif num_f1_args == (0, 1, 3):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            args=(42, "my arg 2", [1, 2, 3]),
                                            kwargs={'kwarg1': 13})
        elif num_f1_args == (0, 2, 0):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg"})
        elif num_f1_args == (0, 2, 1):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            args=(42, ),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg"})
        elif num_f1_args == (0, 2, 2):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            args=(42, "my arg 2"),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg"})
        elif num_f1_args == (0, 2, 3):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            args=(42, "my arg 2", [1, 2, 3]),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg"})
        elif num_f1_args == (0, 3, 0):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg",
                                                    'kwarg3': [11, 22, 33]})
        elif num_f1_args == (0, 3, 1):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            args=(42, ),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg",
                                                    'kwarg3': [11, 22, 33]})
        elif num_f1_args == (0, 3, 2):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            args=(42, "my arg 2"),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg",
                                                    'kwarg3': [11, 22, 33]})
        elif num_f1_args == (0, 3, 3):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            args=(42, "my arg 2", [1, 2, 3]),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg",
                                                    'kwarg3': [11, 22, 33]})
        elif num_f1_args == (1, 0, 0):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            thread_parm_name='smart_thread')
        elif num_f1_args == (1, 0, 1):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            thread_parm_name='smart_thread',
                                            args=(42, ))
        elif num_f1_args == (1, 0, 2):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            thread_parm_name='smart_thread',
                                            args=(42, "my arg 2"))
        elif num_f1_args == (1, 0, 3):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            thread_parm_name='smart_thread',
                                            args=(42, "my arg 2", [1, 2, 3]))
        elif num_f1_args == (1, 1, 0):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            thread_parm_name='smart_thread',
                                            kwargs={'kwarg1': 13})
        elif num_f1_args == (1, 1, 1):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            thread_parm_name='smart_thread',
                                            args=(42, ),
                                            kwargs={'kwarg1': 13})
        elif num_f1_args == (1, 1, 2):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            thread_parm_name='smart_thread',
                                            args=(42, "my arg 2"),
                                            kwargs={'kwarg1': 13})
        elif num_f1_args == (1, 1, 3):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            thread_parm_name='smart_thread',
                                            args=(42, "my arg 2", [1, 2, 3]),
                                            kwargs={'kwarg1': 13})
        elif num_f1_args == (1, 2, 0):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            thread_parm_name='smart_thread',
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg"})
        elif num_f1_args == (1, 2, 1):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            thread_parm_name='smart_thread',
                                            args=(42, ),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg"})
        elif num_f1_args == (1, 2, 2):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            thread_parm_name='smart_thread',
                                            args=(42, "my arg 2"),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg"})
        elif num_f1_args == (1, 2, 3):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            thread_parm_name='smart_thread',
                                            args=(42, "my arg 2", [1, 2, 3]),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg"})
        elif num_f1_args == (1, 3, 0):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            thread_parm_name='smart_thread',
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg",
                                                    'kwarg3': [11, 22, 33]})
        elif num_f1_args == (1, 3, 1):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            thread_parm_name='smart_thread',
                                            args=(42, ),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg",
                                                    'kwarg3': [11, 22, 33]})
        elif num_f1_args == (1, 3, 2):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            thread_parm_name='smart_thread',
                                            args=(42, "my arg 2"),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg",
                                                    'kwarg3': [11, 22, 33]})
        elif num_f1_args == (1, 3, 3):
            beta_smart_thread = SmartThread(name='beta',
                                            target=f1,
                                            thread_parm_name='smart_thread',
                                            args=(42, "my arg 2", [1, 2, 3]),
                                            kwargs={'kwarg1': 13,
                                                    'kwarg2': "second kwarg",
                                                    'kwarg3': [11, 22, 33]})

        time.sleep(0.5)
        assert beta_smart_thread._get_state('beta') == ThreadState.Stopped
        alpha_smart_thread.smart_join(targets='beta')
        logger.debug('mainline exiting')

    ####################################################################
    # test_smart_thread_interface_4
    ####################################################################
    @pytest.mark.parametrize("num_f1_args",
                             [(0, 0, 0), (0, 0, 1), (0, 0, 2), (0, 0, 3),
                              (0, 1, 0), (0, 1, 1), (0, 1, 2), (0, 1, 3),
                              (0, 2, 0), (0, 2, 1), (0, 2, 2), (0, 2, 3),
                              (0, 3, 0), (0, 3, 1), (0, 3, 2), (0, 3, 3),
                              (1, 0, 0), (1, 0, 1), (1, 0, 2), (1, 0, 3),
                              (1, 1, 0), (1, 1, 1), (1, 1, 2), (1, 1, 3),
                              (1, 2, 0), (1, 2, 1), (1, 2, 2), (1, 2, 3),
                              (1, 3, 0), (1, 3, 1), (1, 3, 2), (1, 3, 3)
                              ])
    def test_smart_thread_interface_4(self,
                                      num_f1_args: tuple[int, int, int]
                                      ) -> None:
        """Test smart_send example 4 with no parms.

        Args:
            num_f1_args: number of arguments to specify
        """
        from scottbrian_paratools.smart_thread import SmartThread, ThreadState

        def f1(*args,
               kwarg1: Optional[int] = None,
               kwarg2: Optional[str] = None,
               kwarg3: Optional[list[int]] = None,
               smart_thread: Optional[SmartThread] = None) -> None:
            logger.debug('f1 beta entry')

            exp_args = (0, 42, "my arg 2", [1, 2, 3])
            exp_kwargs = {'kwarg1': 13,
                          'kwarg2': "second kwarg",
                          'kwarg3': [11, 22, 33]
                          }
            args_str = ''
            comma = ''
            for idx, arg in enumerate(args, 1):
                args_str = f'{args_str}{comma}arg{idx}={arg}'
                comma = ', '
                assert arg == exp_args[idx]
            if args_str:
                logger.debug(args_str)

            kwargs_str = ''
            if kwarg1:
                kwargs_str = f'{kwargs_str}{kwarg1=}'
                assert kwarg1 == exp_kwargs['kwarg1']
            if kwarg2:
                kwargs_str = f'{kwargs_str}, {kwarg2=}'
                assert kwarg2 == exp_kwargs['kwarg2']
            if kwarg3:
                kwargs_str = f'{kwargs_str}, {kwarg3=}'
                assert kwarg3 == exp_kwargs['kwarg3']

            if kwargs_str:
                logger.debug(kwargs_str)

            if smart_thread:
                logger.debug(f'{smart_thread=}')
                assert smart_thread._get_state('beta') == ThreadState.Alive

            logger.debug('f1 beta exit')

        logger.debug('mainline entered')
        alpha_smart_thread = SmartThread(name='alpha')

        smart_thread_name_to_specify = None
        args_to_specify = None
        kwargs_to_specify = None
        if num_f1_args[0] == 1:
            smart_thread_name_to_specify = 'smart_thread'

        if num_f1_args[1] >= 1:
            kwargs_to_specify = {'kwarg1': 13}
        if num_f1_args[1] >= 2:
            kwargs_to_specify['kwarg2'] = "second kwarg"
        if num_f1_args[1] == 3:
            kwargs_to_specify['kwarg3'] = [11, 22, 33]

        if num_f1_args[2] == 1:
            args_to_specify = (42, )
        if num_f1_args[2] >= 2:
            args_to_specify = (42, "my arg 2")
        if num_f1_args[2] == 3:
            args_to_specify = (42, "my arg 2", [1, 2, 3])

        beta_smart_thread = SmartThread(
            name='beta',
            target=f1,
            thread_parm_name=smart_thread_name_to_specify,
            args=args_to_specify,
            kwargs=kwargs_to_specify)

        time.sleep(0.5)
        assert beta_smart_thread._get_state('beta') == ThreadState.Stopped
        alpha_smart_thread.smart_join(targets='beta')
        logger.debug('mainline exiting')


########################################################################
# TestSmartThreadErrors class
########################################################################
class TestSmartThreadErrors:
    """Test class for SmartThread error tests."""
    ####################################################################
    # Basic Scenario1
    ####################################################################
    @pytest.mark.cover
    def test_smart_thread_instantiation_errors(self):
        """Test error cases for SmartThread."""
        ################################################################
        # f1
        ################################################################
        def f1():
            logger.debug('f1 entered')
            logger.debug('f1 exiting')

        ####################################################################
        # Create smart thread with bad name
        ####################################################################
        logger.debug('mainline entered')

        logger.debug('mainline creating bad name thread')

        with pytest.raises(st.SmartThreadIncorrectNameSpecified):
            st.SmartThread(name=1)  # type: ignore

        test_thread = threading.Thread(target=f1)
        with pytest.raises(
                st.SmartThreadMutuallyExclusiveTargetThreadSpecified):

            st.SmartThread(name='alpha', target=f1, thread=test_thread)

        with pytest.raises(st.SmartThreadArgsSpecificationWithoutTarget):
            st.SmartThread(name='alpha', args=(1,))

        with pytest.raises(st.SmartThreadArgsSpecificationWithoutTarget):
            st.SmartThread(name='alpha', kwargs={'arg1': 1})

        with pytest.raises(st.SmartThreadArgsSpecificationWithoutTarget):
            st.SmartThread(name='alpha', args=(1,), kwargs={'arg1': 1})

        alpha_thread = st.SmartThread(name='alpha')
        alpha_thread.name = 1
        with pytest.raises(st.SmartThreadErrorInRegistry):
            alpha_thread._register()

        # we still have alpha with name changed to 1
        # which will cause the following registry error
        # when we try to create another thread
        with pytest.raises(st.SmartThreadErrorInRegistry):
            st.SmartThread(name='alpha')

        alpha_thread.name = 'alpha'  # restore name

        with pytest.raises(st.SmartThreadNameAlreadyInUse):
            st.SmartThread(name='alpha')

        logger.debug('mainline exiting')

    ####################################################################
    # Foreign Op
    ####################################################################
    def test_foreign_op_scenario(self,
                                 caplog: pytest.CaptureFixture[str]
                                 ) -> None:
        """Test foreign op error for SmartThread.

        Args:
            caplog: pytest fixture to capture log output

        """
        ################################################################
        # f1
        ################################################################
        def f1(f1_name: str):
            logger.debug(f'f1 entered for {f1_name}')
            msgs.get_msg(f1_name)
            logger.debug(f'f1 exit for {f1_name}')
            ############################################################
            # exit
            ############################################################

        logger.debug('mainline entry')
        msgs = Msgs()
        alpha_thread = st.SmartThread(name='alpha')
        beta_thread = st.SmartThread(name='beta',
                                     target=f1,
                                     kwargs={'f1_name': 'beta'})
        with pytest.raises(st.SmartThreadDetectedOpFromForeignThread):
            beta_thread.smart_send(receivers='alpha', msg='hi alpha')

        with pytest.raises(st.SmartThreadDetectedOpFromForeignThread):
            beta_thread.smart_recv(senders='alpha')

        with pytest.raises(st.SmartThreadDetectedOpFromForeignThread):
            beta_thread.smart_resume(waiters='alpha')

        with pytest.raises(st.SmartThreadDetectedOpFromForeignThread):
            beta_thread.smart_sync(targets='alpha')

        with pytest.raises(st.SmartThreadDetectedOpFromForeignThread):
            beta_thread.smart_wait(resumers='alpha')

        st.SmartThread(name='charlie',
                       auto_start=False,
                       target=f1,
                       kwargs={'f1_name': 'charlie'})

        alpha_thread.smart_start(targets='charlie')

        # error_msg = (f'alpha raising '
        #              'SmartThreadDetectedOpFromForeignThread. '
        #              f'self.thread=beta, threading.current_thread()=alpha. '
        #              f'SmartThread services must be called from the '
        #              f'thread that was originally assigned during '
        #              f'instantiation of SmartThread. '
        #              f'Call sequence: {get_formatted_call_sequence(1, 2)}')
        msgs.queue_msg('beta')
        msgs.queue_msg('charlie')
        alpha_thread.smart_join(targets=('beta', 'charlie'))

        logger.debug('mainline exit')

    ####################################################################
    # Unreg error cases
    ####################################################################
    def test_unreg_scenario(self,
                            caplog: pytest.CaptureFixture[str]
                            ) -> None:
        """Test unreg error cases for SmartThread.

        Args:
            caplog: pytest fixture to capture log output

        """
        ################################################################
        # f1
        ################################################################
        def f1(f1_name: str):
            logger.debug(f'f1 entered for {f1_name}')
            msgs.get_msg(f1_name)
            logger.debug(f'f1 exit for {f1_name}')
            ############################################################
            # exit
            ############################################################

        logger.debug('mainline entry')
        msgs = Msgs()
        alpha_thread = st.SmartThread(name='alpha')
        beta_thread = st.SmartThread(name='beta',
                                     auto_start=True,
                                     target=f1,
                                     kwargs={'f1_name': 'beta'})
        with pytest.raises(st.SmartThreadRemoteThreadNotRegistered):
            alpha_thread.smart_unreg(targets='beta')

        msgs.queue_msg('beta')
        alpha_thread.smart_join(targets='beta')

        logger.debug('mainline exit')


